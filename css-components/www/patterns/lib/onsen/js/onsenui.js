/*! onsenui v2.0.0-rc.19 - 2016-09-15 */
if (!window.CustomEvent) {
  (function() {
    var CustomEvent;

    CustomEvent = function(event, params) {
      var evt;
      params = params || {
        bubbles: false,
        cancelable: false,
        detail: undefined
      };
      evt = document.createEvent("CustomEvent");
      evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
      return evt;
    };

    CustomEvent.prototype = window.Event.prototype;

    window.CustomEvent = CustomEvent;
  })();
}

/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
// @version 0.7.22
if (typeof WeakMap === "undefined") {
  (function() {
    var defineProperty = Object.defineProperty;
    var counter = Date.now() % 1e9;
    var WeakMap = function() {
      this.name = "__st" + (Math.random() * 1e9 >>> 0) + (counter++ + "__");
    };
    WeakMap.prototype = {
      set: function(key, value) {
        var entry = key[this.name];
        if (entry && entry[0] === key) entry[1] = value; else defineProperty(key, this.name, {
          value: [ key, value ],
          writable: true
        });
        return this;
      },
      get: function(key) {
        var entry;
        return (entry = key[this.name]) && entry[0] === key ? entry[1] : undefined;
      },
      "delete": function(key) {
        var entry = key[this.name];
        if (!entry || entry[0] !== key) return false;
        entry[0] = entry[1] = undefined;
        return true;
      },
      has: function(key) {
        var entry = key[this.name];
        if (!entry) return false;
        return entry[0] === key;
      }
    };
    window.WeakMap = WeakMap;
  })();
}

(function(global) {
  if (global.JsMutationObserver) {
    return;
  }
  var registrationsTable = new WeakMap();
  var setImmediate;
  if (/Trident|Edge/.test(navigator.userAgent)) {
    setImmediate = setTimeout;
  } else if (window.setImmediate) {
    setImmediate = window.setImmediate;
  } else {
    var setImmediateQueue = [];
    var sentinel = String(Math.random());
    window.addEventListener("message", function(e) {
      if (e.data === sentinel) {
        var queue = setImmediateQueue;
        setImmediateQueue = [];
        queue.forEach(function(func) {
          func();
        });
      }
    });
    setImmediate = function(func) {
      setImmediateQueue.push(func);
      window.postMessage(sentinel, "*");
    };
  }
  var isScheduled = false;
  var scheduledObservers = [];
  function scheduleCallback(observer) {
    scheduledObservers.push(observer);
    if (!isScheduled) {
      isScheduled = true;
      setImmediate(dispatchCallbacks);
    }
  }
  function wrapIfNeeded(node) {
    return window.ShadowDOMPolyfill && window.ShadowDOMPolyfill.wrapIfNeeded(node) || node;
  }
  function dispatchCallbacks() {
    isScheduled = false;
    var observers = scheduledObservers;
    scheduledObservers = [];
    observers.sort(function(o1, o2) {
      return o1.uid_ - o2.uid_;
    });
    var anyNonEmpty = false;
    observers.forEach(function(observer) {
      var queue = observer.takeRecords();
      removeTransientObserversFor(observer);
      if (queue.length) {
        observer.callback_(queue, observer);
        anyNonEmpty = true;
      }
    });
    if (anyNonEmpty) dispatchCallbacks();
  }
  function removeTransientObserversFor(observer) {
    observer.nodes_.forEach(function(node) {
      var registrations = registrationsTable.get(node);
      if (!registrations) return;
      registrations.forEach(function(registration) {
        if (registration.observer === observer) registration.removeTransientObservers();
      });
    });
  }
  function forEachAncestorAndObserverEnqueueRecord(target, callback) {
    for (var node = target; node; node = node.parentNode) {
      var registrations = registrationsTable.get(node);
      if (registrations) {
        for (var j = 0; j < registrations.length; j++) {
          var registration = registrations[j];
          var options = registration.options;
          if (node !== target && !options.subtree) continue;
          var record = callback(options);
          if (record) registration.enqueue(record);
        }
      }
    }
  }
  var uidCounter = 0;
  function JsMutationObserver(callback) {
    this.callback_ = callback;
    this.nodes_ = [];
    this.records_ = [];
    this.uid_ = ++uidCounter;
  }
  JsMutationObserver.prototype = {
    observe: function(target, options) {
      target = wrapIfNeeded(target);
      if (!options.childList && !options.attributes && !options.characterData || options.attributeOldValue && !options.attributes || options.attributeFilter && options.attributeFilter.length && !options.attributes || options.characterDataOldValue && !options.characterData) {
        throw new SyntaxError();
      }
      var registrations = registrationsTable.get(target);
      if (!registrations) registrationsTable.set(target, registrations = []);
      var registration;
      for (var i = 0; i < registrations.length; i++) {
        if (registrations[i].observer === this) {
          registration = registrations[i];
          registration.removeListeners();
          registration.options = options;
          break;
        }
      }
      if (!registration) {
        registration = new Registration(this, target, options);
        registrations.push(registration);
        this.nodes_.push(target);
      }
      registration.addListeners();
    },
    disconnect: function() {
      this.nodes_.forEach(function(node) {
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          var registration = registrations[i];
          if (registration.observer === this) {
            registration.removeListeners();
            registrations.splice(i, 1);
            break;
          }
        }
      }, this);
      this.records_ = [];
    },
    takeRecords: function() {
      var copyOfRecords = this.records_;
      this.records_ = [];
      return copyOfRecords;
    }
  };
  function MutationRecord(type, target) {
    this.type = type;
    this.target = target;
    this.addedNodes = [];
    this.removedNodes = [];
    this.previousSibling = null;
    this.nextSibling = null;
    this.attributeName = null;
    this.attributeNamespace = null;
    this.oldValue = null;
  }
  function copyMutationRecord(original) {
    var record = new MutationRecord(original.type, original.target);
    record.addedNodes = original.addedNodes.slice();
    record.removedNodes = original.removedNodes.slice();
    record.previousSibling = original.previousSibling;
    record.nextSibling = original.nextSibling;
    record.attributeName = original.attributeName;
    record.attributeNamespace = original.attributeNamespace;
    record.oldValue = original.oldValue;
    return record;
  }
  var currentRecord, recordWithOldValue;
  function getRecord(type, target) {
    return currentRecord = new MutationRecord(type, target);
  }
  function getRecordWithOldValue(oldValue) {
    if (recordWithOldValue) return recordWithOldValue;
    recordWithOldValue = copyMutationRecord(currentRecord);
    recordWithOldValue.oldValue = oldValue;
    return recordWithOldValue;
  }
  function clearRecords() {
    currentRecord = recordWithOldValue = undefined;
  }
  function recordRepresentsCurrentMutation(record) {
    return record === recordWithOldValue || record === currentRecord;
  }
  function selectRecord(lastRecord, newRecord) {
    if (lastRecord === newRecord) return lastRecord;
    if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord)) return recordWithOldValue;
    return null;
  }
  function Registration(observer, target, options) {
    this.observer = observer;
    this.target = target;
    this.options = options;
    this.transientObservedNodes = [];
  }
  Registration.prototype = {
    enqueue: function(record) {
      var records = this.observer.records_;
      var length = records.length;
      if (records.length > 0) {
        var lastRecord = records[length - 1];
        var recordToReplaceLast = selectRecord(lastRecord, record);
        if (recordToReplaceLast) {
          records[length - 1] = recordToReplaceLast;
          return;
        }
      } else {
        scheduleCallback(this.observer);
      }
      records[length] = record;
    },
    addListeners: function() {
      this.addListeners_(this.target);
    },
    addListeners_: function(node) {
      var options = this.options;
      if (options.attributes) node.addEventListener("DOMAttrModified", this, true);
      if (options.characterData) node.addEventListener("DOMCharacterDataModified", this, true);
      if (options.childList) node.addEventListener("DOMNodeInserted", this, true);
      if (options.childList || options.subtree) node.addEventListener("DOMNodeRemoved", this, true);
    },
    removeListeners: function() {
      this.removeListeners_(this.target);
    },
    removeListeners_: function(node) {
      var options = this.options;
      if (options.attributes) node.removeEventListener("DOMAttrModified", this, true);
      if (options.characterData) node.removeEventListener("DOMCharacterDataModified", this, true);
      if (options.childList) node.removeEventListener("DOMNodeInserted", this, true);
      if (options.childList || options.subtree) node.removeEventListener("DOMNodeRemoved", this, true);
    },
    addTransientObserver: function(node) {
      if (node === this.target) return;
      this.addListeners_(node);
      this.transientObservedNodes.push(node);
      var registrations = registrationsTable.get(node);
      if (!registrations) registrationsTable.set(node, registrations = []);
      registrations.push(this);
    },
    removeTransientObservers: function() {
      var transientObservedNodes = this.transientObservedNodes;
      this.transientObservedNodes = [];
      transientObservedNodes.forEach(function(node) {
        this.removeListeners_(node);
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          if (registrations[i] === this) {
            registrations.splice(i, 1);
            break;
          }
        }
      }, this);
    },
    handleEvent: function(e) {
      e.stopImmediatePropagation();
      switch (e.type) {
       case "DOMAttrModified":
        var name = e.attrName;
        var namespace = e.relatedNode.namespaceURI;
        var target = e.target;
        var record = new getRecord("attributes", target);
        record.attributeName = name;
        record.attributeNamespace = namespace;
        var oldValue = e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;
        forEachAncestorAndObserverEnqueueRecord(target, function(options) {
          if (!options.attributes) return;
          if (options.attributeFilter && options.attributeFilter.length && options.attributeFilter.indexOf(name) === -1 && options.attributeFilter.indexOf(namespace) === -1) {
            return;
          }
          if (options.attributeOldValue) return getRecordWithOldValue(oldValue);
          return record;
        });
        break;

       case "DOMCharacterDataModified":
        var target = e.target;
        var record = getRecord("characterData", target);
        var oldValue = e.prevValue;
        forEachAncestorAndObserverEnqueueRecord(target, function(options) {
          if (!options.characterData) return;
          if (options.characterDataOldValue) return getRecordWithOldValue(oldValue);
          return record;
        });
        break;

       case "DOMNodeRemoved":
        this.addTransientObserver(e.target);

       case "DOMNodeInserted":
        var changedNode = e.target;
        var addedNodes, removedNodes;
        if (e.type === "DOMNodeInserted") {
          addedNodes = [ changedNode ];
          removedNodes = [];
        } else {
          addedNodes = [];
          removedNodes = [ changedNode ];
        }
        var previousSibling = changedNode.previousSibling;
        var nextSibling = changedNode.nextSibling;
        var record = getRecord("childList", e.target.parentNode);
        record.addedNodes = addedNodes;
        record.removedNodes = removedNodes;
        record.previousSibling = previousSibling;
        record.nextSibling = nextSibling;
        forEachAncestorAndObserverEnqueueRecord(e.relatedNode, function(options) {
          if (!options.childList) return;
          return record;
        });
      }
      clearRecords();
    }
  };
  global.JsMutationObserver = JsMutationObserver;
  if (!global.MutationObserver) {
    global.MutationObserver = JsMutationObserver;
    JsMutationObserver._isPolyfilled = true;
  }
})(self);
/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/


/**
 * Minimal animation library for managing css transition on mobile browsers.
 */
window.animit = (function(){
  'use strict';

  var TIMEOUT_RATIO = 1.4;

  var util = {
  };

  // capitalize string
  util.capitalize = function(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  };

  /**
  * @param {Object} params
  * @param {String} params.property
  * @param {Float} params.duration
  * @param {String} params.timing
  */
  util.buildTransitionValue = function(params) {
    params.property = params.property || 'all';
    params.duration = params.duration || 0.4;
    params.timing = params.timing || 'linear';

    var props = params.property.split(/ +/);

    return props.map(function(prop) {
      return prop + ' ' + params.duration + 's ' + params.timing;
    }).join(', ');
  };

  /**
  * Add an event handler on "transitionend" event.
  */
  util.onceOnTransitionEnd = function(element, callback) {
    if (!element) {
      return function() {};
    }

    var fn = function(event) {
      if (element == event.target) {
        event.stopPropagation();
        removeListeners();

        callback();
      }
    };

    var removeListeners = function() {
      util._transitionEndEvents.forEach(function(eventName) {
        element.removeEventListener(eventName, fn, false);
      });
    };

    util._transitionEndEvents.forEach(function(eventName) {
      element.addEventListener(eventName, fn, false);
    });

    return removeListeners;
  };

  util._transitionEndEvents = (function() {

    if ('ontransitionend' in window) {
      return ['transitionend'];
    }

    if ('onwebkittransitionend' in window) {
      return ['webkitTransitionEnd'];
    }

    if (util.vendorPrefix === 'webkit' || util.vendorPrefix === 'o' || util.vendorPrefix === 'moz' || util.vendorPrefix === 'ms') {
      return [util.vendorPrefix + 'TransitionEnd', 'transitionend'];
    }

    return [];
  })();

  util._cssPropertyDict = (function() {
    var styles = window.getComputedStyle(document.documentElement, '');
    var dict = {};
    var a = 'A'.charCodeAt(0);
    var z = 'z'.charCodeAt(0);

    var upper = function(s) {
      return s.substr(1).toUpperCase();
    };

    for (var i = 0; i < styles.length; i++) {

      var key = styles[i]
        .replace(/^[\-]+/, '')
        .replace(/[\-][a-z]/g, upper)
        .replace(/^moz/, 'Moz');

      if (a <= key.charCodeAt(0) && z >= key.charCodeAt(0)) {
        if (key !== 'cssText' && key !== 'parentText') {
          dict[key] = true;
        }
      }
    }

    return dict;
  })();

  util.hasCssProperty = function(name) {
    return name in util._cssPropertyDict;
  };

  /**
   * Vendor prefix for css property.
   */
  util.vendorPrefix = (function() {
    var styles = window.getComputedStyle(document.documentElement, ''),
    pre = (Array.prototype.slice
      .call(styles)
      .join('')
      .match(/-(moz|webkit|ms)-/) || (styles.OLink === '' && ['', 'o'])
    )[1];
    return pre;
  })();

  util.forceLayoutAtOnce = function(elements, callback) {
    this.batchImmediate(function() {
      elements.forEach(function(element) {
        // force layout
        element.offsetHeight;
      });
      callback();
    });
  };

  util.batchImmediate = (function() {
    var callbacks = [];

    return function(callback) {
      if (callbacks.length === 0) {
        setImmediate(function() {
          var concreateCallbacks = callbacks.slice(0);
          callbacks = [];
          concreateCallbacks.forEach(function(callback) {
            callback();
          });
        });
      }

      callbacks.push(callback);
    };
  })();

  util.batchAnimationFrame = (function() {
    var callbacks = [];

    var raf = window.requestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.oRequestAnimationFrame ||
    window.msRequestAnimationFrame ||
    function(callback) {
      setTimeout(callback, 1000 / 60);
    };

    return function(callback) {
      if (callbacks.length === 0) {
        raf(function() {
          var concreateCallbacks = callbacks.slice(0);
          callbacks = [];
          concreateCallbacks.forEach(function(callback) {
            callback();
          });
        });
      }

      callbacks.push(callback);
    };
  })();

  util.transitionPropertyName = (function() {
    if (util.hasCssProperty('transitionDuration')) {
      return 'transition';
    }

    if (util.hasCssProperty(util.vendorPrefix + 'TransitionDuration')) {
      return util.vendorPrefix + 'Transition';
    }

    throw new Error('Invalid state');
  })();


  /**
   * @param {HTMLElement} element
   */
  var Animit = function(element) {
    if (!(this instanceof Animit)) {
      return new Animit(element);
    }

    if (element instanceof HTMLElement) {
      this.elements = [element];
    } else if (Object.prototype.toString.call(element) === '[object Array]') {
      this.elements = element;

    } else {
      throw new Error('First argument must be an array or an instance of HTMLElement.');
    }

    this.transitionQueue = [];
    this.lastStyleAttributeDict = [];
  };

  Animit.prototype = {

    /**
     * @property {Array}
     */
    transitionQueue: undefined,

    /**
     * @property {Array}
     */
    elements: undefined,

    /**
     * Start animation sequence with passed animations.
     *
     * @param {Function} callback
     */
    play: function(callback) {
      if (typeof callback === 'function') {
        this.transitionQueue.push(function(done) {
          callback();
          done();
        });
      }

      this.startAnimation();

      return this;
    },

    /**
     * Queue transition animations or other function.
     *
     * e.g. animit(elt).queue({color: 'red'})
     * e.g. animit(elt).queue({color: 'red'}, {duration: 0.4})
     * e.g. animit(elt).queue({css: {color: 'red'}, duration: 0.2})
     *
     * @param {Object|Animit.Transition|Function} transition
     * @param {Object} [options]
     */
    queue: function(transition, options) {
      var queue = this.transitionQueue;

      if (transition && options) {
        options.css = transition;
        transition = new Animit.Transition(options);
      }

      if (!(transition instanceof Function || transition instanceof Animit.Transition)) {
        if (transition.css) {
          transition = new Animit.Transition(transition);
        } else {
          transition = new Animit.Transition({
            css: transition
          });
        }
      }

      if (transition instanceof Function) {
        queue.push(transition);
      } else if (transition instanceof Animit.Transition) {
        queue.push(transition.build());
      } else {
        throw new Error('Invalid arguments');
      }

      return this;
    },

    /**
     * Queue transition animations.
     *
     * @param {Float} seconds
     */
    wait: function(seconds) {
      if (seconds > 0) {
        this.transitionQueue.push(function(done) {
          setTimeout(done, 1000 * seconds);
        });
      }

      return this;
    },

    saveStyle: function() {

      this.transitionQueue.push(function(done) {
        this.elements.forEach(function(element, index) {
          var css = this.lastStyleAttributeDict[index] = {};

          for (var i = 0; i < element.style.length; i++) {
            css[element.style[i]] = element.style[element.style[i]];
          }
        }.bind(this));
        done();
      }.bind(this));

      return this;
    },

    /**
     * Restore element's style.
     *
     * @param {Object} [options]
     * @param {Float} [options.duration]
     * @param {String} [options.timing]
     * @param {String} [options.transition]
     */
    restoreStyle: function(options) {
      options = options || {};
      var self = this;

      if (options.transition && !options.duration) {
        throw new Error('"options.duration" is required when "options.transition" is enabled.');
      }

      var transitionName = util.transitionPropertyName;

      if (options.transition || (options.duration && options.duration > 0)) {
        var transitionValue = options.transition || ('all ' + options.duration + 's ' + (options.timing || 'linear'));

        this.transitionQueue.push(function(done) {
          var elements = this.elements;
          var timeoutId;

          var clearTransition = function() {
            elements.forEach(function(element) {
              element.style[transitionName] = '';
            });
          };

          // add "transitionend" event handler
          var removeListeners = util.onceOnTransitionEnd(elements[0], function() {
            clearTimeout(timeoutId);
            clearTransition();
            done();
          });

          // for fail safe.
          timeoutId = setTimeout(function() {
            removeListeners();
            clearTransition();
            done();
          }, options.duration * 1000 * TIMEOUT_RATIO);

          // transition and style settings
          elements.forEach(function(element, index) {

            var css = self.lastStyleAttributeDict[index];

            if (!css) {
              throw new Error('restoreStyle(): The style is not saved. Invoke saveStyle() before.');
            }

            self.lastStyleAttributeDict[index] = undefined;

            var name;
            for (var i = 0, len = element.style.length; i < len; i++) {
              name = element.style[i];
              if (css[name] === undefined) {
                css[name] = '';
              }
            }

            element.style[transitionName] = transitionValue;

            Object.keys(css).forEach(function(key) {
              if (key !== transitionName) {
                element.style[key] = css[key];
              }
            });

            element.style[transitionName] = transitionValue;
          });
        });
      } else {
        this.transitionQueue.push(function(done) {
          reset();
          done();
        });
      }

      return this;

      function reset() {
        // Clear transition animation settings.
        self.elements.forEach(function(element, index) {
          element.style[transitionName] = 'none';

          var css = self.lastStyleAttributeDict[index];

          if (!css) {
            throw new Error('restoreStyle(): The style is not saved. Invoke saveStyle() before.');
          }

          self.lastStyleAttributeDict[index] = undefined;

          for (var i = 0, name = ''; i < element.style.length; i++) {
            name = element.style[i];
            if (typeof css[element.style[i]] === 'undefined') {
              css[element.style[i]] = '';
            }
          }

          Object.keys(css).forEach(function(key) {
            element.style[key] = css[key];
          });

        });
      }
    },

    /**
     * Start animation sequence.
     */
    startAnimation: function() {
      this._dequeueTransition();

      return this;
    },

    _dequeueTransition: function() {
      var transition = this.transitionQueue.shift();
      if (this._currentTransition) {
        throw new Error('Current transition exists.');
      }
      this._currentTransition = transition;
      var self = this;
      var called = false;

      var done = function() {
        if (!called) {
          called = true;
          self._currentTransition = undefined;
          self._dequeueTransition();
        } else {
          throw new Error('Invalid state: This callback is called twice.');
        }
      };

      if (transition) {
        transition.call(this, done);
      }
    }

  };

  /**
   * @param {Animit} arguments
   */
  Animit.runAll = function(/* arguments... */) {
    for (var i = 0; i < arguments.length; i++) {
      arguments[i].play();
    }
  };


  /**
   * @param {Object} options
   * @param {Float} [options.duration]
   * @param {String} [options.property]
   * @param {String} [options.timing]
   */
  Animit.Transition = function(options) {
    this.options = options || {};
    this.options.duration = this.options.duration || 0;
    this.options.timing = this.options.timing || 'linear';
    this.options.css = this.options.css || {};
    this.options.property = this.options.property || 'all';
  };

  Animit.Transition.prototype = {

    /**
     * @param {HTMLElement} element
     * @return {Function}
     */
    build: function() {

      if (Object.keys(this.options.css).length === 0) {
        throw new Error('options.css is required.');
      }

      var css = createActualCssProps(this.options.css);

      if (this.options.duration > 0) {
        var transitionValue = util.buildTransitionValue(this.options);
        var self = this;

        return function(callback) {
          var elements = this.elements;
          var timeout = self.options.duration * 1000 * TIMEOUT_RATIO;
          var timeoutId;

          var removeListeners = util.onceOnTransitionEnd(elements[0], function() {
            clearTimeout(timeoutId);
            callback();
          });

          timeoutId = setTimeout(function() {
            removeListeners();
            callback();
          }, timeout);

          elements.forEach(function(element) {
            element.style[util.transitionPropertyName] = transitionValue;

            Object.keys(css).forEach(function(name) {
              element.style[name] = css[name];
            });
          });

        };
      }

      if (this.options.duration <= 0) {
        return function(callback) {
          var elements = this.elements;

          elements.forEach(function(element) {
            element.style[util.transitionPropertyName] = '';

            Object.keys(css).forEach(function(name) {
              element.style[name] = css[name];
            });
          });

          if (elements.length > 0) {
            util.forceLayoutAtOnce(elements, function() {
              util.batchAnimationFrame(callback);
            });
          } else {
            util.batchAnimationFrame(callback);
          }
        };
      }

      function createActualCssProps(css) {
        var result = {};

        Object.keys(css).forEach(function(name) {
          var value = css[name];

          if (util.hasCssProperty(name)) {
            result[name] = value;
            return;
          }

          var prefixed = util.vendorPrefix + util.capitalize(name);
          if (util.hasCssProperty(prefixed)) {
            result[prefixed] = value;
          } else {
            result[prefixed] = value;
            result[name] = value;
          }
        });

        return result;
      }

    }
  };


  return Animit;
})();

/*
 * childNode.remove method polyfill for IE.
 * https://developer.mozilla.org/en-US/docs/Web/API/ChildNode/remove
 */

(function() {
	if (!('remove' in Element.prototype)) {
	  Element.prototype.remove = function() {
	    if (this.parentNode) {
	    	this.parentNode.removeChild(this);
	    }
	  };
	}
})();

/*
 * classList.js: Cross-browser full element.classList implementation.
 * 1.1.20150312
 *
 * By Eli Grey, http://eligrey.com
 * License: Dedicated to the public domain.
 *   See https://github.com/eligrey/classList.js/blob/master/LICENSE.md
 */

/*global self, document, DOMException */

/*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js */

if ("document" in self) {

// Full polyfill for browsers with no classList support
// Including IE < Edge missing SVGElement.classList
if (!("classList" in document.createElement("_"))
  || document.createElementNS && !("classList" in document.createElementNS("http://www.w3.org/2000/svg","g"))) {

(function (view) {

"use strict";

if (!('Element' in view)) return;

var
    classListProp = "classList"
  , protoProp = "prototype"
  , elemCtrProto = view.Element[protoProp]
  , objCtr = Object
  , strTrim = String[protoProp].trim || function () {
    return this.replace(/^\s+|\s+$/g, "");
  }
  , arrIndexOf = Array[protoProp].indexOf || function (item) {
    var
        i = 0
      , len = this.length
    ;
    for (; i < len; i++) {
      if (i in this && this[i] === item) {
        return i;
      }
    }
    return -1;
  }
  // Vendors: please allow content code to instantiate DOMExceptions
  , DOMEx = function (type, message) {
    this.name = type;
    this.code = DOMException[type];
    this.message = message;
  }
  , checkTokenAndGetIndex = function (classList, token) {
    if (token === "") {
      throw new DOMEx(
          "SYNTAX_ERR"
        , "An invalid or illegal string was specified"
      );
    }
    if (/\s/.test(token)) {
      throw new DOMEx(
          "INVALID_CHARACTER_ERR"
        , "String contains an invalid character"
      );
    }
    return arrIndexOf.call(classList, token);
  }
  , ClassList = function (elem) {
    var
        trimmedClasses = strTrim.call(elem.getAttribute("class") || "")
      , classes = trimmedClasses ? trimmedClasses.split(/\s+/) : []
      , i = 0
      , len = classes.length
    ;
    for (; i < len; i++) {
      this.push(classes[i]);
    }
    this._updateClassName = function () {
      elem.setAttribute("class", this.toString());
    };
  }
  , classListProto = ClassList[protoProp] = []
  , classListGetter = function () {
    return new ClassList(this);
  }
;
// Most DOMException implementations don't allow calling DOMException's toString()
// on non-DOMExceptions. Error's toString() is sufficient here.
DOMEx[protoProp] = Error[protoProp];
classListProto.item = function (i) {
  return this[i] || null;
};
classListProto.contains = function (token) {
  token += "";
  return checkTokenAndGetIndex(this, token) !== -1;
};
classListProto.add = function () {
  var
      tokens = arguments
    , i = 0
    , l = tokens.length
    , token
    , updated = false
  ;
  do {
    token = tokens[i] + "";
    if (checkTokenAndGetIndex(this, token) === -1) {
      this.push(token);
      updated = true;
    }
  }
  while (++i < l);

  if (updated) {
    this._updateClassName();
  }
};
classListProto.remove = function () {
  var
      tokens = arguments
    , i = 0
    , l = tokens.length
    , token
    , updated = false
    , index
  ;
  do {
    token = tokens[i] + "";
    index = checkTokenAndGetIndex(this, token);
    while (index !== -1) {
      this.splice(index, 1);
      updated = true;
      index = checkTokenAndGetIndex(this, token);
    }
  }
  while (++i < l);

  if (updated) {
    this._updateClassName();
  }
};
classListProto.toggle = function (token, force) {
  token += "";

  var
      result = this.contains(token)
    , method = result ?
      force !== true && "remove"
    :
      force !== false && "add"
  ;

  if (method) {
    this[method](token);
  }

  if (force === true || force === false) {
    return force;
  } else {
    return !result;
  }
};
classListProto.toString = function () {
  return this.join(" ");
};

if (objCtr.defineProperty) {
  var classListPropDesc = {
      get: classListGetter
    , enumerable: true
    , configurable: true
  };
  try {
    objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
  } catch (ex) { // IE 8 doesn't support enumerable:true
    if (ex.number === -0x7FF5EC54) {
      classListPropDesc.enumerable = false;
      objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
    }
  }
} else if (objCtr[protoProp].__defineGetter__) {
  elemCtrProto.__defineGetter__(classListProp, classListGetter);
}

}(self));

} else {
// There is full or partial native classList support, so just check if we need
// to normalize the add/remove and toggle APIs.

(function () {
  "use strict";

  var testElement = document.createElement("_");

  testElement.classList.add("c1", "c2");

  // Polyfill for IE 10/11 and Firefox <26, where classList.add and
  // classList.remove exist but support only one argument at a time.
  if (!testElement.classList.contains("c2")) {
    var createMethod = function(method) {
      var original = DOMTokenList.prototype[method];

      DOMTokenList.prototype[method] = function(token) {
        var i, len = arguments.length;

        for (i = 0; i < len; i++) {
          token = arguments[i];
          original.call(this, token);
        }
      };
    };
    createMethod('add');
    createMethod('remove');
  }

  testElement.classList.toggle("c3", false);

  // Polyfill for IE 10 and Firefox <24, where classList.toggle does not
  // support the second argument.
  if (testElement.classList.contains("c3")) {
    var _toggle = DOMTokenList.prototype.toggle;

    DOMTokenList.prototype.toggle = function(token, force) {
      if (1 in arguments && !this.contains(token) === !force) {
        return force;
      } else {
        return _toggle.call(this, token);
      }
    };

  }

  testElement = null;
}());

}

}


/*!

Copyright (C) 2014-2016 by Andrea Giammarchi - @WebReflection

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/
(function(window, document, Object, REGISTER_ELEMENT){'use strict';
var htmlClass = (function (info) {
  // (C) Andrea Giammarchi - @WebReflection - MIT Style
  var
    catchClass = /^[A-Z]+[a-z]/,
    filterBy = function (re) {
      var arr = [], tag;
      for (tag in register) {
        if (re.test(tag)) arr.push(tag);
      }
      return arr;
    },
    add = function (Class, tag) {
      tag = tag.toLowerCase();
      if (!(tag in register)) {
        register[Class] = (register[Class] || []).concat(tag);
        register[tag] = (register[tag.toUpperCase()] = Class);
      }
    },
    register = (Object.create || Object)(null),
    htmlClass = {},
    i, section, tags, Class
  ;
  for (section in info) {
    for (Class in info[section]) {
      tags = info[section][Class];
      register[Class] = tags;
      for (i = 0; i < tags.length; i++) {
        register[tags[i].toLowerCase()] =
        register[tags[i].toUpperCase()] = Class;
      }
    }
  }
  htmlClass.get = function get(tagOrClass) {
    return typeof tagOrClass === 'string' ?
      (register[tagOrClass] || (catchClass.test(tagOrClass) ? [] : '')) :
      filterBy(tagOrClass);
  };
  htmlClass.set = function set(tag, Class) {
    return (catchClass.test(tag) ?
      add(tag, Class) :
      add(Class, tag)
    ), htmlClass;
  };
  return htmlClass;
}({
  "collections": {
    "HTMLAllCollection": [
      "all"
    ],
    "HTMLCollection": [
      "forms"
    ],
    "HTMLFormControlsCollection": [
      "elements"
    ],
    "HTMLOptionsCollection": [
      "options"
    ]
  },
  "elements": {
    "Element": [
      "element"
    ],
    "HTMLAnchorElement": [
      "a"
    ],
    "HTMLAppletElement": [
      "applet"
    ],
    "HTMLAreaElement": [
      "area"
    ],
    "HTMLAttachmentElement": [
      "attachment"
    ],
    "HTMLAudioElement": [
      "audio"
    ],
    "HTMLBRElement": [
      "br"
    ],
    "HTMLBaseElement": [
      "base"
    ],
    "HTMLBodyElement": [
      "body"
    ],
    "HTMLButtonElement": [
      "button"
    ],
    "HTMLCanvasElement": [
      "canvas"
    ],
    "HTMLContentElement": [
      "content"
    ],
    "HTMLDListElement": [
      "dl"
    ],
    "HTMLDataElement": [
      "data"
    ],
    "HTMLDataListElement": [
      "datalist"
    ],
    "HTMLDetailsElement": [
      "details"
    ],
    "HTMLDialogElement": [
      "dialog"
    ],
    "HTMLDirectoryElement": [
      "dir"
    ],
    "HTMLDivElement": [
      "div"
    ],
    "HTMLDocument": [
      "document"
    ],
    "HTMLElement": [
      "element",
      "abbr",
      "address",
      "article",
      "aside",
      "b",
      "bdi",
      "bdo",
      "cite",
      "code",
      "command",
      "dd",
      "dfn",
      "dt",
      "em",
      "figcaption",
      "figure",
      "footer",
      "header",
      "i",
      "kbd",
      "mark",
      "nav",
      "noscript",
      "rp",
      "rt",
      "ruby",
      "s",
      "samp",
      "section",
      "small",
      "strong",
      "sub",
      "summary",
      "sup",
      "u",
      "var",
      "wbr"
    ],
    "HTMLEmbedElement": [
      "embed"
    ],
    "HTMLFieldSetElement": [
      "fieldset"
    ],
    "HTMLFontElement": [
      "font"
    ],
    "HTMLFormElement": [
      "form"
    ],
    "HTMLFrameElement": [
      "frame"
    ],
    "HTMLFrameSetElement": [
      "frameset"
    ],
    "HTMLHRElement": [
      "hr"
    ],
    "HTMLHeadElement": [
      "head"
    ],
    "HTMLHeadingElement": [
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6"
    ],
    "HTMLHtmlElement": [
      "html"
    ],
    "HTMLIFrameElement": [
      "iframe"
    ],
    "HTMLImageElement": [
      "img"
    ],
    "HTMLInputElement": [
      "input"
    ],
    "HTMLKeygenElement": [
      "keygen"
    ],
    "HTMLLIElement": [
      "li"
    ],
    "HTMLLabelElement": [
      "label"
    ],
    "HTMLLegendElement": [
      "legend"
    ],
    "HTMLLinkElement": [
      "link"
    ],
    "HTMLMapElement": [
      "map"
    ],
    "HTMLMarqueeElement": [
      "marquee"
    ],
    "HTMLMediaElement": [
      "media"
    ],
    "HTMLMenuElement": [
      "menu"
    ],
    "HTMLMenuItemElement": [
      "menuitem"
    ],
    "HTMLMetaElement": [
      "meta"
    ],
    "HTMLMeterElement": [
      "meter"
    ],
    "HTMLModElement": [
      "del",
      "ins"
    ],
    "HTMLOListElement": [
      "ol"
    ],
    "HTMLObjectElement": [
      "object"
    ],
    "HTMLOptGroupElement": [
      "optgroup"
    ],
    "HTMLOptionElement": [
      "option"
    ],
    "HTMLOutputElement": [
      "output"
    ],
    "HTMLParagraphElement": [
      "p"
    ],
    "HTMLParamElement": [
      "param"
    ],
    "HTMLPictureElement": [
      "picture"
    ],
    "HTMLPreElement": [
      "pre"
    ],
    "HTMLProgressElement": [
      "progress"
    ],
    "HTMLQuoteElement": [
      "blockquote",
      "q",
      "quote"
    ],
    "HTMLScriptElement": [
      "script"
    ],
    "HTMLSelectElement": [
      "select"
    ],
    "HTMLShadowElement": [
      "shadow"
    ],
    "HTMLSlotElement": [
      "slot"
    ],
    "HTMLSourceElement": [
      "source"
    ],
    "HTMLSpanElement": [
      "span"
    ],
    "HTMLStyleElement": [
      "style"
    ],
    "HTMLTableCaptionElement": [
      "caption"
    ],
    "HTMLTableCellElement": [
      "td",
      "th"
    ],
    "HTMLTableColElement": [
      "col",
      "colgroup"
    ],
    "HTMLTableElement": [
      "table"
    ],
    "HTMLTableRowElement": [
      "tr"
    ],
    "HTMLTableSectionElement": [
      "thead",
      "tbody",
      "tfoot"
    ],
    "HTMLTemplateElement": [
      "template"
    ],
    "HTMLTextAreaElement": [
      "textarea"
    ],
    "HTMLTimeElement": [
      "time"
    ],
    "HTMLTitleElement": [
      "title"
    ],
    "HTMLTrackElement": [
      "track"
    ],
    "HTMLUListElement": [
      "ul"
    ],
    "HTMLUnknownElement": [
      "unknown",
      "vhgroupv",
      "vkeygen"
    ],
    "HTMLVideoElement": [
      "video"
    ]
  },
  "nodes": {
    "Attr": [
      "node"
    ],
    "Audio": [
      "audio"
    ],
    "CDATASection": [
      "node"
    ],
    "CharacterData": [
      "node"
    ],
    "Comment": [
      "#comment"
    ],
    "Document": [
      "#document"
    ],
    "DocumentFragment": [
      "#document-fragment"
    ],
    "DocumentType": [
      "node"
    ],
    "HTMLDocument": [
      "#document"
    ],
    "Image": [
      "img"
    ],
    "Option": [
      "option"
    ],
    "ProcessingInstruction": [
      "node"
    ],
    "ShadowRoot": [
      "#shadow-root"
    ],
    "Text": [
      "#text"
    ],
    "XMLDocument": [
      "xml"
    ]
  }
}));



// DO NOT USE THIS FILE DIRECTLY, IT WON'T WORK
// THIS IS A PROJECT BASED ON A BUILD SYSTEM
// THIS FILE IS JUST WRAPPED UP RESULTING IN
// build/document-register-element.js
// and its .max.js counter part

var
  // IE < 11 only + old WebKit for attributes + feature detection
  EXPANDO_UID = '__' + REGISTER_ELEMENT + (Math.random() * 10e4 >> 0),

  // shortcuts and costants
  ADD_EVENT_LISTENER = 'addEventListener',
  ATTACHED = 'attached',
  CALLBACK = 'Callback',
  DETACHED = 'detached',
  EXTENDS = 'extends',

  ATTRIBUTE_CHANGED_CALLBACK = 'attributeChanged' + CALLBACK,
  ATTACHED_CALLBACK = ATTACHED + CALLBACK,
  CONNECTED_CALLBACK = 'connected' + CALLBACK,
  DISCONNECTED_CALLBACK = 'disconnected' + CALLBACK,
  CREATED_CALLBACK = 'created' + CALLBACK,
  DETACHED_CALLBACK = DETACHED + CALLBACK,

  ADDITION = 'ADDITION',
  MODIFICATION = 'MODIFICATION',
  REMOVAL = 'REMOVAL',

  DOM_ATTR_MODIFIED = 'DOMAttrModified',
  DOM_CONTENT_LOADED = 'DOMContentLoaded',
  DOM_SUBTREE_MODIFIED = 'DOMSubtreeModified',

  PREFIX_TAG = '<',
  PREFIX_IS = '=',

  // valid and invalid node names
  validName = /^[A-Z][A-Z0-9]*(?:-[A-Z0-9]+)+$/,
  invalidNames = [
    'ANNOTATION-XML',
    'COLOR-PROFILE',
    'FONT-FACE',
    'FONT-FACE-SRC',
    'FONT-FACE-URI',
    'FONT-FACE-FORMAT',
    'FONT-FACE-NAME',
    'MISSING-GLYPH'
  ],

  // registered types and their prototypes
  types = [],
  protos = [],

  // to query subnodes
  query = '',

  // html shortcut used to feature detect
  documentElement = document.documentElement,

  // ES5 inline helpers || basic patches
  indexOf = types.indexOf || function (v) {
    for(var i = this.length; i-- && this[i] !== v;){}
    return i;
  },

  // other helpers / shortcuts
  OP = Object.prototype,
  hOP = OP.hasOwnProperty,
  iPO = OP.isPrototypeOf,

  defineProperty = Object.defineProperty,
  empty = [],
  gOPD = Object.getOwnPropertyDescriptor,
  gOPN = Object.getOwnPropertyNames,
  gPO = Object.getPrototypeOf,
  sPO = Object.setPrototypeOf,

  // jshint proto: true
  hasProto = !!Object.__proto__,

  // V1 helpers
  fixGetClass = false,
  DRECEV1 = '__dreCEv1',
  customElements = window.customElements,
  usableCustomElements = !!(
    customElements &&
    customElements.define &&
    customElements.get &&
    customElements.whenDefined
  ),
  Dict = Object.create || Object,
  Map = window.Map || function Map() {
    var K = [], V = [], i;
    return {
      get: function (k) {
        return V[indexOf.call(K, k)];
      },
      set: function (k, v) {
        i = indexOf.call(K, k);
        if (i < 0) V[K.push(k) - 1] = v;
        else V[i] = v;
      }
    };
  },
  Promise = window.Promise || function (fn) {
    var
      notify = [],
      done = false,
      p = {
        'catch': function () {
          return p;
        },
        'then': function (cb) {
          notify.push(cb);
          if (done) setTimeout(resolve, 1);
          return p;
        }
      }
    ;
    function resolve(value) {
      done = true;
      while (notify.length) notify.shift()(value);
    }
    fn(resolve);
    return p;
  },
  justCreated = false,
  constructors = Dict(null),
  waitingList = Dict(null),
  nodeNames = new Map(),
  secondArgument = String,

  // used to create unique instances
  create = Object.create || function Bridge(proto) {
    // silly broken polyfill probably ever used but short enough to work
    return proto ? ((Bridge.prototype = proto), new Bridge()) : this;
  },

  // will set the prototype if possible
  // or copy over all properties
  setPrototype = sPO || (
    hasProto ?
      function (o, p) {
        o.__proto__ = p;
        return o;
      } : (
    (gOPN && gOPD) ?
      (function(){
        function setProperties(o, p) {
          for (var
            key,
            names = gOPN(p),
            i = 0, length = names.length;
            i < length; i++
          ) {
            key = names[i];
            if (!hOP.call(o, key)) {
              defineProperty(o, key, gOPD(p, key));
            }
          }
        }
        return function (o, p) {
          do {
            setProperties(o, p);
          } while ((p = gPO(p)) && !iPO.call(p, o));
          return o;
        };
      }()) :
      function (o, p) {
        for (var key in p) {
          o[key] = p[key];
        }
        return o;
      }
  )),

  // DOM shortcuts and helpers, if any

  MutationObserver = window.MutationObserver ||
                     window.WebKitMutationObserver,

  HTMLElementPrototype = (
    window.HTMLElement ||
    window.Element ||
    window.Node
  ).prototype,

  IE8 = !iPO.call(HTMLElementPrototype, documentElement),

  safeProperty = IE8 ? function (o, k, d) {
    o[k] = d.value;
    return o;
  } : defineProperty,

  isValidNode = IE8 ?
    function (node) {
      return node.nodeType === 1;
    } :
    function (node) {
      return iPO.call(HTMLElementPrototype, node);
    },

  targets = IE8 && [],

  cloneNode = HTMLElementPrototype.cloneNode,
  dispatchEvent = HTMLElementPrototype.dispatchEvent,
  getAttribute = HTMLElementPrototype.getAttribute,
  hasAttribute = HTMLElementPrototype.hasAttribute,
  removeAttribute = HTMLElementPrototype.removeAttribute,
  setAttribute = HTMLElementPrototype.setAttribute,

  // replaced later on
  createElement = document.createElement,
  patchedCreateElement = createElement,

  // shared observer for all attributes
  attributesObserver = MutationObserver && {
    attributes: true,
    characterData: true,
    attributeOldValue: true
  },

  // useful to detect only if there's no MutationObserver
  DOMAttrModified = MutationObserver || function(e) {
    doesNotSupportDOMAttrModified = false;
    documentElement.removeEventListener(
      DOM_ATTR_MODIFIED,
      DOMAttrModified
    );
  },

  // will both be used to make DOMNodeInserted asynchronous
  asapQueue,
  asapTimer = 0,

  // internal flags
  setListener = false,
  doesNotSupportDOMAttrModified = true,
  dropDomContentLoaded = true,

  // needed for the innerHTML helper
  notFromInnerHTMLHelper = true,

  // optionally defined later on
  onSubtreeModified,
  callDOMAttrModified,
  getAttributesMirror,
  observer,

  // based on setting prototype capability
  // will check proto or the expando attribute
  // in order to setup the node once
  patchIfNotAlready,
  patch
;

// only if needed
if (!(REGISTER_ELEMENT in document)) {

  if (sPO || hasProto) {
      patchIfNotAlready = function (node, proto) {
        if (!iPO.call(proto, node)) {
          setupNode(node, proto);
        }
      };
      patch = setupNode;
  } else {
      patchIfNotAlready = function (node, proto) {
        if (!node[EXPANDO_UID]) {
          node[EXPANDO_UID] = Object(true);
          setupNode(node, proto);
        }
      };
      patch = patchIfNotAlready;
  }

  if (IE8) {
    doesNotSupportDOMAttrModified = false;
    (function (){
      var
        descriptor = gOPD(HTMLElementPrototype, ADD_EVENT_LISTENER),
        addEventListener = descriptor.value,
        patchedRemoveAttribute = function (name) {
          var e = new CustomEvent(DOM_ATTR_MODIFIED, {bubbles: true});
          e.attrName = name;
          e.prevValue = getAttribute.call(this, name);
          e.newValue = null;
          e[REMOVAL] = e.attrChange = 2;
          removeAttribute.call(this, name);
          dispatchEvent.call(this, e);
        },
        patchedSetAttribute = function (name, value) {
          var
            had = hasAttribute.call(this, name),
            old = had && getAttribute.call(this, name),
            e = new CustomEvent(DOM_ATTR_MODIFIED, {bubbles: true})
          ;
          setAttribute.call(this, name, value);
          e.attrName = name;
          e.prevValue = had ? old : null;
          e.newValue = value;
          if (had) {
            e[MODIFICATION] = e.attrChange = 1;
          } else {
            e[ADDITION] = e.attrChange = 0;
          }
          dispatchEvent.call(this, e);
        },
        onPropertyChange = function (e) {
          // jshint eqnull:true
          var
            node = e.currentTarget,
            superSecret = node[EXPANDO_UID],
            propertyName = e.propertyName,
            event
          ;
          if (superSecret.hasOwnProperty(propertyName)) {
            superSecret = superSecret[propertyName];
            event = new CustomEvent(DOM_ATTR_MODIFIED, {bubbles: true});
            event.attrName = superSecret.name;
            event.prevValue = superSecret.value || null;
            event.newValue = (superSecret.value = node[propertyName] || null);
            if (event.prevValue == null) {
              event[ADDITION] = event.attrChange = 0;
            } else {
              event[MODIFICATION] = event.attrChange = 1;
            }
            dispatchEvent.call(node, event);
          }
        }
      ;
      descriptor.value = function (type, handler, capture) {
        if (
          type === DOM_ATTR_MODIFIED &&
          this[ATTRIBUTE_CHANGED_CALLBACK] &&
          this.setAttribute !== patchedSetAttribute
        ) {
          this[EXPANDO_UID] = {
            className: {
              name: 'class',
              value: this.className
            }
          };
          this.setAttribute = patchedSetAttribute;
          this.removeAttribute = patchedRemoveAttribute;
          addEventListener.call(this, 'propertychange', onPropertyChange);
        }
        addEventListener.call(this, type, handler, capture);
      };
      defineProperty(HTMLElementPrototype, ADD_EVENT_LISTENER, descriptor);
    }());
  } else if (!MutationObserver) {
    documentElement[ADD_EVENT_LISTENER](DOM_ATTR_MODIFIED, DOMAttrModified);
    documentElement.setAttribute(EXPANDO_UID, 1);
    documentElement.removeAttribute(EXPANDO_UID);
    if (doesNotSupportDOMAttrModified) {
      onSubtreeModified = function (e) {
        var
          node = this,
          oldAttributes,
          newAttributes,
          key
        ;
        if (node === e.target) {
          oldAttributes = node[EXPANDO_UID];
          node[EXPANDO_UID] = (newAttributes = getAttributesMirror(node));
          for (key in newAttributes) {
            if (!(key in oldAttributes)) {
              // attribute was added
              return callDOMAttrModified(
                0,
                node,
                key,
                oldAttributes[key],
                newAttributes[key],
                ADDITION
              );
            } else if (newAttributes[key] !== oldAttributes[key]) {
              // attribute was changed
              return callDOMAttrModified(
                1,
                node,
                key,
                oldAttributes[key],
                newAttributes[key],
                MODIFICATION
              );
            }
          }
          // checking if it has been removed
          for (key in oldAttributes) {
            if (!(key in newAttributes)) {
              // attribute removed
              return callDOMAttrModified(
                2,
                node,
                key,
                oldAttributes[key],
                newAttributes[key],
                REMOVAL
              );
            }
          }
        }
      };
      callDOMAttrModified = function (
        attrChange,
        currentTarget,
        attrName,
        prevValue,
        newValue,
        action
      ) {
        var e = {
          attrChange: attrChange,
          currentTarget: currentTarget,
          attrName: attrName,
          prevValue: prevValue,
          newValue: newValue
        };
        e[action] = attrChange;
        onDOMAttrModified(e);
      };
      getAttributesMirror = function (node) {
        for (var
          attr, name,
          result = {},
          attributes = node.attributes,
          i = 0, length = attributes.length;
          i < length; i++
        ) {
          attr = attributes[i];
          name = attr.name;
          if (name !== 'setAttribute') {
            result[name] = attr.value;
          }
        }
        return result;
      };
    }
  }

  // set as enumerable, writable and configurable
  document[REGISTER_ELEMENT] = function registerElement(type, options) {
    upperType = type.toUpperCase();
    if (!setListener) {
      // only first time document.registerElement is used
      // we need to set this listener
      // setting it by default might slow down for no reason
      setListener = true;
      if (MutationObserver) {
        observer = (function(attached, detached){
          function checkEmAll(list, callback) {
            for (var i = 0, length = list.length; i < length; callback(list[i++])){}
          }
          return new MutationObserver(function (records) {
            for (var
              current, node, newValue,
              i = 0, length = records.length; i < length; i++
            ) {
              current = records[i];
              if (current.type === 'childList') {
                checkEmAll(current.addedNodes, attached);
                checkEmAll(current.removedNodes, detached);
              } else {
                node = current.target;
                if (notFromInnerHTMLHelper &&
                    node[ATTRIBUTE_CHANGED_CALLBACK] &&
                    current.attributeName !== 'style') {
                  newValue = getAttribute.call(node, current.attributeName);
                  if (newValue !== current.oldValue) {
                    node[ATTRIBUTE_CHANGED_CALLBACK](
                      current.attributeName,
                      current.oldValue,
                      newValue
                    );
                  }
                }
              }
            }
          });
        }(executeAction(ATTACHED), executeAction(DETACHED)));
        observer.observe(
          document,
          {
            childList: true,
            subtree: true
          }
        );
      } else {
        asapQueue = [];
        document[ADD_EVENT_LISTENER]('DOMNodeInserted', onDOMNode(ATTACHED));
        document[ADD_EVENT_LISTENER]('DOMNodeRemoved', onDOMNode(DETACHED));
      }

      document[ADD_EVENT_LISTENER](DOM_CONTENT_LOADED, onReadyStateChange);
      document[ADD_EVENT_LISTENER]('readystatechange', onReadyStateChange);

      HTMLElementPrototype.cloneNode = function (deep) {
        var
          node = cloneNode.call(this, !!deep),
          i = getTypeIndex(node)
        ;
        if (-1 < i) patch(node, protos[i]);
        if (deep) loopAndSetup(node.querySelectorAll(query));
        return node;
      };
    }

    if (-2 < (
      indexOf.call(types, PREFIX_IS + upperType) +
      indexOf.call(types, PREFIX_TAG + upperType)
    )) {
      throwTypeError(type);
    }

    if (!validName.test(upperType) || -1 < indexOf.call(invalidNames, upperType)) {
      throw new Error('The type ' + type + ' is invalid');
    }

    var
      constructor = function () {
        return extending ?
          document.createElement(nodeName, upperType) :
          document.createElement(nodeName);
      },
      opt = options || OP,
      extending = hOP.call(opt, EXTENDS),
      nodeName = extending ? options[EXTENDS].toUpperCase() : upperType,
      upperType,
      i
    ;

    if (extending && -1 < (
      indexOf.call(types, PREFIX_TAG + nodeName)
    )) {
      throwTypeError(nodeName);
    }

    i = types.push((extending ? PREFIX_IS : PREFIX_TAG) + upperType) - 1;

    query = query.concat(
      query.length ? ',' : '',
      extending ? nodeName + '[is="' + type.toLowerCase() + '"]' : nodeName
    );

    constructor.prototype = (
      protos[i] = hOP.call(opt, 'prototype') ?
        opt.prototype :
        create(HTMLElementPrototype)
    );

    loopAndVerify(
      document.querySelectorAll(query),
      ATTACHED
    );

    return constructor;
  };

  document.createElement = (patchedCreateElement = function (localName, typeExtension) {
    var
      is = getIs(typeExtension),
      node = is ?
        createElement.call(document, localName, secondArgument(is)) :
        createElement.call(document, localName),
      name = '' + localName,
      i = indexOf.call(
        types,
        (is ? PREFIX_IS : PREFIX_TAG) +
        (is || name).toUpperCase()
      ),
      setup = -1 < i
    ;
    if (is) {
      node.setAttribute('is', is = is.toLowerCase());
      if (setup) {
        setup = isInQSA(name.toUpperCase(), is);
      }
    }
    notFromInnerHTMLHelper = !document.createElement.innerHTMLHelper;
    if (setup) patch(node, protos[i]);
    return node;
  });

}

function ASAP() {
  var queue = asapQueue.splice(0, asapQueue.length);
  asapTimer = 0;
  while (queue.length) {
    queue.shift().call(
      null, queue.shift()
    );
  }
}

function loopAndVerify(list, action) {
  for (var i = 0, length = list.length; i < length; i++) {
    verifyAndSetupAndAction(list[i], action);
  }
}

function loopAndSetup(list) {
  for (var i = 0, length = list.length, node; i < length; i++) {
    node = list[i];
    patch(node, protos[getTypeIndex(node)]);
  }
}

function executeAction(action) {
  return function (node) {
    if (isValidNode(node)) {
      verifyAndSetupAndAction(node, action);
      loopAndVerify(
        node.querySelectorAll(query),
        action
      );
    }
  };
}

function getTypeIndex(target) {
  var
    is = getAttribute.call(target, 'is'),
    nodeName = target.nodeName.toUpperCase(),
    i = indexOf.call(
      types,
      is ?
          PREFIX_IS + is.toUpperCase() :
          PREFIX_TAG + nodeName
    )
  ;
  return is && -1 < i && !isInQSA(nodeName, is) ? -1 : i;
}

function isInQSA(name, type) {
  return -1 < query.indexOf(name + '[is="' + type + '"]');
}

function onDOMAttrModified(e) {
  var
    node = e.currentTarget,
    attrChange = e.attrChange,
    attrName = e.attrName,
    target = e.target
  ;
  if (notFromInnerHTMLHelper &&
      (!target || target === node) &&
      node[ATTRIBUTE_CHANGED_CALLBACK] &&
      attrName !== 'style' &&
      e.prevValue !== e.newValue) {
    node[ATTRIBUTE_CHANGED_CALLBACK](
      attrName,
      attrChange === e[ADDITION] ? null : e.prevValue,
      attrChange === e[REMOVAL] ? null : e.newValue
    );
  }
}

function onDOMNode(action) {
  var executor = executeAction(action);
  return function (e) {
    asapQueue.push(executor, e.target);
    if (asapTimer) clearTimeout(asapTimer);
    asapTimer = setTimeout(ASAP, 1);
  };
}

function onReadyStateChange(e) {
  if (dropDomContentLoaded) {
    dropDomContentLoaded = false;
    e.currentTarget.removeEventListener(DOM_CONTENT_LOADED, onReadyStateChange);
  }
  loopAndVerify(
    (e.target || document).querySelectorAll(query),
    e.detail === DETACHED ? DETACHED : ATTACHED
  );
  if (IE8) purge();
}

function patchedSetAttribute(name, value) {
  // jshint validthis:true
  var self = this;
  setAttribute.call(self, name, value);
  onSubtreeModified.call(self, {target: self});
}

function setupNode(node, proto) {
  setPrototype(node, proto);
  if (observer) {
    observer.observe(node, attributesObserver);
  } else {
    if (doesNotSupportDOMAttrModified) {
      node.setAttribute = patchedSetAttribute;
      node[EXPANDO_UID] = getAttributesMirror(node);
      node[ADD_EVENT_LISTENER](DOM_SUBTREE_MODIFIED, onSubtreeModified);
    }
    node[ADD_EVENT_LISTENER](DOM_ATTR_MODIFIED, onDOMAttrModified);
  }
  if (node[CREATED_CALLBACK] && notFromInnerHTMLHelper) {
    node.created = true;
    node[CREATED_CALLBACK]();
    node.created = false;
  }
}

function purge() {
  for (var
    node,
    i = 0,
    length = targets.length;
    i < length; i++
  ) {
    node = targets[i];
    if (!documentElement.contains(node)) {
      length--;
      targets.splice(i--, 1);
      verifyAndSetupAndAction(node, DETACHED);
    }
  }
}

function throwTypeError(type) {
  throw new Error('A ' + type + ' type is already registered');
}

function verifyAndSetupAndAction(node, action) {
  var
    fn,
    i = getTypeIndex(node)
  ;
  if (-1 < i) {
    patchIfNotAlready(node, protos[i]);
    i = 0;
    if (action === ATTACHED && !node[ATTACHED]) {
      node[DETACHED] = false;
      node[ATTACHED] = true;
      i = 1;
      if (IE8 && indexOf.call(targets, node) < 0) {
        targets.push(node);
      }
    } else if (action === DETACHED && !node[DETACHED]) {
      node[ATTACHED] = false;
      node[DETACHED] = true;
      i = 1;
    }
    if (i && (fn = node[action + CALLBACK])) fn.call(node);
  }
}



// V1 in da House!
function CustomElementRegistry() {}

CustomElementRegistry.prototype = {
  constructor: CustomElementRegistry,
  // a workaround for the stubborn WebKit
  define: usableCustomElements ?
    function (name, Class, options) {
      if (options) {
        CERDefine(name, Class, options);
      } else {
        customElements.define(name, Class);
        name = name.toUpperCase();
        constructors[name] = {
          constructor: Class,
          create: [name]
        };
        nodeNames.set(Class, name);
      }
    } :
    CERDefine,
  get: usableCustomElements ?
    function (name) {
      return customElements.get(name) || get(name);
    } :
    get,
  whenDefined: usableCustomElements ?
    function (name) {
      return Promise.race([
        customElements.whenDefined(name),
        whenDefined(name)
      ]);
    } :
    whenDefined
};

function CERDefine(name, Class, options) {
  var
    is = options && options[EXTENDS] || '',
    CProto = Class.prototype,
    proto = create(CProto),
    attributes = Class.observedAttributes || empty,
    definition = {prototype: proto}
  ;
  // TODO: is this needed at all since it's inherited?
  // defineProperty(proto, 'constructor', {value: Class});
  safeProperty(proto, CREATED_CALLBACK, {
      value: function () {
        if (justCreated) justCreated = false;
        else if (!this[DRECEV1]) {
          this[DRECEV1] = true;
          new Class(this);
          if (CProto[CREATED_CALLBACK])
            CProto[CREATED_CALLBACK].call(this);
          var info = constructors[nodeNames.get(Class)];
          if (!usableCustomElements || info.create.length > 1) {
            notifyAttributes(this);
          }
        }
    }
  });
  safeProperty(proto, ATTRIBUTE_CHANGED_CALLBACK, {
    value: function (name) {
      if (-1 < indexOf.call(attributes, name))
        CProto[ATTRIBUTE_CHANGED_CALLBACK].apply(this, arguments);
    }
  });
  if (CProto[CONNECTED_CALLBACK]) {
    safeProperty(proto, ATTACHED_CALLBACK, {
      value: CProto[CONNECTED_CALLBACK]
    });
  }
  if (CProto[DISCONNECTED_CALLBACK]) {
    safeProperty(proto, DETACHED_CALLBACK, {
      value: CProto[DISCONNECTED_CALLBACK]
    });
  }
  if (is) definition[EXTENDS] = is;
  document[REGISTER_ELEMENT](name, definition);
  name = name.toUpperCase();
  constructors[name] = {
    constructor: Class,
    create: is ? [is, secondArgument(name)] : [name]
  };
  nodeNames.set(Class, name);
  whenDefined(name);
  waitingList[name].r();
}

function get(name) {
  var info = constructors[name.toUpperCase()];
  return info && info.constructor;
}

function getIs(options) {
  return typeof options === 'string' ?
      options : (options && options.is || '');
}

function notifyAttributes(self) {
  var
    callback = self[ATTRIBUTE_CHANGED_CALLBACK],
    attributes = callback ? self.attributes : empty,
    i = attributes.length,
    attribute
  ;
  while (i--) {
    attribute =  attributes[i]; // || attributes.item(i);
    callback.call(
      self,
      attribute.name || attribute.nodeName,
      null,
      attribute.value || attribute.nodeValue
    );
  }
}

function whenDefined(name) {
  name = name.toUpperCase();
  if (!(name in waitingList)) {
    waitingList[name] = {};
    waitingList[name].p = new Promise(function (resolve) {
      waitingList[name].r = resolve;
    });
  }
  return waitingList[name].p;
}

function polyfillV1() {
  if (customElements) delete window.customElements;
  defineProperty(window, 'customElements', {
    configurable: true,
    value: new CustomElementRegistry()
  });
  defineProperty(window, 'CustomElementRegistry', {
    configurable: true,
    value: CustomElementRegistry
  });
  for (var
    patchClass = function (name) {
      var Class = window[name];
      if (Class) {
        window[name] = function CustomElementsV1(self) {
          var info, isNative;
          if (!self) self = this;
          if (!self[DRECEV1]) {
            justCreated = true;
            info = constructors[nodeNames.get(self.constructor)];
            isNative = usableCustomElements && info.create.length === 1;
            self = isNative ?
              Reflect.construct(Class, empty, info.constructor) :
              document.createElement.apply(document, info.create);
            self[DRECEV1] = true;
            justCreated = false;
            if (!isNative) notifyAttributes(self);
          }
          return self;
        };
        window[name].prototype = Class.prototype;
        try {
          Class.prototype.constructor = window[name];
        } catch(WebKit) {
          fixGetClass = true;
          defineProperty(Class, DRECEV1, {value: window[name]});
        }
      }
    },
    Classes = htmlClass.get(/^HTML/),
    i = Classes.length;
    i--;
    patchClass(Classes[i])
  ) {}
  (document.createElement = function (name, options) {
    var is = getIs(options);
    return is ?
      patchedCreateElement.call(this, name, secondArgument(is)) :
      patchedCreateElement.call(this, name);
  });
}

if (!customElements) polyfillV1();
try {
  (function (DRE, options, name) {
    options[EXTENDS] = 'a';
    DRE.prototype = HTMLAnchorElement.prototype;
    customElements.define(name, DRE, options);
    if (document.createElement(name).getAttribute('is') !== name) {
      throw options;
    }
  }(
    function DRE() {
      return Reflect.construct(HTMLAnchorElement, [], DRE);
    },
    {},
    'document-register-element-a'
  ));
} catch(o_O) {
  polyfillV1();
}

try {
  createElement.call(document, 'a', 'a');
} catch(FireFox) {
  secondArgument = function (is) {
    return {is: is};
  };
}

}(window, document, Object, 'registerElement'));
;(function () {
	'use strict';

	/**
	 * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
	 *
	 * @codingstandard ftlabs-jsv2
	 * @copyright The Financial Times Limited [All Rights Reserved]
	 * @license MIT License (see LICENSE.txt)
	 */

	/*jslint browser:true, node:true*/
	/*global define, Event, Node*/


	/**
	 * Instantiate fast-clicking listeners on the specified layer.
	 *
	 * @constructor
	 * @param {Element} layer The layer to listen on
	 * @param {Object} [options={}] The options to override the defaults
	 */
	function FastClick(layer, options) {
		var oldOnClick;

		options = options || {};

		/**
		 * Whether a click is currently being tracked.
		 *
		 * @type boolean
		 */
		this.trackingClick = false;


		/**
		 * Timestamp for when click tracking started.
		 *
		 * @type number
		 */
		this.trackingClickStart = 0;


		/**
		 * The element being tracked for a click.
		 *
		 * @type EventTarget
		 */
		this.targetElement = null;


		/**
		 * X-coordinate of touch start event.
		 *
		 * @type number
		 */
		this.touchStartX = 0;


		/**
		 * Y-coordinate of touch start event.
		 *
		 * @type number
		 */
		this.touchStartY = 0;


		/**
		 * ID of the last touch, retrieved from Touch.identifier.
		 *
		 * @type number
		 */
		this.lastTouchIdentifier = 0;


		/**
		 * Touchmove boundary, beyond which a click will be cancelled.
		 *
		 * @type number
		 */
		this.touchBoundary = options.touchBoundary || 10;


		/**
		 * The FastClick layer.
		 *
		 * @type Element
		 */
		this.layer = layer;

		/**
		 * The minimum time between tap(touchstart and touchend) events
		 *
		 * @type number
		 */
		this.tapDelay = options.tapDelay || 200;

		/**
		 * The maximum time for a tap
		 *
		 * @type number
		 */
		this.tapTimeout = options.tapTimeout || 700;

		if (FastClick.notNeeded(layer)) {
			return;
		}

		// Some old versions of Android don't have Function.prototype.bind
		function bind(method, context) {
			return function() { return method.apply(context, arguments); };
		}


		var methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];
		var context = this;
		for (var i = 0, l = methods.length; i < l; i++) {
			context[methods[i]] = bind(context[methods[i]], context);
		}

		// Set up event handlers as required
		if (deviceIsAndroid) {
			layer.addEventListener('mouseover', this.onMouse, true);
			layer.addEventListener('mousedown', this.onMouse, true);
			layer.addEventListener('mouseup', this.onMouse, true);
		}

		layer.addEventListener('click', this.onClick, true);
		layer.addEventListener('touchstart', this.onTouchStart, false);
		layer.addEventListener('touchmove', this.onTouchMove, false);
		layer.addEventListener('touchend', this.onTouchEnd, false);
		layer.addEventListener('touchcancel', this.onTouchCancel, false);

		// Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
		// which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
		// layer when they are cancelled.
		if (!Event.prototype.stopImmediatePropagation) {
			layer.removeEventListener = function(type, callback, capture) {
				var rmv = Node.prototype.removeEventListener;
				if (type === 'click') {
					rmv.call(layer, type, callback.hijacked || callback, capture);
				} else {
					rmv.call(layer, type, callback, capture);
				}
			};

			layer.addEventListener = function(type, callback, capture) {
				var adv = Node.prototype.addEventListener;
				if (type === 'click') {
					adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {
						if (!event.propagationStopped) {
							callback(event);
						}
					}), capture);
				} else {
					adv.call(layer, type, callback, capture);
				}
			};
		}

		// If a handler is already declared in the element's onclick attribute, it will be fired before
		// FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
		// adding it as listener.
		if (typeof layer.onclick === 'function') {

			// Android browser on at least 3.2 requires a new reference to the function in layer.onclick
			// - the old one won't work if passed to addEventListener directly.
			oldOnClick = layer.onclick;
			layer.addEventListener('click', function(event) {
				oldOnClick(event);
			}, false);
			layer.onclick = null;
		}
	}

	/**
	* Windows Phone 8.1 fakes user agent string to look like Android and iPhone.
	*
	* @type boolean
	*/
	var deviceIsWindowsPhone = navigator.userAgent.indexOf("Windows Phone") >= 0;

	/**
	 * Android requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;


	/**
	 * iOS requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;


	/**
	 * iOS 4 requires an exception for select elements.
	 *
	 * @type boolean
	 */
	var deviceIsIOS4 = deviceIsIOS && (/OS 4_\d(_\d)?/).test(navigator.userAgent);


	/**
	 * iOS 6.0-7.* requires the target element to be manually derived
	 *
	 * @type boolean
	 */
	var deviceIsIOSWithBadTarget = deviceIsIOS && (/OS [6-7]_\d/).test(navigator.userAgent);

	/**
	 * BlackBerry requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;

	/**
	 * Determine whether a given element requires a native click.
	 *
	 * @param {EventTarget|Element} target Target DOM element
	 * @returns {boolean} Returns true if the element needs a native click
	 */
	FastClick.prototype.needsClick = function(target) {
		switch (target.nodeName.toLowerCase()) {

		// Don't send a synthetic click to disabled inputs (issue #62)
		case 'button':
		case 'select':
		case 'textarea':
			if (target.disabled) {
				return true;
			}

			break;
		case 'input':

			// File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
			if ((deviceIsIOS && target.type === 'file') || target.disabled) {
				return true;
			}

			break;
		case 'label':
		case 'iframe': // iOS8 homescreen apps can prevent events bubbling into frames
		case 'video':
			return true;
		}

		return (/\bneedsclick\b/).test(target.className);
	};


	/**
	 * Determine whether a given element requires a call to focus to simulate click into element.
	 *
	 * @param {EventTarget|Element} target Target DOM element
	 * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
	 */
	FastClick.prototype.needsFocus = function(target) {
		switch (target.nodeName.toLowerCase()) {
		case 'textarea':
			return true;
		case 'select':
			return !deviceIsAndroid;
		case 'input':
			switch (target.type) {
			case 'button':
			case 'checkbox':
			case 'file':
			case 'image':
			case 'radio':
			case 'submit':
				return false;
			}

			// No point in attempting to focus disabled inputs
			return !target.disabled && !target.readOnly;
		default:
			return (/\bneedsfocus\b/).test(target.className);
		}
	};


	/**
	 * Send a click event to the specified element.
	 *
	 * @param {EventTarget|Element} targetElement
	 * @param {Event} event
	 */
	FastClick.prototype.sendClick = function(targetElement, event) {
		var clickEvent, touch;

		// On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)
		if (document.activeElement && document.activeElement !== targetElement) {
			document.activeElement.blur();
		}

		touch = event.changedTouches[0];

		// Synthesize a click event, with an extra attribute so it can be tracked
		clickEvent = document.createEvent('MouseEvents');
		clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
		clickEvent.forwardedTouchEvent = true;
		targetElement.dispatchEvent(clickEvent);
	};

	FastClick.prototype.determineEventType = function(targetElement) {

		//Issue #159: Android Chrome Select Box does not open with a synthetic click event
		if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
			return 'mousedown';
		}

		return 'click';
	};


	/**
	 * @param {EventTarget|Element} targetElement
	 */
	FastClick.prototype.focus = function(targetElement) {
		var length;

		// Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.
		if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && targetElement.type !== 'month') {
			length = targetElement.value.length;
			targetElement.setSelectionRange(length, length);
		} else {
			targetElement.focus();
		}
	};


	/**
	 * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
	 *
	 * @param {EventTarget|Element} targetElement
	 */
	FastClick.prototype.updateScrollParent = function(targetElement) {
		var scrollParent, parentElement;

		scrollParent = targetElement.fastClickScrollParent;

		// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
		// target element was moved to another parent.
		if (!scrollParent || !scrollParent.contains(targetElement)) {
			parentElement = targetElement;
			do {
				if (parentElement.scrollHeight > parentElement.offsetHeight) {
					scrollParent = parentElement;
					targetElement.fastClickScrollParent = parentElement;
					break;
				}

				parentElement = parentElement.parentElement;
			} while (parentElement);
		}

		// Always update the scroll top tracker if possible.
		if (scrollParent) {
			scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
		}
	};


	/**
	 * @param {EventTarget} targetElement
	 * @returns {Element|EventTarget}
	 */
	FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {

		// On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
		if (eventTarget.nodeType === Node.TEXT_NODE) {
			return eventTarget.parentNode;
		}

		return eventTarget;
	};


	/**
	 * On touch start, record the position and scroll offset.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchStart = function(event) {
		var targetElement, touch, selection;

		// Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).
		if (event.targetTouches.length > 1) {
			return true;
		}

		targetElement = this.getTargetElementFromEventTarget(event.target);
		touch = event.targetTouches[0];

		if (deviceIsIOS) {

			// Only trusted events will deselect text on iOS (issue #49)
			selection = window.getSelection();
			if (selection.rangeCount && !selection.isCollapsed) {
				return true;
			}

			if (!deviceIsIOS4) {

				// Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
				// when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
				// with the same identifier as the touch event that previously triggered the click that triggered the alert.
				// Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
				// immediately preceding touch event (issue #52), so this fix is unavailable on that platform.
				// Issue 120: touch.identifier is 0 when Chrome dev tools 'Emulate touch events' is set with an iOS device UA string,
				// which causes all touch events to be ignored. As this block only applies to iOS, and iOS identifiers are always long,
				// random integers, it's safe to to continue if the identifier is 0 here.
				if (touch.identifier && touch.identifier === this.lastTouchIdentifier) {
					event.preventDefault();
					return false;
				}

				this.lastTouchIdentifier = touch.identifier;

				// If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
				// 1) the user does a fling scroll on the scrollable layer
				// 2) the user stops the fling scroll with another tap
				// then the event.target of the last 'touchend' event will be the element that was under the user's finger
				// when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
				// is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).
				this.updateScrollParent(targetElement);
			}
		}

		this.trackingClick = true;
		this.trackingClickStart = event.timeStamp;
		this.targetElement = targetElement;

		this.touchStartX = touch.pageX;
		this.touchStartY = touch.pageY;

		// Prevent phantom clicks on fast double-tap (issue #36)
		if ((event.timeStamp - this.lastClickTime) < this.tapDelay && (event.timeStamp - this.lastClickTime) > -1) {
			event.preventDefault();
		}

		return true;
	};


	/**
	 * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.touchHasMoved = function(event) {
		var touch = event.changedTouches[0], boundary = this.touchBoundary;

		if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
			return true;
		}

		return false;
	};


	/**
	 * Update the last position.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchMove = function(event) {
		if (!this.trackingClick) {
			return true;
		}

		// If the touch has moved, cancel the click tracking
		if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
			this.trackingClick = false;
			this.targetElement = null;
		}

		return true;
	};


	/**
	 * Attempt to find the labelled control for the given label element.
	 *
	 * @param {EventTarget|HTMLLabelElement} labelElement
	 * @returns {Element|null}
	 */
	FastClick.prototype.findControl = function(labelElement) {

		// Fast path for newer browsers supporting the HTML5 control attribute
		if (labelElement.control !== undefined) {
			return labelElement.control;
		}

		// All browsers under test that support touch events also support the HTML5 htmlFor attribute
		if (labelElement.htmlFor) {
			return document.getElementById(labelElement.htmlFor);
		}

		// If no for attribute exists, attempt to retrieve the first labellable descendant element
		// the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label
		return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
	};


	/**
	 * On touch end, determine whether to send a click event at once.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchEnd = function(event) {
		var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;

		if (!this.trackingClick) {
			return true;
		}

		// Prevent phantom clicks on fast double-tap (issue #36)
		if ((event.timeStamp - this.lastClickTime) < this.tapDelay && (event.timeStamp - this.lastClickTime) > -1) {
			this.cancelNextClick = true;
			return true;
		}

		if ((event.timeStamp - this.trackingClickStart) > this.tapTimeout) {
			return true;
		}

		// Reset to prevent wrong click cancel on input (issue #156).
		this.cancelNextClick = false;

		this.lastClickTime = event.timeStamp;

		trackingClickStart = this.trackingClickStart;
		this.trackingClick = false;
		this.trackingClickStart = 0;

		// On some iOS devices, the targetElement supplied with the event is invalid if the layer
		// is performing a transition or scroll, and has to be re-detected manually. Note that
		// for this to function correctly, it must be called *after* the event target is checked!
		// See issue #57; also filed as rdar://13048589 .
		if (deviceIsIOSWithBadTarget) {
			touch = event.changedTouches[0];

			// In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null
			targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
			targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
		}

		targetTagName = targetElement.tagName.toLowerCase();
		if (targetTagName === 'label') {
			forElement = this.findControl(targetElement);
			if (forElement) {
				this.focus(targetElement);
				if (deviceIsAndroid) {
					return false;
				}

				targetElement = forElement;
			}
		} else if (this.needsFocus(targetElement)) {

			// Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
			// Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
			if ((event.timeStamp - trackingClickStart) > 100 || (deviceIsIOS && window.top !== window && targetTagName === 'input')) {
				this.targetElement = null;
				return false;
			}

			this.focus(targetElement);
			this.sendClick(targetElement, event);

			// Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
			// Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)
			if (!deviceIsIOS || targetTagName !== 'select') {
				this.targetElement = null;
				event.preventDefault();
			}

			return false;
		}

		if (deviceIsIOS && !deviceIsIOS4) {

			// Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
			// and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
			scrollParent = targetElement.fastClickScrollParent;
			if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
				return true;
			}
		}

		// Prevent the actual click from going though - unless the target node is marked as requiring
		// real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.
		if (!this.needsClick(targetElement)) {
			event.preventDefault();
			this.sendClick(targetElement, event);
		}

		return false;
	};


	/**
	 * On touch cancel, stop tracking the click.
	 *
	 * @returns {void}
	 */
	FastClick.prototype.onTouchCancel = function() {
		this.trackingClick = false;
		this.targetElement = null;
	};


	/**
	 * Determine mouse events which should be permitted.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onMouse = function(event) {

		// If a target element was never set (because a touch event was never fired) allow the event
		if (!this.targetElement) {
			return true;
		}

		if (event.forwardedTouchEvent) {
			return true;
		}

		// Programmatically generated events targeting a specific element should be permitted
		if (!event.cancelable) {
			return true;
		}

		// Derive and check the target element to see whether the mouse event needs to be permitted;
		// unless explicitly enabled, prevent non-touch click events from triggering actions,
		// to prevent ghost/doubleclicks.
		if (!this.needsClick(this.targetElement) || this.cancelNextClick) {

			// Prevent any user-added listeners declared on FastClick element from being fired.
			if (event.stopImmediatePropagation) {
				event.stopImmediatePropagation();
			} else {

				// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
				event.propagationStopped = true;
			}

			// Cancel the event
			event.stopPropagation();
			event.preventDefault();

			return false;
		}

		// If the mouse event is permitted, return true for the action to go through.
		return true;
	};


	/**
	 * On actual clicks, determine whether this is a touch-generated click, a click action occurring
	 * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
	 * an actual click which should be permitted.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onClick = function(event) {
		var permitted;

		// It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.
		if (this.trackingClick) {
			this.targetElement = null;
			this.trackingClick = false;
			return true;
		}

		// Very odd behavior on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.
		if (event.target.type === 'submit' && event.detail === 0) {
			return true;
		}

		permitted = this.onMouse(event);

		// Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.
		if (!permitted) {
			this.targetElement = null;
		}

		// If clicks are permitted, return true for the action to go through.
		return permitted;
	};


	/**
	 * Remove all FastClick's event listeners.
	 *
	 * @returns {void}
	 */
	FastClick.prototype.destroy = function() {
		var layer = this.layer;

		if (deviceIsAndroid) {
			layer.removeEventListener('mouseover', this.onMouse, true);
			layer.removeEventListener('mousedown', this.onMouse, true);
			layer.removeEventListener('mouseup', this.onMouse, true);
		}

		layer.removeEventListener('click', this.onClick, true);
		layer.removeEventListener('touchstart', this.onTouchStart, false);
		layer.removeEventListener('touchmove', this.onTouchMove, false);
		layer.removeEventListener('touchend', this.onTouchEnd, false);
		layer.removeEventListener('touchcancel', this.onTouchCancel, false);
	};


	/**
	 * Check whether FastClick is needed.
	 *
	 * @param {Element} layer The layer to listen on
	 */
	FastClick.notNeeded = function(layer) {
		var metaViewport;
		var chromeVersion;
		var blackberryVersion;
		var firefoxVersion;

		// Devices that don't support touch don't need FastClick
		if (typeof window.ontouchstart === 'undefined') {
			return true;
		}

		// Chrome version - zero for other browsers
		chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];

		if (chromeVersion) {

			if (deviceIsAndroid) {
				metaViewport = document.querySelector('meta[name=viewport]');

				if (metaViewport) {
					// Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
						return true;
					}
					// Chrome 32 and above with width=device-width or less don't need FastClick
					if (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {
						return true;
					}
				}

			// Chrome desktop doesn't need FastClick (issue #15)
			} else {
				return true;
			}
		}

		if (deviceIsBlackBerry10) {
			blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/);

			// BlackBerry 10.3+ does not require Fastclick library.
			// https://github.com/ftlabs/fastclick/issues/251
			if (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {
				metaViewport = document.querySelector('meta[name=viewport]');

				if (metaViewport) {
					// user-scalable=no eliminates click delay.
					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
						return true;
					}
					// width=device-width (or less than device-width) eliminates click delay.
					if (document.documentElement.scrollWidth <= window.outerWidth) {
						return true;
					}
				}
			}
		}

		// IE10 with -ms-touch-action: none or manipulation, which disables double-tap-to-zoom (issue #97)
		if (layer.style.msTouchAction === 'none' || layer.style.touchAction === 'manipulation') {
			return true;
		}

		// Firefox version - zero for other browsers
		firefoxVersion = +(/Firefox\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];

		if (firefoxVersion >= 27) {
			// Firefox 27+ does not have tap delay if the content is not zoomable - https://bugzilla.mozilla.org/show_bug.cgi?id=922896

			metaViewport = document.querySelector('meta[name=viewport]');
			if (metaViewport && (metaViewport.content.indexOf('user-scalable=no') !== -1 || document.documentElement.scrollWidth <= window.outerWidth)) {
				return true;
			}
		}

		// IE11: prefixed -ms-touch-action is no longer supported and it's recommended to use non-prefixed version
		// http://msdn.microsoft.com/en-us/library/windows/apps/Hh767313.aspx
		if (layer.style.touchAction === 'none' || layer.style.touchAction === 'manipulation') {
			return true;
		}

		return false;
	};


	/**
	 * Factory method for creating a FastClick object
	 *
	 * @param {Element} layer The layer to listen on
	 * @param {Object} [options={}] The options to override the defaults
	 */
	FastClick.attach = function(layer, options) {
		return new FastClick(layer, options);
	};

  window.FastClick = FastClick;
}());

// see https://github.com/WebReflection/document-register-element/issues/21#issuecomment-102020311
var innerHTML = (function (document) {

  var
    EXTENDS = 'extends',
    register = document.registerElement,
    div = document.createElement('div'),
    dre = 'document-register-element',
    innerHTML = register.innerHTML,
    initialize,
    registered
  ;

  // avoid duplicated wrappers
  if (innerHTML) return innerHTML;

  try {

    // feature detect the problem
    register.call(
      document,
      dre,
      {prototype: Object.create(
        HTMLElement.prototype,
        {createdCallback: {value: Object}}
      )}
    );

    div.innerHTML = '<' + dre + '></' + dre + '>';

    // if natively supported, nothing to do
    if ('createdCallback' in div.querySelector(dre)) {
      // return just an innerHTML wrap
      return (register.innerHTML = function (el, html) {
        el.innerHTML = html;
        return el;
      });
    }

  } catch(meh) {}

  // in other cases
  registered = [];
  initialize = function (el) {
    if (
      'createdCallback' in el         ||
      'attachedCallback' in el        ||
      'detachedCallback' in el        ||
      'attributeChangedCallback' in el
    ) return;
    document.createElement.innerHTMLHelper = true;
    for (var
      parentNode = el.parentNode,
      type = el.getAttribute('is'),
      name = el.nodeName,
      node = document.createElement.apply(
        document,
        type ? [name, type] : [name]
      ),
      attributes = el.attributes,
      i = 0,
      length = attributes.length,
      attr, fc;
      i < length; i++
    ) {
      attr = attributes[i];
      node.setAttribute(attr.name, attr.value);
    }
    if (node.createdCallback) {
      node.created = true;
      node.createdCallback();
      node.created = false;
    }
    while ((fc = el.firstChild)) node.appendChild(fc);
    document.createElement.innerHTMLHelper = false;
    if (parentNode) parentNode.replaceChild(node, el);
  };
  // augment the document.registerElement method
  return ((document.registerElement = function registerElement(type, options) {
    var name = (options[EXTENDS] ?
      (options[EXTENDS] + '[is="' + type + '"]') : type
    ).toLowerCase();
    if (registered.indexOf(name) < 0) registered.push(name);
    return register.apply(document, arguments);
  }).innerHTML = function (el, html) {
    el.innerHTML = html;
    for (var
      nodes = el.querySelectorAll(registered.join(',')),
      i = nodes.length; i--; initialize(nodes[i])
    ) {}
    return el;
  });
}(document));
/**
 * MicroEvent - to make any js object an event emitter (server or browser)
 * 
 * - pure javascript - server compatible, browser compatible
 * - dont rely on the browser doms
 * - super simple - you get it immediately, no mystery, no magic involved
 *
 * - create a MicroEventDebug with goodies to debug
 *   - make it safer to use
*/

/** NOTE: This library is customized for Onsen UI. */

var MicroEvent  = function(){};
MicroEvent.prototype  = {
  on  : function(event, fct){
    this._events = this._events || {};
    this._events[event] = this._events[event] || [];
    this._events[event].push(fct);
  },
  once : function(event, fct){
    var self = this;
    var wrapper = function() {
      self.off(event, wrapper);
      return fct.apply(null, arguments);
    };
    this.on(event, wrapper);
  },
  off  : function(event, fct){
    this._events = this._events || {};
    if( event in this._events === false  )  return;
    this._events[event].splice(this._events[event].indexOf(fct), 1);
  },
  emit : function(event /* , args... */){
    this._events = this._events || {};
    if( event in this._events === false  )  return;
    for(var i = 0; i < this._events[event].length; i++){
      this._events[event][i].apply(this, Array.prototype.slice.call(arguments, 1));
    }
  }
};

/**
 * mixin will delegate all MicroEvent.js function in the destination object
 *
 * - require('MicroEvent').mixin(Foobar) will make Foobar able to use MicroEvent
 *
 * @param {Object} the object which will support MicroEvent
*/
MicroEvent.mixin  = function(destObject){
  var props = ['on', 'once', 'off', 'emit'];
  for(var i = 0; i < props.length; i ++){
    if( typeof destObject === 'function' ){
      destObject.prototype[props[i]]  = MicroEvent.prototype[props[i]];
    }else{
      destObject[props[i]] = MicroEvent.prototype[props[i]];
    }
  }
}

// export in common js
if( typeof module !== "undefined" && ('exports' in module)){
  module.exports  = MicroEvent;
}

window.MicroEvent = MicroEvent;

(function (root) {

  // Store setTimeout reference so promise-polyfill will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var setTimeoutFunc = setTimeout;

  function noop() {}
  
  // Polyfill for Function.prototype.bind
  function bind(fn, thisArg) {
    return function () {
      fn.apply(thisArg, arguments);
    };
  }

  function Promise(fn) {
    if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');
    if (typeof fn !== 'function') throw new TypeError('not a function');
    this._state = 0;
    this._handled = false;
    this._value = undefined;
    this._deferreds = [];

    doResolve(fn, this);
  }

  function handle(self, deferred) {
    while (self._state === 3) {
      self = self._value;
    }
    if (self._state === 0) {
      self._deferreds.push(deferred);
      return;
    }
    self._handled = true;
    Promise._immediateFn(function () {
      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
      if (cb === null) {
        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
        return;
      }
      var ret;
      try {
        ret = cb(self._value);
      } catch (e) {
        reject(deferred.promise, e);
        return;
      }
      resolve(deferred.promise, ret);
    });
  }

  function resolve(self, newValue) {
    try {
      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');
      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
        var then = newValue.then;
        if (newValue instanceof Promise) {
          self._state = 3;
          self._value = newValue;
          finale(self);
          return;
        } else if (typeof then === 'function') {
          doResolve(bind(then, newValue), self);
          return;
        }
      }
      self._state = 1;
      self._value = newValue;
      finale(self);
    } catch (e) {
      reject(self, e);
    }
  }

  function reject(self, newValue) {
    self._state = 2;
    self._value = newValue;
    finale(self);
  }

  function finale(self) {
    if (self._state === 2 && self._deferreds.length === 0) {
      Promise._immediateFn(function() {
        if (!self._handled) {
          Promise._unhandledRejectionFn(self._value);
        }
      });
    }

    for (var i = 0, len = self._deferreds.length; i < len; i++) {
      handle(self, self._deferreds[i]);
    }
    self._deferreds = null;
  }

  function Handler(onFulfilled, onRejected, promise) {
    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
    this.promise = promise;
  }

  /**
   * Take a potentially misbehaving resolver function and make sure
   * onFulfilled and onRejected are only called once.
   *
   * Makes no guarantees about asynchrony.
   */
  function doResolve(fn, self) {
    var done = false;
    try {
      fn(function (value) {
        if (done) return;
        done = true;
        resolve(self, value);
      }, function (reason) {
        if (done) return;
        done = true;
        reject(self, reason);
      });
    } catch (ex) {
      if (done) return;
      done = true;
      reject(self, ex);
    }
  }

  Promise.prototype['catch'] = function (onRejected) {
    return this.then(null, onRejected);
  };

  Promise.prototype.then = function (onFulfilled, onRejected) {
    var prom = new (this.constructor)(noop);

    handle(this, new Handler(onFulfilled, onRejected, prom));
    return prom;
  };

  Promise.all = function (arr) {
    var args = Array.prototype.slice.call(arr);

    return new Promise(function (resolve, reject) {
      if (args.length === 0) return resolve([]);
      var remaining = args.length;

      function res(i, val) {
        try {
          if (val && (typeof val === 'object' || typeof val === 'function')) {
            var then = val.then;
            if (typeof then === 'function') {
              then.call(val, function (val) {
                res(i, val);
              }, reject);
              return;
            }
          }
          args[i] = val;
          if (--remaining === 0) {
            resolve(args);
          }
        } catch (ex) {
          reject(ex);
        }
      }

      for (var i = 0; i < args.length; i++) {
        res(i, args[i]);
      }
    });
  };

  Promise.resolve = function (value) {
    if (value && typeof value === 'object' && value.constructor === Promise) {
      return value;
    }

    return new Promise(function (resolve) {
      resolve(value);
    });
  };

  Promise.reject = function (value) {
    return new Promise(function (resolve, reject) {
      reject(value);
    });
  };

  Promise.race = function (values) {
    return new Promise(function (resolve, reject) {
      for (var i = 0, len = values.length; i < len; i++) {
        values[i].then(resolve, reject);
      }
    });
  };

  // Use polyfill for setImmediate for performance gains
  Promise._immediateFn = (typeof setImmediate === 'function' && function (fn) { setImmediate(fn); }) ||
    function (fn) {
      setTimeoutFunc(fn, 0);
    };

  Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
    if (typeof console !== 'undefined' && console) {
      console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
    }
  };

  /**
   * Set the immediate function to execute callbacks
   * @param fn {function} Function to execute
   * @deprecated
   */
  Promise._setImmediateFn = function _setImmediateFn(fn) {
    Promise._immediateFn = fn;
  };

  /**
   * Change the function to execute on unhandled rejection
   * @param {function} fn Function to execute on unhandled rejection
   * @deprecated
   */
  Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {
    Promise._unhandledRejectionFn = fn;
  };

  if (!window.Promise) {
    window.Promise = Promise;
  }
})(this);

/*
Copyright (c) 2012 Barnesandnoble.com, llc, Donavon West, and Domenic Denicola

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/
(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var setImmediate;

    function addFromSetImmediateArguments(args) {
        tasksByHandle[nextHandle] = partiallyApplied.apply(undefined, args);
        return nextHandle++;
    }

    // This function accepts the same arguments as setImmediate, but
    // returns a function that requires no arguments.
    function partiallyApplied(handler) {
        var args = [].slice.call(arguments, 1);
        return function() {
            if (typeof handler === "function") {
                handler.apply(undefined, args);
            } else {
                (new Function("" + handler))();
            }
        };
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(partiallyApplied(runIfPresent, handle), 0);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    task();
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function installNextTickImplementation() {
        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            process.nextTick(partiallyApplied(runIfPresent, handle));
            return handle;
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            global.postMessage(messagePrefix + handle, "*");
            return handle;
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            channel.port2.postMessage(handle);
            return handle;
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
            return handle;
        };
    }

    function installSetTimeoutImplementation() {
        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            setTimeout(partiallyApplied(runIfPresent, handle), 0);
            return handle;
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(function() {return this;}()));

(function() {
    function Viewport() {

        this.PRE_IOS7_VIEWPORT = "initial-scale=1, maximum-scale=1, user-scalable=no";
        this.IOS7_VIEWPORT = "initial-scale=1, maximum-scale=1, user-scalable=no";
        this.DEFAULT_VIEWPORT = "initial-scale=1, maximum-scale=1, user-scalable=no";

        this.ensureViewportElement();
        this.platform = {};
        this.platform.name = this.getPlatformName();
        this.platform.version = this.getPlatformVersion();

        return this;
    };

    Viewport.prototype.ensureViewportElement = function(){
        this.viewportElement = document.querySelector('meta[name=viewport]');
        if(!this.viewportElement){
            this.viewportElement = document.createElement('meta');
            this.viewportElement.name = "viewport";
            document.head.appendChild(this.viewportElement);
        }
    },

    Viewport.prototype.setup = function() {
        if (!this.viewportElement) {
            return;
        }

        if (this.viewportElement.getAttribute('data-no-adjust') == "true") {
            return;
        }

        if (!this.viewportElement.getAttribute('content')) {
            if (this.platform.name == 'ios') {
                if (this.platform.version >= 7 && isWebView()) {
                    this.viewportElement.setAttribute('content', this.IOS7_VIEWPORT);
                } else {
                    this.viewportElement.setAttribute('content', this.PRE_IOS7_VIEWPORT);
                }
            } else {
                this.viewportElement.setAttribute('content', this.DEFAULT_VIEWPORT);
            }
        }

        function isWebView() {
            return !!(window.cordova || window.phonegap || window.PhoneGap);
        }
    };

    Viewport.prototype.getPlatformName = function() {
        if (navigator.userAgent.match(/Android/i)) {
            return "android";
        }

        if (navigator.userAgent.match(/iPhone|iPad|iPod/i)) {
            return "ios";
        }

        // unknown
        return undefined;
    };

    Viewport.prototype.getPlatformVersion = function() {
        var start = window.navigator.userAgent.indexOf('OS ');
        return window.Number(window.navigator.userAgent.substr(start + 3, 3).replace('_', '.'));
    };

    window.Viewport = Viewport;
})();

// Copyright (c) Microsoft Open Technologies, Inc.  All rights reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.
// JavaScript Dynamic Content shim for Windows Store apps
(function () {

    if (window.MSApp && MSApp.execUnsafeLocalFunction) {

        // Some nodes will have an "attributes" property which shadows the Node.prototype.attributes property
        //  and means we don't actually see the attributes of the Node (interestingly the VS debug console
        //  appears to suffer from the same issue).
        //
        var Element_setAttribute = Object.getOwnPropertyDescriptor(Element.prototype, "setAttribute").value;
        var Element_removeAttribute = Object.getOwnPropertyDescriptor(Element.prototype, "removeAttribute").value;
        var HTMLElement_insertAdjacentHTMLPropertyDescriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, "insertAdjacentHTML");
        var Node_get_attributes = Object.getOwnPropertyDescriptor(Node.prototype, "attributes").get;
        var Node_get_childNodes = Object.getOwnPropertyDescriptor(Node.prototype, "childNodes").get;
        var detectionDiv = document.createElement("div");

        function getAttributes(element) {
            return Node_get_attributes.call(element);
        }

        function setAttribute(element, attribute, value) {
            try {
                Element_setAttribute.call(element, attribute, value);
            } catch (e) {
                // ignore
            }
        }

        function removeAttribute(element, attribute) {
            Element_removeAttribute.call(element, attribute);
        }

        function childNodes(element) {
            return Node_get_childNodes.call(element);
        }

        function empty(element) {
            while (element.childNodes.length) {
                element.removeChild(element.lastChild);
            }
        }

        function insertAdjacentHTML(element, position, html) {
            HTMLElement_insertAdjacentHTMLPropertyDescriptor.value.call(element, position, html);
        }

        function inUnsafeMode() {
            var isUnsafe = true;
            try {
                detectionDiv.innerHTML = "<test/>";
            }
            catch (ex) {
                isUnsafe = false;
            }

            return isUnsafe;
        }

        function cleanse(html, targetElement) {
            var cleaner = document.implementation.createHTMLDocument("cleaner");
            empty(cleaner.documentElement);
            MSApp.execUnsafeLocalFunction(function () {
                insertAdjacentHTML(cleaner.documentElement, "afterbegin", html);
            });

            var scripts = cleaner.documentElement.querySelectorAll("script");
            Array.prototype.forEach.call(scripts, function (script) {
                switch (script.type.toLowerCase()) {
                    case "":
                        script.type = "text/inert";
                        break;
                    case "text/javascript":
                    case "text/ecmascript":
                    case "text/x-javascript":
                    case "text/jscript":
                    case "text/livescript":
                    case "text/javascript1.1":
                    case "text/javascript1.2":
                    case "text/javascript1.3":
                        script.type = "text/inert-" + script.type.slice("text/".length);
                        break;
                    case "application/javascript":
                    case "application/ecmascript":
                    case "application/x-javascript":
                        script.type = "application/inert-" + script.type.slice("application/".length);
                        break;

                    default:
                        break;
                }
            });

            function cleanseAttributes(element) {
                var attributes = getAttributes(element);
                if (attributes && attributes.length) {
                    // because the attributes collection is live it is simpler to queue up the renames
                    var events;
                    for (var i = 0, len = attributes.length; i < len; i++) {
                        var attribute = attributes[i];
                        var name = attribute.name;
                        if ((name[0] === "o" || name[0] === "O") &&
                            (name[1] === "n" || name[1] === "N")) {
                            events = events || [];
                            events.push({ name: attribute.name, value: attribute.value });
                        }
                    }
                    if (events) {
                        for (var i = 0, len = events.length; i < len; i++) {
                            var attribute = events[i];
                            removeAttribute(element, attribute.name);
                            setAttribute(element, "x-" + attribute.name, attribute.value);
                        }
                    }
                }
                var children = childNodes(element);
                for (var i = 0, len = children.length; i < len; i++) {
                    cleanseAttributes(children[i]);
                }
            }
            cleanseAttributes(cleaner.documentElement);

            var cleanedNodes = [];

            if (targetElement.tagName === 'HTML') {
                cleanedNodes = Array.prototype.slice.call(document.adoptNode(cleaner.documentElement).childNodes);
            } else {
                if (cleaner.head) {
                    cleanedNodes = cleanedNodes.concat(Array.prototype.slice.call(document.adoptNode(cleaner.head).childNodes));
                }
                if (cleaner.body) {
                    cleanedNodes = cleanedNodes.concat(Array.prototype.slice.call(document.adoptNode(cleaner.body).childNodes));
                }
            }

            return cleanedNodes;
        }

        function cleansePropertySetter(property, setter) {
            var propertyDescriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, property);
            var originalSetter = propertyDescriptor.set;
            Object.defineProperty(HTMLElement.prototype, property, {
                get: propertyDescriptor.get,
                set: function (value) {
                    if(window.WinJS && window.WinJS._execUnsafe && inUnsafeMode()) {
                        originalSetter.call(this, value);
                    } else {
                        var that = this;
                        var nodes = cleanse(value, that);
                        MSApp.execUnsafeLocalFunction(function () {
                            setter(propertyDescriptor, that, nodes);
                        });
                    }
                },
                enumerable: propertyDescriptor.enumerable,
                configurable: propertyDescriptor.configurable,
            });
        }
        cleansePropertySetter("innerHTML", function (propertyDescriptor, target, elements) {
            empty(target);
            for (var i = 0, len = elements.length; i < len; i++) {
                target.appendChild(elements[i]);
            }
        });
        cleansePropertySetter("outerHTML", function (propertyDescriptor, target, elements) {
            for (var i = 0, len = elements.length; i < len; i++) {
                target.insertAdjacentElement("afterend", elements[i]);
            }
            target.parentNode.removeChild(target);
        });

    }

}());
(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
   typeof define === 'function' && define.amd ? define(factory) :
   (global.ons = factory());
}(this, function () { 'use strict';

   var babelHelpers = {};
   babelHelpers.typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
     return typeof obj;
   } : function (obj) {
     return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
   };

   babelHelpers.classCallCheck = function (instance, Constructor) {
     if (!(instance instanceof Constructor)) {
       throw new TypeError("Cannot call a class as a function");
     }
   };

   babelHelpers.createClass = function () {
     function defineProperties(target, props) {
       for (var i = 0; i < props.length; i++) {
         var descriptor = props[i];
         descriptor.enumerable = descriptor.enumerable || false;
         descriptor.configurable = true;
         if ("value" in descriptor) descriptor.writable = true;
         Object.defineProperty(target, descriptor.key, descriptor);
       }
     }

     return function (Constructor, protoProps, staticProps) {
       if (protoProps) defineProperties(Constructor.prototype, protoProps);
       if (staticProps) defineProperties(Constructor, staticProps);
       return Constructor;
     };
   }();

   babelHelpers.inherits = function (subClass, superClass) {
     if (typeof superClass !== "function" && superClass !== null) {
       throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
     }

     subClass.prototype = Object.create(superClass && superClass.prototype, {
       constructor: {
         value: subClass,
         enumerable: false,
         writable: true,
         configurable: true
       }
     });
     if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
   };

   babelHelpers.possibleConstructorReturn = function (self, call) {
     if (!self) {
       throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
     }

     return call && (typeof call === "object" || typeof call === "function") ? call : self;
   };

   babelHelpers;

   var unwrap = function unwrap(string) {
     return string.slice(1, -1);
   };
   var isObjectString = function isObjectString(string) {
     return string.startsWith('{') && string.endsWith('}');
   };
   var isArrayString = function isArrayString(string) {
     return string.startsWith('[') && string.endsWith(']');
   };
   var isQuotedString = function isQuotedString(string) {
     return string.startsWith('\'') && string.endsWith('\'') || string.startsWith('"') && string.endsWith('"');
   };

   var error = function error(token, string, originalString) {
     throw new Error('Unexpected token \'' + token + '\' at position ' + (originalString.length - string.length - 1) + ' in string: \'' + originalString + '\'');
   };

   var processToken = function processToken(token, string, originalString) {
     if (token === 'true' || token === 'false') {
       return token === 'true';
     } else if (isQuotedString(token)) {
       return unwrap(token);
     } else if (!isNaN(token)) {
       return +token;
     } else if (isObjectString(token)) {
       return parseObject(unwrap(token));
     } else if (isArrayString(token)) {
       return parseArray(unwrap(token));
     } else {
       error(token, string, originalString);
     }
   };

   var nextToken = function nextToken(string) {
     string = string.trimLeft();
     var limit = string.length;

     if (string[0] === ':' || string[0] === ',') {

       limit = 1;
     } else if (string[0] === '{' || string[0] === '[') {

       var c = string.charCodeAt(0);
       var nestedObject = 1;
       for (var i = 1; i < string.length; i++) {
         if (string.charCodeAt(i) === c) {
           nestedObject++;
         } else if (string.charCodeAt(i) === c + 2) {
           nestedObject--;
           if (nestedObject === 0) {
             limit = i + 1;
             break;
           }
         }
       }
     } else if (string[0] === '\'' || string[0] === '\"') {

       for (var _i = 1; _i < string.length; _i++) {
         if (string[_i] === string[0]) {
           limit = _i + 1;
           break;
         }
       }
     } else {

       for (var _i2 = 1; _i2 < string.length; _i2++) {
         if ([' ', ',', ':'].indexOf(string[_i2]) !== -1) {
           limit = _i2;
           break;
         }
       }
     }

     return string.slice(0, limit);
   };

   var parseObject = function parseObject(string) {
     var isValidKey = function isValidKey(key) {
       return (/^[A-Z_\$][A-Z0-9_\$]*$/i.test(key)
       );
     };

     string = string.trim();
     var originalString = string;
     var object = {};
     var readingKey = true,
         key = void 0,
         previousToken = void 0,
         token = void 0;

     while (string.length > 0) {
       previousToken = token;
       token = nextToken(string);
       string = string.slice(token.length, string.length).trimLeft();

       if (token === ':' && (!readingKey || !previousToken || previousToken === ',') || token === ',' && readingKey || token !== ':' && token !== ',' && previousToken && previousToken !== ',' && previousToken !== ':') {
         error(token, string, originalString);
       } else if (token === ':' && readingKey && previousToken) {
         if (isValidKey(previousToken)) {
           key = previousToken;
           readingKey = false;
         } else {
           throw new Error('Invalid key token \'' + previousToken + '\' at position 0 in string: \'' + originalString + '\'');
         }
       } else if (token === ',' && !readingKey && previousToken) {
         object[key] = processToken(previousToken, string, originalString);
         readingKey = true;
       }
     }

     if (token) {
       object[key] = processToken(token, string, originalString);
     }

     return object;
   };

   var parseArray = function parseArray(string) {
     string = string.trim();
     var originalString = string;
     var array = [];
     var previousToken = void 0,
         token = void 0;

     while (string.length > 0) {
       previousToken = token;
       token = nextToken(string);
       string = string.slice(token.length, string.length).trimLeft();

       if (token === ',' && (!previousToken || previousToken === ',')) {
         error(token, string, originalString);
       } else if (token === ',') {
         array.push(processToken(previousToken, string, originalString));
       }
     }

     if (token) {
       if (token !== ',') {
         array.push(processToken(token, string, originalString));
       } else {
         error(token, string, originalString);
       }
     }

     return array;
   };

   var parse = function parse(string) {
     string = string.trim();

     if (isObjectString(string)) {
       return parseObject(unwrap(string));
     } else if (isArrayString(string)) {
       return parseArray(unwrap(string));
     } else {
       throw new Error('Provided string must be object or array like: ' + string);
     }
   };

   var util = {};

   /**
    * @param {String/Function} query dot class name or node name or matcher function.
    * @return {Function}
    */
   util.prepareQuery = function (query) {
     return query instanceof Function ? query : function (element) {
       return util.match(element, query);
     };
   };

   /**
    * @param {Element} element
    * @param {String/Function} query dot class name or node name.
    * @return {Boolean}
    */
   util.match = function (element, query) {
     if (query[0] === '.') {
       return element.classList.contains(query.slice(1));
     }
     return element.nodeName.toLowerCase() === query;
   };

   /**
    * @param {Element} element
    * @param {String/Function} query dot class name or node name or matcher function.
    * @return {HTMLElement/null}
    */
   util.findChild = function (element, query) {
     var match = util.prepareQuery(query);

     for (var i = 0; i < element.children.length; i++) {
       var node = element.children[i];
       if (match(node)) {
         return node;
       }
     }
     return null;
   };

   /**
    * @param {Element} element
    * @param {String/Function} query dot class name or node name or matcher function.
    * @return {HTMLElement/null}
    */
   util.findParent = function (element, query) {
     var match = util.prepareQuery(query);

     var parent = element.parentNode;
     for (;;) {
       if (!parent || parent === document) {
         return null;
       }
       if (match(parent)) {
         return parent;
       }
       parent = parent.parentNode;
     }
   };

   /**
    * @param {Element} element
    * @return {boolean}
    */
   util.isAttached = function (element) {
     while (document.documentElement !== element) {
       if (!element) {
         return false;
       }
       element = element.parentNode;
     }
     return true;
   };

   /**
    * @param {Element} element
    * @return {boolean}
    */
   util.hasAnyComponentAsParent = function (element) {
     while (element && document.documentElement !== element) {
       element = element.parentNode;
       if (element && element.nodeName.toLowerCase().match(/(ons-navigator|ons-tabbar|ons-sliding-menu|ons-split-view)/)) {
         return true;
       }
     }
     return false;
   };

   /**
    * @param {Element} element
    * @param {String} action to propagate
    */
   util.propagateAction = function (element, action) {
     for (var i = 0; i < element.childNodes.length; i++) {
       var child = element.childNodes[i];
       if (child[action] instanceof Function) {
         child[action]();
       } else {
         util.propagateAction(child, action);
       }
     }
   };

   /**
    * @param {String} selector - tag and class only
    * @param {Object} style
    * @param {Element}
    */
   util.create = function () {
     var selector = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];
     var style = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

     var classList = selector.split('.');
     var element = document.createElement(classList.shift() || 'div');

     if (classList.length) {
       element.className = classList.join(' ');
     }

     util.extend(element.style, style);

     return element;
   };

   /**
    * @param {String} html
    * @return {Element}
    */
   util.createElement = function (html) {
     var wrapper = document.createElement('div');
     innerHTML(wrapper, html);

     if (wrapper.children.length > 1) {
       throw new Error('"html" must be one wrapper element.');
     }

     return wrapper.children[0];
   };

   /**
    * @param {String} html
    * @return {HTMLFragment}
    */
   util.createFragment = function (html) {
     var wrapper = document.createElement('div');
     innerHTML(wrapper, html);
     var fragment = document.createDocumentFragment();

     while (wrapper.firstChild) {
       fragment.appendChild(wrapper.firstChild);
     }

     return fragment;
   };

   /*
    * @param {Object} dst Destination object.
    * @param {...Object} src Source object(s).
    * @returns {Object} Reference to `dst`.
    */
   util.extend = function (dst) {
     for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
       args[_key - 1] = arguments[_key];
     }

     for (var i = 0; i < args.length; i++) {
       if (args[i]) {
         var keys = Object.keys(args[i]);
         for (var j = 0; j < keys.length; j++) {
           var key = keys[j];
           dst[key] = args[i][key];
         }
       }
     }

     return dst;
   };

   /**
    * @param {Object} arrayLike
    * @return {Array}
    */
   util.arrayFrom = function (arrayLike) {
     return Array.prototype.slice.apply(arrayLike);
   };

   /**
    * @param {String} jsonString
    * @param {Object} [failSafe]
    * @return {Object}
    */
   util.parseJSONObjectSafely = function (jsonString) {
     var failSafe = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

     try {
       var result = JSON.parse('' + jsonString);
       if ((typeof result === 'undefined' ? 'undefined' : babelHelpers.typeof(result)) === 'object' && result !== null) {
         return result;
       }
     } catch (e) {
       return failSafe;
     }
     return failSafe;
   };

   /**
    * @param {String} path - path such as 'myApp.controllers.data.loadData'
    * @return {Any} - whatever is located at that path
    */
   util.findFromPath = function (path) {
     path = path.split('.');
     var el = window,
         key;
     while (key = path.shift()) {
       // eslint-disable-line no-cond-assign
       el = el[key];
     }
     return el;
   };

   /**
    * @param {Element} element
    * @param {String} eventName
    * @param {Object} [detail]
    * @return {CustomEvent}
    */
   util.triggerElementEvent = function (target, eventName) {
     var detail = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];


     var event = new CustomEvent(eventName, {
       bubbles: true,
       cancelable: true,
       detail: detail
     });

     Object.keys(detail).forEach(function (key) {
       event[key] = detail[key];
     });

     target.dispatchEvent(event);

     return event;
   };

   /**
    * @param {Element} target
    * @param {String} modifierName
    * @return {Boolean}
    */
   util.hasModifier = function (target, modifierName) {
     if (!target.hasAttribute('modifier')) {
       return false;
     }
     return target.getAttribute('modifier').split(/\s+/).some(function (e) {
       return e === modifierName;
     });
   };

   /**
    * @param {Element} target
    * @param {String} modifierName
    * @return {Boolean} Whether it was added or not.
    */
   util.addModifier = function (target, modifierName) {
     if (util.hasModifier(target, modifierName)) {
       return false;
     }

     modifierName = modifierName.trim();
     var modifierAttribute = target.getAttribute('modifier') || '';
     target.setAttribute('modifier', (modifierAttribute + ' ' + modifierName).trim());
     return true;
   };

   /**
    * @param {Element} target
    * @param {String} modifierName
    * @return {Boolean} Whether it was found or not.
    */
   util.removeModifier = function (target, modifierName) {
     if (!target.getAttribute('modifier')) {
       return false;
     }

     var modifiers = target.getAttribute('modifier').split(/\s+/);

     var newModifiers = modifiers.filter(function (item) {
       return item && item !== modifierName;
     });
     target.setAttribute('modifier', newModifiers.join(' '));

     return modifiers.length !== newModifiers.length;
   };

   util.updateParentPosition = function (el) {
     if (!el._parentUpdated && el.parentElement) {
       if (window.getComputedStyle(el.parentElement).getPropertyValue('position') === 'static') {
         el.parentElement.style.position = 'relative';
       }
       el._parentUpdated = true;
     }
   };

   util.toggleAttribute = function (element, name, enable) {
     if (enable) {
       element.setAttribute(name, '');
     } else {
       element.removeAttribute(name);
     }
   };

   util.bindListeners = function (element, listenerNames) {
     listenerNames.forEach(function (name) {
       var boundName = name.replace(/^_[a-z]/, '_bound' + name[1].toUpperCase());
       element[boundName] = element[boundName] || element[name].bind(element);
     });
   };

   util.each = function (obj, f) {
     return Object.keys(obj).forEach(function (key) {
       return f(key, obj[key]);
     });
   };

   /**
    * @param {Element} target
    */
   util.updateRipple = function (target) {
     var rippleElement = util.findChild(target, 'ons-ripple');

     if (target.hasAttribute('ripple')) {
       if (!rippleElement) {
         target.insertBefore(document.createElement('ons-ripple'), target.firstChild);
       }
     } else if (rippleElement) {
       rippleElement.remove();
     }
   };

   /**
    * @param {String}
    * @return {Object}
    */
   util.animationOptionsParse = parse;

   /**
    * @param {*} value
    */
   util.isInteger = function (value) {
     return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
   };

   var Event$1;
   var Utils;
   var Detection;
   var PointerEvent;
   /**
    * @object ons.GestureDetector
    * @category gesture
    * @description
    *   [en]Utility class for gesture detection.[/en]
    *   [ja][/ja]
    */

   /**
    * @method constructor
    * @signature constructor(element[, options])
    * @description
    *  [en]Create a new GestureDetector instance.[/en]
    *  [ja]GestureDetector[/ja]
    * @param {Element} element
    *   [en]Name of the event.[/en]
    *   [ja]DOM[/ja]
    * @param {Object} [options]
    *   [en]Options object.[/en]
    *   [ja][/ja]
    * @return {ons.GestureDetector.Instance}
    */
   var GestureDetector = function GestureDetector(element, options) {
     return new GestureDetector.Instance(element, options || {});
   };

   /**
    * default settings.
    * more settings are defined per gesture at `/gestures`. Each gesture can be disabled/enabled
    * by setting it's name (like `swipe`) to false.
    * You can set the defaults for all instances by changing this object before creating an instance.
    * @example
    * ````
    *  GestureDetector.defaults.drag = false;
    *  GestureDetector.defaults.behavior.touchAction = 'pan-y';
    *  delete GestureDetector.defaults.behavior.userSelect;
    * ````
    * @property defaults
    * @type {Object}
    */
   GestureDetector.defaults = {
     behavior: {
       // userSelect: 'none', // Also disables selection in `input` children
       touchAction: 'pan-y',
       touchCallout: 'none',
       contentZooming: 'none',
       userDrag: 'none',
       tapHighlightColor: 'rgba(0,0,0,0)'
     }
   };

   /**
    * GestureDetector document where the base events are added at
    * @property DOCUMENT
    * @type {HTMLElement}
    * @default window.document
    */
   GestureDetector.DOCUMENT = document;

   /**
    * detect support for pointer events
    * @property HAS_POINTEREVENTS
    * @type {Boolean}
    */
   GestureDetector.HAS_POINTEREVENTS = navigator.pointerEnabled || navigator.msPointerEnabled;

   /**
    * detect support for touch events
    * @property HAS_TOUCHEVENTS
    * @type {Boolean}
    */
   GestureDetector.HAS_TOUCHEVENTS = 'ontouchstart' in window;

   /**
    * detect mobile browsers
    * @property IS_MOBILE
    * @type {Boolean}
    */
   GestureDetector.IS_MOBILE = /mobile|tablet|ip(ad|hone|od)|android|silk/i.test(navigator.userAgent);

   /**
    * detect if we want to support mouseevents at all
    * @property NO_MOUSEEVENTS
    * @type {Boolean}
    */
   GestureDetector.NO_MOUSEEVENTS = GestureDetector.HAS_TOUCHEVENTS && GestureDetector.IS_MOBILE || GestureDetector.HAS_POINTEREVENTS;

   /**
    * interval in which GestureDetector recalculates current velocity/direction/angle in ms
    * @property CALCULATE_INTERVAL
    * @type {Number}
    * @default 25
    */
   GestureDetector.CALCULATE_INTERVAL = 25;

   /**
    * eventtypes per touchevent (start, move, end) are filled by `Event.determineEventTypes` on `setup`
    * the object contains the DOM event names per type (`EVENT_START`, `EVENT_MOVE`, `EVENT_END`)
    * @property EVENT_TYPES
    * @private
    * @writeOnce
    * @type {Object}
    */
   var EVENT_TYPES = {};

   /**
    * direction strings, for safe comparisons
    * @property DIRECTION_DOWN|LEFT|UP|RIGHT
    * @final
    * @type {String}
    * @default 'down' 'left' 'up' 'right'
    */
   var DIRECTION_DOWN = GestureDetector.DIRECTION_DOWN = 'down';
   var DIRECTION_LEFT = GestureDetector.DIRECTION_LEFT = 'left';
   var DIRECTION_UP = GestureDetector.DIRECTION_UP = 'up';
   var DIRECTION_RIGHT = GestureDetector.DIRECTION_RIGHT = 'right';

   /**
    * pointertype strings, for safe comparisons
    * @property POINTER_MOUSE|TOUCH|PEN
    * @final
    * @type {String}
    * @default 'mouse' 'touch' 'pen'
    */
   var POINTER_MOUSE = GestureDetector.POINTER_MOUSE = 'mouse';
   var POINTER_TOUCH = GestureDetector.POINTER_TOUCH = 'touch';
   var POINTER_PEN = GestureDetector.POINTER_PEN = 'pen';

   /**
    * eventtypes
    * @property EVENT_START|MOVE|END|RELEASE|TOUCH
    * @final
    * @type {String}
    * @default 'start' 'change' 'move' 'end' 'release' 'touch'
    */
   var EVENT_START = GestureDetector.EVENT_START = 'start';
   var EVENT_MOVE = GestureDetector.EVENT_MOVE = 'move';
   var EVENT_END = GestureDetector.EVENT_END = 'end';
   var EVENT_RELEASE = GestureDetector.EVENT_RELEASE = 'release';
   var EVENT_TOUCH = GestureDetector.EVENT_TOUCH = 'touch';

   /**
    * if the window events are set...
    * @property READY
    * @writeOnce
    * @type {Boolean}
    * @default false
    */
   GestureDetector.READY = false;

   /**
    * plugins namespace
    * @property plugins
    * @type {Object}
    */
   GestureDetector.plugins = GestureDetector.plugins || {};

   /**
    * gestures namespace
    * see `/gestures` for the definitions
    * @property gestures
    * @type {Object}
    */
   GestureDetector.gestures = GestureDetector.gestures || {};

   /**
    * setup events to detect gestures on the document
    * this function is called when creating an new instance
    * @private
    */
   function setup() {
     if (GestureDetector.READY) {
       return;
     }

     // find what eventtypes we add listeners to
     Event$1.determineEventTypes();

     // Register all gestures inside GestureDetector.gestures
     Utils.each(GestureDetector.gestures, function (gesture) {
       Detection.register(gesture);
     });

     // Add touch events on the document
     Event$1.onTouch(GestureDetector.DOCUMENT, EVENT_MOVE, Detection.detect);
     Event$1.onTouch(GestureDetector.DOCUMENT, EVENT_END, Detection.detect);

     // GestureDetector is ready...!
     GestureDetector.READY = true;
   }

   /**
    * @module GestureDetector
    *
    * @class Utils
    * @static
    */
   Utils = GestureDetector.utils = {
     /**
      * extend method, could also be used for cloning when `dest` is an empty object.
      * changes the dest object
      * @param {Object} dest
      * @param {Object} src
      * @param {Boolean} [merge=false]  do a merge
      * @return {Object} dest
      */
     extend: function extend(dest, src, merge) {
       for (var key in src) {
         if (src.hasOwnProperty(key) && (dest[key] === undefined || !merge)) {
           dest[key] = src[key];
         }
       }
       return dest;
     },

     /**
      * simple addEventListener wrapper
      * @param {HTMLElement} element
      * @param {String} type
      * @param {Function} handler
      */
     on: function on(element, type, handler) {
       element.addEventListener(type, handler, false);
     },

     /**
      * simple removeEventListener wrapper
      * @param {HTMLElement} element
      * @param {String} type
      * @param {Function} handler
      */
     off: function off(element, type, handler) {
       element.removeEventListener(type, handler, false);
     },

     /**
      * forEach over arrays and objects
      * @param {Object|Array} obj
      * @param {Function} iterator
      * @param {any} iterator.item
      * @param {Number} iterator.index
      * @param {Object|Array} iterator.obj the source object
      * @param {Object} context value to use as `this` in the iterator
      */
     each: function each(obj, iterator, context) {
       var i, len;

       // native forEach on arrays
       if ('forEach' in obj) {
         obj.forEach(iterator, context);
         // arrays
       } else if (obj.length !== undefined) {
           for (i = 0, len = obj.length; i < len; i++) {
             if (iterator.call(context, obj[i], i, obj) === false) {
               return;
             }
           }
           // objects
         } else {
             for (i in obj) {
               if (obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj) === false) {
                 return;
               }
             }
           }
     },

     /**
      * find if a string contains the string using indexOf
      * @param {String} src
      * @param {String} find
      * @return {Boolean} found
      */
     inStr: function inStr(src, find) {
       return src.indexOf(find) > -1;
     },

     /**
      * find if a array contains the object using indexOf or a simple polyfill
      * @param {String} src
      * @param {String} find
      * @return {Boolean|Number} false when not found, or the index
      */
     inArray: function inArray(src, find) {
       if (src.indexOf) {
         var index = src.indexOf(find);
         return index === -1 ? false : index;
       } else {
         for (var i = 0, len = src.length; i < len; i++) {
           if (src[i] === find) {
             return i;
           }
         }
         return false;
       }
     },

     /**
      * convert an array-like object (`arguments`, `touchlist`) to an array
      * @param {Object} obj
      * @return {Array}
      */
     toArray: function toArray(obj) {
       return Array.prototype.slice.call(obj, 0);
     },

     /**
      * find if a node is in the given parent
      * @param {HTMLElement} node
      * @param {HTMLElement} parent
      * @return {Boolean} found
      */
     hasParent: function hasParent(node, parent) {
       while (node) {
         if (node == parent) {
           return true;
         }
         node = node.parentNode;
       }
       return false;
     },

     /**
      * get the center of all the touches
      * @param {Array} touches
      * @return {Object} center contains `pageX`, `pageY`, `clientX` and `clientY` properties
      */
     getCenter: function getCenter(touches) {
       var pageX = [],
           pageY = [],
           clientX = [],
           clientY = [],
           min = Math.min,
           max = Math.max;

       // no need to loop when only one touch
       if (touches.length === 1) {
         return {
           pageX: touches[0].pageX,
           pageY: touches[0].pageY,
           clientX: touches[0].clientX,
           clientY: touches[0].clientY
         };
       }

       Utils.each(touches, function (touch) {
         pageX.push(touch.pageX);
         pageY.push(touch.pageY);
         clientX.push(touch.clientX);
         clientY.push(touch.clientY);
       });

       return {
         pageX: (min.apply(Math, pageX) + max.apply(Math, pageX)) / 2,
         pageY: (min.apply(Math, pageY) + max.apply(Math, pageY)) / 2,
         clientX: (min.apply(Math, clientX) + max.apply(Math, clientX)) / 2,
         clientY: (min.apply(Math, clientY) + max.apply(Math, clientY)) / 2
       };
     },

     /**
      * calculate the velocity between two points. unit is in px per ms.
      * @param {Number} deltaTime
      * @param {Number} deltaX
      * @param {Number} deltaY
      * @return {Object} velocity `x` and `y`
      */
     getVelocity: function getVelocity(deltaTime, deltaX, deltaY) {
       return {
         x: Math.abs(deltaX / deltaTime) || 0,
         y: Math.abs(deltaY / deltaTime) || 0
       };
     },

     /**
      * calculate the angle between two coordinates
      * @param {Touch} touch1
      * @param {Touch} touch2
      * @return {Number} angle
      */
     getAngle: function getAngle(touch1, touch2) {
       var x = touch2.clientX - touch1.clientX,
           y = touch2.clientY - touch1.clientY;

       return Math.atan2(y, x) * 180 / Math.PI;
     },

     /**
      * do a small comparison to get the direction between two touches.
      * @param {Touch} touch1
      * @param {Touch} touch2
      * @return {String} direction matches `DIRECTION_LEFT|RIGHT|UP|DOWN`
      */
     getDirection: function getDirection(touch1, touch2) {
       var x = Math.abs(touch1.clientX - touch2.clientX),
           y = Math.abs(touch1.clientY - touch2.clientY);

       if (x >= y) {
         return touch1.clientX - touch2.clientX > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
       }
       return touch1.clientY - touch2.clientY > 0 ? DIRECTION_UP : DIRECTION_DOWN;
     },

     /**
      * calculate the distance between two touches
      * @param {Touch}touch1
      * @param {Touch} touch2
      * @return {Number} distance
      */
     getDistance: function getDistance(touch1, touch2) {
       var x = touch2.clientX - touch1.clientX,
           y = touch2.clientY - touch1.clientY;

       return Math.sqrt(x * x + y * y);
     },

     /**
      * calculate the scale factor between two touchLists
      * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
      * @param {Array} start array of touches
      * @param {Array} end array of touches
      * @return {Number} scale
      */
     getScale: function getScale(start, end) {
       // need two fingers...
       if (start.length >= 2 && end.length >= 2) {
         return this.getDistance(end[0], end[1]) / this.getDistance(start[0], start[1]);
       }
       return 1;
     },

     /**
      * calculate the rotation degrees between two touchLists
      * @param {Array} start array of touches
      * @param {Array} end array of touches
      * @return {Number} rotation
      */
     getRotation: function getRotation(start, end) {
       // need two fingers
       if (start.length >= 2 && end.length >= 2) {
         return this.getAngle(end[1], end[0]) - this.getAngle(start[1], start[0]);
       }
       return 0;
     },

     /**
      * find out if the direction is vertical   *
      * @param {String} direction matches `DIRECTION_UP|DOWN`
      * @return {Boolean} is_vertical
      */
     isVertical: function isVertical(direction) {
       return direction == DIRECTION_UP || direction == DIRECTION_DOWN;
     },

     /**
      * set css properties with their prefixes
      * @param {HTMLElement} element
      * @param {String} prop
      * @param {String} value
      * @param {Boolean} [toggle=true]
      * @return {Boolean}
      */
     setPrefixedCss: function setPrefixedCss(element, prop, value, toggle) {
       var prefixes = ['', 'Webkit', 'Moz', 'O', 'ms'];
       prop = Utils.toCamelCase(prop);

       for (var i = 0; i < prefixes.length; i++) {
         var p = prop;
         // prefixes
         if (prefixes[i]) {
           p = prefixes[i] + p.slice(0, 1).toUpperCase() + p.slice(1);
         }

         // test the style
         if (p in element.style) {
           element.style[p] = (toggle === null || toggle) && value || '';
           break;
         }
       }
     },

     /**
      * toggle browser default behavior by setting css properties.
      * `userSelect='none'` also sets `element.onselectstart` to false
      * `userDrag='none'` also sets `element.ondragstart` to false
      *
      * @param {HtmlElement} element
      * @param {Object} props
      * @param {Boolean} [toggle=true]
      */
     toggleBehavior: function toggleBehavior(element, props, toggle) {
       if (!props || !element || !element.style) {
         return;
       }

       // set the css properties
       Utils.each(props, function (value, prop) {
         Utils.setPrefixedCss(element, prop, value, toggle);
       });

       var falseFn = toggle && function () {
         return false;
       };

       // also the disable onselectstart
       if (props.userSelect == 'none') {
         element.onselectstart = falseFn;
       }
       // and disable ondragstart
       if (props.userDrag == 'none') {
         element.ondragstart = falseFn;
       }
     },

     /**
      * convert a string with underscores to camelCase
      * so prevent_default becomes preventDefault
      * @param {String} str
      * @return {String} camelCaseStr
      */
     toCamelCase: function toCamelCase(str) {
       return str.replace(/[_-]([a-z])/g, function (s) {
         return s[1].toUpperCase();
       });
     }
   };

   /**
    * @module GestureDetector
    */
   /**
    * @class Event
    * @static
    */
   Event$1 = GestureDetector.event = {
     /**
      * when touch events have been fired, this is true
      * this is used to stop mouse events
      * @property prevent_mouseevents
      * @private
      * @type {Boolean}
      */
     preventMouseEvents: false,

     /**
      * if EVENT_START has been fired
      * @property started
      * @private
      * @type {Boolean}
      */
     started: false,

     /**
      * when the mouse is hold down, this is true
      * @property should_detect
      * @private
      * @type {Boolean}
      */
     shouldDetect: false,

     /**
      * simple event binder with a hook and support for multiple types
      * @param {HTMLElement} element
      * @param {String} type
      * @param {Function} handler
      * @param {Function} [hook]
      * @param {Object} hook.type
      */
     on: function on(element, type, handler, hook) {
       var types = type.split(' ');
       Utils.each(types, function (type) {
         Utils.on(element, type, handler);
         hook && hook(type);
       });
     },

     /**
      * simple event unbinder with a hook and support for multiple types
      * @param {HTMLElement} element
      * @param {String} type
      * @param {Function} handler
      * @param {Function} [hook]
      * @param {Object} hook.type
      */
     off: function off(element, type, handler, hook) {
       var types = type.split(' ');
       Utils.each(types, function (type) {
         Utils.off(element, type, handler);
         hook && hook(type);
       });
     },

     /**
      * the core touch event handler.
      * this finds out if we should to detect gestures
      * @param {HTMLElement} element
      * @param {String} eventType matches `EVENT_START|MOVE|END`
      * @param {Function} handler
      * @return onTouchHandler {Function} the core event handler
      */
     onTouch: function onTouch(element, eventType, handler) {
       var self = this;

       var onTouchHandler = function onTouchHandler(ev) {
         var srcType = ev.type.toLowerCase(),
             isPointer = GestureDetector.HAS_POINTEREVENTS,
             isMouse = Utils.inStr(srcType, 'mouse'),
             triggerType;

         // if we are in a mouseevent, but there has been a touchevent triggered in this session
         // we want to do nothing. simply break out of the event.
         if (isMouse && self.preventMouseEvents) {
           return;

           // mousebutton must be down
         } else if (isMouse && eventType == EVENT_START && ev.button === 0) {
             self.preventMouseEvents = false;
             self.shouldDetect = true;
           } else if (isPointer && eventType == EVENT_START) {
             self.shouldDetect = ev.buttons === 1 || PointerEvent.matchType(POINTER_TOUCH, ev);
             // just a valid start event, but no mouse
           } else if (!isMouse && eventType == EVENT_START) {
               self.preventMouseEvents = true;
               self.shouldDetect = true;
             }

         // update the pointer event before entering the detection
         if (isPointer && eventType != EVENT_END) {
           PointerEvent.updatePointer(eventType, ev);
         }

         // we are in a touch/down state, so allowed detection of gestures
         if (self.shouldDetect) {
           triggerType = self.doDetect.call(self, ev, eventType, element, handler);
         }

         // ...and we are done with the detection
         // so reset everything to start each detection totally fresh
         if (triggerType == EVENT_END) {
           self.preventMouseEvents = false;
           self.shouldDetect = false;
           PointerEvent.reset();
           // update the pointerevent object after the detection
         }

         if (isPointer && eventType == EVENT_END) {
           PointerEvent.updatePointer(eventType, ev);
         }
       };

       this.on(element, EVENT_TYPES[eventType], onTouchHandler);
       return onTouchHandler;
     },

     /**
      * the core detection method
      * this finds out what GestureDetector-touch-events to trigger
      * @param {Object} ev
      * @param {String} eventType matches `EVENT_START|MOVE|END`
      * @param {HTMLElement} element
      * @param {Function} handler
      * @return {String} triggerType matches `EVENT_START|MOVE|END`
      */
     doDetect: function doDetect(ev, eventType, element, handler) {
       var touchList = this.getTouchList(ev, eventType);
       var touchListLength = touchList.length;
       var triggerType = eventType;
       var triggerChange = touchList.trigger; // used by fakeMultitouch plugin
       var changedLength = touchListLength;

       // at each touchstart-like event we want also want to trigger a TOUCH event...
       if (eventType == EVENT_START) {
         triggerChange = EVENT_TOUCH;
         // ...the same for a touchend-like event
       } else if (eventType == EVENT_END) {
           triggerChange = EVENT_RELEASE;

           // keep track of how many touches have been removed
           changedLength = touchList.length - (ev.changedTouches ? ev.changedTouches.length : 1);
         }

       // after there are still touches on the screen,
       // we just want to trigger a MOVE event. so change the START or END to a MOVE
       // but only after detection has been started, the first time we actually want a START
       if (changedLength > 0 && this.started) {
         triggerType = EVENT_MOVE;
       }

       // detection has been started, we keep track of this, see above
       this.started = true;

       // generate some event data, some basic information
       var evData = this.collectEventData(element, triggerType, touchList, ev);

       // trigger the triggerType event before the change (TOUCH, RELEASE) events
       // but the END event should be at last
       if (eventType != EVENT_END) {
         handler.call(Detection, evData);
       }

       // trigger a change (TOUCH, RELEASE) event, this means the length of the touches changed
       if (triggerChange) {
         evData.changedLength = changedLength;
         evData.eventType = triggerChange;

         handler.call(Detection, evData);

         evData.eventType = triggerType;
         delete evData.changedLength;
       }

       // trigger the END event
       if (triggerType == EVENT_END) {
         handler.call(Detection, evData);

         // ...and we are done with the detection
         // so reset everything to start each detection totally fresh
         this.started = false;
       }

       return triggerType;
     },

     /**
      * we have different events for each device/browser
      * determine what we need and set them in the EVENT_TYPES constant
      * the `onTouch` method is bind to these properties.
      * @return {Object} events
      */
     determineEventTypes: function determineEventTypes() {
       var types;
       if (GestureDetector.HAS_POINTEREVENTS) {
         if (window.PointerEvent) {
           types = ['pointerdown', 'pointermove', 'pointerup pointercancel lostpointercapture'];
         } else {
           types = ['MSPointerDown', 'MSPointerMove', 'MSPointerUp MSPointerCancel MSLostPointerCapture'];
         }
       } else if (GestureDetector.NO_MOUSEEVENTS) {
         types = ['touchstart', 'touchmove', 'touchend touchcancel'];
       } else {
         types = ['touchstart mousedown', 'touchmove mousemove', 'touchend touchcancel mouseup'];
       }

       EVENT_TYPES[EVENT_START] = types[0];
       EVENT_TYPES[EVENT_MOVE] = types[1];
       EVENT_TYPES[EVENT_END] = types[2];
       return EVENT_TYPES;
     },

     /**
      * create touchList depending on the event
      * @param {Object} ev
      * @param {String} eventType
      * @return {Array} touches
      */
     getTouchList: function getTouchList(ev, eventType) {
       // get the fake pointerEvent touchlist
       if (GestureDetector.HAS_POINTEREVENTS) {
         return PointerEvent.getTouchList();
       }

       // get the touchlist
       if (ev.touches) {
         if (eventType == EVENT_MOVE) {
           return ev.touches;
         }

         var identifiers = [];
         var concat = [].concat(Utils.toArray(ev.touches), Utils.toArray(ev.changedTouches));
         var touchList = [];

         Utils.each(concat, function (touch) {
           if (Utils.inArray(identifiers, touch.identifier) === false) {
             touchList.push(touch);
           }
           identifiers.push(touch.identifier);
         });

         return touchList;
       }

       // make fake touchList from mouse position
       ev.identifier = 1;
       return [ev];
     },

     /**
      * collect basic event data
      * @param {HTMLElement} element
      * @param {String} eventType matches `EVENT_START|MOVE|END`
      * @param {Array} touches
      * @param {Object} ev
      * @return {Object} ev
      */
     collectEventData: function collectEventData(element, eventType, touches, ev) {
       // find out pointerType
       var pointerType = POINTER_TOUCH;
       if (Utils.inStr(ev.type, 'mouse') || PointerEvent.matchType(POINTER_MOUSE, ev)) {
         pointerType = POINTER_MOUSE;
       } else if (PointerEvent.matchType(POINTER_PEN, ev)) {
         pointerType = POINTER_PEN;
       }

       return {
         center: Utils.getCenter(touches),
         timeStamp: Date.now(),
         target: ev.target,
         touches: touches,
         eventType: eventType,
         pointerType: pointerType,
         srcEvent: ev,

         /**
          * prevent the browser default actions
          * mostly used to disable scrolling of the browser
          */
         preventDefault: function preventDefault() {
           var srcEvent = this.srcEvent;
           srcEvent.preventManipulation && srcEvent.preventManipulation();
           srcEvent.preventDefault && srcEvent.preventDefault();
         },

         /**
          * stop bubbling the event up to its parents
          */
         stopPropagation: function stopPropagation() {
           this.srcEvent.stopPropagation();
         },

         /**
          * immediately stop gesture detection
          * might be useful after a swipe was detected
          * @return {*}
          */
         stopDetect: function stopDetect() {
           return Detection.stopDetect();
         }
       };
     }
   };

   /**
    * @module GestureDetector
    *
    * @class PointerEvent
    * @static
    */
   PointerEvent = GestureDetector.PointerEvent = {
     /**
      * holds all pointers, by `identifier`
      * @property pointers
      * @type {Object}
      */
     pointers: {},

     /**
      * get the pointers as an array
      * @return {Array} touchlist
      */
     getTouchList: function getTouchList() {
       var touchlist = [];
       // we can use forEach since pointerEvents only is in IE10
       Utils.each(this.pointers, function (pointer) {
         touchlist.push(pointer);
       });
       return touchlist;
     },

     /**
      * update the position of a pointer
      * @param {String} eventType matches `EVENT_START|MOVE|END`
      * @param {Object} pointerEvent
      */
     updatePointer: function updatePointer(eventType, pointerEvent) {
       if (eventType == EVENT_END || eventType != EVENT_END && pointerEvent.buttons !== 1) {
         delete this.pointers[pointerEvent.pointerId];
       } else {
         pointerEvent.identifier = pointerEvent.pointerId;
         this.pointers[pointerEvent.pointerId] = pointerEvent;
       }
     },

     /**
      * check if ev matches pointertype
      * @param {String} pointerType matches `POINTER_MOUSE|TOUCH|PEN`
      * @param {PointerEvent} ev
      */
     matchType: function matchType(pointerType, ev) {
       if (!ev.pointerType) {
         return false;
       }

       var pt = ev.pointerType,
           types = {};

       types[POINTER_MOUSE] = pt === (ev.MSPOINTER_TYPE_MOUSE || POINTER_MOUSE);
       types[POINTER_TOUCH] = pt === (ev.MSPOINTER_TYPE_TOUCH || POINTER_TOUCH);
       types[POINTER_PEN] = pt === (ev.MSPOINTER_TYPE_PEN || POINTER_PEN);
       return types[pointerType];
     },

     /**
      * reset the stored pointers
      */
     reset: function resetList() {
       this.pointers = {};
     }
   };

   /**
    * @module GestureDetector
    *
    * @class Detection
    * @static
    */
   Detection = GestureDetector.detection = {
     // contains all registered GestureDetector.gestures in the correct order
     gestures: [],

     // data of the current GestureDetector.gesture detection session
     current: null,

     // the previous GestureDetector.gesture session data
     // is a full clone of the previous gesture.current object
     previous: null,

     // when this becomes true, no gestures are fired
     stopped: false,

     /**
      * start GestureDetector.gesture detection
      * @param {GestureDetector.Instance} inst
      * @param {Object} eventData
      */
     startDetect: function startDetect(inst, eventData) {
       // already busy with a GestureDetector.gesture detection on an element
       if (this.current) {
         return;
       }

       this.stopped = false;

       // holds current session
       this.current = {
         inst: inst, // reference to GestureDetectorInstance we're working for
         startEvent: Utils.extend({}, eventData), // start eventData for distances, timing etc
         lastEvent: false, // last eventData
         lastCalcEvent: false, // last eventData for calculations.
         futureCalcEvent: false, // last eventData for calculations.
         lastCalcData: {}, // last lastCalcData
         name: '' // current gesture we're in/detected, can be 'tap', 'hold' etc
       };

       this.detect(eventData);
     },

     /**
      * GestureDetector.gesture detection
      * @param {Object} eventData
      * @return {any}
      */
     detect: function detect(eventData) {
       if (!this.current || this.stopped) {
         return;
       }

       // extend event data with calculations about scale, distance etc
       eventData = this.extendEventData(eventData);

       // GestureDetector instance and instance options
       var inst = this.current.inst,
           instOptions = inst.options;

       // call GestureDetector.gesture handlers
       Utils.each(this.gestures, function triggerGesture(gesture) {
         // only when the instance options have enabled this gesture
         if (!this.stopped && inst.enabled && instOptions[gesture.name]) {
           gesture.handler.call(gesture, eventData, inst);
         }
       }, this);

       // store as previous event event
       if (this.current) {
         this.current.lastEvent = eventData;
       }

       if (eventData.eventType == EVENT_END) {
         this.stopDetect();
       }

       return eventData; // eslint-disable-line consistent-return
     },

     /**
      * clear the GestureDetector.gesture vars
      * this is called on endDetect, but can also be used when a final GestureDetector.gesture has been detected
      * to stop other GestureDetector.gestures from being fired
      */
     stopDetect: function stopDetect() {
       // clone current data to the store as the previous gesture
       // used for the double tap gesture, since this is an other gesture detect session
       this.previous = Utils.extend({}, this.current);

       // reset the current
       this.current = null;
       this.stopped = true;
     },

     /**
      * calculate velocity, angle and direction
      * @param {Object} ev
      * @param {Object} center
      * @param {Number} deltaTime
      * @param {Number} deltaX
      * @param {Number} deltaY
      */
     getCalculatedData: function getCalculatedData(ev, center, deltaTime, deltaX, deltaY) {
       var cur = this.current,
           recalc = false,
           calcEv = cur.lastCalcEvent,
           calcData = cur.lastCalcData;

       if (calcEv && ev.timeStamp - calcEv.timeStamp > GestureDetector.CALCULATE_INTERVAL) {
         center = calcEv.center;
         deltaTime = ev.timeStamp - calcEv.timeStamp;
         deltaX = ev.center.clientX - calcEv.center.clientX;
         deltaY = ev.center.clientY - calcEv.center.clientY;
         recalc = true;
       }

       if (ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {
         cur.futureCalcEvent = ev;
       }

       if (!cur.lastCalcEvent || recalc) {
         calcData.velocity = Utils.getVelocity(deltaTime, deltaX, deltaY);
         calcData.angle = Utils.getAngle(center, ev.center);
         calcData.direction = Utils.getDirection(center, ev.center);

         cur.lastCalcEvent = cur.futureCalcEvent || ev;
         cur.futureCalcEvent = ev;
       }

       ev.velocityX = calcData.velocity.x;
       ev.velocityY = calcData.velocity.y;
       ev.interimAngle = calcData.angle;
       ev.interimDirection = calcData.direction;
     },

     /**
      * extend eventData for GestureDetector.gestures
      * @param {Object} ev
      * @return {Object} ev
      */
     extendEventData: function extendEventData(ev) {
       var cur = this.current,
           startEv = cur.startEvent,
           lastEv = cur.lastEvent || startEv;

       // update the start touchlist to calculate the scale/rotation
       if (ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {
         startEv.touches = [];
         Utils.each(ev.touches, function (touch) {
           startEv.touches.push({
             clientX: touch.clientX,
             clientY: touch.clientY
           });
         });
       }

       var deltaTime = ev.timeStamp - startEv.timeStamp,
           deltaX = ev.center.clientX - startEv.center.clientX,
           deltaY = ev.center.clientY - startEv.center.clientY;

       this.getCalculatedData(ev, lastEv.center, deltaTime, deltaX, deltaY);

       Utils.extend(ev, {
         startEvent: startEv,

         deltaTime: deltaTime,
         deltaX: deltaX,
         deltaY: deltaY,

         distance: Utils.getDistance(startEv.center, ev.center),
         angle: Utils.getAngle(startEv.center, ev.center),
         direction: Utils.getDirection(startEv.center, ev.center),
         scale: Utils.getScale(startEv.touches, ev.touches),
         rotation: Utils.getRotation(startEv.touches, ev.touches)
       });

       return ev;
     },

     /**
      * register new gesture
      * @param {Object} gesture object, see `gestures/` for documentation
      * @return {Array} gestures
      */
     register: function register(gesture) {
       // add an enable gesture options if there is no given
       var options = gesture.defaults || {};
       if (options[gesture.name] === undefined) {
         options[gesture.name] = true;
       }

       // extend GestureDetector default options with the GestureDetector.gesture options
       Utils.extend(GestureDetector.defaults, options, true);

       // set its index
       gesture.index = gesture.index || 1000;

       // add GestureDetector.gesture to the list
       this.gestures.push(gesture);

       // sort the list by index
       this.gestures.sort(function (a, b) {
         if (a.index < b.index) {
           return -1;
         }
         if (a.index > b.index) {
           return 1;
         }
         return 0;
       });

       return this.gestures;
     }
   };

   /**
    * @module GestureDetector
    */

   /**
    * create new GestureDetector instance
    * all methods should return the instance itself, so it is chainable.
    *
    * @class Instance
    * @constructor
    * @param {HTMLElement} element
    * @param {Object} [options={}] options are merged with `GestureDetector.defaults`
    * @return {GestureDetector.Instance}
    */
   GestureDetector.Instance = function (element, options) {
     var self = this;

     // setup GestureDetectorJS window events and register all gestures
     // this also sets up the default options
     setup();

     /**
      * @property element
      * @type {HTMLElement}
      */
     this.element = element;

     /**
      * @property enabled
      * @type {Boolean}
      * @protected
      */
     this.enabled = true;

     /**
      * options, merged with the defaults
      * options with an _ are converted to camelCase
      * @property options
      * @type {Object}
      */
     Utils.each(options, function (value, name) {
       delete options[name];
       options[Utils.toCamelCase(name)] = value;
     });

     this.options = Utils.extend(Utils.extend({}, GestureDetector.defaults), options || {});

     // add some css to the element to prevent the browser from doing its native behavior
     if (this.options.behavior) {
       Utils.toggleBehavior(this.element, this.options.behavior, true);
     }

     /**
      * event start handler on the element to start the detection
      * @property eventStartHandler
      * @type {Object}
      */
     this.eventStartHandler = Event$1.onTouch(element, EVENT_START, function (ev) {
       if (self.enabled && ev.eventType == EVENT_START) {
         Detection.startDetect(self, ev);
       } else if (ev.eventType == EVENT_TOUCH) {
         Detection.detect(ev);
       }
     });

     /**
      * keep a list of user event handlers which needs to be removed when calling 'dispose'
      * @property eventHandlers
      * @type {Array}
      */
     this.eventHandlers = [];
   };

   GestureDetector.Instance.prototype = {
     /**
      * @method on
      * @signature on(gestures, handler)
      * @description
      *  [en]Adds an event handler for a gesture. Available gestures are: drag, dragleft, dragright, dragup, dragdown, hold, release, swipe, swipeleft, swiperight, swipeup, swipedown, tap, doubletap, touch, transform, pinch, pinchin, pinchout and rotate. [/en]
      *  [ja]drag dragleft dragright dragup dragdown hold release swipe swipeleft swiperight swipeup swipedown tap doubletap touch transform pinch pinchin pinchout rotate [/ja]
      * @param {String} gestures
      *   [en]A space separated list of gestures.[/en]
      *   [ja][/ja]
      * @param {Function} handler
      *   [en]An event handling function.[/en]
      *   [ja][/ja]
      */
     on: function onEvent(gestures, handler) {
       var self = this;
       Event$1.on(self.element, gestures, handler, function (type) {
         self.eventHandlers.push({ gesture: type, handler: handler });
       });
       return self;
     },

     /**
      * @method off
      * @signature off(gestures, handler)
      * @description
      *  [en]Remove an event listener.[/en]
      *  [ja][/ja]
      * @param {String} gestures
      *   [en]A space separated list of gestures.[/en]
      *   [ja][/ja]
      * @param {Function} handler
      *   [en]An event handling function.[/en]
      *   [ja][/ja]
      */
     off: function offEvent(gestures, handler) {
       var self = this;

       Event$1.off(self.element, gestures, handler, function (type) {
         var index = Utils.inArray({ gesture: type, handler: handler });
         if (index !== false) {
           self.eventHandlers.splice(index, 1);
         }
       });
       return self;
     },

     /**
      * trigger gesture event
      * @method trigger
      * @signature trigger(gesture, eventData)
      * @param {String} gesture
      * @param {Object} [eventData]
      */
     trigger: function triggerEvent(gesture, eventData) {
       // optional
       if (!eventData) {
         eventData = {};
       }

       // create DOM event
       var event = GestureDetector.DOCUMENT.createEvent('Event');
       event.initEvent(gesture, true, true);
       event.gesture = eventData;

       // trigger on the target if it is in the instance element,
       // this is for event delegation tricks
       var element = this.element;
       if (Utils.hasParent(eventData.target, element)) {
         element = eventData.target;
       }

       element.dispatchEvent(event);
       return this;
     },

     /**
      * @method enable
      * @signature enable(state)
      * @description
      *  [en]Enable or disable gesture detection.[/en]
      *  [ja]/[/ja]
      * @param {Boolean} state
      *   [en]Specify if it should be enabled or not.[/en]
      *   [ja][/ja]
      */
     enable: function enable(state) {
       this.enabled = state;
       return this;
     },

     /**
      * @method dispose
      * @signature dispose()
      * @description
      *  [en]Remove and destroy all event handlers for this instance.[/en]
      *  [ja][/ja]
      */
     dispose: function dispose() {
       var i, eh;

       // undo all changes made by stop_browser_behavior
       Utils.toggleBehavior(this.element, this.options.behavior, false);

       // unbind all custom event handlers
       for (i = -1; eh = this.eventHandlers[++i];) {
         // eslint-disable-line no-cond-assign
         Utils.off(this.element, eh.gesture, eh.handler);
       }

       this.eventHandlers = [];

       // unbind the start event listener
       Event$1.off(this.element, EVENT_TYPES[EVENT_START], this.eventStartHandler);

       return null;
     }
   };

   /**
    * @module gestures
    */
   /**
    * Move with x fingers (default 1) around on the page.
    * Preventing the default browser behavior is a good way to improve feel and working.
    * ````
    *  GestureDetectortime.on("drag", function(ev) {
    *    console.log(ev);
    *    ev.gesture.preventDefault();
    *  });
    * ````
    *
    * @class Drag
    * @static
    */
   /**
    * @event drag
    * @param {Object} ev
    */
   /**
    * @event dragstart
    * @param {Object} ev
    */
   /**
    * @event dragend
    * @param {Object} ev
    */
   /**
    * @event drapleft
    * @param {Object} ev
    */
   /**
    * @event dragright
    * @param {Object} ev
    */
   /**
    * @event dragup
    * @param {Object} ev
    */
   /**
    * @event dragdown
    * @param {Object} ev
    */

   /**
    * @param {String} name
    */
   (function (name) {
     var triggered = false;

     function dragGesture(ev, inst) {
       var cur = Detection.current;

       // max touches
       if (inst.options.dragMaxTouches > 0 && ev.touches.length > inst.options.dragMaxTouches) {
         return;
       }

       switch (ev.eventType) {
         case EVENT_START:
           triggered = false;
           break;

         case EVENT_MOVE:
           // when the distance we moved is too small we skip this gesture
           // or we can be already in dragging
           if (ev.distance < inst.options.dragMinDistance && cur.name != name) {
             return;
           }

           var startCenter = cur.startEvent.center;

           // we are dragging!
           if (cur.name != name) {
             cur.name = name;
             if (inst.options.dragDistanceCorrection && ev.distance > 0) {
               // When a drag is triggered, set the event center to dragMinDistance pixels from the original event center.
               // Without this correction, the dragged distance would jumpstart at dragMinDistance pixels instead of at 0.
               // It might be useful to save the original start point somewhere
               var factor = Math.abs(inst.options.dragMinDistance / ev.distance);
               startCenter.pageX += ev.deltaX * factor;
               startCenter.pageY += ev.deltaY * factor;
               startCenter.clientX += ev.deltaX * factor;
               startCenter.clientY += ev.deltaY * factor;

               // recalculate event data using new start point
               ev = Detection.extendEventData(ev);
             }
           }

           // lock drag to axis?
           if (cur.lastEvent.dragLockToAxis || inst.options.dragLockToAxis && inst.options.dragLockMinDistance <= ev.distance) {
             ev.dragLockToAxis = true;
           }

           // keep direction on the axis that the drag gesture started on
           var lastDirection = cur.lastEvent.direction;
           if (ev.dragLockToAxis && lastDirection !== ev.direction) {
             if (Utils.isVertical(lastDirection)) {
               ev.direction = ev.deltaY < 0 ? DIRECTION_UP : DIRECTION_DOWN;
             } else {
               ev.direction = ev.deltaX < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
             }
           }

           // first time, trigger dragstart event
           if (!triggered) {
             inst.trigger(name + 'start', ev);
             triggered = true;
           }

           // trigger events
           inst.trigger(name, ev);
           inst.trigger(name + ev.direction, ev);

           var isVertical = Utils.isVertical(ev.direction);

           // block the browser events
           if (inst.options.dragBlockVertical && isVertical || inst.options.dragBlockHorizontal && !isVertical) {
             ev.preventDefault();
           }
           break;

         case EVENT_RELEASE:
           if (triggered && ev.changedLength <= inst.options.dragMaxTouches) {
             inst.trigger(name + 'end', ev);
             triggered = false;
           }
           break;

         case EVENT_END:
           triggered = false;
           break;
       }
     }

     GestureDetector.gestures.Drag = {
       name: name,
       index: 50,
       handler: dragGesture,
       defaults: {
         /**
          * minimal movement that have to be made before the drag event gets triggered
          * @property dragMinDistance
          * @type {Number}
          * @default 10
          */
         dragMinDistance: 10,

         /**
          * Set dragDistanceCorrection to true to make the starting point of the drag
          * be calculated from where the drag was triggered, not from where the touch started.
          * Useful to avoid a jerk-starting drag, which can make fine-adjustments
          * through dragging difficult, and be visually unappealing.
          * @property dragDistanceCorrection
          * @type {Boolean}
          * @default true
          */
         dragDistanceCorrection: true,

         /**
          * set 0 for unlimited, but this can conflict with transform
          * @property dragMaxTouches
          * @type {Number}
          * @default 1
          */
         dragMaxTouches: 1,

         /**
          * prevent default browser behavior when dragging occurs
          * be careful with it, it makes the element a blocking element
          * when you are using the drag gesture, it is a good practice to set this true
          * @property dragBlockHorizontal
          * @type {Boolean}
          * @default false
          */
         dragBlockHorizontal: false,

         /**
          * same as `dragBlockHorizontal`, but for vertical movement
          * @property dragBlockVertical
          * @type {Boolean}
          * @default false
          */
         dragBlockVertical: false,

         /**
          * dragLockToAxis keeps the drag gesture on the axis that it started on,
          * It disallows vertical directions if the initial direction was horizontal, and vice versa.
          * @property dragLockToAxis
          * @type {Boolean}
          * @default false
          */
         dragLockToAxis: false,

         /**
          * drag lock only kicks in when distance > dragLockMinDistance
          * This way, locking occurs only when the distance has become large enough to reliably determine the direction
          * @property dragLockMinDistance
          * @type {Number}
          * @default 25
          */
         dragLockMinDistance: 25
       }
     };
   })('drag');

   /**
    * @module gestures
    */
   /**
    * trigger a simple gesture event, so you can do anything in your handler.
    * only usable if you know what your doing...
    *
    * @class Gesture
    * @static
    */
   /**
    * @event gesture
    * @param {Object} ev
    */
   GestureDetector.gestures.Gesture = {
     name: 'gesture',
     index: 1337,
     handler: function releaseGesture(ev, inst) {
       inst.trigger(this.name, ev);
     }
   };

   /**
    * @module gestures
    */
   /**
    * Touch stays at the same place for x time
    *
    * @class Hold
    * @static
    */
   /**
    * @event hold
    * @param {Object} ev
    */

   /**
    * @param {String} name
    */
   (function (name) {
     var timer;

     function holdGesture(ev, inst) {
       var options = inst.options,
           current = Detection.current;

       switch (ev.eventType) {
         case EVENT_START:
           clearTimeout(timer);

           // set the gesture so we can check in the timeout if it still is
           current.name = name;

           // set timer and if after the timeout it still is hold,
           // we trigger the hold event
           timer = setTimeout(function () {
             if (current && current.name == name) {
               inst.trigger(name, ev);
             }
           }, options.holdTimeout);
           break;

         case EVENT_MOVE:
           if (ev.distance > options.holdThreshold) {
             clearTimeout(timer);
           }
           break;

         case EVENT_RELEASE:
           clearTimeout(timer);
           break;
       }
     }

     GestureDetector.gestures.Hold = {
       name: name,
       index: 10,
       defaults: {
         /**
          * @property holdTimeout
          * @type {Number}
          * @default 500
          */
         holdTimeout: 500,

         /**
          * movement allowed while holding
          * @property holdThreshold
          * @type {Number}
          * @default 2
          */
         holdThreshold: 2
       },
       handler: holdGesture
     };
   })('hold');

   /**
    * @module gestures
    */
   /**
    * when a touch is being released from the page
    *
    * @class Release
    * @static
    */
   /**
    * @event release
    * @param {Object} ev
    */
   GestureDetector.gestures.Release = {
     name: 'release',
     index: Infinity,
     handler: function releaseGesture(ev, inst) {
       if (ev.eventType == EVENT_RELEASE) {
         inst.trigger(this.name, ev);
       }
     }
   };

   /**
    * @module gestures
    */
   /**
    * triggers swipe events when the end velocity is above the threshold
    * for best usage, set `preventDefault` (on the drag gesture) to `true`
    * ````
    *  GestureDetectortime.on("dragleft swipeleft", function(ev) {
    *    console.log(ev);
    *    ev.gesture.preventDefault();
    *  });
    * ````
    *
    * @class Swipe
    * @static
    */
   /**
    * @event swipe
    * @param {Object} ev
    */
   /**
    * @event swipeleft
    * @param {Object} ev
    */
   /**
    * @event swiperight
    * @param {Object} ev
    */
   /**
    * @event swipeup
    * @param {Object} ev
    */
   /**
    * @event swipedown
    * @param {Object} ev
    */
   GestureDetector.gestures.Swipe = {
     name: 'swipe',
     index: 40,
     defaults: {
       /**
        * @property swipeMinTouches
        * @type {Number}
        * @default 1
        */
       swipeMinTouches: 1,

       /**
        * @property swipeMaxTouches
        * @type {Number}
        * @default 1
        */
       swipeMaxTouches: 1,

       /**
        * horizontal swipe velocity
        * @property swipeVelocityX
        * @type {Number}
        * @default 0.6
        */
       swipeVelocityX: 0.6,

       /**
        * vertical swipe velocity
        * @property swipeVelocityY
        * @type {Number}
        * @default 0.6
        */
       swipeVelocityY: 0.6
     },

     handler: function swipeGesture(ev, inst) {
       if (ev.eventType == EVENT_RELEASE) {
         var touches = ev.touches.length,
             options = inst.options;

         // max touches
         if (touches < options.swipeMinTouches || touches > options.swipeMaxTouches) {
           return;
         }

         // when the distance we moved is too small we skip this gesture
         // or we can be already in dragging
         if (ev.velocityX > options.swipeVelocityX || ev.velocityY > options.swipeVelocityY) {
           // trigger swipe events
           inst.trigger(this.name, ev);
           inst.trigger(this.name + ev.direction, ev);
         }
       }
     }
   };

   /**
    * @module gestures
    */
   /**
    * Single tap and a double tap on a place
    *
    * @class Tap
    * @static
    */
   /**
    * @event tap
    * @param {Object} ev
    */
   /**
    * @event doubletap
    * @param {Object} ev
    */

   /**
    * @param {String} name
    */
   (function (name) {
     var hasMoved = false;

     function tapGesture(ev, inst) {
       var options = inst.options,
           current = Detection.current,
           prev = Detection.previous,
           sincePrev,
           didDoubleTap;

       switch (ev.eventType) {
         case EVENT_START:
           hasMoved = false;
           break;

         case EVENT_MOVE:
           hasMoved = hasMoved || ev.distance > options.tapMaxDistance;
           break;

         case EVENT_END:
           if (!Utils.inStr(ev.srcEvent.type, 'cancel') && ev.deltaTime < options.tapMaxTime && !hasMoved) {
             // previous gesture, for the double tap since these are two different gesture detections
             sincePrev = prev && prev.lastEvent && ev.timeStamp - prev.lastEvent.timeStamp;
             didDoubleTap = false;

             // check if double tap
             if (prev && prev.name == name && sincePrev && sincePrev < options.doubleTapInterval && ev.distance < options.doubleTapDistance) {
               inst.trigger('doubletap', ev);
               didDoubleTap = true;
             }

             // do a single tap
             if (!didDoubleTap || options.tapAlways) {
               current.name = name;
               inst.trigger(current.name, ev);
             }
           }
           break;
       }
     }

     GestureDetector.gestures.Tap = {
       name: name,
       index: 100,
       handler: tapGesture,
       defaults: {
         /**
          * max time of a tap, this is for the slow tappers
          * @property tapMaxTime
          * @type {Number}
          * @default 250
          */
         tapMaxTime: 250,

         /**
          * max distance of movement of a tap, this is for the slow tappers
          * @property tapMaxDistance
          * @type {Number}
          * @default 10
          */
         tapMaxDistance: 10,

         /**
          * always trigger the `tap` event, even while double-tapping
          * @property tapAlways
          * @type {Boolean}
          * @default true
          */
         tapAlways: true,

         /**
          * max distance between two taps
          * @property doubleTapDistance
          * @type {Number}
          * @default 20
          */
         doubleTapDistance: 20,

         /**
          * max time between two taps
          * @property doubleTapInterval
          * @type {Number}
          * @default 300
          */
         doubleTapInterval: 300
       }
     };
   })('tap');

   /**
    * @module gestures
    */
   /**
    * when a touch is being touched at the page
    *
    * @class Touch
    * @static
    */
   /**
    * @event touch
    * @param {Object} ev
    */
   GestureDetector.gestures.Touch = {
     name: 'touch',
     index: -Infinity,
     defaults: {
       /**
        * call preventDefault at touchstart, and makes the element blocking by disabling the scrolling of the page,
        * but it improves gestures like transforming and dragging.
        * be careful with using this, it can be very annoying for users to be stuck on the page
        * @property preventDefault
        * @type {Boolean}
        * @default false
        */
       preventDefault: false,

       /**
        * disable mouse events, so only touch (or pen!) input triggers events
        * @property preventMouse
        * @type {Boolean}
        * @default false
        */
       preventMouse: false
     },
     handler: function touchGesture(ev, inst) {
       if (inst.options.preventMouse && ev.pointerType == POINTER_MOUSE) {
         ev.stopDetect();
         return;
       }

       if (inst.options.preventDefault) {
         ev.preventDefault();
       }

       if (ev.eventType == EVENT_TOUCH) {
         inst.trigger('touch', ev);
       }
     }
   };

   /**
    * @module gestures
    */
   /**
    * User want to scale or rotate with 2 fingers
    * Preventing the default browser behavior is a good way to improve feel and working. This can be done with the
    * `preventDefault` option.
    *
    * @class Transform
    * @static
    */
   /**
    * @event transform
    * @param {Object} ev
    */
   /**
    * @event transformstart
    * @param {Object} ev
    */
   /**
    * @event transformend
    * @param {Object} ev
    */
   /**
    * @event pinchin
    * @param {Object} ev
    */
   /**
    * @event pinchout
    * @param {Object} ev
    */
   /**
    * @event rotate
    * @param {Object} ev
    */

   /**
    * @param {String} name
    */
   (function (name) {
     var triggered = false;

     function transformGesture(ev, inst) {
       switch (ev.eventType) {
         case EVENT_START:
           triggered = false;
           break;

         case EVENT_MOVE:
           // at least multitouch
           if (ev.touches.length < 2) {
             return;
           }

           var scaleThreshold = Math.abs(1 - ev.scale);
           var rotationThreshold = Math.abs(ev.rotation);

           // when the distance we moved is too small we skip this gesture
           // or we can be already in dragging
           if (scaleThreshold < inst.options.transformMinScale && rotationThreshold < inst.options.transformMinRotation) {
             return;
           }

           // we are transforming!
           Detection.current.name = name;

           // first time, trigger dragstart event
           if (!triggered) {
             inst.trigger(name + 'start', ev);
             triggered = true;
           }

           inst.trigger(name, ev); // basic transform event

           // trigger rotate event
           if (rotationThreshold > inst.options.transformMinRotation) {
             inst.trigger('rotate', ev);
           }

           // trigger pinch event
           if (scaleThreshold > inst.options.transformMinScale) {
             inst.trigger('pinch', ev);
             inst.trigger('pinch' + (ev.scale < 1 ? 'in' : 'out'), ev);
           }
           break;

         case EVENT_RELEASE:
           if (triggered && ev.changedLength < 2) {
             inst.trigger(name + 'end', ev);
             triggered = false;
           }
           break;
       }
     }

     GestureDetector.gestures.Transform = {
       name: name,
       index: 45,
       defaults: {
         /**
          * minimal scale factor, no scale is 1, zoomin is to 0 and zoomout until higher then 1
          * @property transformMinScale
          * @type {Number}
          * @default 0.01
          */
         transformMinScale: 0.01,

         /**
          * rotation in degrees
          * @property transformMinRotation
          * @type {Number}
          * @default 1
          */
         transformMinRotation: 1
       },

       handler: transformGesture
     };
   })('transform');

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */

   /**
    * @object ons.platform
    * @category util
    * @description
    *   [en]Utility methods to detect current platform.[/en]
    *   [ja][/ja]
    */

   var Platform = function () {

     /**
      * All elements will be rendered as if the app was running on this platform.
      * @type {String}
      */

     function Platform() {
       babelHelpers.classCallCheck(this, Platform);

       this._renderPlatform = null;
     }

     /**
      * @method select
      * @signature select(platform)
      * @param  {string} platform Name of the platform.
      *   [en]Possible values are: "opera", "firefox", "safari", "chrome", "ie", "android", "blackberry", "ios" or "wp".[/en]
      *   [ja]"opera", "firefox", "safari", "chrome", "ie", "android", "blackberry", "ios", "wp"[/ja]
      * @description
      *   [en]Sets the platform used to render the elements. Useful for testing.[/en]
      *   [ja][/ja]
      */


     babelHelpers.createClass(Platform, [{
       key: 'select',
       value: function select(platform) {
         if (typeof platform === 'string') {
           this._renderPlatform = platform.trim().toLowerCase();
         }
       }

       /**
        * @method isWebView
        * @signature isWebView()
        * @description
        *   [en]Returns whether app is running in Cordova.[/en]
        *   [ja]Cordova[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isWebView',
       value: function isWebView() {
         if (document.readyState === 'loading' || document.readyState == 'uninitialized') {
           throw new Error('isWebView() method is available after dom contents loaded.');
         }

         return !!(window.cordova || window.phonegap || window.PhoneGap);
       }

       /**
        * @method isIOS
        * @signature isIOS()
        * @description
        *   [en]Returns whether the OS is iOS.[/en]
        *   [ja]iOS[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isIOS',
       value: function isIOS() {
         if (this._renderPlatform) {
           return this._renderPlatform === 'ios';
         } else if ((typeof device === 'undefined' ? 'undefined' : babelHelpers.typeof(device)) === 'object' && !/browser/i.test(device.platform)) {
           return (/iOS/i.test(device.platform)
           );
         } else {
           return (/iPhone|iPad|iPod/i.test(navigator.userAgent)
           );
         }
       }

       /**
        * @method isAndroid
        * @signature isAndroid()
        * @description
        *   [en]Returns whether the OS is Android.[/en]
        *   [ja]Android[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isAndroid',
       value: function isAndroid() {
         if (this._renderPlatform) {
           return this._renderPlatform === 'android';
         } else if ((typeof device === 'undefined' ? 'undefined' : babelHelpers.typeof(device)) === 'object' && !/browser/i.test(device.platform)) {
           return (/Android/i.test(device.platform)
           );
         } else {
           return (/Android/i.test(navigator.userAgent)
           );
         }
       }

       /**
        * @method isAndroidPhone
        * @signature isAndroidPhone()
        * @description
        *   [en]Returns whether the device is Android phone.[/en]
        *   [ja]Android[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isAndroidPhone',
       value: function isAndroidPhone() {
         return (/Android/i.test(navigator.userAgent) && /Mobile/i.test(navigator.userAgent)
         );
       }

       /**
        * @method isAndroidTablet
        * @signature isAndroidTablet()
        * @description
        *   [en]Returns whether the device is Android tablet.[/en]
        *   [ja]Android[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isAndroidTablet',
       value: function isAndroidTablet() {
         return (/Android/i.test(navigator.userAgent) && !/Mobile/i.test(navigator.userAgent)
         );
       }

       /**
        * @return {Boolean}
        */

     }, {
       key: 'isWP',
       value: function isWP() {
         if (this._renderPlatform) {
           return this._renderPlatform === 'wp';
         } else if ((typeof device === 'undefined' ? 'undefined' : babelHelpers.typeof(device)) === 'object' && !/browser/i.test(device.platform)) {
           return (/Win32NT|WinCE/i.test(device.platform)
           );
         } else {
           return (/Windows Phone|IEMobile|WPDesktop/i.test(navigator.userAgent)
           );
         }
       }

       /**
        * @methos isIPhone
        * @signature isIPhone()
        * @description
        *   [en]Returns whether the device is iPhone.[/en]
        *   [ja]iPhone[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isIPhone',
       value: function isIPhone() {
         return (/iPhone/i.test(navigator.userAgent)
         );
       }

       /**
        * @method isIPad
        * @signature isIPad()
        * @description
        *   [en]Returns whether the device is iPad.[/en]
        *   [ja]iPad[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isIPad',
       value: function isIPad() {
         return (/iPad/i.test(navigator.userAgent)
         );
       }

       /**
        * @return {Boolean}
        */

     }, {
       key: 'isIPod',
       value: function isIPod() {
         return (/iPod/i.test(navigator.userAgent)
         );
       }

       /**
        * @method isBlackBerry
        * @signature isBlackBerry()
        * @description
        *   [en]Returns whether the device is BlackBerry.[/en]
        *   [ja]BlackBerry[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isBlackBerry',
       value: function isBlackBerry() {
         if (this._renderPlatform) {
           return this._renderPlatform === 'blackberry';
         } else if ((typeof device === 'undefined' ? 'undefined' : babelHelpers.typeof(device)) === 'object' && !/browser/i.test(device.platform)) {
           return (/BlackBerry/i.test(device.platform)
           );
         } else {
           return (/BlackBerry|RIM Tablet OS|BB10/i.test(navigator.userAgent)
           );
         }
       }

       /**
        * @method isOpera
        * @signature isOpera()
        * @description
        *   [en]Returns whether the browser is Opera.[/en]
        *   [ja]Opera[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isOpera',
       value: function isOpera() {
         if (this._renderPlatform) {
           return this._renderPlatform === 'opera';
         } else {
           return !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;
         }
       }

       /**
        * @method isFirefox
        * @signature isFirefox()
        * @description
        *   [en]Returns whether the browser is Firefox.[/en]
        *   [ja]Firefox[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isFirefox',
       value: function isFirefox() {
         if (this._renderPlatform) {
           return this._renderPlatform === 'firefox';
         } else {
           return typeof InstallTrigger !== 'undefined';
         }
       }

       /**
        * @method isSafari
        * @signature isSafari()
        * @description
        *   [en]Returns whether the browser is Safari.[/en]
        *   [ja]Safari[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isSafari',
       value: function isSafari() {
         if (this._renderPlatform) {
           return this._renderPlatform === 'safari';
         } else {
           return Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0;
         }
       }

       /**
        * @method isChrome
        * @signature isChrome()
        * @description
        *   [en]Returns whether the browser is Chrome.[/en]
        *   [ja]Chrome[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isChrome',
       value: function isChrome() {
         if (this._renderPlatform) {
           return this._renderPlatform === 'chrome';
         } else {
           return !!window.chrome && !(!!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0) && !(navigator.userAgent.indexOf(' Edge/') >= 0);
         }
       }

       /**
        * @method isIE
        * @signature isIE()
        * @description
        *   [en]Returns whether the browser is Internet Explorer.[/en]
        *   [ja]Internet Explorer[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isIE',
       value: function isIE() {
         if (this._renderPlatform) {
           return this._renderPlatform === 'ie';
         } else {
           return false || !!document.documentMode;
         }
       }

       /**
        * @method isEdge
        * @signature isEdge()
        * @description
        *   [en]Returns whether the browser is Edge.[/en]
        *   [ja]Edge[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isEdge',
       value: function isEdge() {
         if (this._renderPlatform) {
           return this._renderPlatform === 'edge';
         } else {
           return navigator.userAgent.indexOf(' Edge/') >= 0;
         }
       }

       /**
        * @method isIOS7above
        * @signature isIOS7above()
        * @description
        *   [en]Returns whether the iOS version is 7 or above.[/en]
        *   [ja]iOS7[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isIOS7above',
       value: function isIOS7above() {
         if ((typeof device === 'undefined' ? 'undefined' : babelHelpers.typeof(device)) === 'object' && !/browser/i.test(device.platform)) {
           return (/iOS/i.test(device.platform) && parseInt(device.version.split('.')[0]) >= 7
           );
         } else if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
           var ver = (navigator.userAgent.match(/\b[0-9]+_[0-9]+(?:_[0-9]+)?\b/) || [''])[0].replace(/_/g, '.');
           return parseInt(ver.split('.')[0]) >= 7;
         }
         return false;
       }

       /**
        * @return {String}
        */

     }, {
       key: 'getMobileOS',
       value: function getMobileOS() {
         if (this.isAndroid()) {
           return 'android';
         } else if (this.isIOS()) {
           return 'ios';
         } else if (this.isWP()) {
           return 'wp';
         } else {
           return 'other';
         }
       }

       /**
        * @return {String}
        */

     }, {
       key: 'getIOSDevice',
       value: function getIOSDevice() {
         if (this.isIPhone()) {
           return 'iphone';
         } else if (this.isIPad()) {
           return 'ipad';
         } else if (this.isIPod()) {
           return 'ipod';
         } else {
           return 'na';
         }
       }
     }]);
     return Platform;
   }();

   var platform = new Platform();

   /**
    * @object ons.notification
    * @category dialog
    * @codepen Qwwxyp
    * @tutorial vanilla/Reference/dialog
    * @description
    *   [en]
    *     Utility methods to create different kinds of alert dialogs. There are three methods available:
    *
    *     * `ons.notification.alert()`
    *     * `ons.notification.confirm()`
    *     * `ons.notification.prompt()`
    *
    *     It will automatically display a Material Design dialog on Android devices.
    *   [/en]
    *   [ja][/ja]
    * @example
    * ons.notification.alert('Hello, world!');
    *
    * ons.notification.confirm('Are you ready?')
    *   .then(
    *     function(answer) {
    *       if (answer === 1) {
    *         ons.notification.alert('Let\'s go!');
    *       }
    *     }
    *   );
    *
    * ons.notification.prompt('How old are ?')
    *   .then(
    *     function(age) {
    *       ons.notification.alert('You are ' + age + ' years old.');
    *     }
    *   );
    */
   var notification = {};

   notification._createAlertDialog = function (title, message, buttonLabels, primaryButtonIndex, modifier, animation, id, _callback, messageIsHTML, cancelable, promptDialog, autofocus, placeholder, defaultValue, submitOnEnter, compile) {

     compile = compile || function (object) {
       return object;
     };

     var titleElementHTML = typeof title === 'string' ? '<div class="alert-dialog-title"></div>' : '';

     var dialogElement = document.createElement('ons-alert-dialog');

     innerHTML(dialogElement, '\n    ' + titleElementHTML + '\n    <div class="alert-dialog-content"></div>\n    <div class="alert-dialog-footer"></div>\n  ');

     if (id) {
       dialogElement.setAttribute('id', id);
     }

     var titleElement = dialogElement.querySelector('.alert-dialog-title');
     var messageElement = dialogElement.querySelector('.alert-dialog-content');
     var footerElement = dialogElement.querySelector('.alert-dialog-footer');
     var inputElement = void 0;
     var result = {};

     result.promise = new Promise(function (resolve, reject) {
       result.resolve = resolve;
       result.reject = reject;
     });

     modifier = modifier || dialogElement.getAttribute('modifier');

     if (typeof title === 'string') {
       titleElement.textContent = title;
     }

     titleElement = null;

     dialogElement.setAttribute('animation', animation);

     if (messageIsHTML) {
       innerHTML(messageElement, message);
     } else {
       messageElement.textContent = message;
     }

     if (promptDialog) {
       inputElement = util.createElement('<input class="text-input text-input--underbar" type="text"></input>');

       if (modifier) {
         inputElement.classList.add('text-input--' + modifier);
       }

       inputElement.setAttribute('placeholder', placeholder);
       inputElement.value = defaultValue;
       inputElement.style.width = '100%';
       inputElement.style.marginTop = '10px';

       messageElement.appendChild(inputElement);

       if (submitOnEnter) {
         inputElement.addEventListener('keypress', function (event) {
           if (event.keyCode === 13) {
             dialogElement.hide({
               callback: function callback() {
                 _callback(inputElement.value);
                 result.resolve(inputElement.value);
                 dialogElement.remove();
                 dialogElement = null;
               }
             });
           }
         }, false);
       }
     }

     document.body.appendChild(dialogElement);

     compile(dialogElement);

     if (buttonLabels.length <= 2) {
       footerElement.classList.add('alert-dialog-footer--one');
     }

     var createButton = function createButton(i) {
       var buttonElement = util.createElement('<button class="alert-dialog-button"></button>');
       buttonElement.appendChild(document.createTextNode(buttonLabels[i]));

       if (i == primaryButtonIndex) {
         buttonElement.classList.add('alert-dialog-button--primal');
       }

       if (buttonLabels.length <= 2) {
         buttonElement.classList.add('alert-dialog-button--one');
       }

       var onClick = function onClick() {
         buttonElement.removeEventListener('click', onClick, false);

         dialogElement.hide({
           callback: function callback() {
             if (promptDialog) {
               _callback(inputElement.value);
               result.resolve(inputElement.value);
             } else {
               _callback(i);
               result.resolve(i);
             }
             dialogElement.remove();
             dialogElement = inputElement = buttonElement = null;
           }
         });
       };

       buttonElement.addEventListener('click', onClick, false);
       footerElement.appendChild(buttonElement);
     };

     for (var i = 0; i < buttonLabels.length; i++) {
       createButton(i);
     }

     if (cancelable) {
       dialogElement.cancelable = true;
       dialogElement.addEventListener('dialog-cancel', function () {
         if (promptDialog) {
           _callback(null);
           result.reject(null);
         } else {
           _callback(-1);
           result.reject(-1);
         }
         setTimeout(function () {
           dialogElement.remove();
           dialogElement = null;
           inputElement = null;
         });
       }, false);
     }

     setImmediate(function () {
       dialogElement.show({
         callback: function callback() {
           if (inputElement && promptDialog && autofocus) {
             inputElement.focus();
           }
         }
       });
     });

     messageElement = footerElement = null;

     if (modifier) {
       dialogElement.setAttribute('modifier', '');
       dialogElement.setAttribute('modifier', modifier);
     }

     return result.promise;
   };

   notification._alertOriginal = function (message) {
     var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

     typeof message === 'string' ? options.message = message : options = message;

     var defaults = {
       buttonLabel: 'OK',
       animation: 'default',
       title: 'Alert',
       callback: function callback() {}
     };

     options = util.extend({}, defaults, options);
     if (!options.message && !options.messageHTML) {
       throw new Error('Alert dialog must contain a message.');
     }

     return notification._createAlertDialog(options.title, options.message || options.messageHTML, [options.buttonLabel], 0, options.modifier, options.animation, options.id, options.callback, !options.message ? true : false, false, false, false, '', '', false, options.compile);
   };

   /**
    * @method alert
    * @signature alert(message [, options] | options)
    * @return {Promise}
    *   [en]Will resolve when the dialog is closed.[/en]
    *   [ja][/ja]
    * @param {String} message
    *   [en]Alert message. This argument is optional but if it's not defined either `options.message` or `options.messageHTML` must be defined instead.[/en]
    *   [ja][/ja]
    * @param {Object} options
    *   [en]Parameter object.[/en]
    *   [ja][/ja]
    * @param {String} [options.message]
    *   [en]Alert message.[/en]
    *   [ja][/ja]
    * @param {String} [options.messageHTML]
    *   [en]Alert message in HTML.[/en]
    *   [ja]HTML[/ja]
    * @param {String} [options.buttonLabel]
    *   [en]Label for confirmation button. Default is `"OK"`.[/en]
    *   [ja]"OK"[/ja]
    * @param {String} [options.animation]
    *   [en]Animation name. Available animations are `"none"`, `"fade"` and `"slide"`.[/en]
    *   [ja]"none", "fade", "slide"[/ja]
    * @param {String} [options.id]
    *   [en]The `<ons-alert-dialog>` element's ID.[/en]
    *   [ja]ons-alert-dialogID[/ja]
    * @param {String} [options.title]
    *   [en]Dialog title. Default is `"Alert"`.[/en]
    *   [ja]"Alert"[/ja]
    * @param {String} [options.modifier]
    *   [en]Modifier for the dialog.[/en]
    *   [ja]modifier[/ja]
    * @param {Function} [options.callback]
    *   [en]Function that executes after dialog has been closed.[/en]
    *   [ja][/ja]
    * @description
    *   [en]
    *     Display an alert dialog to show the user a message.
    *
    *     The content of the message can be either simple text or HTML.
    *
    *     It can be called in the following ways:
    *
    *     ```
    *     ons.notification.alert(message, options);
    *     ons.notification.alert(options);
    *     ```
    *
    *     Must specify either `message` or `messageHTML`.
    *   [/en]
    *   [ja]
    *     
    *     HTML
    *     options.messageoptions.messageHTML
    *   [/ja]
    */
   notification.alert = notification._alertOriginal;

   notification._confirmOriginal = function (message) {
     var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

     typeof message === 'string' ? options.message = message : options = message;

     var defaults = {
       buttonLabels: ['Cancel', 'OK'],
       primaryButtonIndex: 1,
       animation: 'default',
       title: 'Confirm',
       callback: function callback() {},
       cancelable: false
     };

     options = util.extend({}, defaults, options);

     if (!options.message && !options.messageHTML) {
       throw new Error('Confirm dialog must contain a message.');
     }

     return notification._createAlertDialog(options.title, options.message || options.messageHTML, options.buttonLabels, options.primaryButtonIndex, options.modifier, options.animation, options.id, options.callback, !options.message ? true : false, options.cancelable, false, false, '', '', false, options.compile);
   };

   /**
    * @method confirm
    * @signature confirm(message [, options] | options)
    * @return {Promise}
    *   [en]Will resolve to the index of the button that was pressed.[/en]
    *   [ja][/ja]
    * @param {String} message
    *   [en]Alert message. This argument is optional but if it's not defined either `options.message` or `options.messageHTML` must be defined instead.[/en]
    *   [ja][/ja]
    * @param {Object} options
    *   [en]Parameter object.[/en]
    * @param {String} [options.message]
    *   [en]Confirmation question.[/en]
    *   [ja][/ja]
    * @param {String} [options.messageHTML]
    *   [en]Dialog content in HTML.[/en]
    *   [ja]HTML[/ja]
    * @param {Array} [options.buttonLabels]
    *   [en]Labels for the buttons. Default is `["Cancel", "OK"]`.[/en]
    *   [ja]["Cancel", "OK"][/ja]
    * @param {Number} [options.primaryButtonIndex]
    *   [en]Index of primary button. Default is `1`.[/en]
    *   [ja] 1 [/ja]
    * @param {Boolean} [options.cancelable]
    *   [en]Whether the dialog is cancelable or not. Default is `false`. If the dialog is cancelable it can be closed by clicking the background or pressing the Android back button.[/en]
    *   [ja][/ja]
    * @param {String} [options.animation]
    *   [en]Animation name. Available animations are `"none"`, `"fade"` and `"slide"`.[/en]
    *   [ja]"none", "fade", "slide"[/ja]
    * @param {String} [options.id]
    *   [en]The `<ons-alert-dialog>` element's ID.[/en]
    *   [ja]ons-alert-dialogID[/ja]
    * @param {String} [options.title]
    *   [en]Dialog title. Default is `"Confirm"`.[/en]
    *   [ja]"Confirm"[/ja]
    * @param {String} [options.modifier]
    *   [en]Modifier for the dialog.[/en]
    *   [ja]modifier[/ja]
    * @param {Function} [options.callback]
    *   [en]
    *     Function that executes after the dialog has been closed.
    *     Argument for the function is the index of the button that was pressed or `-1` if the dialog was canceled.
    *   [/en]
    *   [ja]
    *     
    *     
    *     -1
    *   [/ja]
    * @description
    *   [en]
    *     Display a dialog to ask the user for confirmation.
    *     The default button labels are `"Cancel"` and `"OK"` but they can be customized.
    *
    *     It can be called in the following ways:
    *
    *     ```
    *     ons.notification.confirm(message, options);
    *     ons.notification.confirm(options);
    *     ```
    *
    *     Must specify either `message` or `messageHTML`.
    *   [/en]
    *   [ja]
    *     
    *     "Cancel""OK"
    *     options.messageoptions.messageHTML
    *   [/ja]
    */
   notification.confirm = notification._confirmOriginal;

   notification._promptOriginal = function (message) {
     var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

     typeof message === 'string' ? options.message = message : options = message;

     var defaults = {
       buttonLabel: 'OK',
       animation: 'default',
       title: 'Alert',
       defaultValue: '',
       placeholder: '',
       callback: function callback() {},
       cancelable: false,
       autofocus: true,
       submitOnEnter: true
     };

     options = util.extend({}, defaults, options);
     if (!options.message && !options.messageHTML) {
       throw new Error('Prompt dialog must contain a message.');
     }

     return notification._createAlertDialog(options.title, options.message || options.messageHTML, [options.buttonLabel], 0, options.modifier, options.animation, options.id, options.callback, !options.message ? true : false, options.cancelable, true, options.autofocus, options.placeholder, options.defaultValue, options.submitOnEnter, options.compile);
   };

   /**
    * @method prompt
    * @signature prompt(message [, options] | options)
    * @param {String} message
    *   [en]Alert message. This argument is optional but if it's not defined either `options.message` or `options.messageHTML` must be defined instead.[/en]
    *   [ja][/ja]
    * @return {Promise}
    *   [en]Will resolve to the input value when the dialog is closed.[/en]
    *   [ja][/ja]
    * @param {Object} options
    *   [en]Parameter object.[/en]
    *   [ja][/ja]
    * @param {String} [options.message]
    *   [en]Prompt question.[/en]
    *   [ja][/ja]
    * @param {String} [options.messageHTML]
    *   [en]Dialog content in HTML.[/en]
    *   [ja]HTML[/ja]
    * @param {String} [options.buttonLabel]
    *   [en]Label for confirmation button. Default is `"OK"`.[/en]
    *   [ja]"OK"[/ja]
    * @param {Number} [options.primaryButtonIndex]
    *   [en]Index of primary button. Default is `1`.[/en]
    *   [ja] 1 [/ja]
    * @param {Boolean} [options.cancelable]
    *   [en]Whether the dialog is cancelable or not. Default is false. When the dialog is cancelable it will be closed if the user taps the background or presses the Android back button.[/en]
    *   [ja] false [/ja]
    * @param {String} [options.animation]
    *   [en]Animation name. Available animations are `"none"`, `"fade"` and `"slide"`.[/en]
    *   [ja]"none", "fade", "slide"[/ja]
    * @param {String} [options.id]
    *   [en]The `<ons-alert-dialog>` element's ID.[/en]
    *   [ja]ons-alert-dialogID[/ja]
    * @param {String} [options.title]
    *   [en]Dialog title. Default is `"Alert"`.[/en]
    *   [ja] "Alert" [/ja]
    * @param {String} [options.placeholder]
    *   [en]Placeholder for the text input.[/en]
    *   [ja][/ja]
    * @param {String} [options.defaultValue]
    *   [en]Default value for the text input.[/en]
    *   [ja][/ja]
    * @param {Boolean} [options.autofocus]
    *   [en]Autofocus the input element. Default is `true`.[/en]
    *   [ja]inputtrue[/ja]
    * @param {String} [options.modifier]
    *   [en]Modifier for the dialog.[/en]
    *   [ja]modifier[/ja]
    * @param {Function} [options.callback]
    *   [en]
    *     Function that executes after the dialog has been closed.
    *     Argument for the function is the value of the input field or `null` if the dialog was canceled.
    *   [/en]
    *   [ja]
    *     
    *     null
    *   [/ja]
    * @param {Boolean} [options.submitOnEnter]
    *   [en]Submit automatically when enter is pressed. Default is `true`.[/en]
    *   [ja]Enterformsubmittrue[/ja]
    * @description
    *   [en]
    *     Display a dialog with a prompt to ask the user a question.
    *
    *     It can be called in the following ways:
    *
    *     ```
    *     ons.notification.prompt(message, options);
    *     ons.notification.prompt(options);
    *     ```
    *
    *     Must specify either `message` or `messageHTML`.
    *   [/en]
    *   [ja]
    *     
    *     options.messageoptions.messageHTML
    *   [/ja]
    */
   notification.prompt = notification._promptOriginal;

   var pageAttributeExpression = {
     _variables: {},

     /**
      * Define a variable.
      *
      * @param {String} name Name of the variable
      * @param {String|Function} value Value of the variable. Can be a string or a function. The function must return a string.
      * @param {Boolean} overwrite If this value is false, an error will be thrown when trying to define a variable that has already been defined.
      */
     defineVariable: function defineVariable(name, value) {
       var overwrite = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

       if (typeof name !== 'string') {
         throw new Error('Variable name must be a string.');
       } else if (typeof value !== 'string' && typeof value !== 'function') {
         throw new Error('Variable value must be a string or a function.');
       } else if (this._variables.hasOwnProperty(name) && !overwrite) {
         throw new Error('"' + name + '" is already defined.');
       }
       this._variables[name] = value;
     },

     /**
      * Get a variable.
      *
      * @param {String} name Name of the variable.
      * @return {String|Function|null}
      */
     getVariable: function getVariable(name) {
       if (!this._variables.hasOwnProperty(name)) {
         return null;
       }

       return this._variables[name];
     },

     /**
      * Remove a variable.
      *
      * @param {String} name Name of the varaible.
      */
     removeVariable: function removeVariable(name) {
       delete this._variables[name];
     },

     /**
      * Get all variables.
      *
      * @return {Object}
      */
     getAllVariables: function getAllVariables() {
       return this._variables;
     },
     _parsePart: function _parsePart(part) {
       var c = void 0,
           inInterpolation = false,
           currentIndex = 0;

       var tokens = [];

       if (part.length === 0) {
         throw new Error('Unable to parse empty string.');
       }

       for (var i = 0; i < part.length; i++) {
         c = part.charAt(i);

         if (c === '$' && part.charAt(i + 1) === '{') {
           if (inInterpolation) {
             throw new Error('Nested interpolation not supported.');
           }

           var token = part.substring(currentIndex, i);
           if (token.length > 0) {
             tokens.push(part.substring(currentIndex, i));
           }

           currentIndex = i;
           inInterpolation = true;
         } else if (c === '}') {
           if (!inInterpolation) {
             throw new Error('} must be preceeded by ${');
           }

           var _token = part.substring(currentIndex, i + 1);
           if (_token.length > 0) {
             tokens.push(part.substring(currentIndex, i + 1));
           }

           currentIndex = i + 1;
           inInterpolation = false;
         }
       }

       if (inInterpolation) {
         throw new Error('Unterminated interpolation.');
       }

       tokens.push(part.substring(currentIndex, part.length));

       return tokens;
     },
     _replaceToken: function _replaceToken(token) {
       var re = /^\${(.*?)}$/,
           match = token.match(re);

       if (match) {
         var name = match[1].trim();
         var variable = this.getVariable(name);

         if (variable === null) {
           throw new Error('Variable "' + name + '" does not exist.');
         } else if (typeof variable === 'string') {
           return variable;
         } else {
           var rv = variable();

           if (typeof rv !== 'string') {
             throw new Error('Must return a string.');
           }

           return rv;
         }
       } else {
         return token;
       }
     },
     _replaceTokens: function _replaceTokens(tokens) {
       return tokens.map(this._replaceToken.bind(this));
     },
     _parseExpression: function _parseExpression(expression) {
       return expression.split(',').map(function (part) {
         return part.trim();
       }).map(this._parsePart.bind(this)).map(this._replaceTokens.bind(this)).map(function (part) {
         return part.join('');
       });
     },

     /**
      * Evaluate an expression.
      *
      * @param {String} expression An page attribute expression.
      * @return {Array}
      */
     evaluate: function evaluate(expression) {
       if (!expression) {
         return [];
       }

       return this._parseExpression(expression);
     }
   };

   // Define default variables.
   pageAttributeExpression.defineVariable('mobileOS', platform.getMobileOS());
   pageAttributeExpression.defineVariable('iOSDevice', platform.getIOSDevice());
   pageAttributeExpression.defineVariable('runtime', function () {
     return platform.isWebView() ? 'cordova' : 'browser';
   });

   var internal = {};

   internal.config = {
     autoStatusBarFill: true,
     animationsDisabled: false
   };

   internal.nullElement = window.document.createElement('div');

   /**
    * @return {Boolean}
    */
   internal.isEnabledAutoStatusBarFill = function () {
     return !!internal.config.autoStatusBarFill;
   };

   /**
    * @param {String} html
    * @return {String}
    */
   internal.normalizePageHTML = function (html) {
     html = ('' + html).trim();

     if (!html.match(/^<ons-page/)) {
       html = '<ons-page _muted>' + html + '</ons-page>';
     }

     return html;
   };

   internal.waitDOMContentLoaded = function (callback) {
     if (window.document.readyState === 'loading' || window.document.readyState == 'uninitialized') {
       window.document.addEventListener('DOMContentLoaded', callback);
     } else {
       setImmediate(callback);
     }
   };

   internal.autoStatusBarFill = function (action) {
     var onReady = function onReady() {
       if (internal.shouldFillStatusBar()) {
         action();
       }
       document.removeEventListener('deviceready', onReady);
       document.removeEventListener('DOMContentLoaded', onReady);
     };

     if ((typeof device === 'undefined' ? 'undefined' : babelHelpers.typeof(device)) === 'object') {
       document.addEventListener('deviceready', onReady);
     } else if (['complete', 'interactive'].indexOf(document.readyState) === -1) {
       document.addEventListener('DOMContentLoaded', function () {
         onReady();
       });
     } else {
       onReady();
     }
   };

   internal.shouldFillStatusBar = function () {
     return internal.isEnabledAutoStatusBarFill() && platform.isWebView() && platform.isIOS7above();
   };

   internal.templateStore = {
     _storage: {},

     /**
      * @param {String} key
      * @return {String/null} template
      */
     get: function get(key) {
       return internal.templateStore._storage[key] || null;
     },


     /**
      * @param {String} key
      * @param {String} template
      */
     set: function set(key, template) {
       internal.templateStore._storage[key] = template;
     }
   };

   window.document.addEventListener('_templateloaded', function (e) {
     if (e.target.nodeName.toLowerCase() === 'ons-template') {
       internal.templateStore.set(e.templateId, e.template);
     }
   }, false);

   window.document.addEventListener('DOMContentLoaded', function () {
     register('script[type="text/ons-template"]');
     register('script[type="text/template"]');
     register('script[type="text/ng-template"]');

     function register(query) {
       var templates = window.document.querySelectorAll(query);
       for (var i = 0; i < templates.length; i++) {
         internal.templateStore.set(templates[i].getAttribute('id'), templates[i].textContent);
       }
     }
   }, false);

   /**
    * @param {String} page
    * @return {Promise}
    */
   internal.getTemplateHTMLAsync = function (page) {
     return new Promise(function (resolve, reject) {
       setImmediate(function () {
         var cache = internal.templateStore.get(page);

         if (cache) {
           var html = typeof cache === 'string' ? cache : cache[1];
           resolve(html);
         } else {
           (function () {
             var xhr = new XMLHttpRequest();
             xhr.open('GET', page, true);
             xhr.onload = function (response) {
               var html = xhr.responseText;
               if (xhr.status >= 400 && xhr.status < 600) {
                 reject(html);
               } else {
                 resolve(html);
               }
             };
             xhr.onerror = function () {
               throw new Error('The page is not found: ' + page);
             };
             xhr.send(null);
           })();
         }
       });
     });
   };

   /**
    * @param {String} page
    * @return {Promise}
    */
   internal.getPageHTMLAsync = function (page) {
     var pages = pageAttributeExpression.evaluate(page);

     var getPage = function getPage(page) {
       if (typeof page !== 'string') {
         return Promise.reject('Must specify a page.');
       }

       return internal.getTemplateHTMLAsync(page).then(function (html) {
         return internal.normalizePageHTML(html);
       }, function (error) {
         if (pages.length === 0) {
           return Promise.reject(error);
         }

         return getPage(pages.shift());
       }).then(function (html) {
         return internal.normalizePageHTML(html);
       });
     };

     return getPage(pages.shift());
   };

   var AnimatorFactory = function () {

     /**
      * @param {Object} opts
      * @param {Object} opts.animators The dictionary for animator classes
      * @param {Function} opts.baseClass The base class of animators
      * @param {String} [opts.baseClassName] The name of the base class of animators
      * @param {String} [opts.defaultAnimation] The default animation name
      * @param {Object} [opts.defaultAnimationOptions] The default animation options
      */

     function AnimatorFactory(opts) {
       babelHelpers.classCallCheck(this, AnimatorFactory);

       this._animators = opts.animators;
       this._baseClass = opts.baseClass;
       this._baseClassName = opts.baseClassName || opts.baseClass.name;
       this._animation = opts.defaultAnimation || 'default';
       this._animationOptions = opts.defaultAnimationOptions || {};

       if (!this._animators[this._animation]) {
         throw new Error('No such animation: ' + this._animation);
       }
     }

     /**
      * @param {String} jsonString
      * @return {Object/null}
      */


     babelHelpers.createClass(AnimatorFactory, [{
       key: 'setAnimationOptions',


       /**
        * @param {Object} options
        */
       value: function setAnimationOptions(options) {
         this._animationOptions = options;
       }

       /**
        * @param {Object} options
        * @param {String} [options.animation] The animation name
        * @param {Object} [options.animationOptions] The animation options
        * @param {Object} defaultAnimator The default animator instance
        * @return {Object} An animator instance
        */

     }, {
       key: 'newAnimator',
       value: function newAnimator() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
         var defaultAnimator = arguments[1];


         var animator = null;

         if (options.animation instanceof this._baseClass) {
           return options.animation;
         }

         var Animator = null;

         if (typeof options.animation === 'string') {
           Animator = this._animators[options.animation];
         }

         if (!Animator && defaultAnimator) {
           animator = defaultAnimator;
         } else {
           Animator = Animator || this._animators[this._animation];

           var animationOpts = util.extend({}, this._animationOptions, options.animationOptions || {}, internal.config.animationsDisabled ? { duration: 0, delay: 0 } : {});

           animator = new Animator(animationOpts);

           if (typeof animator === 'function') {
             animator = new animator(animationOpts); // eslint-disable-line new-cap
           }
         }

         if (!(animator instanceof this._baseClass)) {
           throw new Error('"animator" is not an instance of ' + this._baseClassName + '.');
         }

         return animator;
       }
     }], [{
       key: 'parseAnimationOptionsString',
       value: function parseAnimationOptionsString(jsonString) {
         try {
           if (typeof jsonString === 'string') {
             var result = util.animationOptionsParse(jsonString);
             if ((typeof result === 'undefined' ? 'undefined' : babelHelpers.typeof(result)) === 'object' && result !== null) {
               return result;
             } else {
               console.error('"animation-options" attribute must be a JSON object string: ' + jsonString);
             }
           }
           return {};
         } catch (e) {
           console.error('"animation-options" attribute must be a JSON object string: ' + jsonString);
           return {};
         }
       }
     }]);
     return AnimatorFactory;
   }();

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */

   var ModifierUtil = function () {
     function ModifierUtil() {
       babelHelpers.classCallCheck(this, ModifierUtil);
     }

     babelHelpers.createClass(ModifierUtil, null, [{
       key: 'diff',

       /**
        * @param {String} last
        * @param {String} current
        */
       value: function diff(last, current) {
         last = makeDict(('' + last).trim());
         current = makeDict(('' + current).trim());

         var removed = Object.keys(last).reduce(function (result, token) {
           if (!current[token]) {
             result.push(token);
           }
           return result;
         }, []);

         var added = Object.keys(current).reduce(function (result, token) {
           if (!last[token]) {
             result.push(token);
           }
           return result;
         }, []);

         return { added: added, removed: removed };

         function makeDict(modifier) {
           var dict = {};
           ModifierUtil.split(modifier).forEach(function (token) {
             return dict[token] = token;
           });
           return dict;
         }
       }

       /**
        * @param {Object} diff
        * @param {Object} classList
        * @param {String} template
        */

     }, {
       key: 'applyDiffToClassList',
       value: function applyDiffToClassList(diff, classList, template) {
         diff.added.map(function (modifier) {
           return template.replace(/\*/g, modifier);
         }).forEach(function (klass) {
           return classList.add(klass);
         });

         diff.removed.map(function (modifier) {
           return template.replace(/\*/g, modifier);
         }).forEach(function (klass) {
           return classList.remove(klass);
         });
       }

       /**
        * @param {Object} diff
        * @param {HTMLElement} element
        * @param {Object} scheme
        */

     }, {
       key: 'applyDiffToElement',
       value: function applyDiffToElement(diff, element, scheme) {
         var matches = function matches(e, s) {
           return (e.matches || e.webkitMatchesSelector || e.mozMatchesSelector || e.msMatchesSelector).call(e, s);
         };
         for (var selector in scheme) {
           if (scheme.hasOwnProperty(selector)) {
             var targetElements = !selector || matches(element, selector) ? [element] : element.querySelectorAll(selector);
             for (var i = 0; i < targetElements.length; i++) {
               ModifierUtil.applyDiffToClassList(diff, targetElements[i].classList, scheme[selector]);
             }
           }
         }
       }

       /**
        * @param {String} last
        * @param {String} current
        * @param {HTMLElement} element
        * @param {Object} scheme
        */

     }, {
       key: 'onModifierChanged',
       value: function onModifierChanged(last, current, element, scheme) {
         return ModifierUtil.applyDiffToElement(ModifierUtil.diff(last, current), element, scheme);
       }

       /**
        * @param {HTMLElement} element
        * @param {Object} scheme
        */

     }, {
       key: 'initModifier',
       value: function initModifier(element, scheme) {
         var modifier = element.getAttribute('modifier');
         if (typeof modifier !== 'string') {
           return;
         }

         ModifierUtil.applyDiffToElement({
           removed: [],
           added: ModifierUtil.split(modifier)
         }, element, scheme);
       }
     }, {
       key: 'split',
       value: function split(modifier) {
         if (typeof modifier !== 'string') {
           return [];
         }

         return modifier.trim().split(/ +/).filter(function (token) {
           return token !== '';
         });
       }
     }]);
     return ModifierUtil;
   }();

   var LazyRepeatDelegate = function () {
     function LazyRepeatDelegate(userDelegate) {
       var templateElement = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
       babelHelpers.classCallCheck(this, LazyRepeatDelegate);

       if ((typeof userDelegate === 'undefined' ? 'undefined' : babelHelpers.typeof(userDelegate)) !== 'object' || userDelegate === null) {
         throw Error('"delegate" parameter must be an object.');
       }
       this._userDelegate = userDelegate;

       if (!(templateElement instanceof Element) && templateElement !== null) {
         throw Error('"templateElement" parameter must be an instance of Element or null.');
       }
       this._templateElement = templateElement;
     }

     babelHelpers.createClass(LazyRepeatDelegate, [{
       key: 'hasRenderFunction',


       /**
        * @return {Boolean}
        */
       value: function hasRenderFunction() {
         return this._userDelegate._render instanceof Function;
       }

       /**
        * @return {void}
        */

     }, {
       key: '_render',
       value: function _render(items, height) {
         this._userDelegate._render(items, height);
       }

       /**
        * @param {Number} index
        * @param {Element} parent
        * @param {Function} done A function that take item object as parameter.
        */

     }, {
       key: 'loadItemElement',
       value: function loadItemElement(index, parent, done) {
         if (this._userDelegate.loadItemElement instanceof Function) {
           this._userDelegate.loadItemElement(index, parent, function (element) {
             return done({ element: element });
           });
         } else {
           var element = this._userDelegate.createItemContent(index, this._templateElement);
           if (!(element instanceof Element)) {
             throw Error('createItemContent() must return an instance of Element.');
           }
           parent.appendChild(element);
           done({ element: element });
         }
       }

       /**
        * @return {Number}
        */

     }, {
       key: 'countItems',
       value: function countItems() {
         var count = this._userDelegate.countItems();
         if (typeof count !== 'number') {
           throw Error('countItems() must return a number.');
         }
         return count;
       }

       /**
        * @param {Number} index
        * @param {Object} item
        * @param {Element} item.element
        */

     }, {
       key: 'updateItem',
       value: function updateItem(index, item) {
         if (this._userDelegate.updateItemContent instanceof Function) {
           this._userDelegate.updateItemContent(index, item);
         }
       }

       /**
        * @return {Number}
        */

     }, {
       key: 'calculateItemHeight',
       value: function calculateItemHeight(index) {
         if (this._userDelegate.calculateItemHeight instanceof Function) {
           var height = this._userDelegate.calculateItemHeight(index);

           if (typeof height !== 'number') {
             throw Error('calculateItemHeight() must return a number.');
           }

           return height;
         }

         return 0;
       }

       /**
        * @param {Number} index
        * @param {Object} item
        */

     }, {
       key: 'destroyItem',
       value: function destroyItem(index, item) {
         if (this._userDelegate.destroyItem instanceof Function) {
           this._userDelegate.destroyItem(index, item);
         }
       }

       /**
        * @return {void}
        */

     }, {
       key: 'destroy',
       value: function destroy() {
         if (this._userDelegate.destroy instanceof Function) {
           this._userDelegate.destroy();
         }

         this._userDelegate = this._templateElement = null;
       }
     }, {
       key: 'itemHeight',
       get: function get() {
         return this._userDelegate.itemHeight;
       }
     }]);
     return LazyRepeatDelegate;
   }();

   /**
    * This class provide core functions for ons-lazy-repeat.
    */
   var LazyRepeatProvider = function () {

     /**
      * @param {Element} wrapperElement
      * @param {LazyRepeatDelegate} delegate
      */

     function LazyRepeatProvider(wrapperElement, delegate) {
       babelHelpers.classCallCheck(this, LazyRepeatProvider);

       if (!(delegate instanceof LazyRepeatDelegate)) {
         throw Error('"delegate" parameter must be an instance of LazyRepeatDelegate.');
       }

       this._wrapperElement = wrapperElement;
       this._delegate = delegate;

       if (wrapperElement.tagName.toLowerCase() === 'ons-list') {
         wrapperElement.classList.add('lazy-list');
       }

       this._pageContent = util.findParent(wrapperElement, '.page__content');

       if (!this._pageContent) {
         throw new Error('ons-lazy-repeat must be a descendant of an <ons-page> or an element.');
       }

       this._topPositions = [];
       this._renderedItems = {};

       if (!this._delegate.itemHeight && !this._delegate.calculateItemHeight(0)) {
         this._unknownItemHeight = true;
       }
       this._addEventListeners();
       this._onChange();
     }

     babelHelpers.createClass(LazyRepeatProvider, [{
       key: '_checkItemHeight',
       value: function _checkItemHeight(callback) {
         var _this = this;

         this._delegate.loadItemElement(0, this._wrapperElement, function (item) {
           if (!_this._unknownItemHeight) {
             throw Error('Invalid state');
           }

           var done = function done() {
             _this._wrapperElement.removeChild(item.element);
             delete _this._unknownItemHeight;
             callback();
           };

           _this._itemHeight = item.element.offsetHeight;

           if (_this._itemHeight > 0) {
             done();
             return;
           }

           // retry to measure offset height
           // dirty fix for angular2 directive
           var lastVisibility = _this._wrapperElement.style.visibility;
           _this._wrapperElement.style.visibility = 'hidden';
           item.element.style.visibility = 'hidden';

           setImmediate(function () {
             _this._itemHeight = item.element.offsetHeight;
             if (_this._itemHeight == 0) {
               throw Error('Invalid state: this._itemHeight must be greater than zero.');
             }
             _this._wrapperElement.style.visibility = lastVisibility;
             done();
           });
         });
       }
     }, {
       key: '_countItems',
       value: function _countItems() {
         return this._delegate.countItems();
       }
     }, {
       key: '_getItemHeight',
       value: function _getItemHeight(i) {
         return this.staticItemHeight || this._delegate.calculateItemHeight(i);
       }
     }, {
       key: '_onChange',
       value: function _onChange() {
         this._render();
       }
     }, {
       key: 'refresh',
       value: function refresh() {
         this._removeAllElements();
         this._onChange();
       }
     }, {
       key: '_render',
       value: function _render() {
         var _this2 = this;

         if (this._unknownItemHeight) {
           return this._checkItemHeight(this._render.bind(this));
         }

         var items = this._getItemsInView();

         if (this._delegate.hasRenderFunction && this._delegate.hasRenderFunction()) {
           this._delegate._render(items, this._listHeight);
           return null;
         }

         var keep = {};

         items.forEach(function (item) {
           _this2._renderElement(item);
           keep[item.index] = true;
         });

         Object.keys(this._renderedItems).forEach(function (key) {
           return keep[key] || _this2._removeElement(key);
         });

         this._wrapperElement.style.height = this._listHeight + 'px';
       }

       /**
        * @param {Object} item
        * @param {Number} item.index
        * @param {Number} item.top
        */

     }, {
       key: '_renderElement',
       value: function _renderElement(_ref) {
         var _this3 = this;

         var index = _ref.index;
         var top = _ref.top;

         var item = this._renderedItems[index];
         if (item) {
           this._delegate.updateItem(index, item); // update if it exists
           item.element.style.top = top + 'px';
           return;
         }

         this._delegate.loadItemElement(index, this._wrapperElement, function (item) {
           util.extend(item.element.style, {
             position: 'absolute',
             top: top + 'px',
             left: 0,
             right: 0
           });

           _this3._renderedItems[index] = item;
         });
       }

       /**
        * @param {Number} index
        */

     }, {
       key: '_removeElement',
       value: function _removeElement(index) {
         var item = this._renderedItems[index];

         this._delegate.destroyItem(index, item);

         if (item.element.parentElement) {
           item.element.parentElement.removeChild(item.element);
         }

         delete this._renderedItems[index];
       }
     }, {
       key: '_removeAllElements',
       value: function _removeAllElements() {
         var _this4 = this;

         Object.keys(this._renderedItems).forEach(function (key) {
           return _this4._removeElement(key);
         });
       }
     }, {
       key: '_calculateStartIndex',
       value: function _calculateStartIndex(current) {
         var start = 0;
         var end = this._itemCount - 1;

         if (this.staticItemHeight) {
           return parseInt(-current / this.staticItemHeight);
         }

         // Binary search for index at top of screen so we can speed up rendering.
         for (;;) {
           var middle = Math.floor((start + end) / 2);
           var value = current + this._topPositions[middle];

           if (end < start) {
             return 0;
           } else if (value <= 0 && value + this._getItemHeight(middle) > 0) {
             return middle;
           } else if (isNaN(value) || value >= 0) {
             end = middle - 1;
           } else {
             start = middle + 1;
           }
         }
       }
     }, {
       key: '_recalculateTopPositions',
       value: function _recalculateTopPositions() {
         var l = Math.min(this._topPositions.length, this._itemCount);
         this._topPositions[0] = 0;
         for (var i = 1, _l; i < _l; i++) {
           this._topPositions[i] = this._topPositions[i - 1] + this._getItemHeight(i);
         }
       }
     }, {
       key: '_getItemsInView',
       value: function _getItemsInView() {
         var offset = this._wrapperElement.getBoundingClientRect().top;
         var limit = 4 * window.innerHeight - offset;
         var count = this._countItems();

         if (count !== this._itemCount) {
           this._itemCount = count;
           this._recalculateTopPositions();
         }

         var i = Math.max(0, this._calculateStartIndex(offset) - 30);

         var items = [];
         for (var top = this._topPositions[i]; i < count && top < limit; i++) {
           if (i >= this._topPositions.length) {
             // perf optimization
             this._topPositions.length += 100;
           }

           this._topPositions[i] = top;
           items.push({ top: top, index: i });
           top += this._getItemHeight(i);
         }
         this._listHeight = top;

         return items;
       }
     }, {
       key: '_debounce',
       value: function _debounce(func, wait, immediate) {
         var timeout = void 0;
         return function () {
           var _this5 = this,
               _arguments = arguments;

           var callNow = immediate && !timeout;
           clearTimeout(timeout);
           if (callNow) {
             func.apply(this, arguments);
           } else {
             timeout = setTimeout(function () {
               timeout = null;
               func.apply(_this5, _arguments);
             }, wait);
           }
         };
       }
     }, {
       key: '_doubleFireOnTouchend',
       value: function _doubleFireOnTouchend() {
         this._render();
         this._debounce(this._render.bind(this), 100);
       }
     }, {
       key: '_addEventListeners',
       value: function _addEventListeners() {
         util.bindListeners(this, ['_onChange', '_doubleFireOnTouchend']);

         if (platform.isIOS()) {
           this._boundOnChange = this._debounce(this._boundOnChange, 30);
         }

         this._pageContent.addEventListener('scroll', this._boundOnChange, true);

         if (platform.isIOS()) {
           this._pageContent.addEventListener('touchmove', this._boundOnChange, true);
           this._pageContent.addEventListener('touchend', this._boundDoubleFireOnTouchend, true);
         }

         window.document.addEventListener('resize', this._boundOnChange, true);
       }
     }, {
       key: '_removeEventListeners',
       value: function _removeEventListeners() {
         this._pageContent.removeEventListener('scroll', this._boundOnChange, true);

         if (platform.isIOS()) {
           this._pageContent.removeEventListener('touchmove', this._boundOnChange, true);
           this._pageContent.removeEventListener('touchend', this._boundDoubleFireOnTouchend, true);
         }

         window.document.removeEventListener('resize', this._boundOnChange, true);
       }
     }, {
       key: 'destroy',
       value: function destroy() {
         this._removeAllElements();
         this._delegate.destroy();
         this._parentElement = this._delegate = this._renderedItems = null;
         this._removeEventListeners();
       }
     }, {
       key: 'staticItemHeight',
       get: function get() {
         return this._delegate.itemHeight || this._itemHeight;
       }
     }]);
     return LazyRepeatProvider;
   }();

   internal.AnimatorFactory = AnimatorFactory;
   internal.ModifierUtil = ModifierUtil;
   internal.LazyRepeatProvider = LazyRepeatProvider;
   internal.LazyRepeatDelegate = LazyRepeatDelegate;

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */

   var create = function create() {

     /**
      * @object ons.orientation
      * @category util
      * @description
      *   [en]Utility methods for orientation detection.[/en]
      *   [ja][/ja]
      */
     var obj = {
       /**
        * @event change
        * @description
        *   [en]Fired when the device orientation changes.[/en]
        *   [ja][/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja][/ja]
        * @param {Boolean} event.isPortrait
        *   [en]Will be true if the current orientation is portrait mode.[/en]
        *   [ja]portraittrue[/ja]
        */

       /**
        * @method on
        * @signature on(eventName, listener)
        * @description
        *   [en]Add an event listener.[/en]
        *   [ja][/ja]
        * @param {String} eventName
        *   [en]Name of the event.[/en]
        *   [ja][/ja]
        * @param {Function} listener
        *   [en]Function to execute when the event is triggered.[/en]
        *   [ja][/ja]
        */

       /**
        * @method once
        * @signature once(eventName, listener)
        * @description
        *  [en]Add an event listener that's only triggered once.[/en]
        *  [ja][/ja]
        * @param {String} eventName
        *   [en]Name of the event.[/en]
        *   [ja][/ja]
        * @param {Function} listener
        *   [en]Function to execute when the event is triggered.[/en]
        *   [ja][/ja]
        */

       /**
        * @method off
        * @signature off(eventName, [listener])
        * @description
        *  [en]Remove an event listener. If the listener is not specified all listeners for the event type will be removed.[/en]
        *  [ja][/ja]
        * @param {String} eventName
        *   [en]Name of the event.[/en]
        *   [ja][/ja]
        * @param {Function} listener
        *   [en]Function to execute when the event is triggered.[/en]
        *   [ja][/ja]
        */

       // actual implementation to detect if whether current screen is portrait or not
       _isPortrait: false,

       /**
        * @method isPortrait
        * @signature isPortrait()
        * @return {Boolean}
        *   [en]Will be true if the current orientation is portrait mode.[/en]
        *   [ja]portraittrue[/ja]
        * @description
        *   [en]Returns whether the current screen orientation is portrait or not.[/en]
        *   [ja]portrait[/ja]
        */
       isPortrait: function isPortrait() {
         return this._isPortrait();
       },

       /**
        * @method isLandscape
        * @signature isLandscape()
        * @return {Boolean}
        *   [en]Will be true if the current orientation is landscape mode.[/en]
        *   [ja]landscapetrue[/ja]
        * @description
        *   [en]Returns whether the current screen orientation is landscape or not.[/en]
        *   [ja]landscape[/ja]
        */
       isLandscape: function isLandscape() {
         return !this.isPortrait();
       },

       _init: function _init() {
         document.addEventListener('DOMContentLoaded', this._onDOMContentLoaded.bind(this), false);

         if ('orientation' in window) {
           window.addEventListener('orientationchange', this._onOrientationChange.bind(this), false);
         } else {
           window.addEventListener('resize', this._onResize.bind(this), false);
         }

         this._isPortrait = function () {
           return window.innerHeight > window.innerWidth;
         };

         return this;
       },

       _onDOMContentLoaded: function _onDOMContentLoaded() {
         this._installIsPortraitImplementation();
         this.emit('change', { isPortrait: this.isPortrait() });
       },

       _installIsPortraitImplementation: function _installIsPortraitImplementation() {
         var isPortrait = window.innerWidth < window.innerHeight;

         if (!('orientation' in window)) {
           this._isPortrait = function () {
             return window.innerHeight > window.innerWidth;
           };
         } else if (window.orientation % 180 === 0) {
           this._isPortrait = function () {
             return Math.abs(window.orientation % 180) === 0 ? isPortrait : !isPortrait;
           };
         } else {
           this._isPortrait = function () {
             return Math.abs(window.orientation % 180) === 90 ? isPortrait : !isPortrait;
           };
         }
       },

       _onOrientationChange: function _onOrientationChange() {
         var _this = this;

         var isPortrait = this._isPortrait();

         // Wait for the dimensions to change because
         // of Android inconsistency.
         var nIter = 0;
         var interval = setInterval(function () {
           nIter++;

           var w = window.innerWidth;
           var h = window.innerHeight;

           if (isPortrait && w <= h || !isPortrait && w >= h) {
             _this.emit('change', { isPortrait: isPortrait });
             clearInterval(interval);
           } else if (nIter === 50) {
             _this.emit('change', { isPortrait: isPortrait });
             clearInterval(interval);
           }
         }, 20);
       },

       // Run on not mobile browser.
       _onResize: function _onResize() {
         this.emit('change', { isPortrait: this.isPortrait() });
       }
     };

     MicroEvent.mixin(obj);

     return obj;
   };

   var orientation = create()._init();

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */

   var softwareKeyboard = new MicroEvent();
   softwareKeyboard._visible = false;

   var onShow = function onShow() {
     softwareKeyboard._visible = true;
     softwareKeyboard.emit('show');
   };

   var onHide = function onHide() {
     softwareKeyboard._visible = false;
     softwareKeyboard.emit('hide');
   };

   var bindEvents = function bindEvents() {
     if (typeof Keyboard !== 'undefined') {
       // https://github.com/martinmose/cordova-keyboard/blob/95f3da3a38d8f8e1fa41fbf40145352c13535a00/README.md
       Keyboard.onshow = onShow;
       Keyboard.onhide = onHide;
       softwareKeyboard.emit('init', { visible: Keyboard.isVisible });

       return true;
     } else if (typeof cordova.plugins !== 'undefined' && typeof cordova.plugins.Keyboard !== 'undefined') {
       // https://github.com/driftyco/ionic-plugins-keyboard/blob/ca27ecf/README.md
       window.addEventListener('native.keyboardshow', onShow);
       window.addEventListener('native.keyboardhide', onHide);
       softwareKeyboard.emit('init', { visible: cordova.plugins.Keyboard.isVisible });

       return true;
     }

     return false;
   };

   var noPluginError = function noPluginError() {
     console.warn('ons-keyboard: Cordova Keyboard plugin is not present.');
   };

   document.addEventListener('deviceready', function () {
     if (!bindEvents()) {
       if (document.querySelector('[ons-keyboard-active]') || document.querySelector('[ons-keyboard-inactive]')) {
         noPluginError();
       }

       softwareKeyboard.on = noPluginError;
     }
   });

   var util$1 = {
     _ready: false,

     _domContentLoaded: false,

     _onDOMContentLoaded: function _onDOMContentLoaded() {
       util$1._domContentLoaded = true;

       if (platform.isWebView()) {
         window.document.addEventListener('deviceready', function () {
           util$1._ready = true;
         }, false);
       } else {
         util$1._ready = true;
       }
     },

     addBackButtonListener: function addBackButtonListener(fn) {
       if (!this._domContentLoaded) {
         throw new Error('This method is available after DOMContentLoaded');
       }

       if (this._ready) {
         window.document.addEventListener('backbutton', fn, false);
       } else {
         window.document.addEventListener('deviceready', function () {
           window.document.addEventListener('backbutton', fn, false);
         });
       }
     },

     removeBackButtonListener: function removeBackButtonListener(fn) {
       if (!this._domContentLoaded) {
         throw new Error('This method is available after DOMContentLoaded');
       }

       if (this._ready) {
         window.document.removeEventListener('backbutton', fn, false);
       } else {
         window.document.addEventListener('deviceready', function () {
           window.document.removeEventListener('backbutton', fn, false);
         });
       }
     }
   };
   window.addEventListener('DOMContentLoaded', function () {
     return util$1._onDOMContentLoaded();
   }, false);

   var HandlerRepository = {
     _store: {},

     _genId: function () {
       var i = 0;
       return function () {
         return i++;
       };
     }(),

     set: function set(element, handler) {
       if (element.dataset.deviceBackButtonHandlerId) {
         this.remove(element);
       }
       var id = element.dataset.deviceBackButtonHandlerId = HandlerRepository._genId();
       this._store[id] = handler;
     },

     remove: function remove(element) {
       if (element.dataset.deviceBackButtonHandlerId) {
         delete this._store[element.dataset.deviceBackButtonHandlerId];
         delete element.dataset.deviceBackButtonHandlerId;
       }
     },

     get: function get(element) {
       if (!element.dataset.deviceBackButtonHandlerId) {
         return undefined;
       }

       var id = element.dataset.deviceBackButtonHandlerId;

       if (!this._store[id]) {
         throw new Error();
       }

       return this._store[id];
     },

     has: function has(element) {
       if (!element.dataset) {
         return false;
       }

       var id = element.dataset.deviceBackButtonHandlerId;

       return !!this._store[id];
     }
   };

   var DeviceBackButtonDispatcher = function () {
     function DeviceBackButtonDispatcher() {
       babelHelpers.classCallCheck(this, DeviceBackButtonDispatcher);

       this._isEnabled = false;
       this._boundCallback = this._callback.bind(this);
     }

     /**
      * Enable to handle 'backbutton' events.
      */


     babelHelpers.createClass(DeviceBackButtonDispatcher, [{
       key: 'enable',
       value: function enable() {
         if (!this._isEnabled) {
           util$1.addBackButtonListener(this._boundCallback);
           this._isEnabled = true;
         }
       }

       /**
        * Disable to handle 'backbutton' events.
        */

     }, {
       key: 'disable',
       value: function disable() {
         if (this._isEnabled) {
           util$1.removeBackButtonListener(this._boundCallback);
           this._isEnabled = false;
         }
       }

       /**
        * Fire a 'backbutton' event manually.
        */

     }, {
       key: 'fireDeviceBackButtonEvent',
       value: function fireDeviceBackButtonEvent() {
         var event = document.createEvent('Event');
         event.initEvent('backbutton', true, true);
         document.dispatchEvent(event);
       }
     }, {
       key: '_callback',
       value: function _callback() {
         this._dispatchDeviceBackButtonEvent();
       }

       /**
        * @param {HTMLElement} element
        * @param {Function} callback
        */

     }, {
       key: 'createHandler',
       value: function createHandler(element, callback) {
         if (!(element instanceof HTMLElement)) {
           throw new Error('element must be an instance of HTMLElement');
         }

         if (!(callback instanceof Function)) {
           throw new Error('callback must be an instance of Function');
         }

         var handler = {
           _callback: callback,
           _element: element,

           disable: function disable() {
             HandlerRepository.remove(element);
           },

           setListener: function setListener(callback) {
             this._callback = callback;
           },

           enable: function enable() {
             HandlerRepository.set(element, this);
           },

           isEnabled: function isEnabled() {
             return HandlerRepository.get(element) === this;
           },

           destroy: function destroy() {
             HandlerRepository.remove(element);
             this._callback = this._element = null;
           }
         };

         handler.enable();

         return handler;
       }
     }, {
       key: '_dispatchDeviceBackButtonEvent',
       value: function _dispatchDeviceBackButtonEvent() {
         var tree = this._captureTree();

         var element = this._findHandlerLeafElement(tree);

         var handler = HandlerRepository.get(element);
         handler._callback(createEvent(element));

         function createEvent(element) {
           return {
             _element: element,
             callParentHandler: function callParentHandler() {
               var parent = this._element.parentNode;

               while (parent) {
                 handler = HandlerRepository.get(parent);
                 if (handler) {
                   return handler._callback(createEvent(parent));
                 }
                 parent = parent.parentNode;
               }
             }
           };
         }
       }

       /**
        * @return {Object}
        */

     }, {
       key: '_captureTree',
       value: function _captureTree() {
         return createTree(document.body);

         function createTree(element) {
           return {
             element: element,
             children: Array.prototype.concat.apply([], arrayOf(element.children).map(function (childElement) {

               if (childElement.style.display === 'none') {
                 return [];
               }

               if (childElement.children.length === 0 && !HandlerRepository.has(childElement)) {
                 return [];
               }

               var result = createTree(childElement);

               if (result.children.length === 0 && !HandlerRepository.has(result.element)) {
                 return [];
               }

               return [result];
             }))
           };
         }

         function arrayOf(target) {
           var result = [];
           for (var i = 0; i < target.length; i++) {
             result.push(target[i]);
           }
           return result;
         }
       }

       /**
        * @param {Object} tree
        * @return {HTMLElement}
        */

     }, {
       key: '_findHandlerLeafElement',
       value: function _findHandlerLeafElement(tree) {
         return find(tree);

         function find(node) {
           if (node.children.length === 0) {
             return node.element;
           }

           if (node.children.length === 1) {
             return find(node.children[0]);
           }

           return node.children.map(function (childNode) {
             return childNode.element;
           }).reduce(function (left, right) {
             if (!left) {
               return right;
             }

             var leftZ = parseInt(window.getComputedStyle(left, '').zIndex, 10);
             var rightZ = parseInt(window.getComputedStyle(right, '').zIndex, 10);

             if (!isNaN(leftZ) && !isNaN(rightZ)) {
               return leftZ > rightZ ? left : right;
             }

             throw new Error('Capturing backbutton-handler is failure.');
           }, null);
         }
       }
     }]);
     return DeviceBackButtonDispatcher;
   }();

   var deviceBackButtonDispatcher = new DeviceBackButtonDispatcher();

   var autoStyleEnabled = true;

   // Modifiers
   var modifiersMap = {
     'quiet': 'material--flat',
     'light': 'material--flat',
     'outline': 'material--flat',
     'cta': '',
     'large--quiet': 'material--flat large',
     'large--cta': 'large',
     'noborder': '',
     'chevron': '',
     'tappable': ''
   };

   var platforms = {};

   platforms.android = function (element) {

     if (!/ons-fab|ons-speed-dial|ons-progress/.test(element.tagName.toLowerCase()) && !/material/.test(element.getAttribute('modifier'))) {

       var oldModifier = element.getAttribute('modifier') || '';

       var newModifier = oldModifier.trim().split(/\s+/).map(function (e) {
         return modifiersMap.hasOwnProperty(e) ? modifiersMap[e] : e;
       });
       newModifier.unshift('material');

       element.setAttribute('modifier', newModifier.join(' ').trim());
     }

     // Effects
     if (/ons-button|ons-list-item|ons-fab|ons-speed-dial|ons-tab$/.test(element.tagName.toLowerCase()) && !element.hasAttribute('ripple') && !util.findChild(element, 'ons-ripple')) {

       if (element.tagName.toLowerCase() === 'ons-list-item') {
         if (element.hasAttribute('tappable')) {
           element.setAttribute('ripple', '');
           element.removeAttribute('tappable');
         }
       } else {
         element.setAttribute('ripple', '');
       }
     }
   };

   platforms.ios = function (element) {

     // Modifiers
     if (/material/.test(element.getAttribute('modifier'))) {
       util.removeModifier(element, 'material');

       if (util.removeModifier(element, 'material--flat')) {
         util.addModifier(element, util.removeModifier(element, 'large') ? 'large--quiet' : 'quiet');
       }

       if (!element.getAttribute('modifier')) {
         element.removeAttribute('modifier');
       }
     }

     // Effects
     if (element.hasAttribute('ripple')) {
       if (element.tagName.toLowerCase() === 'ons-list-item') {
         element.setAttribute('tappable', '');
       }

       element.removeAttribute('ripple');
     }
   };

   var unlocked = {
     android: true
   };

   var prepareAutoStyle = function prepareAutoStyle(element, force) {
     if (autoStyleEnabled && !element.hasAttribute('disable-auto-styling')) {
       var mobileOS = platform.getMobileOS();
       if (platforms.hasOwnProperty(mobileOS) && (unlocked.hasOwnProperty(mobileOS) || force)) {
         platforms[mobileOS](element);
       }
     }
   };

   var autoStyle = {
     isEnabled: function isEnabled() {
       return autoStyleEnabled;
     },
     enable: function enable() {
       return autoStyleEnabled = true;
     },
     disable: function disable() {
       return autoStyleEnabled = false;
     },
     prepare: prepareAutoStyle
   };

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */

   var generateId = function () {
     var i = 0;
     return function () {
       return i++;
     };
   }();

   /**
    * Door locking system.
    *
    * @param {Object} [options]
    * @param {Function} [options.log]
    */

   var DoorLock = function () {
     function DoorLock() {
       var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
       babelHelpers.classCallCheck(this, DoorLock);

       this._lockList = [];
       this._waitList = [];
       this._log = options.log || function () {};
     }

     /**
      * Register a lock.
      *
      * @return {Function} Callback for unlocking.
      */


     babelHelpers.createClass(DoorLock, [{
       key: 'lock',
       value: function lock() {
         var _this = this;

         var unlock = function unlock() {
           _this._unlock(unlock);
         };
         unlock.id = generateId();
         this._lockList.push(unlock);
         this._log('lock: ' + unlock.id);

         return unlock;
       }
     }, {
       key: '_unlock',
       value: function _unlock(fn) {
         var index = this._lockList.indexOf(fn);
         if (index === -1) {
           throw new Error('This function is not registered in the lock list.');
         }

         this._lockList.splice(index, 1);
         this._log('unlock: ' + fn.id);

         this._tryToFreeWaitList();
       }
     }, {
       key: '_tryToFreeWaitList',
       value: function _tryToFreeWaitList() {
         while (!this.isLocked() && this._waitList.length > 0) {
           this._waitList.shift()();
         }
       }

       /**
        * Register a callback for waiting unlocked door.
        *
        * @params {Function} callback Callback on unlocking the door completely.
        */

     }, {
       key: 'waitUnlock',
       value: function waitUnlock(callback) {
         if (!(callback instanceof Function)) {
           throw new Error('The callback param must be a function.');
         }

         if (this.isLocked()) {
           this._waitList.push(callback);
         } else {
           callback();
         }
       }

       /**
        * @return {Boolean}
        */

     }, {
       key: 'isLocked',
       value: function isLocked() {
         return this._lockList.length > 0;
       }
     }]);
     return DoorLock;
   }();

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */
   var readyMap = new WeakMap();
   var queueMap = new WeakMap();

   function isContentReady(element) {
     if (element.childNodes.length > 0) {
       setContentReady(element);
     }
     return readyMap.has(element);
   }

   function setContentReady(element) {
     readyMap.set(element, true);
   }

   function addCallback(element, fn) {
     if (!queueMap.has(element)) {
       queueMap.set(element, []);
     }
     queueMap.get(element).push(fn);
   }

   function consumeQueue(element) {
     var callbacks = queueMap.get(element, []) || [];
     queueMap.delete(element);
     callbacks.forEach(function (callback) {
       return callback();
     });
   }

   function contentReady(element, fn) {
     addCallback(element, fn);

     if (isContentReady(element)) {
       consumeQueue(element);
       return;
     }

     var observer = new MutationObserver(function (changes) {
       setContentReady(element);
       consumeQueue(element);
     });
     observer.observe(element, { childList: true, characterData: true });

     // failback for elements has empty content.
     setImmediate(function () {
       setContentReady(element);
       consumeQueue(element);
     });
   }

   // Default implementation for global PageLoader.
   function loadPage(_ref, done) {
     var page = _ref.page;
     var parent = _ref.parent;
     var _ref$params = _ref.params;
     var params = _ref$params === undefined ? {} : _ref$params;
     var replace = _ref.replace;

     internal.getPageHTMLAsync(page).then(function (html) {
       if (replace) {
         util.propagateAction(parent, '_destroy');
         parent.innerHTML = '';
       }

       var element = util.createElement(html.trim());
       parent.appendChild(element);

       done({
         element: element,
         unload: function unload() {
           return element.remove();
         }
       });
     });
   }

   var PageLoader = function () {
     /**
      * @param {Function} [fn] Returns an object that has "element" property and "unload" function.
      */

     function PageLoader(fn) {
       babelHelpers.classCallCheck(this, PageLoader);

       this._loader = fn instanceof Function ? fn : loadPage;
     }

     /**
      * Set internal loader implementation.
      */


     babelHelpers.createClass(PageLoader, [{
       key: 'load',


       /**
        * @param {any} options.page
        * @param {Element} options.parent A location to load page.
        * @param {Object} [options.params] Extra parameters for ons-page.
        * @param {Boolean} [options.replace] Remove the previous content.
        * @param {Function} done Take an object that has "element" property and "unload" function.
        */
       value: function load(_ref2, done) {
         var page = _ref2.page;
         var parent = _ref2.parent;
         var _ref2$params = _ref2.params;
         var params = _ref2$params === undefined ? {} : _ref2$params;
         var replace = _ref2.replace;

         this._loader({ page: page, parent: parent, params: params, replace: replace }, function (result) {
           if (!(result.element instanceof Element)) {
             throw Error('target.element must be an instance of Element.');
           }

           if (!(result.unload instanceof Function)) {
             throw Error('target.unload must be an instance of Function.');
           }

           done(result);
         }, params);
       }
     }, {
       key: 'internalLoader',
       set: function set(fn) {
         if (!(fn instanceof Function)) {
           throw Error('First parameter must be an instance of Function');
         }
         this._loader = fn;
       },
       get: function get() {
         return this._loader;
       }
     }]);
     return PageLoader;
   }();

   var defaultPageLoader = new PageLoader();

   var instantPageLoader = new PageLoader(function (_ref3, done) {
     var page = _ref3.page;
     var parent = _ref3.parent;
     var _ref3$params = _ref3.params;
     var params = _ref3$params === undefined ? {} : _ref3$params;
     var replace = _ref3.replace;

     if (replace) {
       util.propagateAction(parent, '_destroy');
       parent.innerHTML = '';
     }

     var element = util.createElement(page.trim());
     parent.appendChild(element);

     done({
       element: element,
       unload: function unload() {
         return element.remove();
       }
     });
   });

   /**
    * @object ons
    * @category util
    * @description
    *   [ja]Onsen UI[/ja]
    *   [en]A global object that's used in Onsen UI. [/en]
    */
   var ons = {};

   ons._util = util;
   ons._deviceBackButtonDispatcher = deviceBackButtonDispatcher;
   ons._internal = internal;
   ons.GestureDetector = GestureDetector;
   ons.platform = platform;
   ons.softwareKeyboard = softwareKeyboard;
   ons.pageAttributeExpression = pageAttributeExpression;
   ons.orientation = orientation;
   ons.notification = notification;
   ons._animationOptionsParser = parse;
   ons._autoStyle = autoStyle;
   ons._DoorLock = DoorLock;
   ons._contentReady = contentReady;
   ons.defaultPageLoader = defaultPageLoader;
   ons.PageLoader = PageLoader;

   ons._readyLock = new DoorLock();

   ons.platform.select((window.location.search.match(/platform=([\w-]+)/) || [])[1]);

   waitDeviceReady();

   /**
    * @method isReady
    * @signature isReady()
    * @return {Boolean}
    *   [en]Will be true if Onsen UI is initialized.[/en]
    *   [ja][/ja]
    * @description
    *   [en]Returns true if Onsen UI is initialized.[/en]
    *   [ja]Onsen UI[/ja]
    */
   ons.isReady = function () {
     return !ons._readyLock.isLocked();
   };

   /**
    * @method isWebView
    * @signature isWebView()
    * @return {Boolean}
    *   [en]Will be true if the app is running in Cordova.[/en]
    *   [ja]Cordovatrue[/ja]
    * @description
    *   [en]Returns true if running inside Cordova.[/en]
    *   [ja]Cordova[/ja]
    */
   ons.isWebView = ons.platform.isWebView;

   /**
    * @method ready
    * @signature ready(callback)
    * @description
    *   [ja]Onsen UI[/ja]
    *   [en]Method used to wait for app initialization. The callback will not be executed until Onsen UI has been completely initialized.[/en]
    * @param {Function} callback
    *   [en]Function that executes after Onsen UI has been initialized.[/en]
    *   [ja]Onsen UI[/ja]
    */
   ons.ready = function (callback) {
     if (ons.isReady()) {
       callback();
     } else {
       ons._readyLock.waitUnlock(callback);
     }
   };

   /**
    * @method setDefaultDeviceBackButtonListener
    * @signature setDefaultDeviceBackButtonListener(listener)
    * @param {Function} listener
    *   [en]Function that executes when device back button is pressed.[/en]
    *   [ja][/ja]
    * @description
    *   [en]Set default handler for device back button.[/en]
    *   [ja][/ja]
    */
   ons.setDefaultDeviceBackButtonListener = function (listener) {
     ons._defaultDeviceBackButtonHandler.setListener(listener);
   };

   /**
    * @method disableDeviceBackButtonHandler
    * @signature disableDeviceBackButtonHandler()
    * @description
    * [en]Disable device back button event handler.[/en]
    * [ja][/ja]
    */
   ons.disableDeviceBackButtonHandler = function () {
     ons._deviceBackButtonDispatcher.disable();
   };

   /**
    * @method enableDeviceBackButtonHandler
    * @signature enableDeviceBackButtonHandler()
    * @description
    * [en]Enable device back button event handler.[/en]
    * [ja][/ja]
    */
   ons.enableDeviceBackButtonHandler = function () {
     ons._deviceBackButtonDispatcher.enable();
   };

   /**
    * @method enableAutoStatusBarFill
    * @signature enableAutoStatusBarFill()
    * @description
    *   [en]Enable status bar fill feature on iOS7 and above.[/en]
    *   [ja]iOS7[/ja]
    */
   ons.enableAutoStatusBarFill = function () {
     if (ons.isReady()) {
       throw new Error('This method must be called before ons.isReady() is true.');
     }
     ons._internal.config.autoStatusBarFill = true;
   };

   /**
    * @method disableAutoStatusBarFill
    * @signature disableAutoStatusBarFill()
    * @description
    *   [en]Disable status bar fill feature on iOS7 and above.[/en]
    *   [ja]iOS7[/ja]
    */
   ons.disableAutoStatusBarFill = function () {
     if (ons.isReady()) {
       throw new Error('This method must be called before ons.isReady() is true.');
     }
     ons._internal.config.autoStatusBarFill = false;
   };

   /**
    * @method disableAnimations
    * @signature disableAnimations()
    * @description
    *   [en]Disable all animations. Could be handy for testing and older devices.[/en]
    *   [ja][/ja]
    */
   ons.disableAnimations = function () {
     ons._internal.config.animationsDisabled = true;
   };

   /**
    * @method enableAnimations
    * @signature enableAnimations()
    * @description
    *   [en]Enable animations (default).[/en]
    *   [ja][/ja]
    */
   ons.enableAnimations = function () {
     ons._internal.config.animationsDisabled = false;
   };

   /**
    * @method disableAutoStyling
    * @signature disableAutoStyling()
    * @description
    *   [en]Disable automatic styling.[/en]
    *   [ja][/ja]
    */
   ons.disableAutoStyling = ons._autoStyle.disable;

   /**
    * @method enableAutoStyling
    * @signature enableAutoStyling()
    * @description
    *   [en]Enable automatic styling based on OS (default).[/en]
    *   [ja][/ja]
    */
   ons.enableAutoStyling = ons._autoStyle.enable;

   /**
    * @method forcePlatformStyling
    * @signature forcePlatformStyling(platform)
    * @description
    *   [en]Refresh styling for the given platform.[/en]
    *   [ja][/ja]
    * @param {string} platform New platform to style the elements.
    */
   ons.forcePlatformStyling = function (newPlatform) {
     ons.enableAutoStyling();
     ons.platform.select(newPlatform || 'ios');

     ons._util.arrayFrom(document.querySelectorAll('*')).forEach(function (element) {
       if (element.tagName.toLowerCase() === 'ons-if') {
         element._platformUpdate();
       } else if (element.tagName.match(/^ons-/i)) {
         ons._autoStyle.prepare(element, true);
         if (element.tagName.toLowerCase() === 'ons-tabbar') {
           element._updatePosition();
         }
       }
     });
   };

   /**
    * @param {String} page
    * @param {Object} [options]
    * @param {Function} [options.link]
    * @return {Promise}
    */
   ons._createPopoverOriginal = function (page) {
     var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];


     if (!page) {
       throw new Error('Page url must be defined.');
     }

     return ons._internal.getPageHTMLAsync(page).then(function (html) {
       html = html.match(/<ons-popover/gi) ? '<div>' + html + '</div>' : '<ons-popover>' + html + '</ons-popover>';
       var div = ons._util.createElement('<div>' + html + '</div>');

       var popover = div.querySelector('ons-popover');
       document.body.appendChild(popover);

       if (options.link instanceof Function) {
         options.link(popover);
       }

       return popover;
     });
   };

   /**
    * @method createPopover
    * @signature createPopover(page, [options])
    * @param {String} page
    *   [en]Page name. Can be either an HTML file or an <ons-template> containing a <ons-dialog> component.[/en]
    *   [ja]pageURLons-templateid[/ja]
    * @param {Object} [options]
    *   [en]Parameter object.[/en]
    *   [ja][/ja]
    * @param {Object} [options.parentScope]
    *   [en]Parent scope of the dialog. Used to bind models and access scope methods from the dialog.[/en]
    *   [ja]AngularJS[/ja]
    * @return {Promise}
    *   [en]Promise object that resolves to the popover component object.[/en]
    *   [ja]Promise[/ja]
    * @description
    *   [en]Create a popover instance from a template.[/en]
    *   [ja][/ja]
    */
   ons.createPopover = ons._createPopoverOriginal;

   /**
    * @param {String} page
    * @param {Object} [options]
    * @param {Function} [options.link]
    * @return {Promise}
    */
   ons._createDialogOriginal = function (page) {
     var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];


     if (!page) {
       throw new Error('Page url must be defined.');
     }

     return ons._internal.getPageHTMLAsync(page).then(function (html) {
       html = html.match(/<ons-dialog/gi) ? '<div>' + html + '</div>' : '<ons-dialog>' + html + '</ons-dialog>';
       var div = ons._util.createElement('<div>' + html + '</div>');

       var dialog = div.querySelector('ons-dialog');
       document.body.appendChild(dialog);

       if (options.link instanceof Function) {
         options.link(dialog);
       }

       return dialog;
     });
   };

   /**
    * @method createDialog
    * @signature createDialog(page, [options])
    * @param {String} page
    *   [en]Page name. Can be either an HTML file or an <ons-template> containing a <ons-dialog> component.[/en]
    *   [ja]pageURLons-templateid[/ja]
    * @param {Object} [options]
    *   [en]Parameter object.[/en]
    *   [ja][/ja]
    * @return {Promise}
    *   [en]Promise object that resolves to the dialog component object.[/en]
    *   [ja]Promise[/ja]
    * @description
    *   [en]Create a dialog instance from a template.[/en]
    *   [ja][/ja]
    */
   ons.createDialog = ons._createDialogOriginal;

   /**
    * @param {String} page
    * @param {Object} [options]
    * @param {Function} [options.link]
    * @return {Promise}
    */
   ons._createAlertDialogOriginal = function (page) {
     var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];


     if (!page) {
       throw new Error('Page url must be defined.');
     }

     return ons._internal.getPageHTMLAsync(page).then(function (html) {
       html = html.match(/<ons-alert-dialog/gi) ? '<div>' + html + '</div>' : '<ons-alert-dialog>' + html + '</ons-alert-dialog>';
       var div = ons._util.createElement('<div>' + html + '</div>');

       var alertDialog = div.querySelector('ons-alert-dialog');
       document.body.appendChild(alertDialog);

       if (options.link instanceof Function) {
         options.link(alertDialog);
       }

       return alertDialog;
     });
   };

   /**
    * @method createAlertDialog
    * @signature createAlertDialog(page, [options])
    * @param {String} page
    *   [en]Page name. Can be either an HTML file or an <ons-template> containing a <ons-alert-dialog> component.[/en]
    *   [ja]pageURLons-templateid[/ja]
    * @param {Object} [options]
    *   [en]Parameter object.[/en]
    *   [ja][/ja]
    * @return {Promise}
    *   [en]Promise object that resolves to the alert dialog component object.[/en]
    *   [ja]Promise[/ja]
    * @description
    *   [en]Create a alert dialog instance from a template.[/en]
    *   [ja][/ja]
    */
   ons.createAlertDialog = ons._createAlertDialogOriginal;

   /**
    * @param {String} page
    * @param {Function} link
    */
   ons._resolveLoadingPlaceholderOriginal = function (page, link) {
     var elements = ons._util.arrayFrom(window.document.querySelectorAll('[ons-loading-placeholder]'));

     if (elements.length > 0) {
       elements.filter(function (element) {
         return !element.getAttribute('page');
       }).forEach(function (element) {
         element.setAttribute('ons-loading-placeholder', page);
         ons._resolveLoadingPlaceholder(element, page, link);
       });
     } else {
       throw new Error('No ons-loading-placeholder exists.');
     }
   };

   /**
    * @method resolveLoadingPlaceholder
    * @signature resolveLoadingPlaceholder(page)
    * @param {String} page
    *   [en]Page name. Can be either an HTML file or an <ons-template> element.[/en]
    *   [ja]pageURLons-templateid[/ja]
    * @description
    *   [en]If no page is defined for the `ons-loading-placeholder` attribute it will wait for this method being called before loading the page.[/en]
    *   [ja]ons-loading-placeholderons.resolveLoadingPlaceholder[/ja]
    */
   ons.resolveLoadingPlaceholder = ons._resolveLoadingPlaceholderOriginal;

   ons._setupLoadingPlaceHolders = function () {
     ons.ready(function () {
       var elements = ons._util.arrayFrom(window.document.querySelectorAll('[ons-loading-placeholder]'));

       elements.forEach(function (element) {
         var page = element.getAttribute('ons-loading-placeholder');
         if (typeof page === 'string') {
           ons._resolveLoadingPlaceholder(element, page);
         }
       });
     });
   };

   ons._resolveLoadingPlaceholder = function (element, page, link) {
     link = link || function (element, done) {
       done();
     };
     ons._internal.getPageHTMLAsync(page).then(function (html) {

       while (element.firstChild) {
         element.removeChild(element.firstChild);
       }

       var contentElement = ons._util.createElement('<div>' + html + '</div>');
       contentElement.style.display = 'none';

       element.appendChild(contentElement);

       link(contentElement, function () {
         contentElement.style.display = '';
       });
     }).catch(function (error) {
       throw new Error('Unabled to resolve placeholder: ' + error);
     });
   };

   function waitDeviceReady() {
     var unlockDeviceReady = ons._readyLock.lock();
     window.addEventListener('DOMContentLoaded', function () {
       if (ons.isWebView()) {
         window.document.addEventListener('deviceready', unlockDeviceReady, false);
       } else {
         unlockDeviceReady();
       }
     }, false);
   }

   window._superSecretOns = ons;

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */

   function getElementClass() {
     if (typeof HTMLElement !== 'function') {
       // case of Safari
       var _BaseElement = function _BaseElement() {};
       _BaseElement.prototype = document.createElement('div');
       return _BaseElement;
     } else {
       return HTMLElement;
     }
   }

   var BaseElement = function (_getElementClass) {
     babelHelpers.inherits(BaseElement, _getElementClass);

     function BaseElement(self) {
       var _this, _ret;

       babelHelpers.classCallCheck(this, BaseElement);

       self = (_this = babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(BaseElement).call(this, self)), _this);
       self.init();
       return _ret = self, babelHelpers.possibleConstructorReturn(_this, _ret);
     }

     babelHelpers.createClass(BaseElement, [{
       key: 'init',
       value: function init() {}
     }]);
     return BaseElement;
   }(getElementClass());

   /**
    * @element ons-template
    * @category util
    * @description
    *   [en]
    *     Define a separate HTML fragment and use as a template.
    *
    *     These templates can be loaded as pages in `<ons-navigator>`, `<ons-tabbar>` and `<ons-splitter>`. They can also be used to generate dialogs.
    *   [/en]
    *   [ja]HTMLHTMLidpageURLons-navigator[/ja]
    * @guide templates
    *   [en]Defining multiple pages in single html[/en]
    *   [ja]1HTML[/ja]
    * @seealso ons-navigator
    *   [en]The `<ons-navigator>` component enables stack based navigation.[/en]
    *   [ja][/ja]
    * @seealso ons-tabbar
    *   [en]The `<ons-tabbar>` component is used to add tab navigation.[/en]
    *   [ja][/ja]
    * @seealso ons-splitter
    *   [en]The `<ons-splitter>` component can be used to create a draggable menu or column based layout.[/en]
    *   [ja][/ja]
    * @example
    * <ons-template id="foobar.html">
    *   <ons-page>
    *     Page content
    *   </ons-page>
    * </ons-template>
    *
    * <ons-navigator page="foobar.html">
    * </ons-navigator>
    */

   var TemplateElement = function (_BaseElement) {
     babelHelpers.inherits(TemplateElement, _BaseElement);

     function TemplateElement() {
       babelHelpers.classCallCheck(this, TemplateElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(TemplateElement).apply(this, arguments));
     }

     babelHelpers.createClass(TemplateElement, [{
       key: 'init',


       /**
        * @property template
        * @type {String}
        * @description
        *  [en]Template content. This property can not be used with AngularJS bindings.[/en]
        *  [ja][/ja]
        */

       value: function init() {
         this.template = this.innerHTML;

         while (this.firstChild) {
           this.removeChild(this.firstChild);
         }
       }
     }, {
       key: 'connectedCallback',
       value: function connectedCallback() {
         var event = new CustomEvent('_templateloaded', { bubbles: true, cancelable: true });
         event.template = this.template;
         event.templateId = this.getAttribute('id');

         this.dispatchEvent(event);
       }
     }]);
     return TemplateElement;
   }(BaseElement);

   customElements.define('ons-template', TemplateElement);

   /**
    * @element ons-if
    * @category conditional
    * @tutorial vanilla/Reference/if
    * @description
    *   [en]
    *     Conditionally display content depending on the platform, device orientation or both.
    *
    *     Sometimes it is useful to conditionally hide or show certain components based on platform. When running on iOS the `<ons-if>` element can be used to hide the `<ons-fab>` element.
    *   [/en]
    *   [ja][/ja]
    * @guide cross-platform-styling [en]Information about cross platform styling[/en][ja]Information about cross platform styling[/ja]
    * @example
    * <ons-page>
    *   <ons-if orientation="landscape">
    *     Landscape view!
    *   </ons-if>
    *   <ons-if platform="android">
    *     This is Android.
    *   </ons-if>
    *   <ons-if platform="ios other">
    *     This is not Android.
    *   </ons-if>
    * </ons-page>
    */

   var IfElement = function (_BaseElement) {
     babelHelpers.inherits(IfElement, _BaseElement);

     function IfElement() {
       babelHelpers.classCallCheck(this, IfElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(IfElement).apply(this, arguments));
     }

     babelHelpers.createClass(IfElement, [{
       key: 'init',


       /**
        * @attribute platform
        * @initonly
        * @type {string}
        * @description
        *  [en]Space-separated platform names. Possible values are `"ios"`, `"android"`, `"windows"` and `"other"`.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute orientation
        * @type {string}
        * @description
        *  [en]Either `"portrait"` or `"landscape"`.[/en]
        *  [ja]portraitlandscape[/ja]
        */

       value: function init() {
         var _this2 = this;

         contentReady(this, function () {
           if (platform._renderPlatform !== null) {
             _this2._platformUpdate();
           } else if (!_this2._isAllowedPlatform()) {
             while (_this2.childNodes[0]) {
               _this2.childNodes[0].remove();
             }
             _this2._platformUpdate();
           }
         });

         this._onOrientationChange();
       }
     }, {
       key: 'connectedCallback',
       value: function connectedCallback() {
         orientation.on('change', this._onOrientationChange.bind(this));
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name) {
         if (name === 'orientation') {
           this._onOrientationChange();
         }
       }
     }, {
       key: 'disconnectedCallback',
       value: function disconnectedCallback() {
         orientation.off('change', this._onOrientationChange);
       }
     }, {
       key: '_platformUpdate',
       value: function _platformUpdate() {
         this.style.display = this._isAllowedPlatform() ? '' : 'none';
       }
     }, {
       key: '_isAllowedPlatform',
       value: function _isAllowedPlatform() {
         return !this.getAttribute('platform') || this.getAttribute('platform').split(/\s+/).indexOf(platform.getMobileOS()) >= 0;
       }
     }, {
       key: '_onOrientationChange',
       value: function _onOrientationChange() {
         if (this.hasAttribute('orientation') && this._isAllowedPlatform()) {
           var conditionalOrientation = this.getAttribute('orientation').toLowerCase();
           var currentOrientation = orientation.isPortrait() ? 'portrait' : 'landscape';

           this.style.display = conditionalOrientation === currentOrientation ? '' : 'none';
         }
       }
     }], [{
       key: 'observedAttributes',
       get: function get() {
         return ['orientation'];
       }
     }]);
     return IfElement;
   }(BaseElement);

   customElements.define('ons-if', IfElement);

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */

   var AlertDialogAnimator = function () {
     function AlertDialogAnimator() {
       var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

       var _ref$timing = _ref.timing;
       var timing = _ref$timing === undefined ? 'linear' : _ref$timing;
       var _ref$delay = _ref.delay;
       var delay = _ref$delay === undefined ? 0 : _ref$delay;
       var _ref$duration = _ref.duration;
       var duration = _ref$duration === undefined ? 0.2 : _ref$duration;
       babelHelpers.classCallCheck(this, AlertDialogAnimator);

       this.timing = timing;
       this.delay = delay;
       this.duration = duration;
     }

     /**
      * @param {HTMLElement} dialog
      * @param {Function} done
      */


     babelHelpers.createClass(AlertDialogAnimator, [{
       key: 'show',
       value: function show(dialog, done) {
         done();
       }

       /**
        * @param {HTMLElement} dialog
        * @param {Function} done
        */

     }, {
       key: 'hide',
       value: function hide(dialog, done) {
         done();
       }
     }]);
     return AlertDialogAnimator;
   }();

   /**
    * Android style animator for alert dialog.
    */
   var AndroidAlertDialogAnimator = function (_AlertDialogAnimator) {
     babelHelpers.inherits(AndroidAlertDialogAnimator, _AlertDialogAnimator);

     function AndroidAlertDialogAnimator() {
       var _ref2 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

       var _ref2$timing = _ref2.timing;
       var timing = _ref2$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref2$timing;
       var _ref2$duration = _ref2.duration;
       var duration = _ref2$duration === undefined ? 0.2 : _ref2$duration;
       var _ref2$delay = _ref2.delay;
       var delay = _ref2$delay === undefined ? 0 : _ref2$delay;
       babelHelpers.classCallCheck(this, AndroidAlertDialogAnimator);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(AndroidAlertDialogAnimator).call(this, { duration: duration, timing: timing, delay: delay }));
     }

     /**
      * @param {Object} dialog
      * @param {Function} callback
      */


     babelHelpers.createClass(AndroidAlertDialogAnimator, [{
       key: 'show',
       value: function show(dialog, callback) {
         callback = callback ? callback : function () {};

         animit.runAll(animit(dialog._mask).queue({
           opacity: 0
         }).wait(this.delay).queue({
           opacity: 1.0
         }, {
           duration: this.duration,
           timing: this.timing
         }), animit(dialog._dialog).saveStyle().queue({
           css: {
             transform: 'translate3d(-50%, -50%, 0) scale3d(0.9, 0.9, 1.0)',
             opacity: 0.0
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3d(-50%, -50%, 0) scale3d(1.0, 1.0, 1.0)',
             opacity: 1.0
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }

       /**
        * @param {Object} dialog
        * @param {Function} callback
        */

     }, {
       key: 'hide',
       value: function hide(dialog, callback) {
         callback = callback ? callback : function () {};

         animit.runAll(animit(dialog._mask).queue({
           opacity: 1.0
         }).wait(this.delay).queue({
           opacity: 0
         }, {
           duration: this.duration,
           timing: this.timing
         }), animit(dialog._dialog).saveStyle().queue({
           css: {
             transform: 'translate3d(-50%, -50%, 0) scale3d(1.0, 1.0, 1.0)',
             opacity: 1.0
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3d(-50%, -50%, 0) scale3d(0.9, 0.9, 1.0)',
             opacity: 0.0
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }
     }]);
     return AndroidAlertDialogAnimator;
   }(AlertDialogAnimator);

   /**
    * iOS style animator for alert dialog.
    */
   var IOSAlertDialogAnimator = function (_AlertDialogAnimator2) {
     babelHelpers.inherits(IOSAlertDialogAnimator, _AlertDialogAnimator2);

     function IOSAlertDialogAnimator() {
       var _ref3 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

       var _ref3$timing = _ref3.timing;
       var timing = _ref3$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref3$timing;
       var _ref3$duration = _ref3.duration;
       var duration = _ref3$duration === undefined ? 0.2 : _ref3$duration;
       var _ref3$delay = _ref3.delay;
       var delay = _ref3$delay === undefined ? 0 : _ref3$delay;
       babelHelpers.classCallCheck(this, IOSAlertDialogAnimator);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(IOSAlertDialogAnimator).call(this, { duration: duration, timing: timing, delay: delay }));
     }

     /*
      * @param {Object} dialog
      * @param {Function} callback
      */


     babelHelpers.createClass(IOSAlertDialogAnimator, [{
       key: 'show',
       value: function show(dialog, callback) {
         callback = callback ? callback : function () {};

         animit.runAll(animit(dialog._mask).queue({
           opacity: 0
         }).wait(this.delay).queue({
           opacity: 1.0
         }, {
           duration: this.duration,
           timing: this.timing
         }), animit(dialog._dialog).saveStyle().queue({
           css: {
             transform: 'translate3d(-50%, -50%, 0) scale3d(1.3, 1.3, 1.0)',
             opacity: 0.0
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3d(-50%, -50%, 0) scale3d(1.0, 1.0, 1.0)',
             opacity: 1.0
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }

       /**
        * @param {Object} dialog
        * @param {Function} callback
        */

     }, {
       key: 'hide',
       value: function hide(dialog, callback) {
         callback = callback ? callback : function () {};

         animit.runAll(animit(dialog._mask).queue({
           opacity: 1.0
         }).wait(this.delay).queue({
           opacity: 0
         }, {
           duration: this.duration,
           timing: this.timing
         }), animit(dialog._dialog).saveStyle().queue({
           css: {
             opacity: 1.0
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             opacity: 0.0
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }
     }]);
     return IOSAlertDialogAnimator;
   }(AlertDialogAnimator);

   var scheme = {
     '.alert-dialog': 'alert-dialog--*',
     '.alert-dialog-container': 'alert-dialog-container--*',
     '.alert-dialog-title': 'alert-dialog-title--*',
     '.alert-dialog-content': 'alert-dialog-content--*',
     '.alert-dialog-footer': 'alert-dialog-footer--*',
     '.alert-dialog-button': 'alert-dialog-button--*',
     '.alert-dialog-footer--one': 'alert-dialog-footer--one--*',
     '.alert-dialog-button--one': 'alert-dialog-button--one--*',
     '.alert-dialog-button--primal': 'alert-dialog-button--primal--*',
     '.alert-dialog-mask': 'alert-dialog-mask--*'
   };

   var _animatorDict = {
     'none': AlertDialogAnimator,
     'default': function _default() {
       return platform.isAndroid() ? AndroidAlertDialogAnimator : IOSAlertDialogAnimator;
     },
     'fade': function fade() {
       return platform.isAndroid() ? AndroidAlertDialogAnimator : IOSAlertDialogAnimator;
     }
   };

   /**
    * @element ons-alert-dialog
    * @category dialog
    * @description
    *   [en]
    *     Alert dialog that is displayed on top of the current screen. Useful for displaying questions, warnings or error messages to the user. The title, content and buttons can be easily customized and it will automatically switch style based on the platform.
    *
    *     To use the element it can either be attached directly to the `<body>` element or dynamically created from a template using the `ons.createAlertDialog(template)` utility function and the `<ons-template>` tag.
    *   [/en]
    *   [ja][/ja]
    * @codepen Qwwxyp
    * @tutorial vanilla/Reference/dialog
    * @modifier material
    *   [en]Material Design style[/en]
    *   [ja][/ja]
    * @guide dialogs
    *   [en]Dialog components[/en]
    *   [ja]Dialog components[/ja]
    * @seealso ons-dialog
    *   [en]ons-dialog component[/en]
    *   [ja]ons-dialog[/ja]
    * @seealso ons-popover
    *   [en]ons-popover component[/en]
    *   [ja]ons-dialog[/ja]
    * @seealso ons.notification
    *   [en]Using ons.notification utility functions.[/en]
    *   [ja]ons.notification[/ja]
    * @example
    * <ons-alert-dialog id="alert-dialog">
    *   <div class="alert-dialog-title">Warning!</div>
    *   <div class="alert-dialog-content">
    *     An error has occurred!
    *   </div>
    *   <div class="alert-dialog-footer">
    *     <button id="alert-dialog-button" class="alert-dialog-button">OK</button>
    *   </div>
    * </ons-alert-dialog>
    * <script>
    *   document.getElementById('alert-dialog').show();
    * </script>
    */

   var AlertDialogElement = function (_BaseElement) {
     babelHelpers.inherits(AlertDialogElement, _BaseElement);

     function AlertDialogElement() {
       babelHelpers.classCallCheck(this, AlertDialogElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(AlertDialogElement).apply(this, arguments));
     }

     babelHelpers.createClass(AlertDialogElement, [{
       key: 'init',


       /**
        * @event preshow
        * @description
        *   [en]Fired just before the alert dialog is displayed.[/en]
        *   [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.alertDialog
        *   [en]Alert dialog object.[/en]
        *   [ja][/ja]
        * @param {Function} event.cancel
        *   [en]Execute to stop the dialog from showing.[/en]
        *   [ja][/ja]
        */

       /**
        * @event postshow
        * @description
        *   [en]Fired just after the alert dialog is displayed.[/en]
        *   [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.alertDialog
        *   [en]Alert dialog object.[/en]
        *   [ja][/ja]
        */

       /**
        * @event prehide
        * @description
        *   [en]Fired just before the alert dialog is hidden.[/en]
        *   [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.alertDialog
        *   [en]Alert dialog object.[/en]
        *   [ja][/ja]
        * @param {Function} event.cancel
        *   [en]Execute to stop the dialog from hiding.[/en]
        *   [ja][/ja]
        */

       /**
        * @event posthide
        * @description
        * [en]Fired just after the alert dialog is hidden.[/en]
        * [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.alertDialog
        *   [en]Alert dialog object.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute modifier
        * @type {String}
        * @description
        *  [en]The appearance of the dialog.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute cancelable
        * @description
        *  [en]If this attribute is set the dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute disabled
        * @description
        *  [en]If this attribute is set the dialog is disabled.[/en]
        *  [ja]disabled[/ja]
        */

       /**
        * @attribute animation
        * @type {String}
        * @default default
        * @description
        *  [en]The animation used when showing and hiding the dialog. Can be either `"none"` or `"default"`.[/en]
        *  [ja]"none""default"[/ja]
        */

       /**
        * @attribute animation-options
        * @type {Expression}
        * @description
        *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
        *  [ja]duration, timing, delay{duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
        */

       /**
        * @attribute mask-color
        * @type {String}
        * @default rgba(0, 0, 0, 0.2)
        * @description
        *  [en]Color of the background mask. Default is "rgba(0, 0, 0, 0.2)".[/en]
        *  [ja]"rgba(0, 0, 0, 0.2)"[/ja]
        */

       value: function init() {
         var _this2 = this;

         contentReady(this, function () {
           return _this2._compile();
         });

         this._visible = false;
         this._doorLock = new DoorLock();
         this._boundCancel = this._cancel.bind(this);

         this._updateAnimatorFactory();
       }

       /**
        * @return {Element}
        */

     }, {
       key: '_updateAnimatorFactory',
       value: function _updateAnimatorFactory() {
         this._animatorFactory = new AnimatorFactory({
           animators: _animatorDict,
           baseClass: AlertDialogAnimator,
           baseClassName: 'AlertDialogAnimator',
           defaultAnimation: this.getAttribute('animation')
         });
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         this.style.display = 'none';

         /**
          * Expected result after compile:
          *
          * <ons-alert-dialog style="none">
          *   <div class="alert-dialog-mask"></div>
          *   <div class="alert-dialog">
          *     <div class="alert-dialog-container">...</div>
          *   </div>
          * </ons-alert-dialog>
          */

         var content = document.createDocumentFragment();

         if (!this._mask && !this._dialog) {
           while (this.firstChild) {
             content.appendChild(this.firstChild);
           }
         }

         if (!this._mask) {
           var mask = document.createElement('div');
           mask.classList.add('alert-dialog-mask');
           this.insertBefore(mask, this.children[0]);
         }

         if (!this._dialog) {
           var dialog = document.createElement('div');
           dialog.classList.add('alert-dialog');
           this.insertBefore(dialog, null);
         }

         if (!util.findChild(this._dialog, '.alert-dialog-container')) {
           var container = document.createElement('div');
           container.classList.add('alert-dialog-container');
           this._dialog.appendChild(container);
         }

         this._dialog.children[0].appendChild(content);

         this._dialog.style.zIndex = 20001;
         this._mask.style.zIndex = 20000;

         if (this.getAttribute('mask-color')) {
           this._mask.style.backgroundColor = this.getAttribute('mask-color');
         }

         ModifierUtil.initModifier(this, scheme);
       }

       /**
        * @property disabled
        * @type {Boolean}
        * @description
        *   [en]Whether the element is disabled or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'show',


       /**
        * @method show
        * @signature show([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]Animation name. Available animations are `"fade"` and `"none"`.[/en]
        *   [ja]"fade", "none"[/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g.  `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
        *   [ja]duration, delay, timinge.g. <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code> [/ja]
        * @param {Function} [options.callback]
        *   [en]Function to execute after the dialog has been revealed.[/en]
        *   [ja][/ja]
        * @description
        *   [en]Show the alert dialog.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]A `Promise` object that resolves to the displayed element.[/en]
        *   [ja][/ja]
        */
       value: function show() {
         var _this3 = this;

         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         var _cancel2 = false;
         var callback = options.callback || function () {};

         options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

         util.triggerElementEvent(this, 'preshow', {
           alertDialog: this,
           cancel: function cancel() {
             _cancel2 = true;
           }
         });

         if (!_cancel2) {
           var _ret = function () {
             var tryShow = function tryShow() {
               var unlock = _this3._doorLock.lock();
               var animator = _this3._animatorFactory.newAnimator(options);

               _this3.style.display = 'block';
               _this3._mask.style.opacity = '1';

               return new Promise(function (resolve) {
                 contentReady(_this3, function () {
                   animator.show(_this3, function () {
                     _this3._visible = true;
                     unlock();

                     util.triggerElementEvent(_this3, 'postshow', { alertDialog: _this3 });

                     callback();
                     resolve(_this3);
                   });
                 });
               });
             };

             return {
               v: new Promise(function (resolve) {
                 _this3._doorLock.waitUnlock(function () {
                   return resolve(tryShow());
                 });
               })
             };
           }();

           if ((typeof _ret === 'undefined' ? 'undefined' : babelHelpers.typeof(_ret)) === "object") return _ret.v;
         } else {
           return Promise.reject('Canceled in preshow event.');
         }
       }

       /**
        * @method hide
        * @signature hide([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]Animation name. Available animations are `"fade"` and `"none"`.[/en]
        *   [ja]"fade", "none"[/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g.  <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code>[/en]
        *   [ja]duration, delay, timinge.g. <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code> [/ja]
        * @param {Function} [options.callback]
        *   [en]Function to execute after the dialog has been hidden.[/en]
        *   [ja][/ja]
        * @description
        *   [en]Hide the alert dialog.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Resolves to the hidden element[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'hide',
       value: function hide() {
         var _this4 = this;

         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         var _cancel3 = false;
         var callback = options.callback || function () {};

         options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

         util.triggerElementEvent(this, 'prehide', {
           alertDialog: this,
           cancel: function cancel() {
             _cancel3 = true;
           }
         });

         if (!_cancel3) {
           var _ret2 = function () {
             var tryHide = function tryHide() {
               var unlock = _this4._doorLock.lock();
               var animator = _this4._animatorFactory.newAnimator(options);

               return new Promise(function (resolve) {
                 contentReady(_this4, function () {
                   animator.hide(_this4, function () {
                     _this4.style.display = 'none';
                     _this4._visible = false;
                     unlock();

                     util.triggerElementEvent(_this4, 'posthide', { alertDialog: _this4 });

                     callback();
                     resolve(_this4);
                   });
                 });
               });
             };

             return {
               v: new Promise(function (resolve) {
                 _this4._doorLock.waitUnlock(function () {
                   return resolve(tryHide());
                 });
               })
             };
           }();

           if ((typeof _ret2 === 'undefined' ? 'undefined' : babelHelpers.typeof(_ret2)) === "object") return _ret2.v;
         } else {
           return Promise.reject('Canceled in prehide event.');
         }
       }

       /**
        * @property visible
        * @readonly
        * @type {Boolean}
        * @description
        *   [en]Whether the dialog is visible or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: '_cancel',
       value: function _cancel() {
         var _this5 = this;

         if (this.cancelable && !this._running) {
           this._running = true;
           this.hide({
             callback: function callback() {
               _this5._running = false;
               util.triggerElementEvent(_this5, 'dialog-cancel');
             }
           });
         }
       }
     }, {
       key: 'connectedCallback',
       value: function connectedCallback() {
         var _this6 = this;

         this.onDeviceBackButton = function (e) {
           return _this6.cancelable ? _this6._cancel() : e.callParentHandler();
         };

         contentReady(this, function () {
           _this6._mask.addEventListener('click', _this6._boundCancel, false);
         });
       }
     }, {
       key: 'disconnectedCallback',
       value: function disconnectedCallback() {
         this._backButtonHandler.destroy();
         this._backButtonHandler = null;

         this._mask.removeEventListener('click', this._boundCancel.bind(this), false);
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme);
         } else if (name === 'animation') {
           this._updateAnimatorFactory();
         }
       }

       /**
        * @param {String} name
        * @param {DialogAnimator} Animator
        */

     }, {
       key: '_mask',
       get: function get() {
         return util.findChild(this, '.alert-dialog-mask');
       }

       /**
        * @return {Element}
        */

     }, {
       key: '_dialog',
       get: function get() {
         return util.findChild(this, '.alert-dialog');
       }

       /**
        * @return {Element}
        */

     }, {
       key: '_titleElement',
       get: function get() {
         return util.findChild(this._dialog.children[0], '.alert-dialog-title');
       }

       /**
        * @return {Element}
        */

     }, {
       key: '_contentElement',
       get: function get() {
         return util.findChild(this._dialog.children[0], '.alert-dialog-content');
       }
     }, {
       key: 'disabled',
       set: function set(value) {
         return util.toggleAttribute(this, 'disabled', value);
       },
       get: function get() {
         return this.hasAttribute('disabled');
       }

       /**
        * @property cancelable
        * @type {Boolean}
        * @description
        *   [en]Whether the dialog is cancelable or not. A cancelable dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'cancelable',
       set: function set(value) {
         return util.toggleAttribute(this, 'cancelable', value);
       },
       get: function get() {
         return this.hasAttribute('cancelable');
       }
     }, {
       key: 'visible',
       get: function get() {
         return this._visible;
       }

       /**
        * @property onDeviceBackButton
        * @type {Object}
        * @description
        *   [en]Back-button handler.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'onDeviceBackButton',
       get: function get() {
         return this._backButtonHandler;
       },
       set: function set(callback) {
         if (this._backButtonHandler) {
           this._backButtonHandler.destroy();
         }

         this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
       }
     }], [{
       key: 'registerAnimator',
       value: function registerAnimator(name, Animator) {
         if (!(Animator.prototype instanceof AlertDialogAnimator)) {
           throw new Error('"Animator" param must inherit OnsAlertDialogElement.AlertDialogAnimator');
         }
         _animatorDict[name] = Animator;
       }
     }, {
       key: 'observedAttributes',
       get: function get() {
         return ['modifier', 'animation'];
       }
     }, {
       key: 'AlertDialogAnimator',
       get: function get() {
         return AlertDialogAnimator;
       }
     }]);
     return AlertDialogElement;
   }(BaseElement);

   customElements.define('ons-alert-dialog', AlertDialogElement);

   var scheme$1 = {
     '': 'back-button--*',
     '.back-button__icon': 'back-button--*__icon',
     '.back-button__label': 'back-button--*__label'
   };

   /**
    * @element ons-back-button
    * @category navigation
    * @description
    *   [en]
    *     Back button component for `<ons-toolbar>`. Put it in the left part of the `<ons-toolbar>`.
    *
    *     It will find the parent `<ons-navigator>` element and pop a page when clicked. This behavior can be overriden by specifying the `onClick` property.
    *   [/en]
    *   [ja][/ja]
    * @codepen aHmGL
    * @tutorial vanilla/Reference/navigator
    * @modifier material
    *   [en]Material Design style[/en]
    *   [ja][/ja]
    * @seealso ons-toolbar
    *   [en]ons-toolbar component[/en]
    *   [ja]ons-toolbar[/ja]
    * @seealso ons-navigator
    *   [en]ons-navigator component[/en]
    *   [ja]ons-navigator[/ja]
    * @example
    * <ons-toolbar>
    *   <div class="left">
    *     <ons-back-button>Back</ons-back-button>
    *   </div>
    *   <div class="center">
    *     Title
    *   <div>
    * </ons-toolbar>
    */

   var BackButtonElement = function (_BaseElement) {
     babelHelpers.inherits(BackButtonElement, _BaseElement);

     function BackButtonElement() {
       babelHelpers.classCallCheck(this, BackButtonElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(BackButtonElement).apply(this, arguments));
     }

     babelHelpers.createClass(BackButtonElement, [{
       key: 'init',

       /**
        * @attribute modifier
        * @type {String}
        * @description
        *  [en]The appearance of the back button.[/en]
        *  [ja][/ja]
        */

       value: function init() {
         var _this2 = this;

         contentReady(this, function () {
           _this2._compile();
         });

         this._options = {};
         this._boundOnClick = this._onClick.bind(this);
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         this.classList.add('back-button');

         if (!util.findChild(this, '.back-button__label')) {
           var label = util.create('span.back-button__label');

           while (this.childNodes[0]) {
             label.appendChild(this.childNodes[0]);
           }
           this.appendChild(label);
         }

         if (!util.findChild(this, '.back-button__icon')) {
           var icon = util.create('span.back-button__icon');

           this.insertBefore(icon, this.children[0]);
         }

         ModifierUtil.initModifier(this, scheme$1);
       }

       /**
        * @property options
        * @type {Object}
        * @description
        *   [en]Options object.[/en]
        *   [ja][/ja]
        */

       /**
        * @property options.animation
        * @type {String}
        * @description
        *   [en]Animation name. Available animations are "slide", "lift", "fade" and "none".
        *     These are platform based animations. For fixed animations, add "-ios" or "-md"
        *     suffix to the animation name. E.g. "lift-ios", "lift-md". Defaults values are "slide-ios" and "fade-md".
        *   [/en]
        *   [ja][/ja]
        */

       /**
        * @property options.animationOptions
        * @type {String}
        * @description
        *   [en]Specify the animation's duration, delay and timing. E.g.  `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`[/en]
        *   [ja]duration, delay, timinge.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
        */

       /**
        * @property options.callback
        * @type {String}
        * @description
        *   [en]Function that is called when the transition has ended.[/en]
        *   [ja][/ja]
        */

       /**
        * @property options.refresh
        * @description
        *   [en]The previous page will be refreshed (destroyed and created again) before popPage action.[/en]
        *   [ja]popPagetrue[/ja]
        */

     }, {
       key: '_onClick',


       /**
        * @property onClick
        * @type {Function}
        * @description
        *   [en]Used to override the default back button behavior.[/en]
        *   [ja][/ja]
        */
       value: function _onClick() {
         if (this.onClick) {
           this.onClick.apply(this);
         } else {
           var navigator = util.findParent(this, 'ons-navigator');
           if (navigator) {
             navigator.popPage(this.options);
           }
         }
       }
     }, {
       key: 'connectedCallback',
       value: function connectedCallback() {
         this.addEventListener('click', this._boundOnClick, false);
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$1);
         }
       }
     }, {
       key: 'disconnectedCallback',
       value: function disconnectedCallback() {
         this.removeEventListener('click', this._boundOnClick, false);
       }
     }, {
       key: 'show',
       value: function show() {
         this.style.display = 'inline-block';
       }
     }, {
       key: 'hide',
       value: function hide() {
         this.style.display = 'none';
       }
     }, {
       key: 'options',
       get: function get() {
         return this._options;
       },
       set: function set(object) {
         this._options = object;
       }
     }], [{
       key: 'observedAttributes',
       get: function get() {
         return ['modifier'];
       }
     }]);
     return BackButtonElement;
   }(BaseElement);

   customElements.define('ons-back-button', BackButtonElement);

   var scheme$2 = { '': 'bottom-bar--*' };

   /**
    * @element ons-bottom-toolbar
    * @category page
    * @description
    *   [en]Toolbar component that is positioned at the bottom of the page.[/en]
    *   [ja][/ja]
    * @modifier transparent
    *   [en]Make the toolbar transparent.[/en]
    *   [ja][/ja]
    * @seealso ons-toolbar [en]ons-toolbar component[/en][ja]ons-toolbar[/ja]
    * @example
    * <ons-bottom-toolbar>
    *   Content
    * </ons-bottom-toolbar>
    */

   var BottomToolbarElement = function (_BaseElement) {
     babelHelpers.inherits(BottomToolbarElement, _BaseElement);

     function BottomToolbarElement() {
       babelHelpers.classCallCheck(this, BottomToolbarElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(BottomToolbarElement).apply(this, arguments));
     }

     babelHelpers.createClass(BottomToolbarElement, [{
       key: 'init',

       /**
        * @attribute modifier
        * @type {String}
        * @description
        *   [en]The appearance of the toolbar.[/en]
        *   [ja][/ja]
        */

       value: function init() {
         this.classList.add('bottom-bar');
         ModifierUtil.initModifier(this, scheme$2);
       }
     }, {
       key: 'connectedCallback',
       value: function connectedCallback() {
         if (util.match(this.parentNode, 'ons-page')) {
           this.parentNode.classList.add('page-with-bottom-toolbar');
         }
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           ModifierUtil.onModifierChanged(last, current, this, scheme$2);
         }
       }
     }], [{
       key: 'observedAttributes',
       get: function get() {
         return ['modifier'];
       }
     }]);
     return BottomToolbarElement;
   }(BaseElement);

   customElements.define('ons-bottom-toolbar', BottomToolbarElement);

   var scheme$3 = { '': 'button--*' };

   /**
    * @element ons-button
    * @category form
    * @modifier outline
    *   [en]Button with outline and transparent background[/en]
    *   [ja][/ja]
    * @modifier light
    *   [en]Button that doesn't stand out.[/en]
    *   [ja][/ja]
    * @modifier quiet
    *   [en]Button with no outline and or background..[/en]
    *   [ja][/ja]
    * @modifier cta
    *   [en]Button that really stands out.[/en]
    *   [ja][/ja]
    * @modifier large
    *   [en]Large button that covers the width of the screen.[/en]
    *   [ja][/ja]
    * @modifier large--quiet
    *   [en]Large quiet button.[/en]
    *   [ja]quiet[/ja]
    * @modifier large--cta
    *   [en]Large call to action button.[/en]
    *   [ja]cta[/ja]
    * @modifier material
    *   [en]Material Design button[/en]
    *   [ja][/ja]
    * @modifier material--flat
    *   [en]Material Design flat button[/en]
    *   [ja][/ja]
    * @description
    *   [en]
    *     Button component. If you want to place a button in a toolbar, use `<ons-toolbar-button>` or `<ons-back-button>` instead.
    *
    *     Will automatically display as a Material Design button with a ripple effect on Android.
    *   [/en]
    *   [ja]ons-toolbar-buttonons-back-button[/ja]
    * @codepen hLayx
    * @tutorial vanilla/Reference/button
    * @guide Button [en]Guide for `<ons-button>`[/en][ja]<ons-button>[/ja]
    * @guide using-modifier [en]More details about the `modifier` attribute[/en][ja]modifier[/ja]
    * @guide cross-platform-styling [en]Information about cross platform styling[/en][ja]Information about cross platform styling[/ja]
    * @example
    * <ons-button modifier="large--cta">
    *   Tap Me
    * </ons-button>
    */

   var ButtonElement = function (_BaseElement) {
     babelHelpers.inherits(ButtonElement, _BaseElement);

     function ButtonElement() {
       babelHelpers.classCallCheck(this, ButtonElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ButtonElement).apply(this, arguments));
     }

     babelHelpers.createClass(ButtonElement, [{
       key: 'init',


       /**
        * @attribute modifier
        * @type {String}
        * @description
        *  [en]The appearance of the button.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute ripple
        * @description
        *  [en]If this attribute is defined, the button will have a ripple effect.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute disabled
        * @description
        *   [en]Specify if button should be disabled.[/en]
        *   [ja][/ja]
        */

       value: function init() {
         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         switch (name) {
           case 'modifier':
             ModifierUtil.onModifierChanged(last, current, this, scheme$3);
             break;
           case 'ripple':
             this._updateRipple();
         }
       }

       /**
        * @property disabled
        * @type {Boolean}
        * @description
        *   [en]Whether the button is disabled or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         this.classList.add('button');

         this._updateRipple();

         ModifierUtil.initModifier(this, scheme$3);

         this.setAttribute('_compiled', '');
       }
     }, {
       key: '_updateRipple',
       value: function _updateRipple() {
         util.updateRipple(this);
       }
     }, {
       key: 'disabled',
       set: function set(value) {
         return util.toggleAttribute(this, 'disabled', value);
       },
       get: function get() {
         return this.hasAttribute('disabled');
       }
     }], [{
       key: 'observedAttributes',
       get: function get() {
         return ['modifier', 'ripple'];
       }
     }]);
     return ButtonElement;
   }(BaseElement);

   customElements.define('ons-button', ButtonElement);

   var scheme$4 = { '': 'carousel-item--*' };

   /**
    * @element ons-carousel-item
    * @category carousel
    * @description
    *   [en]
    *     Carousel item component. Used as a child of the `<ons-carousel>` element.
    *   [/en]
    *   [ja][/ja]
    * @codepen xbbzOQ
    * @tutorial vanilla/Reference/carousel
    * @seealso ons-carousel
    *   [en]`<ons-carousel>` components[/en]
    *   [ja]<ons-carousel>[/ja]
    * @example
    * <ons-carousel style="width: 100%; height: 200px">
    *   <ons-carousel-item>
    *    ...
    *   </ons-carousel-item>
    *   <ons-carousel-item>
    *    ...
    *   </ons-carousel-item>
    * </ons-carousel>
    */

   var CarouselItemElement = function (_BaseElement) {
     babelHelpers.inherits(CarouselItemElement, _BaseElement);

     function CarouselItemElement() {
       babelHelpers.classCallCheck(this, CarouselItemElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(CarouselItemElement).apply(this, arguments));
     }

     babelHelpers.createClass(CarouselItemElement, [{
       key: 'init',
       value: function init() {
         this.style.width = '100%';
         ModifierUtil.initModifier(this, scheme$4);
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$4);
         }
       }
     }], [{
       key: 'observedAttributes',
       get: function get() {
         return ['modifier'];
       }
     }]);
     return CarouselItemElement;
   }(BaseElement);

   customElements.define('ons-carousel-item', CarouselItemElement);

   var VerticalModeTrait = {

     _getScrollDelta: function _getScrollDelta(event) {
       return event.gesture.deltaY;
     },

     _getScrollVelocity: function _getScrollVelocity(event) {
       return event.gesture.velocityY;
     },

     _getElementSize: function _getElementSize() {
       if (!this._currentElementSize) {
         this._currentElementSize = this.getBoundingClientRect().height;
       }

       return this._currentElementSize;
     },

     _generateScrollTransform: function _generateScrollTransform(scroll) {
       return 'translate3d(0px, ' + -scroll + 'px, 0px)';
     },

     _updateDimensionData: function _updateDimensionData() {
       this._style = window.getComputedStyle(this);
       this._dimensions = this.getBoundingClientRect();
     },

     _updateOffset: function _updateOffset() {
       if (this.centered) {
         var height = (this._dimensions.height || 0) - parseInt(this._style.paddingTop, 10) - parseInt(this._style.paddingBottom, 10);
         this._offset = -(height - this._getCarouselItemSize()) / 2;
       }
     },

     _layoutCarouselItems: function _layoutCarouselItems() {
       var children = this._getCarouselItemElements();

       var sizeAttr = this._getCarouselItemSizeAttr();
       var sizeInfo = this._decomposeSizeString(sizeAttr);

       for (var i = 0; i < children.length; i++) {
         children[i].style.position = 'absolute';
         children[i].style.height = sizeAttr;
         children[i].style.visibility = 'visible';
         children[i].style.top = i * sizeInfo.number + sizeInfo.unit;
       }
     },

     _setup: function _setup() {
       this._updateDimensionData();
       this._updateOffset();
       this._layoutCarouselItems();
     }
   };

   var HorizontalModeTrait = {

     _getScrollDelta: function _getScrollDelta(event) {
       return event.gesture.deltaX;
     },

     _getScrollVelocity: function _getScrollVelocity(event) {
       return event.gesture.velocityX;
     },

     _getElementSize: function _getElementSize() {
       if (!this._currentElementSize) {
         this._currentElementSize = this.getBoundingClientRect().width;
       }

       return this._currentElementSize;
     },

     _generateScrollTransform: function _generateScrollTransform(scroll) {
       return 'translate3d(' + -scroll + 'px, 0px, 0px)';
     },

     _updateDimensionData: function _updateDimensionData() {
       this._style = window.getComputedStyle(this);
       this._dimensions = this.getBoundingClientRect();
     },

     _updateOffset: function _updateOffset() {
       if (this.centered) {
         var width = (this._dimensions.width || 0) - parseInt(this._style.paddingLeft, 10) - parseInt(this._style.paddingRight, 10);
         this._offset = -(width - this._getCarouselItemSize()) / 2;
       }
     },

     _layoutCarouselItems: function _layoutCarouselItems() {
       var children = this._getCarouselItemElements();

       var sizeAttr = this._getCarouselItemSizeAttr();
       var sizeInfo = this._decomposeSizeString(sizeAttr);

       for (var i = 0; i < children.length; i++) {
         children[i].style.position = 'absolute';
         children[i].style.width = sizeAttr;
         children[i].style.visibility = 'visible';
         children[i].style.left = i * sizeInfo.number + sizeInfo.unit;
       }
     },

     _setup: function _setup() {
       this._updateDimensionData();
       this._updateOffset();
       this._layoutCarouselItems();
     }
   };

   /**
    * @element ons-carousel
    * @category carousel
    * @description
    *   [en]
    *     Carousel component. A carousel can be used to display several items in the same space.
    *
    *     The component supports displaying content both horizontally and vertically. The user can scroll through the items by dragging and it can also be controller programmatically.
    *   [/en]
    *   [ja][/ja]
    * @codepen xbbzOQ
    * @tutorial vanilla/Reference/carousel
    * @seealso ons-carousel-item
    *   [en]`<ons-carousel-item>` component[/en]
    *   [ja]ons-carousel-item[/ja]
    * @example
    * <ons-carousel style="width: 100%; height: 200px">
    *   <ons-carousel-item>
    *    ...
    *   </ons-carousel-item>
    *   <ons-carousel-item>
    *    ...
    *   </ons-carousel-item>
    * </ons-carousel>
    */

   var CarouselElement = function (_BaseElement) {
     babelHelpers.inherits(CarouselElement, _BaseElement);

     function CarouselElement() {
       babelHelpers.classCallCheck(this, CarouselElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(CarouselElement).apply(this, arguments));
     }

     babelHelpers.createClass(CarouselElement, [{
       key: 'init',


       /**
        * @event postchange
        * @description
        *   [en]Fired just after the current carousel item has changed.[/en]
        *   [ja][/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja][/ja]
        * @param {Object} event.carousel
        *   [en]Carousel object.[/en]
        *   [ja]Carousel[/ja]
        * @param {Number} event.activeIndex
        *   [en]Current active index.[/en]
        *   [ja][/ja]
        * @param {Number} event.lastActiveIndex
        *   [en]Previous active index.[/en]
        *   [ja][/ja]
        */

       /**
        * @event refresh
        * @description
        *   [en]Fired when the carousel has been refreshed.[/en]
        *   [ja][/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja][/ja]
        * @param {Object} event.carousel
        *   [en]Carousel object.[/en]
        *   [ja]Carousel[/ja]
        */

       /**
        * @event overscroll
        * @description
        *   [en]Fired when the carousel has been overscrolled.[/en]
        *   [ja][/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja][/ja]
        * @param {Object} event.carousel
        *   [en]Fired when the carousel has been refreshed.[/en]
        *   [ja][/ja]
        * @param {Number} event.activeIndex
        *   [en]Current active index.[/en]
        *   [ja][/ja]
        * @param {String} event.direction
        *   [en]Can be one of either "up", "down", "left" or "right".[/en]
        *   [ja]"up", "down", "left", "right"[/ja]
        * @param {Function} event.waitToReturn
        *   [en]Takes a <code>Promise</code> object as an argument. The carousel will not scroll back until the promise has been resolved or rejected.[/en]
        *   [ja]PromisePromiseresolvereject[/ja]
        */

       /**
        * @attribute direction
        * @type {String}
        * @description
        *   [en]The direction of the carousel. Can be either "horizontal" or "vertical". Default is "horizontal".[/en]
        *   [ja]"horizontal""vertical""horizontal"[/ja]
        */

       /**
        * @attribute fullscreen
        * @description
        *   [en]If this attribute is set the carousel will cover the whole screen.[/en]
        *   [ja]absolute[/ja]
        */

       /**
        * @attribute overscrollable
        * @description
        *   [en]If this attribute is set the carousel will be scrollable over the edge. It will bounce back when released.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute centered
        * @description
        *   [en]If this attribute is set the carousel then the selected item will be in the center of the carousel instead of the beginning. Useful only when the items are smaller than the carousel. [/en]
        *   [ja]ons-carousel-item[/ja]
        */

       /**
        * @attribute item-width
        * @type {String}
        * @description
        *    [en]ons-carousel-item's width. Only works when the direction is set to "horizontal".[/en]
        *    [ja]ons-carousel-itemdirection"horizontal"[/ja]
        */

       /**
        * @attribute item-height
        * @type {String}
        * @description
        *   [en]ons-carousel-item's height. Only works when the direction is set to "vertical".[/en]
        *   [ja]ons-carousel-itemdirection"vertical"[/ja]
        */

       /**
        * @attribute auto-scroll
        * @description
        *   [en]If this attribute is set the carousel will be automatically scrolled to the closest item border when released.[/en]
        *   [ja]carousel-item[/ja]
        */

       /**
        * @attribute auto-scroll-ratio
        * @type {Number}
        * @description
        *    [en]A number between 0.0 and 1.0 that specifies how much the user must drag the carousel in order for it to auto scroll to the next item.[/en]
        *    [ja]0.01.0[/ja]
        */

       /**
        * @attribute swipeable
        * @description
        *   [en]If this attribute is set the carousel can be scrolled by drag or swipe.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute disabled
        * @description
        *   [en]If this attribute is set the carousel is disabled.[/en]
        *   [ja]dragtouchswipe[/ja]
        */

       /**
        * @attribute initial-index
        * @initonly
        * @type {Number}
        * @description
        *   [en]Specify the index of the ons-carousel-item to show initially. Default is 0.[/en]
        *   [ja]ons-carousel-item0 0 [/ja]
        */

       /**
        * @attribute auto-refresh
        * @description
        *   [en]When this attribute is set the carousel will automatically refresh when the number of child nodes change.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute animation-options
        * @type {Expression}
        * @description
        *   [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
        *   [ja]duration, timing, delay{duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
        */

       value: function init() {
         this._doorLock = new DoorLock();
         this._scroll = 0;
         this._offset = 0;
         this._lastActiveIndex = 0;

         this._boundOnDrag = this._onDrag.bind(this);
         this._boundOnDragEnd = this._onDragEnd.bind(this);
         this._boundOnResize = this._onResize.bind(this);

         this._mixin(this._isVertical() ? VerticalModeTrait : HorizontalModeTrait);
       }
     }, {
       key: '_onResize',
       value: function _onResize() {
         var i = this._scroll / this._currentElementSize;
         delete this._currentElementSize;
         this.setActiveIndex(i);
       }
     }, {
       key: '_onDirectionChange',
       value: function _onDirectionChange() {
         if (this._isVertical()) {
           this.style.overflowX = 'auto';
           this.style.overflowY = '';
         } else {
           this.style.overflowX = '';
           this.style.overflowY = 'auto';
         }

         this.refresh();
       }
     }, {
       key: '_saveLastState',
       value: function _saveLastState() {
         this._lastState = {
           elementSize: this._getCarouselItemSize(),
           carouselElementCount: this.itemCount,
           width: this._getCarouselItemSize() * this.itemCount
         };
       }

       /**
        * @return {Number}
        */

     }, {
       key: '_getCarouselItemSize',
       value: function _getCarouselItemSize() {
         var sizeAttr = this._getCarouselItemSizeAttr();
         var sizeInfo = this._decomposeSizeString(sizeAttr);
         var elementSize = this._getElementSize();

         if (sizeInfo.unit === '%') {
           return Math.round(sizeInfo.number / 100 * elementSize);
         } else if (sizeInfo.unit === 'px') {
           return sizeInfo.number;
         } else {
           throw new Error('Invalid state');
         }
       }

       /**
        * @return {Number}
        */

     }, {
       key: '_getInitialIndex',
       value: function _getInitialIndex() {
         var index = parseInt(this.getAttribute('initial-index'), 10);

         if (typeof index === 'number' && !isNaN(index)) {
           return Math.max(Math.min(index, this.itemCount - 1), 0);
         } else {
           return 0;
         }
       }

       /**
        * @return {String}
        */

     }, {
       key: '_getCarouselItemSizeAttr',
       value: function _getCarouselItemSizeAttr() {
         var attrName = 'item-' + (this._isVertical() ? 'height' : 'width');
         var itemSizeAttr = ('' + this.getAttribute(attrName)).trim();

         return itemSizeAttr.match(/^\d+(px|%)$/) ? itemSizeAttr : '100%';
       }

       /**
        * @return {Object}
        */

     }, {
       key: '_decomposeSizeString',
       value: function _decomposeSizeString(size) {
         var matches = size.match(/^(\d+)(px|%)/);

         return {
           number: parseInt(matches[1], 10),
           unit: matches[2]
         };
       }
     }, {
       key: '_setupInitialIndex',
       value: function _setupInitialIndex() {
         this._scroll = (this._offset || 0) + this._getCarouselItemSize() * this._getInitialIndex();
         this._lastActiveIndex = this._getInitialIndex();
         this._scrollTo(this._scroll);
       }

       /**
        * @method setActiveIndex
        * @signature setActiveIndex(index, [options])
        * @param {Number} index
        *   [en]The index that the carousel should be set to.[/en]
        *   [ja]carousel[/ja]
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {Function} [options.callback]
        *   [en]A function that will be called after the animation is finished.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
        *   [ja][/ja]
        * @param {Object} [options.animationOptions]
        *   [en]An object that can be used to specify duration, delay and timing function of the animation.[/en]
        *   [ja][/ja]
        * @description
        *   [en]Specify the index of the `<ons-carousel-item>` to show.[/en]
        *   [ja]ons-carousel-itemindex[/ja]
        * @return {Promise}
        *   [en]Resolves to the carousel element.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'setActiveIndex',
       value: function setActiveIndex(index) {
         var _this2 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         if (options && (typeof options === 'undefined' ? 'undefined' : babelHelpers.typeof(options)) != 'object') {
           throw new Error('options must be an object. You supplied ' + options);
         }

         options.animationOptions = util.extend({ duration: 0.3, timing: 'cubic-bezier(.1, .7, .1, 1)' }, options.animationOptions || {}, this.hasAttribute('animation-options') ? util.animationOptionsParse(this.getAttribute('animation-options')) : {});

         index = Math.max(0, Math.min(index, this.itemCount - 1));
         var scroll = (this._offset || 0) + this._getCarouselItemSize() * index;
         var max = this._calculateMaxScroll();

         this._scroll = Math.max(0, Math.min(max, scroll));
         return this._scrollTo(this._scroll, options).then(function () {
           _this2._tryFirePostChangeEvent();
           return _this2;
         });
       }

       /**
        * @method getActiveIndex
        * @signature getActiveIndex()
        * @return {Number}
        *   [en]The current carousel item index.[/en]
        *   [ja][/ja]
        * @description
        *   [en]Returns the index of the currently visible `<ons-carousel-item>`.[/en]
        *   [ja]ons-carousel-item[/ja]
        */

     }, {
       key: 'getActiveIndex',
       value: function getActiveIndex() {
         var scroll = this._scroll - (this._offset || 0);
         var count = this.itemCount;
         var size = this._getCarouselItemSize();

         if (scroll < 0) {
           return 0;
         }

         var i = void 0;
         for (i = 0; i < count; i++) {
           if (size * i <= scroll && size * (i + 1) > scroll) {
             return i;
           }
         }

         // max carousel index
         return i;
       }

       /**
        * @method next
        * @signature next([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {Function} [options.callback]
        *   [en]A function that will be executed after the animation has finished.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
        *   [ja][/ja]
        * @param {Object} [options.animationOptions]
        *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Resolves to the carousel element[/en]
        *   [ja][/ja]
        * @description
        *   [en]Show next `<ons-carousel-item>`.[/en]
        *   [ja]ons-carousel-item[/ja]
        */

     }, {
       key: 'next',
       value: function next(options) {
         return this.setActiveIndex(this.getActiveIndex() + 1, options);
       }

       /**
        * @method prev
        * @signature prev([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {Function} [options.callback]
        *   [en]A function that will be executed after the animation has finished.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
        *   [ja][/ja]
        * @param {Object} [options.animationOptions]
        *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Resolves to the carousel element[/en]
        *   [ja][/ja]
        * @description
        *   [en]Show previous `<ons-carousel-item>`.[/en]
        *   [ja]ons-carousel-item[/ja]
        */

     }, {
       key: 'prev',
       value: function prev(options) {
         return this.setActiveIndex(this.getActiveIndex() - 1, options);
       }

       /**
        * @return {Boolean}
        */

     }, {
       key: '_isEnabledChangeEvent',
       value: function _isEnabledChangeEvent() {
         var elementSize = this._getElementSize();
         var carouselItemSize = this._getCarouselItemSize();

         return this.autoScroll && elementSize === carouselItemSize;
       }

       /**
        * @return {Boolean}
        */

     }, {
       key: '_isVertical',
       value: function _isVertical() {
         return this.getAttribute('direction') === 'vertical';
       }
     }, {
       key: '_prepareEventListeners',
       value: function _prepareEventListeners() {
         var _this3 = this;

         this._gestureDetector = new GestureDetector(this, {
           dragMinDistance: 1,
           dragLockToAxis: true
         });
         this._mutationObserver = new MutationObserver(function () {
           return _this3.refresh();
         });

         this._updateSwipeable();
         this._updateAutoRefresh();

         window.addEventListener('resize', this._boundOnResize, true);
       }
     }, {
       key: '_removeEventListeners',
       value: function _removeEventListeners() {
         this._gestureDetector.dispose();
         this._gestureDetector = null;

         this._mutationObserver.disconnect();
         this._mutationObserver = null;

         window.removeEventListener('resize', this._boundOnResize, true);
       }
     }, {
       key: '_updateSwipeable',
       value: function _updateSwipeable() {
         if (this._gestureDetector) {
           if (this.swipeable) {
             this._gestureDetector.on('drag dragleft dragright dragup dragdown swipe swipeleft swiperight swipeup swipedown', this._boundOnDrag);
             this._gestureDetector.on('dragend', this._boundOnDragEnd);
           } else {
             this._gestureDetector.off('drag dragleft dragright dragup dragdown swipe swipeleft swiperight swipeup swipedown', this._boundOnDrag);
             this._gestureDetector.off('dragend', this._boundOnDragEnd);
           }
         }
       }
     }, {
       key: '_updateAutoRefresh',
       value: function _updateAutoRefresh() {
         if (this._mutationObserver) {
           if (this.hasAttribute('auto-refresh')) {
             this._mutationObserver.observe(this, { childList: true });
           } else {
             this._mutationObserver.disconnect();
           }
         }
       }
     }, {
       key: '_tryFirePostChangeEvent',
       value: function _tryFirePostChangeEvent() {
         var currentIndex = this.getActiveIndex();

         if (this._lastActiveIndex !== currentIndex) {
           var lastActiveIndex = this._lastActiveIndex;
           this._lastActiveIndex = currentIndex;

           util.triggerElementEvent(this, 'postchange', {
             carousel: this,
             activeIndex: currentIndex,
             lastActiveIndex: lastActiveIndex
           });
         }
       }
     }, {
       key: '_isWrongDirection',
       value: function _isWrongDirection(d) {
         // this._lastDragDirection = d;
         return this._isVertical() ? d === 'left' || d === 'right' : d === 'up' || d === 'down';
       }
     }, {
       key: '_onDrag',
       value: function _onDrag(event) {
         if (this._isWrongDirection(event.gesture.direction)) {
           return;
         }

         event.stopPropagation();

         this._lastDragEvent = event;

         var scroll = this._scroll - this._getScrollDelta(event);
         this._scrollTo(scroll);
         event.gesture.preventDefault();

         this._tryFirePostChangeEvent();
       }
     }, {
       key: '_onDragEnd',
       value: function _onDragEnd(event) {
         var _this4 = this;

         if (!this._lastDragEvent) {
           return;
         }
         this._currentElementSize = undefined;
         this._scroll = this._scroll - this._getScrollDelta(event);

         // if (!this._isWrongDirection(this._lastDragDirection) && this._getScrollDelta(event) !== 0) {
         //   event.stopPropagation();
         // }

         if (this._isOverScroll(this._scroll)) {
           var waitForAction = false;
           util.triggerElementEvent(this, 'overscroll', {
             carousel: this,
             activeIndex: this.getActiveIndex(),
             direction: this._getOverScrollDirection(),
             waitToReturn: function waitToReturn(promise) {
               waitForAction = true;
               promise.then(function () {
                 return _this4._scrollToKillOverScroll();
               });
             }
           });

           if (!waitForAction) {
             this._scrollToKillOverScroll();
           }
         } else {
           this._startMomentumScroll();
         }
         this._lastDragEvent = null;

         event.gesture.preventDefault();
       }

       /**
        * @param {Object} trait
        */

     }, {
       key: '_mixin',
       value: function _mixin(trait) {
         Object.keys(trait).forEach(function (key) {
           this[key] = trait[key];
         }.bind(this));
       }
     }, {
       key: '_startMomentumScroll',
       value: function _startMomentumScroll() {
         if (this._lastDragEvent) {
           var velocity = this._getScrollVelocity(this._lastDragEvent);
           var duration = 0.3;
           var scrollDelta = duration * 100 * velocity;
           var scroll = this._normalizeScrollPosition(this._scroll + (this._getScrollDelta(this._lastDragEvent) > 0 ? -scrollDelta : scrollDelta));

           this._scroll = scroll;

           animit(this._getCarouselItemElements()).queue({
             transform: this._generateScrollTransform(this._scroll)
           }, {
             duration: duration,
             timing: 'cubic-bezier(.1, .7, .1, 1)'
           }).queue(function (done) {
             done();
             this._tryFirePostChangeEvent();
           }.bind(this)).play();
         }
       }
     }, {
       key: '_normalizeScrollPosition',
       value: function _normalizeScrollPosition(scroll) {
         var max = this._calculateMaxScroll();

         if (!this.autoScroll) {
           return Math.max(0, Math.min(max, scroll));
         }
         var arr = [];
         var size = this._getCarouselItemSize();
         var nbrOfItems = this.itemCount;

         for (var i = 0; i < nbrOfItems; i++) {
           if (i * size + this._offset < max) {
             arr.push(i * size + this._offset);
           }
         }
         arr.push(max);

         arr.sort(function (left, right) {
           left = Math.abs(left - scroll);
           right = Math.abs(right - scroll);

           return left - right;
         });

         arr = arr.filter(function (item, pos) {
           return !pos || item != arr[pos - 1];
         });

         var lastScroll = this._lastActiveIndex * size + this._offset;
         var scrollRatio = Math.abs(scroll - lastScroll) / size;
         var result = arr[0];

         if (scrollRatio <= this.autoScrollRatio) {
           result = lastScroll;
         } else if (scrollRatio < 1.0) {
           if (arr[0] === lastScroll && arr.length > 1) {
             result = arr[1];
           }
         }

         return Math.max(0, Math.min(max, result));
       }

       /**
        * @return {Array}
        */

     }, {
       key: '_getCarouselItemElements',
       value: function _getCarouselItemElements() {
         return util.arrayFrom(this.children).filter(function (child) {
           return child.nodeName.toLowerCase() === 'ons-carousel-item';
         });
       }

       /**
        * @param {Number} scroll
        * @param {Object} [options]
        * @return {Promise} Resolves to the carousel element
        */

     }, {
       key: '_scrollTo',
       value: function _scrollTo(scroll) {
         var _this5 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         var isOverscrollable = this.overscrollable;

         var normalizeScroll = function normalizeScroll(scroll) {
           var ratio = 0.35;

           if (scroll < 0) {
             return isOverscrollable ? Math.round(scroll * ratio) : 0;
           }

           var maxScroll = _this5._calculateMaxScroll();
           if (maxScroll < scroll) {
             return isOverscrollable ? maxScroll + Math.round((scroll - maxScroll) * ratio) : maxScroll;
           }

           return scroll;
         };

         return new Promise(function (resolve) {
           animit(_this5._getCarouselItemElements()).queue({
             transform: _this5._generateScrollTransform(normalizeScroll(scroll))
           }, options.animation !== 'none' ? options.animationOptions : {}).play(function () {
             if (options.callback instanceof Function) {
               options.callback();
             }
             resolve();
           });
         });
       }
     }, {
       key: '_calculateMaxScroll',
       value: function _calculateMaxScroll() {
         var max = this.itemCount * this._getCarouselItemSize() - this._getElementSize();
         return Math.ceil(max < 0 ? 0 : max); // Need to return an integer value.
       }
     }, {
       key: '_isOverScroll',
       value: function _isOverScroll(scroll) {
         if (scroll < 0 || scroll > this._calculateMaxScroll()) {
           return true;
         }
         return false;
       }
     }, {
       key: '_getOverScrollDirection',
       value: function _getOverScrollDirection() {
         if (this._isVertical()) {
           return this._scroll <= 0 ? 'up' : 'down';
         } else {
           return this._scroll <= 0 ? 'left' : 'right';
         }
       }
     }, {
       key: '_scrollToKillOverScroll',
       value: function _scrollToKillOverScroll() {
         var duration = 0.4;

         if (this._scroll < 0) {
           animit(this._getCarouselItemElements()).queue({
             transform: this._generateScrollTransform(0)
           }, {
             duration: duration,
             timing: 'cubic-bezier(.1, .4, .1, 1)'
           }).queue(function (done) {
             done();
             this._tryFirePostChangeEvent();
           }.bind(this)).play();
           this._scroll = 0;
           return;
         }

         var maxScroll = this._calculateMaxScroll();

         if (maxScroll < this._scroll) {
           animit(this._getCarouselItemElements()).queue({
             transform: this._generateScrollTransform(maxScroll)
           }, {
             duration: duration,
             timing: 'cubic-bezier(.1, .4, .1, 1)'
           }).queue(function (done) {
             done();
             this._tryFirePostChangeEvent();
           }.bind(this)).play();
           this._scroll = maxScroll;
           return;
         }

         return;
       }

       /**
        * @property itemCount
        * @readonly
        * @type {Number}
        * @description
        *   [en]The number of carousel items.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'refresh',


       /**
        * @method refresh
        * @signature refresh()
        * @description
        *   [en]Update the layout of the carousel. Used when adding `<ons-carousel-items>` dynamically or to automatically adjust the size.[/en]
        *   [ja]ons-carousel-itemons-carousel[/ja]
        */
       value: function refresh() {
         // Bug fix
         if (this._getCarouselItemSize() === 0) {
           return;
         }

         this._mixin(this._isVertical() ? VerticalModeTrait : HorizontalModeTrait);
         this._setup();

         if (this._lastState && this._lastState.width > 0) {
           var scroll = this._scroll; // - this._offset;

           if (this._isOverScroll(scroll)) {
             this._scrollToKillOverScroll();
           } else {
             if (this.autoScroll) {
               scroll = this._normalizeScrollPosition(scroll);
             }

             this._scrollTo(scroll);
           }
         }

         this._saveLastState();

         util.triggerElementEvent(this, 'refresh', { carousel: this });
       }

       /**
        * @method first
        * @signature first()
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {Function} [options.callback]
        *   [en]A function that will be executed after the animation has finished.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
        *   [ja][/ja]
        * @param {Object} [options.animationOptions]
        *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Resolves to the carousel element[/en]
        *   [ja][/ja]
        * @description
        *   [en]Show first `<ons-carousel-item>`.[/en]
        *   [ja]ons-carousel-item[/ja]
        */

     }, {
       key: 'first',
       value: function first(options) {
         return this.setActiveIndex(0, options);
       }

       /**
        * @method last
        * @signature last()
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {Function} [options.callback]
        *   [en]A function that will be executed after the animation has finished.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
        *   [ja][/ja]
        * @param {Object} [options.animationOptions]
        *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Resolves to the carousel element[/en]
        *   [ja]Resolves to the carousel element[/ja]
        * @description
        *   [en]Show last ons-carousel item.[/en]
        *   [ja]ons-carousel-item[/ja]
        */

     }, {
       key: 'last',
       value: function last(options) {
         this.setActiveIndex(Math.max(this.itemCount - 1, 0), options);
       }
     }, {
       key: 'connectedCallback',
       value: function connectedCallback() {
         var _this6 = this;

         this._prepareEventListeners();

         this._setup();
         this._setupInitialIndex();

         this._saveLastState();

         // Fix rendering glitch on Android 4.1
         if (this.offsetHeight === 0) {
           setImmediate(function () {
             return _this6.refresh();
           });
         }
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         switch (name) {
           case 'swipeable':
             this._updateSwipeable();
             break;
           case 'auto-refresh':
             this._updateAutoRefresh();
             break;
           case 'direction':
             this._onDirectionChange();
         }
       }
     }, {
       key: 'disconnectedCallback',
       value: function disconnectedCallback() {
         this._removeEventListeners();
       }

       /**
        * @property autoScrollRatio
        * @type {Number}
        * @description
        *   [en]The current auto scroll ratio. [/en]
        *   [ja]ratio[/ja]
        */

     }, {
       key: 'itemCount',
       get: function get() {
         return this._getCarouselItemElements().length;
       }
     }, {
       key: 'autoScrollRatio',
       get: function get() {
         var attr = this.getAttribute('auto-scroll-ratio');

         if (!attr) {
           return 0.5;
         }

         var scrollRatio = parseFloat(attr);
         if (scrollRatio < 0.0 || scrollRatio > 1.0) {
           throw new Error('Invalid ratio.');
         }

         return isNaN(scrollRatio) ? 0.5 : scrollRatio;
       },
       set: function set(ratio) {
         if (ratio < 0.0 || ratio > 1.0) {
           throw new Error('Invalid ratio.');
         }

         this.setAttribute('auto-scroll-ratio', ratio);
       }

       /**
        * @property swipeable
        * @type {Boolean}
        * @description
        *   [en]true if the carousel is swipeable.[/en]
        *   [ja]swipeabletrue[/ja]
        */

     }, {
       key: 'swipeable',
       get: function get() {
         return this.hasAttribute('swipeable');
       },
       set: function set(value) {
         return util.toggleAttribute(this, 'swipeable', value);
       }

       /**
        * @property autoScroll
        * @type {Boolean}
        * @description
        *   [en]true if auto scroll is enabled.[/en]
        *   [ja]true[/ja]
        */

     }, {
       key: 'autoScroll',
       get: function get() {
         return this.hasAttribute('auto-scroll');
       },
       set: function set(value) {
         return util.toggleAttribute(this, 'auto-scroll', value);
       }

       /**
        * @property disabled
        * @type {Boolean}
        * @description
        *   [en]Whether the carousel is disabled or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'disabled',
       get: function get() {
         return this.hasAttribute('disabled');
       },
       set: function set(value) {
         return util.toggleAttribute(this, 'disabled', value);
       }

       /**
        * @property overscrollable
        * @type {Boolean}
        * @description
        *   [en]Whether the carousel is overscrollable or not.[/en]
        *   [ja]overscrolltrue[/ja]
        */

     }, {
       key: 'overscrollable',
       get: function get() {
         return this.hasAttribute('overscrollable');
       },
       set: function set(value) {
         return util.toggleAttribute(this, 'overscrollable', value);
       }

       /**
        * @property centered
        * @type {Boolean}
        * @description
        *   [en]Whether the carousel is centered or not.[/en]
        *   [ja]centeredtrue[/ja]
        */

     }, {
       key: 'centered',
       get: function get() {
         return this.hasAttribute('centered');
       },
       set: function set(value) {
         return util.toggleAttribute(this, 'centered', value);
       }
     }], [{
       key: 'observedAttributes',
       get: function get() {
         return ['swipeable', 'auto-refresh', 'direction'];
       }
     }]);
     return CarouselElement;
   }(BaseElement);

   customElements.define('ons-carousel', CarouselElement);

   /**
    * @element ons-col
    * @category grid
    * @description
    *   [en]Represents a column in the grid system. Use with `<ons-row>` to layout components.[/en]
    *   [ja]ons-row[/ja]
    * @note
    *   [en]For Android 4.3 and earlier, and iOS6 and earlier, when using mixed alignment with ons-row and ons-column, they may not be displayed correctly. You can use only one alignment.[/en]
    *   [ja]Android 4.3iOS 6OSons-rowons-column[/ja]
    * @codepen GgujC {wide}
    * @guide layouting [en]Layouting guide[/en][ja][/ja]
    * @seealso ons-row
    *   [en]The `<ons-row>` component is the parent of `<ons-col>`.[/en]
    *   [ja]ons-row[/ja]
    * @example
    * <ons-row>
    *   <ons-col width="50px"><ons-icon icon="fa-twitter"></ons-icon></ons-col>
    *   <ons-col>Text</ons-col>
    * </ons-row>
    */

   /**
    * @attribute vertical-align
    * @type {String}
    * @description
    *   [en]Vertical alignment of the column. Valid values are "top", "center", and "bottom".[/en]
    *   [ja]"top", "center", "bottom"[/ja]
    */

   /**
    * @attribute width
    * @type {String}
    * @description
    *   [en]The width of the column. Valid values are css width values ("10%", "50px").[/en]
    *   [ja]10%50px[/ja]
    */

   var ColElement = function (_BaseElement) {
     babelHelpers.inherits(ColElement, _BaseElement);

     function ColElement() {
       babelHelpers.classCallCheck(this, ColElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ColElement).apply(this, arguments));
     }

     babelHelpers.createClass(ColElement, [{
       key: 'init',
       value: function init() {
         if (this.getAttribute('width')) {
           this._updateWidth();
         }
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'width') {
           this._updateWidth();
         }
       }
     }, {
       key: '_updateWidth',
       value: function _updateWidth() {
         var width = this.getAttribute('width');
         if (typeof width === 'string') {
           width = ('' + width).trim();
           width = width.match(/^\d+$/) ? width + '%' : width;

           this.style.webkitBoxFlex = '0';
           this.style.webkitFlex = '0 0 ' + width;
           this.style.mozBoxFlex = '0';
           this.style.mozFlex = '0 0 ' + width;
           this.style.msFlex = '0 0 ' + width;
           this.style.flex = '0 0 ' + width;
           this.style.maxWidth = width;
         }
       }
     }], [{
       key: 'observedAttributes',
       get: function get() {
         return ['width'];
       }
     }]);
     return ColElement;
   }(BaseElement);

   customElements.define('ons-col', ColElement);

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */

   var DialogAnimator = function () {
     function DialogAnimator() {
       var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

       var _ref$timing = _ref.timing;
       var timing = _ref$timing === undefined ? 'linear' : _ref$timing;
       var _ref$delay = _ref.delay;
       var delay = _ref$delay === undefined ? 0 : _ref$delay;
       var _ref$duration = _ref.duration;
       var duration = _ref$duration === undefined ? 0.2 : _ref$duration;
       babelHelpers.classCallCheck(this, DialogAnimator);

       this.timing = timing;
       this.delay = delay;
       this.duration = duration;
     }

     /**
      * @param {HTMLElement} dialog
      * @param {Function} done
      */


     babelHelpers.createClass(DialogAnimator, [{
       key: 'show',
       value: function show(dialog, done) {
         done();
       }

       /**
        * @param {HTMLElement} dialog
        * @param {Function} done
        */

     }, {
       key: 'hide',
       value: function hide(dialog, done) {
         done();
       }
     }]);
     return DialogAnimator;
   }();

   /**
    * Android style animator for dialog.
    */
   var AndroidDialogAnimator = function (_DialogAnimator) {
     babelHelpers.inherits(AndroidDialogAnimator, _DialogAnimator);

     function AndroidDialogAnimator() {
       var _ref2 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

       var _ref2$timing = _ref2.timing;
       var timing = _ref2$timing === undefined ? 'ease-in-out' : _ref2$timing;
       var _ref2$delay = _ref2.delay;
       var delay = _ref2$delay === undefined ? 0 : _ref2$delay;
       var _ref2$duration = _ref2.duration;
       var duration = _ref2$duration === undefined ? 0.3 : _ref2$duration;
       babelHelpers.classCallCheck(this, AndroidDialogAnimator);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(AndroidDialogAnimator).call(this, { timing: timing, delay: delay, duration: duration }));
     }

     /**
      * @param {Object} dialog
      * @param {Function} callback
      */


     babelHelpers.createClass(AndroidDialogAnimator, [{
       key: 'show',
       value: function show(dialog, callback) {
         callback = callback ? callback : function () {};

         animit.runAll(animit(dialog._mask).queue({
           opacity: 0
         }).wait(this.delay).queue({
           opacity: 1.0
         }, {
           duration: this.duration,
           timing: this.timing
         }), animit(dialog._dialog).saveStyle().queue({
           css: {
             transform: 'translate3d(-50%, -60%, 0)',
             opacity: 0.0
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3d(-50%, -50%, 0)',
             opacity: 1.0
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }

       /**
        * @param {Object} dialog
        * @param {Function} callback
        */

     }, {
       key: 'hide',
       value: function hide(dialog, callback) {
         callback = callback ? callback : function () {};

         animit.runAll(animit(dialog._mask).queue({
           opacity: 1.0
         }).wait(this.delay).queue({
           opacity: 0
         }, {
           duration: this.duration,
           timing: this.timing
         }), animit(dialog._dialog).saveStyle().queue({
           css: {
             transform: 'translate3d(-50%, -50%, 0)',
             opacity: 1.0
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3d(-50%, -60%, 0)',
             opacity: 0.0
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }
     }]);
     return AndroidDialogAnimator;
   }(DialogAnimator);

   /**
    * iOS style animator for dialog.
    */
   var IOSDialogAnimator = function (_DialogAnimator2) {
     babelHelpers.inherits(IOSDialogAnimator, _DialogAnimator2);

     function IOSDialogAnimator() {
       var _ref3 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

       var _ref3$timing = _ref3.timing;
       var timing = _ref3$timing === undefined ? 'ease-in-out' : _ref3$timing;
       var _ref3$delay = _ref3.delay;
       var delay = _ref3$delay === undefined ? 0 : _ref3$delay;
       var _ref3$duration = _ref3.duration;
       var duration = _ref3$duration === undefined ? 0.3 : _ref3$duration;
       babelHelpers.classCallCheck(this, IOSDialogAnimator);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(IOSDialogAnimator).call(this, { timing: timing, delay: delay, duration: duration }));
     }

     /**
      * @param {Object} dialog
      * @param {Function} callback
      */


     babelHelpers.createClass(IOSDialogAnimator, [{
       key: 'show',
       value: function show(dialog, callback) {
         callback = callback ? callback : function () {};

         animit.runAll(animit(dialog._mask).queue({
           opacity: 0
         }).wait(this.delay).queue({
           opacity: 1.0
         }, {
           duration: this.duration,
           timing: this.timing
         }), animit(dialog._dialog).saveStyle().queue({
           css: {
             transform: 'translate3d(-50%, 300%, 0)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3d(-50%, -50%, 0)'
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }

       /**
        * @param {Object} dialog
        * @param {Function} callback
        */

     }, {
       key: 'hide',
       value: function hide(dialog, callback) {
         callback = callback ? callback : function () {};

         animit.runAll(animit(dialog._mask).queue({
           opacity: 1.0
         }).wait(this.delay).queue({
           opacity: 0
         }, {
           duration: this.duration,
           timing: this.timing
         }), animit(dialog._dialog).saveStyle().queue({
           css: {
             transform: 'translate3d(-50%, -50%, 0)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3d(-50%, 300%, 0)'
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }
     }]);
     return IOSDialogAnimator;
   }(DialogAnimator);

   /**
    * Slide animator for dialog.
    */
   var SlideDialogAnimator = function (_DialogAnimator3) {
     babelHelpers.inherits(SlideDialogAnimator, _DialogAnimator3);

     function SlideDialogAnimator() {
       var _ref4 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

       var _ref4$timing = _ref4.timing;
       var timing = _ref4$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref4$timing;
       var _ref4$delay = _ref4.delay;
       var delay = _ref4$delay === undefined ? 0 : _ref4$delay;
       var _ref4$duration = _ref4.duration;
       var duration = _ref4$duration === undefined ? 0.2 : _ref4$duration;
       babelHelpers.classCallCheck(this, SlideDialogAnimator);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(SlideDialogAnimator).call(this, { timing: timing, delay: delay, duration: duration }));
     }

     /**
      * @param {Object} dialog
      * @param {Function} callback
      */


     babelHelpers.createClass(SlideDialogAnimator, [{
       key: 'show',
       value: function show(dialog, callback) {
         callback = callback ? callback : function () {};

         animit.runAll(animit(dialog._mask).queue({
           opacity: 0
         }).wait(this.delay).queue({
           opacity: 1.0
         }, {
           duration: this.duration,
           timing: this.timing
         }), animit(dialog._dialog).saveStyle().queue({
           css: {
             transform: 'translate3D(-50%, -350%, 0)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(-50%, -50%, 0)'
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }

       /**
        * @param {Object} dialog
        * @param {Function} callback
        */

     }, {
       key: 'hide',
       value: function hide(dialog, callback) {
         callback = callback ? callback : function () {};

         animit.runAll(animit(dialog._mask).queue({
           opacity: 1.0
         }).wait(this.delay).queue({
           opacity: 0
         }, {
           duration: this.duration,
           timing: this.timing
         }), animit(dialog._dialog).saveStyle().queue({
           css: {
             transform: 'translate3D(-50%, -50%, 0)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(-50%, -350%, 0)'
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }
     }]);
     return SlideDialogAnimator;
   }(DialogAnimator);

   var scheme$5 = {
     '.dialog': 'dialog--*',
     '.dialog-container': 'dialog-container--*',
     '.dialog-mask': 'dialog-mask--*'
   };

   var _animatorDict$1 = {
     'default': function _default() {
       return platform.isAndroid() ? AndroidDialogAnimator : IOSDialogAnimator;
     },
     'slide': SlideDialogAnimator,
     'none': DialogAnimator
   };

   /**
    * @element ons-dialog
    * @category dialog
    * @description
    *   [en]
    *     Dialog that is displayed on top of current screen. As opposed to the `<ons-alert-dialog>` element, this component can contain any kind of content.
    *
    *     To use the element it can either be attached directly to the `<body>` element or dynamically created from a template using the `ons.createDialog(template)` utility function and the `<ons-template>` tag.
    *
    *     The dialog is useful for displaying menus, additional information or to ask the user to make a decision.
    *
    *     It will automatically be displayed as Material Design when running on an Android device.
    *   [/en]
    *   [ja][/ja]
    * @modifier material
    *   [en]Display a Material Design dialog.[/en]
    *   [ja][/ja]
    * @codepen zxxaGa
    * @tutorial vanilla/Reference/dialog
    * @guide dialogs
    *   [en]Dialog components[/en]
    *   [ja]Dialog components[/ja]
    * @guide using-modifier [en]More details about the `modifier` attribute[/en][ja]modifier[/ja]
    * @seealso ons-alert-dialog
    *   [en]`<ons-alert-dialog>` component[/en]
    *   [ja]ons-alert-dialog[/ja]
    * @seealso ons-popover
    *   [en]`<ons-popover>` component[/en]
    *   [ja]ons-popover[/ja]
    * @seealso ons-modal
    *   [en]`<ons-modal>` component[/en]
    *   [ja]ons-modal[/ja]
    * @example
    * <ons-dialog id="dialog">
    *   <p>This is a dialog!</p>
    * </ons-dialog>
    *
    * <script>
    *   document.getElementById('dialog').show();
    * </script>
    */

   var DialogElement = function (_BaseElement) {
     babelHelpers.inherits(DialogElement, _BaseElement);

     function DialogElement() {
       babelHelpers.classCallCheck(this, DialogElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(DialogElement).apply(this, arguments));
     }

     babelHelpers.createClass(DialogElement, [{
       key: 'init',
       value: function init() {
         var _this2 = this;

         contentReady(this, function () {
           return _this2._compile();
         });

         this._visible = false;
         this._doorLock = new DoorLock();
         this._boundCancel = this._cancel.bind(this);

         this._updateAnimatorFactory();
       }
     }, {
       key: '_updateAnimatorFactory',
       value: function _updateAnimatorFactory() {
         this._animatorFactory = new AnimatorFactory({
           animators: _animatorDict$1,
           baseClass: DialogAnimator,
           baseClassName: 'DialogAnimator',
           defaultAnimation: this.getAttribute('animation')
         });
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         this.style.display = 'none';

         /* Expected result:
          *   <ons-dialog>
          *     <div class="dialog-mask"></div>
          *     <div class="dialog">
          *       <div class="dialog-container">...</div>
          *     </div>
          *   </ons-dialog>
          */

         if (!this._dialog) {
           var dialog = document.createElement('div');
           dialog.classList.add('dialog');

           var container = document.createElement('div');
           dialog.classList.add('dialog-container');

           dialog.appendChild(container);

           while (this.firstChild) {
             container.appendChild(this.firstChild);
           }

           this.appendChild(dialog);
         }

         if (!this._mask) {
           var mask = document.createElement('div');
           mask.classList.add('dialog-mask');
           this.insertBefore(mask, this.firstChild);
         }

         this._dialog.style.zIndex = 20001;
         this._mask.style.zIndex = 20000;

         this.setAttribute('status-bar-fill', '');

         ModifierUtil.initModifier(this, scheme$5);
       }

       /**
        * @property onDeviceBackButton
        * @type {Object}
        * @description
        *   [en]Back-button handler.[/en]
        *   [ja][/ja]
        */

     }, {
       key: '_cancel',
       value: function _cancel() {
         var _this3 = this;

         if (this.cancelable && !this._running) {
           this._running = true;
           this.hide({
             callback: function callback() {
               _this3._running = false;
               util.triggerElementEvent(_this3, 'dialog-cancel');
             }
           });
         }
       }

       /**
        * @method show
        * @signature show([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]Animation name. Available animations are `"none"` and `"slide"`.[/en]
        *   [ja]"none", "slide"[/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
        *   [ja]duration, delay, timinge.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
        * @param {Function} [options.callback]
        *   [en]This function is called after the dialog has been revealed.[/en]
        *   [ja][/ja]
        * @description
        *  [en]Show the dialog.[/en]
        *  [ja][/ja]
        * @return {Promise} Resolves to the displayed element.
        */

     }, {
       key: 'show',
       value: function show() {
         var _this4 = this;

         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         var _cancel2 = false;
         var callback = options.callback || function () {};

         options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

         util.triggerElementEvent(this, 'preshow', {
           dialog: this,
           cancel: function cancel() {
             _cancel2 = true;
           }
         });

         if (!_cancel2) {
           var _ret = function () {
             var tryShow = function tryShow() {
               var unlock = _this4._doorLock.lock();
               var animator = _this4._animatorFactory.newAnimator(options);

               _this4.style.display = 'block';
               _this4._mask.style.opacity = '1';

               return new Promise(function (resolve) {
                 contentReady(_this4, function () {
                   animator.show(_this4, function () {
                     _this4._visible = true;
                     unlock();

                     util.triggerElementEvent(_this4, 'postshow', { dialog: _this4 });

                     callback();
                     resolve(_this4);
                   });
                 });
               });
             };

             return {
               v: new Promise(function (resolve) {
                 _this4._doorLock.waitUnlock(function () {
                   return resolve(tryShow());
                 });
               })
             };
           }();

           if ((typeof _ret === 'undefined' ? 'undefined' : babelHelpers.typeof(_ret)) === "object") return _ret.v;
         } else {
           return Promise.reject('Canceled in preshow event.');
         }
       }

       /**
        * @method hide
        * @signature hide([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]Animation name. Available animations are `"none"` and `"slide"`.[/en]
        *   [ja]"none", "slide"[/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
        *   [ja]duration, delay, timinge.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`[/ja]
        * @param {Function} [options.callback]
        *   [en]This functions is called after the dialog has been hidden.[/en]
        *   [ja][/ja]
        * @description
        *   [en]Hide the dialog.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Resolves to the hidden element[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'hide',
       value: function hide() {
         var _this5 = this;

         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         var _cancel3 = false;
         var callback = options.callback || function () {};

         options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

         util.triggerElementEvent(this, 'prehide', {
           dialog: this,
           cancel: function cancel() {
             _cancel3 = true;
           }
         });

         if (!_cancel3) {
           var _ret2 = function () {
             var tryHide = function tryHide() {
               var unlock = _this5._doorLock.lock();
               var animator = _this5._animatorFactory.newAnimator(options);

               return new Promise(function (resolve) {
                 contentReady(_this5, function () {
                   animator.hide(_this5, function () {
                     _this5.style.display = 'none';
                     _this5._visible = false;
                     unlock();

                     util.triggerElementEvent(_this5, 'posthide', { dialog: _this5 });

                     callback();
                     resolve(_this5);
                   });
                 });
               });
             };

             return {
               v: new Promise(function (resolve) {
                 _this5._doorLock.waitUnlock(function () {
                   return resolve(tryHide());
                 });
               })
             };
           }();

           if ((typeof _ret2 === 'undefined' ? 'undefined' : babelHelpers.typeof(_ret2)) === "object") return _ret2.v;
         } else {
           return Promise.reject('Canceled in prehide event.');
         }
       }

       /**
        * @property visible
        * @readonly
        * @type {Boolean}
        * @description
        *   [en]Whether the dialog is visible or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'connectedCallback',
       value: function connectedCallback() {
         var _this6 = this;

         this.onDeviceBackButton = function (e) {
           return _this6.cancelable ? _this6._cancel() : e.callParentHandler();
         };

         contentReady(this, function () {
           _this6._mask.addEventListener('click', _this6._boundCancel, false);
         });
       }
     }, {
       key: 'disconnectedCallback',
       value: function disconnectedCallback() {
         this._backButtonHandler.destroy();
         this._backButtonHandler = null;

         this._mask.removeEventListener('click', this._boundCancel.bind(this), false);
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$5);
         } else if (name === 'animation') {
           this._updateAnimatorFactory();
         }
       }

       /**
        * @param {String} name
        * @param {DialogAnimator} Animator
        */

     }, {
       key: '_mask',


       /**
        * @event preshow
        * @description
        * [en]Fired just before the dialog is displayed.[/en]
        * [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.dialog
        *   [en]Component object.[/en]
        *   [ja][/ja]
        * @param {Function} event.cancel
        *   [en]Execute this function to stop the dialog from being shown.[/en]
        *   [ja][/ja]
        */

       /**
        * @event postshow
        * @description
        * [en]Fired just after the dialog is displayed.[/en]
        * [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.dialog
        *   [en]Component object.[/en]
        *   [ja][/ja]
        */

       /**
        * @event prehide
        * @description
        * [en]Fired just before the dialog is hidden.[/en]
        * [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.dialog
        *   [en]Component object.[/en]
        *   [ja][/ja]
        * @param {Function} event.cancel
        *   [en]Execute this function to stop the dialog from being hidden.[/en]
        *   [ja][/ja]
        */

       /**
        * @event posthide
        * @description
        * [en]Fired just after the dialog is hidden.[/en]
        * [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.dialog
        *   [en]Component object.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute modifier
        * @type {String}
        * @description
        *  [en]The appearance of the dialog.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute cancelable
        * @description
        *  [en]If this attribute is set the dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute disabled
        * @description
        *  [en]If this attribute is set the dialog is disabled.[/en]
        *  [ja]disabled[/ja]
        */

       /**
        * @attribute animation
        * @type {String}
        * @default default
        * @description
        *  [en]The animation used when showing and hiding the dialog. Can be either `"none"` or `"default"`.[/en]
        *  [ja]"none""default"[/ja]
        */

       /**
        * @attribute animation-options
        * @type {Expression}
        * @description
        *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
        *  [ja]duration, timing, delaye.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`[/ja]
        */

       /**
        * @attribute mask-color
        * @type {String}
        * @default rgba(0, 0, 0, 0.2)
        * @description
        *  [en]Color of the background mask. Default is `"rgba(0, 0, 0, 0.2)"`.[/en]
        *  [ja]"rgba(0, 0, 0, 0.2)"[/ja]
        */

       get: function get() {
         return util.findChild(this, '.dialog-mask');
       }
     }, {
       key: '_dialog',
       get: function get() {
         return util.findChild(this, '.dialog');
       }
     }, {
       key: 'onDeviceBackButton',
       get: function get() {
         return this._backButtonHandler;
       },
       set: function set(callback) {
         if (this._backButtonHandler) {
           this._backButtonHandler.destroy();
         }

         this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
       }
     }, {
       key: 'visible',
       get: function get() {
         return this._visible;
       }

       /**
        * @property disabled
        * @type {Boolean}
        * @description
        *   [en]Whether the dialog is disabled or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'disabled',
       set: function set(value) {
         return util.toggleAttribute(this, 'disabled', value);
       },
       get: function get() {
         return this.hasAttribute('disabled');
       }

       /**
        * @property cancelable
        * @type {Boolean}
        * @description
        *   [en]Whether the dialog is cancelable or not. A cancelable dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'cancelable',
       set: function set(value) {
         return util.toggleAttribute(this, 'cancelable', value);
       },
       get: function get() {
         return this.hasAttribute('cancelable');
       }
     }], [{
       key: 'registerAnimator',
       value: function registerAnimator(name, Animator) {
         if (!(Animator.prototype instanceof DialogAnimator)) {
           throw new Error('"Animator" param must inherit OnsDialogElement.DialogAnimator');
         }
         _animatorDict$1[name] = Animator;
       }
     }, {
       key: 'observedAttributes',
       get: function get() {
         return ['modifier', 'animation'];
       }
     }, {
       key: 'DialogAnimator',
       get: function get() {
         return DialogAnimator;
       }
     }]);
     return DialogElement;
   }(BaseElement);

   customElements.define('ons-dialog', DialogElement);

   var scheme$6 = {
     '': 'fab--*'
   };

   /**
    * @element ons-fab
    * @category form
    * @description
    *   [en]
    *     The Floating action button is a circular button defined in the [Material Design specification](https://www.google.com/design/spec/components/buttons-floating-action-button.html). They are often used to promote the primary action of the app.
    *
    *     It can be displayed either as an inline element or in one of the corners. Normally it will be positioned in the lower right corner of the screen.
    *   [/en]
    *   [ja][/ja]
    * @tutorial vanilla/Reference/fab
    * @guide cross-platform-styling [en]Information about cross platform styling[/en][ja]Information about cross platform styling[/ja]
    * @seealso ons-speed-dial
    *   [en]The `<ons-speed-dial>` component is a Floating action button that displays a menu when tapped.[/en]
    *   [ja][/ja]
    */

   var FabElement = function (_BaseElement) {
     babelHelpers.inherits(FabElement, _BaseElement);

     function FabElement() {
       babelHelpers.classCallCheck(this, FabElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(FabElement).apply(this, arguments));
     }

     babelHelpers.createClass(FabElement, [{
       key: 'init',


       /**
        * @attribute modifier
        * @type {String}
        * @description
        *  [en]The appearance of the button.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute ripple
        * @description
        *  [en]If this attribute is defined, the button will have a ripple effect when tapped.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute position
        * @type {String}
        * @description
        *  [en]The position of the button. Should be a string like `"bottom right"` or `"top left"`. If this attribute is not defined it will be displayed as an inline element.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute disabled
        * @description
        *   [en]Specify if button should be disabled.[/en]
        *   [ja][/ja]
        */

       value: function init() {
         var _this2 = this;

         contentReady(this, function () {
           _this2._compile();
         });
       }
     }, {
       key: '_compile',
       value: function _compile() {
         var _this3 = this;

         autoStyle.prepare(this);

         this.classList.add('fab');

         if (!util.findChild(this, '.fab__icon')) {
           (function () {
             var content = document.createElement('span');
             content.classList.add('fab__icon');

             util.arrayFrom(_this3.childNodes).forEach(function (element) {
               if (!element.tagName || element.tagName.toLowerCase() !== 'ons-ripple') {
                 content.appendChild(element);
               }
             });
             _this3.appendChild(content);
           })();
         }

         this._updateRipple();

         ModifierUtil.initModifier(this, scheme$6);

         this._updatePosition();

         this.show();
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         switch (name) {
           case 'modifier':
             ModifierUtil.onModifierChanged(last, current, this, scheme$6);
             break;
           case 'ripple':
             this._updateRipple();
             break;
           case 'position':
             this._updatePosition();
         }
       }
     }, {
       key: '_show',
       value: function _show() {
         this.show();
       }
     }, {
       key: '_hide',
       value: function _hide() {
         this.hide();
       }
     }, {
       key: '_updateRipple',
       value: function _updateRipple() {
         util.updateRipple(this);
       }
     }, {
       key: '_updatePosition',
       value: function _updatePosition() {
         var position = this.getAttribute('position');
         this.classList.remove('fab--top__left', 'fab--bottom__right', 'fab--bottom__left', 'fab--top__right', 'fab--top__center', 'fab--bottom__center');
         switch (position) {
           case 'top right':
           case 'right top':
             this.classList.add('fab--top__right');
             break;
           case 'top left':
           case 'left top':
             this.classList.add('fab--top__left');
             break;
           case 'bottom right':
           case 'right bottom':
             this.classList.add('fab--bottom__right');
             break;
           case 'bottom left':
           case 'left bottom':
             this.classList.add('fab--bottom__left');
             break;
           case 'center top':
           case 'top center':
             this.classList.add('fab--top__center');
             break;
           case 'center bottom':
           case 'bottom center':
             this.classList.add('fab--bottom__center');
             break;
           default:
             break;
         }
       }

       /**
        * @method show
        * @signature show()
        * @description
        *  [en]Show the floating action button.[/en]
        *  [ja][/ja]
        */

     }, {
       key: 'show',
       value: function show() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         this.style.transform = 'scale(1)';
         this.style.webkitTransform = 'scale(1)';
       }

       /**
        * @method hide
        * @signature hide()
        * @description
        *  [en]Hide the floating action button.[/en]
        *  [ja][/ja]
        */

     }, {
       key: 'hide',
       value: function hide() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         this.style.transform = 'scale(0)';
         this.style.webkitTransform = 'scale(0)';
       }

       /**
        * @property disabled
        * @type {Boolean}
        * @description
        *   [en]Whether the element is disabled or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'toggle',


       /**
        * @method toggle
        * @signature toggle()
        * @description
        *   [en]Toggle the visibility of the button.[/en]
        *   [ja][/ja]
        */
       value: function toggle() {
         this.visible ? this.hide() : this.show();
       }
     }, {
       key: 'disabled',
       set: function set(value) {
         return util.toggleAttribute(this, 'disabled', value);
       },
       get: function get() {
         return this.hasAttribute('disabled');
       }

       /**
        * @property visible
        * @readonly
        * @type {Boolean}
        * @description
        *   [en]Whether the element is visible or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'visible',
       get: function get() {
         return this.style.transform === 'scale(1)' && this.style.display !== 'none';
       }
     }], [{
       key: 'observedAttributes',
       get: function get() {
         return ['modifier', 'ripple', 'position'];
       }
     }]);
     return FabElement;
   }(BaseElement);

   customElements.define('ons-fab', FabElement);

   /**
    * @element ons-gesture-detector
    * @category gesture
    * @description
    *   [en]
    *     Component to detect finger gestures within the wrapped element. Following gestures are supported:
    *     - Drag gestures: `drag`, `dragleft`, `dragright`, `dragup`, `dragdown`
    *     - Hold gestures: `hold`, `release`
    *     - Swipe gestures: `swipe`, `swipeleft`, `swiperight`, `swipeup`, `swipedown`
    *     - Tap gestures: `tap`, `doubletap`
    *     - Pinch gestures: `pinch`, `pinchin`, `pinchout`
    *     - Other gestures: `touch`, `transform`, `rotate`
    *   [/en]
    *   [ja][/ja]
    * @guide gesture-detector
    *   [en]Detecting finger gestures[/en]
    *   [ja][/ja]
    * @example
    * <ons-gesture-detector>
    *   <div id="detect-area" style="width: 100px; height: 100px;">
    *     Swipe Here
    *   </div>
    * </ons-gesture-detector>
    *
    * <script>
    *   document.addEventListener('swipeleft', function(event) {
    *     if (event.target.matches('#detect-area')) {
    *       console.log('Swipe left is detected.');
    *     }
    *   });
    * </script>
    */

   var GestureDetectorElement = function (_BaseElement) {
     babelHelpers.inherits(GestureDetectorElement, _BaseElement);

     function GestureDetectorElement() {
       babelHelpers.classCallCheck(this, GestureDetectorElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(GestureDetectorElement).apply(this, arguments));
     }

     babelHelpers.createClass(GestureDetectorElement, [{
       key: 'init',
       value: function init() {
         this._gestureDetector = new GestureDetector(this);
       }
     }]);
     return GestureDetectorElement;
   }(BaseElement);

   customElements.define('ons-gesture-detector', GestureDetectorElement);

   /**
    * @element ons-icon
    * @category visual
    * @description
    *   [en]
    *     Displays an icon. The following icon suites are available:
    *
    *     * [Font Awesome](https://fortawesome.github.io/Font-Awesome/)
    *     * [Ionicons](http://ionicons.com/)
    *     * [Material Design Iconic Font](http://zavoloklom.github.io/material-design-iconic-font/)
    *   [/en]
    *   [ja][/ja]
    * @codepen xAhvg
    * @tutorial vanilla/Reference/icon
    * @guide cross-platform-styling [en]Information about cross platform styling[/en][ja]Information about cross platform styling[/ja]
    * @example
    * <ons-icon
    *   icon="md-car"
    *   size="20px"
    *   style="color: red">
    * </ons-icon>
    *
    * <ons-button>
    *   <ons-icon icon="md-car"></ons-icon>
    *   Car
    * </ons-button>
    */

   var IconElement = function (_BaseElement) {
     babelHelpers.inherits(IconElement, _BaseElement);

     function IconElement() {
       babelHelpers.classCallCheck(this, IconElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(IconElement).apply(this, arguments));
     }

     babelHelpers.createClass(IconElement, [{
       key: 'init',


       /**
        * @attribute icon
        * @type {String}
        * @description
        *   [en]
        *     The icon name. `"md-"` prefix for Material Icons, `"fa-"` for Font Awesome and `"ion-"` prefix for Ionicons.
        *
        *     See all available icons on their respective sites:
        *
        *     * [Font Awesome](https://fortawesome.github.io/Font-Awesome/)
        *     * [Ionicons](http://ionicons.com)
        *     * [Material Design Iconic Font](http://zavoloklom.github.io/material-design-iconic-font/)
        *
        *     Icons can also be styled based on modifier presence. Add comma-separated icons with `"modifierName:"` prefix.
        *
        *     The code:
        *
        *     ```
        *     <ons-icon
        *       icon="ion-edit, material:md-edit">
        *     </ons-icon>
        *     ```
        *
        *     will display `"md-edit"` for Material Design and `"ion-edit"` as the default icon.
        *   [/en]
        *   [ja][/ja]
        */

       /**
        * @attribute size
        * @type {String}
        * @description
        *   [en]
        *     The sizes of the icon. Valid values are lg, 2x, 3x, 4x, 5x, or in the size in pixels.
        *     Icons can also be styled based on modifier presence. Add comma-separated icons with `"modifierName:"` prefix.
        *
        *     The code:
        *
        *     ```
        *     <ons-icon
        *       icon="ion-edit"
        *       size="32px, material:24px">
        *     </ons-icon>
        *     ```
        *
        *     will render as a `24px` icon if the `"material"` modifier is present and `32px` otherwise.
        *   [/en]
        *   [ja][/ja]
        */

       /**
        * @attribute rotate
        * @type {Number}
        * @description
        *   [en]Number of degrees to rotate the icon. Valid values are 90, 180 and 270.[/en]
        *   [ja]90, 180, 270[/ja]
        */

       /**
        * @attribute fixed-width
        * @type {Boolean}
        * @default false
        * @description
        *  [en]When used in a list, you want the icons to have the same width so that they align vertically by defining this attribute.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute spin
        * @description
        *   [en]Specify whether the icon should be spinning.[/en]
        *   [ja][/ja]
        */

       value: function init() {
         this._compile();
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (['icon', 'size', 'modifier'].indexOf(name) !== -1) {
           this._update();
         }
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);
         this._update();
       }
     }, {
       key: '_update',
       value: function _update() {
         var _this2 = this;

         this._cleanClassAttribute();

         var _buildClassAndStyle2 = this._buildClassAndStyle(this._getAttribute('icon'), this._getAttribute('size'));

         var classList = _buildClassAndStyle2.classList;
         var style = _buildClassAndStyle2.style;

         util.extend(this.style, style);

         classList.forEach(function (className) {
           return _this2.classList.add(className);
         });
       }
     }, {
       key: '_getAttribute',
       value: function _getAttribute(attr) {
         var parts = (this.getAttribute(attr) || '').split(/\s*,\s*/);
         var def = parts[0];
         var md = parts[1];
         md = (md || '').split(/\s*:\s*/);
         return (util.hasModifier(this, md[0]) ? md[1] : def) || '';
       }

       /**
        * Remove unneeded class value.
        */

     }, {
       key: '_cleanClassAttribute',
       value: function _cleanClassAttribute() {
         var _this3 = this;

         util.arrayFrom(this.classList).filter(function (className) {
           return (/^(fa$|fa-|ion-|zmdi-)/.test(className)
           );
         }).forEach(function (className) {
           return _this3.classList.remove(className);
         });

         this.classList.remove('zmdi');
         this.classList.remove('ons-icon--ion');
       }
     }, {
       key: '_buildClassAndStyle',
       value: function _buildClassAndStyle(iconName, size) {
         var classList = ['ons-icon'];
         var style = {};

         // Icon
         if (iconName.indexOf('ion-') === 0) {
           classList.push(iconName);
           classList.push('ons-icon--ion');
         } else if (iconName.indexOf('fa-') === 0) {
           classList.push(iconName);
           classList.push('fa');
         } else if (iconName.indexOf('md-') === 0) {
           classList.push('zmdi');
           classList.push('zmdi-' + iconName.split(/\-(.+)?/)[1]);
         } else {
           classList.push('fa');
           classList.push('fa-' + iconName);
         }

         // Size
         if (size.match(/^[1-5]x|lg$/)) {
           classList.push('fa-' + size);
           this.style.removeProperty('font-size');
         } else {
           style.fontSize = size;
         }

         return {
           classList: classList,
           style: style
         };
       }
     }], [{
       key: 'observedAttributes',
       get: function get() {
         return ['icon', 'size', 'modifier'];
       }
     }]);
     return IconElement;
   }(BaseElement);

   customElements.define('ons-icon', IconElement);

   /**
    * @element ons-lazy-repeat
    * @category list
    * @description
    *   [en]
    *     Using this component a list with millions of items can be rendered without a drop in performance.
    *     It does that by "lazily" loading elements into the DOM when they come into view and
    *     removing items from the DOM when they are not visible.
    *   [/en]
    *   [ja]
    *     DOM
    *     
    *     
    *   [/ja]
    * @codepen QwrGBm
    * @tutorial vanilla/Reference/lazy-repeat
    * @seealso ons-list
    *   [en]The `<ons-list>` element is used to render a list.[/en]
    *   [ja]`<ons-list>`[/ja]
    * @guide infinite-scroll
    *   [en]Loading more items on infinite scroll[/en]
    *   [ja]Loading more items on infinite scroll[/ja]
    * @example
    * <script>
    *   window.addEventListener('load', function() {
    *     var lazyRepeat = document.querySelector('#list');
    *     lazyRepeat.delegate = {
    *      createItemContent: function(i, template) {
    *        var dom = template.cloneNode(true);
    *        dom.innerText = i;
    *
    *        return dom;
    *      },
    *      countItems: function() {
    *        return 10000000;
    *      },
    *      destroyItem: function(index, item) {
    *        console.log('Destroyed item with index: ' + index);
    *      }
    *     };
    *   });
    * </script>
    *
    * <ons-list id="list">
    *   <ons-lazy-repeat>
    *     <ons-list-item></ons-list-item>
    *   </ons-lazy-repeat>
    * </ons-list>
    */

   var LazyRepeatElement = function (_BaseElement) {
     babelHelpers.inherits(LazyRepeatElement, _BaseElement);

     function LazyRepeatElement() {
       babelHelpers.classCallCheck(this, LazyRepeatElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(LazyRepeatElement).apply(this, arguments));
     }

     babelHelpers.createClass(LazyRepeatElement, [{
       key: 'connectedCallback',
       value: function connectedCallback() {
         util.updateParentPosition(this);

         // not very good idea and also not documented
         if (this.hasAttribute('delegate')) {
           this.delegate = window[this.getAttribute('delegate')];
         }
       }

       /**
        * @property delegate
        * @type {Object}
        * @description
        *  [en]Specify a delegate object to load and unload item elements.[/en]
        *  [ja][/ja]
        */

       /**
        * @property delegate.createItemContent
        * @type {Function}
        * @description
        *   [en]
        *     This function should return a `HTMLElement`.
        *
        *     To help rendering the element, the current index and a template is supplied as arguments. The template is the initial content of the `<ons-lazy-repeat>` element.
        *   [/en]
        *   [ja]
        *     `HTMLElement`
        *     
        *     `<ons-lazy-repeat>`
        *   [/ja]
        */

       /**
        * @property delegate.countItems
        * @type {Function}
        * @description
        *   [en]Should return the number of items in the list.[/en]
        *   [ja][/ja]
        */

       /**
        * @property delegate.calculateItemHeight
        * @type {Function}
        * @description
        *   [en]
        *     Should return the height of an item. The index is provided as an argument.
        *
        *     This is important when rendering lists where the items have different height.
        *
        *     The function is optional and if it isn't present the height of the first item will be automatically calculated and used for all other items.
        *   [/en]
        *   [ja]
        *     ()
        *     
        *     
        *     
        *   [/ja]
        */

       /**
        * @property delegate.destroyItem
        * @type {Function}
        * @description
        *   [en]
        *     This function is used called when an item is removed from the DOM. The index and DOM element is provided as arguments.
        *
        *     The function is optional but may be important in order to avoid memory leaks.
        *   [/en]
        *   [ja]
        *     DOM
        *     DOM
        *     
        *   [/ja]
        */

     }, {
       key: 'refresh',


       /**
        * @method refresh
        * @signature refresh()
        * @description
        *   [en]Refresh the list. Use this method when the data has changed.[/en]
        *   [ja][/ja]
        */
       value: function refresh() {
         this._lazyRepeatProvider && this._lazyRepeatProvider.refresh();
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {}
     }, {
       key: 'disconnectedCallback',
       value: function disconnectedCallback() {
         if (this._lazyRepeatProvider) {
           this._lazyRepeatProvider.destroy();
           this._lazyRepeatProvider = null;
         }
       }
     }, {
       key: 'delegate',
       set: function set(userDelegate) {
         this._lazyRepeatProvider && this._lazyRepeatProvider.destroy();

         if (!this._templateElement && this.children[0]) {
           this._templateElement = this.removeChild(this.children[0]);
         }

         var delegate = new LazyRepeatDelegate(userDelegate, this._templateElement || null);
         this._lazyRepeatProvider = new LazyRepeatProvider(this.parentElement, delegate);
       },
       get: function get() {
         throw new Error('This property can only be used to set the delegate object.');
       }
     }]);
     return LazyRepeatElement;
   }(BaseElement);

   customElements.define('ons-lazy-repeat', LazyRepeatElement);

   var scheme$7 = { '': 'list__header--*' };

   /**
    * @element ons-list-header
    * @category list
    * @description
    *   [en]Header element for list items. Must be put inside the `<ons-list>` component.[/en]
    *   [ja]ons-list[/ja]
    * @seealso ons-list
    *   [en]The `<ons-list>` component[/en]
    *   [ja]ons-list[/ja]
    * @seealso ons-list-item
    *   [en]The `<ons-list-item>` component[/en]
    *   [ja]ons-list-item[/ja]
    * @guide lists [en]Using lists[/en][ja][/ja]
    * @codepen yxcCt
    * @tutorial vanilla/Reference/list
    * @modifier material
    *   [en]Display a Material Design list header.[/en]
    *   [ja][/ja]
    * @example
    * <ons-list>
    *   <ons-list-header>Header Text</ons-list-header>
    *   <ons-list-item>Item</ons-list-item>
    *   <ons-list-item>Item</ons-list-item>
    * </ons-list>
    */

   var ListHeaderElement = function (_BaseElement) {
     babelHelpers.inherits(ListHeaderElement, _BaseElement);

     function ListHeaderElement() {
       babelHelpers.classCallCheck(this, ListHeaderElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ListHeaderElement).apply(this, arguments));
     }

     babelHelpers.createClass(ListHeaderElement, [{
       key: 'init',


       /**
        * @attribute modifier
        * @type {String}
        * @description
        *   [en]The appearance of the list header.[/en]
        *   [ja][/ja]
        */

       value: function init() {
         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         this.classList.add('list__header');
         ModifierUtil.initModifier(this, scheme$7);

         this.setAttribute('_compiled', '');
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$7);
         }
       }
     }], [{
       key: 'observedAttributes',
       get: function get() {
         return ['modifier'];
       }
     }]);
     return ListHeaderElement;
   }(BaseElement);

   customElements.define('ons-list-header', ListHeaderElement);

   var scheme$8 = {
     '.list__item': 'list__item--*',
     '.list__item__left': 'list__item--*__left',
     '.list__item__center': 'list__item--*__center',
     '.list__item__right': 'list__item--*__right',
     '.list__item__label': 'list__item--*__label',
     '.list__item__title': 'list__item--*__title',
     '.list__item__subtitle': 'list__item--*__subtitle',
     '.list__item__thumbnail': 'list__item--*__thumbnail',
     '.list__item__icon': 'list__item--*__icon'
   };

   /**
    * @element ons-list-item
    * @category list
    * @modifier tappable
    *   [en]Make the list item change appearance when it's tapped. On iOS it is better to use the "tappable" and "tap-background-color" attribute for better behavior when scrolling.[/en]
    *   [ja][/ja]
    * @modifier chevron
    *   [en]Display a chevron at the right end of the list item and make it change appearance when tapped. The chevron is not displayed in Material Design.[/en]
    *   [ja][/ja]
    * @modifier longdivider
    *   [en]Displays a long horizontal divider between items.[/en]
    *   [ja][/ja]
    * @modifier nodivider
    *   [en]Removes the divider between list items.[/en]
    *   [ja][/ja]
    * @modifier material
    *   [en]Display a Material Design list item.[/en]
    *   [ja][/ja]
    * @description
    *   [en]
    *     Component that represents each item in the list. Must be put inside the `<ons-list>` component.
    *
    *     The list item is composed of three parts that are represented with the `left`, `center` and `right` classes. These classes can be used to ensure that the content of the list items is properly aligned.
    *
    *     ```
    *     <ons-list-item>
    *       <div class="left">Left</div>
    *       <div class="center">Center</div>
    *       <div class="right">Right</div>
    *     </ons-list-item>
    *     ```
    *
    *     There is also a number of classes (prefixed with `list__item__*`) that help when putting things like icons and thumbnails into the list items.
    *   [/en]
    *   [ja][/ja]
    * @seealso ons-list
    *   [en]ons-list component[/en]
    *   [ja]ons-list[/ja]
    * @seealso ons-list-header
    *   [en]ons-list-header component[/en]
    *   [ja]ons-list-header[/ja]
    * @guide lists
    *   [en]Using lists[/en]
    *   [ja][/ja]
    * @codepen yxcCt
    * @tutorial vanilla/Reference/list
    * @example
    * <ons-list-item>
    *   <div class="left">
    *     <ons-icon icon="md-face" class="list__item__icon"></ons-icon>
    *   </div>
    *   <div class="center">
    *     <div class="list__item__title">Title</div>
    *     <div class="list__item__subtitle">Subtitle</div>
    *   </div>
    *   <div class="right">
    *     <ons-switch></ons-switch>
    *   </div>
    * </ons-list-item>
    */

   var ListItemElement = function (_BaseElement) {
     babelHelpers.inherits(ListItemElement, _BaseElement);

     function ListItemElement() {
       babelHelpers.classCallCheck(this, ListItemElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ListItemElement).apply(this, arguments));
     }

     babelHelpers.createClass(ListItemElement, [{
       key: 'init',


       /**
        * @attribute modifier
        * @type {String}
        * @description
        *   [en]The appearance of the list item.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute lock-on-drag
        * @type {String}
        * @description
        *   [en]Prevent vertical scrolling when the user drags horizontally.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute tappable
        * @type {Boolean}
        * @description
        *   [en]Makes the element react to taps.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute tap-background-color
        * @type {Color}
        * @description
        *   [en] Changes the background color when tapped. For this to work, the attribute "tappable" needs to be set. The default color is "#d9d9d9". It will display as a ripple effect on Android.[/en]
        *   [ja][/ja]
        */

       value: function init() {
         var _this2 = this;

         contentReady(this, function () {
           _this2._compile();
         });
       }
     }, {
       key: '_compile',
       value: function _compile() {
         this.classList.add('list__item');

         var left = void 0,
             center = void 0,
             right = void 0;

         for (var i = 0; i < this.children.length; i++) {
           var el = this.children[i];

           if (el.classList.contains('left')) {
             el.classList.add('list__item__left');
             left = el;
           } else if (el.classList.contains('center')) {
             center = el;
           } else if (el.classList.contains('right')) {
             el.classList.add('list__item__right');
             right = el;
           }
         }

         if (!center) {
           center = document.createElement('div');

           if (!left && !right) {
             while (this.childNodes[0]) {
               center.appendChild(this.childNodes[0]);
             }
           } else {
             for (var _i = this.childNodes.length - 1; _i >= 0; _i--) {
               var _el = this.childNodes[_i];
               if (_el !== left && _el !== right) {
                 center.insertBefore(_el, center.firstChild);
               }
             }
           }

           this.insertBefore(center, right || null);
         }

         center.classList.add('center');
         center.classList.add('list__item__center');

         this._updateRipple();

         ModifierUtil.initModifier(this, scheme$8);

         autoStyle.prepare(this);
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         switch (name) {
           case 'modifier':
             ModifierUtil.onModifierChanged(last, current, this, scheme$8);
             break;
           case 'ripple':
             this._updateRipple();
         }
       }
     }, {
       key: 'connectedCallback',
       value: function connectedCallback() {
         this.addEventListener('drag', this._onDrag);
         this.addEventListener('touchstart', this._onTouch);
         this.addEventListener('mousedown', this._onTouch);
         this.addEventListener('touchend', this._onRelease);
         this.addEventListener('touchmove', this._onRelease);
         this.addEventListener('touchcancel', this._onRelease);
         this.addEventListener('mouseup', this._onRelease);
         this.addEventListener('mouseout', this._onRelease);
         this.addEventListener('touchleave', this._onRelease);

         this._originalBackgroundColor = this.style.backgroundColor;

         this.tapped = false;
       }
     }, {
       key: 'disconnectedCallback',
       value: function disconnectedCallback() {
         this.removeEventListener('drag', this._onDrag);
         this.removeEventListener('touchstart', this._onTouch);
         this.removeEventListener('mousedown', this._onTouch);
         this.removeEventListener('touchend', this._onRelease);
         this.removeEventListener('touchmove', this._onRelease);
         this.removeEventListener('touchcancel', this._onRelease);
         this.removeEventListener('mouseup', this._onRelease);
         this.removeEventListener('mouseout', this._onRelease);
         this.removeEventListener('touchleave', this._onRelease);
       }
     }, {
       key: '_updateRipple',
       value: function _updateRipple() {
         util.updateRipple(this);
       }
     }, {
       key: '_onDrag',
       value: function _onDrag(event) {
         var gesture = event.gesture;
         // Prevent vertical scrolling if the users pans left or right.
         if (this._shouldLockOnDrag() && ['left', 'right'].indexOf(gesture.direction) > -1) {
           gesture.preventDefault();
         }
       }
     }, {
       key: '_onTouch',
       value: function _onTouch() {
         if (this.tapped) {
           return;
         }

         this.tapped = true;

         this.style.transition = this._transition;
         this.style.webkitTransition = this._transition;
         this.style.MozTransition = this._transition;

         if (this._tappable) {
           if (this.style.backgroundColor) {
             this._originalBackgroundColor = this.style.backgroundColor;
           }

           this.style.backgroundColor = this._tapBackgroundColor;
           this.style.boxShadow = '0px -1px 0px 0px ' + this._tapBackgroundColor;
         }
       }
     }, {
       key: '_onRelease',
       value: function _onRelease() {
         this.tapped = false;

         this.style.transition = '';
         this.style.webkitTransition = '';
         this.style.MozTransition = '';

         this.style.backgroundColor = this._originalBackgroundColor || '';
         this.style.boxShadow = '';
       }
     }, {
       key: '_shouldLockOnDrag',
       value: function _shouldLockOnDrag() {
         return this.hasAttribute('lock-on-drag');
       }
     }, {
       key: '_transition',
       get: function get() {
         return 'background-color 0.0s linear 0.02s, box-shadow 0.0s linear 0.02s';
       }
     }, {
       key: '_tappable',
       get: function get() {
         return this.hasAttribute('tappable');
       }
     }, {
       key: '_tapBackgroundColor',
       get: function get() {
         return this.getAttribute('tap-background-color') || '#d9d9d9';
       }
     }], [{
       key: 'observedAttributes',
       get: function get() {
         return ['modifier', 'ripple'];
       }
     }]);
     return ListItemElement;
   }(BaseElement);

   customElements.define('ons-list-item', ListItemElement);

   var scheme$9 = { '': 'list--*' };

   /**
    * @element ons-list
    * @category list
    * @modifier inset
    *   [en]Inset list that doesn't cover the whole width of the parent.[/en]
    *   [ja][/ja]
    * @modifier noborder
    *   [en]A list with no borders at the top and bottom.[/en]
    *   [ja][/ja]
    * @description
    *   [en]Component to define a list, and the container for ons-list-item(s).[/en]
    *   [ja]ons-list-item[/ja]
    * @seealso ons-list-item
    *   [en]ons-list-item component[/en]
    *   [ja]ons-list-item[/ja]
    * @seealso ons-list-header
    *   [en]ons-list-header component[/en]
    *   [ja]ons-list-header[/ja]
    * @seealso ons-lazy-repeat
    *   [en]ons-lazy-repeat component[/en]
    *   [ja]ons-lazy-repeat[/ja]
    * @guide lists
    *   [en]Using lists[/en]
    *   [ja][/ja]
    * @guide infinite-scroll
    *   [en]Loading more items on infinite scroll[/en]
    *   [ja]Loading more items on infinite scroll[/ja]
    * @codepen yxcCt
    * @tutorial vanilla/Reference/list
    * @example
    * <ons-list>
    *   <ons-list-header>Header Text</ons-list-header>
    *   <ons-list-item>Item</ons-list-item>
    *   <ons-list-item>Item</ons-list-item>
    * </ons-list>
    */

   var ListElement = function (_BaseElement) {
     babelHelpers.inherits(ListElement, _BaseElement);

     function ListElement() {
       babelHelpers.classCallCheck(this, ListElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ListElement).apply(this, arguments));
     }

     babelHelpers.createClass(ListElement, [{
       key: 'init',


       /**
        * @attribute modifier
        * @type {String}
        * @description
        *   [en]The appearance of the list.[/en]
        *   [ja][/ja]
        */

       value: function init() {
         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         this.classList.add('list');
         ModifierUtil.initModifier(this, scheme$9);

         this.setAttribute('_compiled', '');
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$9);
         }
       }
     }], [{
       key: 'observedAttributes',
       get: function get() {
         return ['modifier'];
       }
     }]);
     return ListElement;
   }(BaseElement);

   customElements.define('ons-list', ListElement);

   var scheme$10 = {
     '.text-input': 'text-input--*',
     '.text-input__label': 'text-input--*__label',
     '.radio-button': 'radio-button--*',
     '.radio-button__input': 'radio-button--*__input',
     '.radio-button__checkmark': 'radio-button--*__checkmark',
     '.checkbox': 'checkbox--*',
     '.checkbox__input': 'checkbox--*__input',
     '.checkbox__checkmark': 'checkbox--*__checkmark'
   };

   var INPUT_ATTRIBUTES = ['autocapitalize', 'autocomplete', 'autocorrect', 'autofocus', 'disabled', 'inputmode', 'max', 'maxlength', 'min', 'minlength', 'name', 'pattern', 'placeholder', 'readonly', 'size', 'step', 'type', 'validator', 'value'];

   /**
    * @element ons-input
    * @category form
    * @modifier material
    *  [en]Displays a Material Design input.[/en]
    *  [ja][/ja]
    * @modifier underbar
    *  [en]Displays a horizontal line underneath a text input.[/en]
    *  [ja][/ja]
    * @description
    *  [en]
    *    An input element. The `type` attribute can be used to change the input type. All text input types as well as `checkbox` and `radio` are supported.
    *
    *    The component will automatically render as a Material Design input on Android devices.
    *
    *    Most attributes that can be used for a normal `<input>` element can also be used on the `<ons-input>` element.
    *  [/en]
    *  [ja][/ja]
    * @codepen ojQxLj
    * @tutorial vanilla/Reference/input
    * @seealso ons-range
    *   [en]The `<ons-range>` element is used to display a range slider.[/en]
    *   [ja][/ja]
    * @seealso ons-switch
    *   [en]The `<ons-switch>` element is used to display a draggable toggle switch.[/en]
    *   [ja][/ja]
    * @guide adding-page-content
    *   [en]Using form components[/en]
    *   [ja][/ja]
    * @guide using-modifier [en]More details about the `modifier` attribute[/en][ja]modifier[/ja]
    * @example
    * <ons-input placeholder="Username" float></ons-input>
    * <ons-input type="checkbox" checked></ons-input>
    */

   var InputElement = function (_BaseElement) {
     babelHelpers.inherits(InputElement, _BaseElement);

     function InputElement() {
       babelHelpers.classCallCheck(this, InputElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(InputElement).apply(this, arguments));
     }

     babelHelpers.createClass(InputElement, [{
       key: 'init',


       /**
        * @attribute placeholder
        * @type {String}
        * @description
        *   [en]Placeholder text. In Material Design, this placeholder will be a floating label.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute float
        * @description
        *  [en]If this attribute is present, the placeholder will be animated in Material Design.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute type
        * @type {String}
        * @description
        *  [en]
        *    Specify the input type. This is the same as the "type" attribute for normal inputs. However, for "range" you should instead use <ons-range> element.
        *
        *    Please take a look at [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-type) for an exhaustive list of possible values. Depending on the platform and browser version some of these might not work.
        *  [/en]
        *  [ja][/ja]
        */

       /**
        * @attribute input-id
        * @type {String}
        * @description
        *  [en]Specify the "id" attribute of the inner `<input>` element. This is useful when using <label for="..."> elements.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute content-left
        * @description
        *  [en]The HTML content of `<ons-input>` is placed before the actual input as a label. Omit this to display it after the input.[/en]
        *  [ja][/ja]
        */

       value: function init() {
         var _this2 = this;

         contentReady(this, function () {
           _this2._compile();
           _this2.attributeChangedCallback('checked', null, _this2.getAttribute('checked'));
         });

         this._boundOnInput = this._onInput.bind(this);
         this._boundOnFocusin = this._onFocusin.bind(this);
         this._boundDelegateEvent = this._delegateEvent.bind(this);
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         if (this.children.length !== 0) {
           return;
         }

         var helper = document.createElement('span');
         helper.classList.add('_helper');

         var container = document.createElement('label');
         container.appendChild(document.createElement('input'));
         container.appendChild(helper);

         var label = document.createElement('span');
         label.classList.add('input-label');

         util.arrayFrom(this.childNodes).forEach(function (element) {
           return label.appendChild(element);
         });
         this.hasAttribute('content-left') ? container.insertBefore(label, container.firstChild) : container.appendChild(label);

         this.appendChild(container);

         switch (this.getAttribute('type')) {
           case 'checkbox':
             this.classList.add('checkbox');
             this._input.classList.add('checkbox__input');
             this._helper.classList.add('checkbox__checkmark');
             this._updateBoundAttributes();
             break;

           case 'radio':
             this.classList.add('radio-button');
             this._input.classList.add('radio-button__input');
             this._helper.classList.add('radio-button__checkmark');
             this._updateBoundAttributes();
             break;

           default:
             this._input.classList.add('text-input');
             this._helper.classList.add('text-input__label');
             this._input.parentElement.classList.add('text-input__container');

             this._updateLabel();
             this._updateBoundAttributes();
             this._updateLabelClass();
             break;
         }

         if (this.hasAttribute('input-id')) {
           this._input.id = this.getAttribute('input-id');
         }

         ModifierUtil.initModifier(this, scheme$10);
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         var _this3 = this;

         if (name === 'modifier') {
           return contentReady(this, function () {
             return ModifierUtil.onModifierChanged(last, current, _this3, scheme$10);
           });
         } else if (name === 'placeholder') {
           return contentReady(this, function () {
             return _this3._updateLabel();
           });
         }if (name === 'input-id') {
           contentReady(this, function () {
             return _this3._input.id = current;
           });
         }if (name === 'checked') {
           this.checked = current !== null;
         } else if (INPUT_ATTRIBUTES.indexOf(name) >= 0) {
           return contentReady(this, function () {
             return _this3._updateBoundAttributes();
           });
         }
       }
     }, {
       key: 'connectedCallback',
       value: function connectedCallback() {
         var _this4 = this;

         contentReady(this, function () {
           if (_this4._input.type !== 'checkbox' && _this4._input.type !== 'radio') {
             _this4._input.addEventListener('input', _this4._boundOnInput);
             _this4._input.addEventListener('focusin', _this4._boundOnFocusin);
             _this4._input.addEventListener('focusout', _this4._boundOnFocusout);
           }

           _this4._input.addEventListener('focus', _this4._boundDelegateEvent);
           _this4._input.addEventListener('blur', _this4._boundDelegateEvent);
         });
       }
     }, {
       key: 'disconnectedCallback',
       value: function disconnectedCallback() {
         var _this5 = this;

         contentReady(this, function () {
           _this5._input.removeEventListener('input', _this5._boundOnInput);
           _this5._input.removeEventListener('focusin', _this5._boundOnFocusin);
           _this5._input.removeEventListener('focus', _this5._boundDelegateEvent);
           _this5._input.removeEventListener('blur', _this5._boundDelegateEvent);
         });
       }
     }, {
       key: '_setLabel',
       value: function _setLabel(value) {
         if (typeof this._helper.textContent !== 'undefined') {
           this._helper.textContent = value;
         } else {
           this._helper.innerText = value;
         }
       }
     }, {
       key: '_updateLabel',
       value: function _updateLabel() {
         this._setLabel(this.hasAttribute('placeholder') ? this.getAttribute('placeholder') : '');
       }
     }, {
       key: '_updateBoundAttributes',
       value: function _updateBoundAttributes() {
         var _this6 = this;

         INPUT_ATTRIBUTES.forEach(function (attr) {
           if (_this6.hasAttribute(attr)) {
             _this6._input.setAttribute(attr, _this6.getAttribute(attr));
           } else {
             _this6._input.removeAttribute(attr);
           }
         });
       }
     }, {
       key: '_updateLabelClass',
       value: function _updateLabelClass() {
         if (this.value === '') {
           this._helper.classList.remove('text-input--material__label--active');
         } else if (['checkbox', 'radio'].indexOf(this.getAttribute('type')) === -1) {
           this._helper.classList.add('text-input--material__label--active');
         }
       }
     }, {
       key: '_delegateEvent',
       value: function _delegateEvent(event) {
         var e = new CustomEvent(event.type, {
           bubbles: false,
           cancelable: true
         });

         return this.dispatchEvent(e);
       }
     }, {
       key: '_onInput',
       value: function _onInput(event) {
         this._updateLabelClass();
       }
     }, {
       key: '_onFocusin',
       value: function _onFocusin(event) {
         this._updateLabelClass();
       }
     }, {
       key: '_input',
       get: function get() {
         return this.querySelector('input');
       }
     }, {
       key: '_helper',
       get: function get() {
         return this.querySelector('._helper');
       }

       /**
        * @property value
        * @type {String}
        * @description
        *   [en]The current value of the input.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'value',
       get: function get() {
         return this._input === null ? this.getAttribute('value') : this._input.value;
       },
       set: function set(val) {
         var _this7 = this;

         this.setAttribute('value', val);

         contentReady(this, function () {
           _this7._input.value = val;
           _this7._onInput();
         });

         return val;
       }

       /**
        * @property checked
        * @type {Boolean}
        * @description
        *   [en]Whether the input is checked or not. Only works for `radio` and `checkbox` type inputs.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'checked',
       get: function get() {
         return this._input.checked;
       },
       set: function set(val) {
         var _this8 = this;

         contentReady(this, function () {
           _this8._input.checked = val;
         });
       }

       /**
        * @property disabled
        * @type {Boolean}
        * @description
        *   [en]Whether the input is disabled or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'disabled',
       set: function set(value) {
         return util.toggleAttribute(this, 'disabled', value);
       },
       get: function get() {
         return this.hasAttribute('disabled');
       }
     }, {
       key: '_isTextInput',
       get: function get() {
         return this.type !== 'radio' && this.type !== 'checkbox';
       }
     }, {
       key: 'type',
       get: function get() {
         return this.getAttribute('type');
       }
     }], [{
       key: 'observedAttributes',
       get: function get() {
         return ['modifier', 'placeholder', 'input-id', 'checked'].concat(INPUT_ATTRIBUTES);
       }
     }]);
     return InputElement;
   }(BaseElement);

   customElements.define('ons-input', InputElement);

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */

   var ModalAnimator = function () {

     /**
      * @param {Object} options
      * @param {String} options.timing
      * @param {Number} options.duration
      * @param {Number} options.delay
      */

     function ModalAnimator() {
       var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
       babelHelpers.classCallCheck(this, ModalAnimator);

       this.delay = 0;
       this.duration = 0.2;

       this.timing = options.timing || this.timing;
       this.duration = options.duration !== undefined ? options.duration : this.duration;
       this.delay = options.delay !== undefined ? options.delay : this.delay;
     }

     /**
      * @param {HTMLElement} modal
      * @param {Function} callback
      */


     babelHelpers.createClass(ModalAnimator, [{
       key: "show",
       value: function show(modal, callback) {
         callback();
       }

       /**
        * @param {HTMLElement} modal
        * @param {Function} callback
        */

     }, {
       key: "hide",
       value: function hide(modal, callback) {
         callback();
       }
     }]);
     return ModalAnimator;
   }();

   /**
    * iOS style animator for dialog.
    */

   var FadeModalAnimator = function (_ModalAnimator) {
     babelHelpers.inherits(FadeModalAnimator, _ModalAnimator);

     function FadeModalAnimator(options) {
       babelHelpers.classCallCheck(this, FadeModalAnimator);

       options.timing = options.timing || 'linear';
       options.duration = options.duration || '0.3';
       options.delay = options.delay || 0;

       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(FadeModalAnimator).call(this, options));
     }

     /**
      * @param {HTMLElement} modal
      * @param {Function} callback
      */


     babelHelpers.createClass(FadeModalAnimator, [{
       key: 'show',
       value: function show(modal, callback) {
         callback = callback ? callback : function () {};

         animit(modal).queue({
           opacity: 0
         }).wait(this.delay).queue({
           opacity: 1.0
         }, {
           duration: this.duration,
           timing: this.timing
         }).queue(function (done) {
           callback();
           done();
         }).play();
       }

       /**
        * @param {HTMLElement} modal
        * @param {Function} callback
        */

     }, {
       key: 'hide',
       value: function hide(modal, callback) {
         callback = callback ? callback : function () {};

         animit(modal).queue({
           opacity: 1
         }).wait(this.delay).queue({
           opacity: 0
         }, {
           duration: this.duration,
           timing: this.timing
         }).queue(function (done) {
           callback();
           done();
         }).play();
       }
     }]);
     return FadeModalAnimator;
   }(ModalAnimator);

   var scheme$11 = {
     '': 'modal--*',
     'modal__content': 'modal--*__content'
   };

   var _animatorDict$2 = {
     'default': ModalAnimator,
     'fade': FadeModalAnimator,
     'none': ModalAnimator
   };

   /**
    * @element ons-modal
    * @category dialog
    * @description
    *   [en]
    *     Modal component that masks current screen. Underlying components are not subject to any events while the modal component is shown.
    *
    *     This component can be used to block user input while some operation is running or to show some information to the user.
    *   [/en]
    *   [ja]
    *     
    *     
    *   [/ja]
    * @guide dialogs
    *   [en]Dialog components[/en]
    *   [ja]Dialog components[/ja]
    * @seealso ons-dialog
    *   [en]The `<ons-dialog>` component can be used to create a modal dialog.[/en]
    *   [ja][/ja]
    * @codepen devIg
    * @example
    * <ons-modal id="modal">
    *   Modal content
    * </ons-modal>
    * <script>
    *   var modal = document.getElementById('modal');
    *   modal.show();
    * </script>
    */

   var ModalElement = function (_BaseElement) {
     babelHelpers.inherits(ModalElement, _BaseElement);

     function ModalElement() {
       babelHelpers.classCallCheck(this, ModalElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ModalElement).apply(this, arguments));
     }

     babelHelpers.createClass(ModalElement, [{
       key: 'init',


       /**
        * @attribute animation
        * @type {String}
        * @default default
        * @description
        *  [en]The animation used when showing and hiding the modal. Can be either `"none"` or `"fade"`.[/en]
        *  [ja]"none""fade"[/ja]
        */

       /**
        * @attribute animation-options
        * @type {Expression}
        * @description
        *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
        *  [ja]duration, timing, delaye.g. <code>{duration: 0.2, delay: 1, timing: 'ease-in'}</code>[/ja]
        */

       value: function init() {
         var _this2 = this;

         contentReady(this, function () {
           _this2._compile();
         });

         this._doorLock = new DoorLock();

         this._animatorFactory = new AnimatorFactory({
           animators: _animatorDict$2,
           baseClass: ModalAnimator,
           baseClassName: 'ModalAnimator',
           defaultAnimation: this.getAttribute('animation')
         });
       }

       /**
        * @property onDeviceBackButton
        * @type {Object}
        * @description
        *   [en]Back-button handler.[/en]
        *   [ja][/ja]
        */

     }, {
       key: '_compile',
       value: function _compile() {
         this.style.display = 'none';
         this.style.zIndex = 10001;
         this.classList.add('modal');

         if (!util.findChild(this, '.modal__content')) {
           var content = document.createElement('div');
           content.classList.add('modal__content');

           while (this.childNodes[0]) {
             var node = this.childNodes[0];
             this.removeChild(node);
             content.insertBefore(node, null);
           }

           this.appendChild(content);
         }

         ModifierUtil.initModifier(this, scheme$11);
       }
     }, {
       key: 'disconnectedCallback',
       value: function disconnectedCallback() {
         if (this._backButtonHandler) {
           this._backButtonHandler.destroy();
         }
       }
     }, {
       key: 'connectedCallback',
       value: function connectedCallback() {
         this.onDeviceBackButton = function () {
           return undefined;
         };
       }

       /**
        * @property visible
        * @readonly
        * @type {Boolean}
        * @description
        *   [en]Whether the element is visible or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'show',


       /**
        * @method show
        * @signature show([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]Animation name. Available animations are `"none"` and `"fade"`.[/en]
        *   [ja]"none", "fade"[/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
        *   [ja]duration, delay, timinge.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
        * @description
        *   [en]Show modal.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Resolves to the displayed element[/en]
        *   [ja][/ja]
        */
       value: function show() {
         var _this3 = this;

         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

         var callback = options.callback || function () {};

         var tryShow = function tryShow() {
           var unlock = _this3._doorLock.lock();
           var animator = _this3._animatorFactory.newAnimator(options);

           return new Promise(function (resolve) {
             contentReady(_this3, function () {
               _this3.style.display = 'table';
               animator.show(_this3, function () {
                 unlock();

                 callback();
                 resolve(_this3);
               });
             });
           });
         };

         return new Promise(function (resolve) {
           _this3._doorLock.waitUnlock(function () {
             return resolve(tryShow());
           });
         });
       }

       /**
        * @method toggle
        * @signature toggle([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]Animation name. Available animations are `"none"` and `"fade"`.[/en]
        *   [ja]"none", "fade"[/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
        *   [ja]duration, delay, timinge.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
        * @description
        *   [en]Toggle modal visibility.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'toggle',
       value: function toggle() {
         if (this.visible) {
           return this.hide.apply(this, arguments);
         } else {
           return this.show.apply(this, arguments);
         }
       }

       /**
        * @method hide
        * @signature hide([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]Animation name. Available animations are `"none"` and `"fade"`.[/en]
        *   [ja]"none", "fade"[/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
        *   [ja]duration, delay, timinge.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
        * @description
        *   [en]Hide modal.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Resolves to the hidden element[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'hide',
       value: function hide() {
         var _this4 = this;

         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

         var callback = options.callback || function () {};

         var tryHide = function tryHide() {
           var unlock = _this4._doorLock.lock();
           var animator = _this4._animatorFactory.newAnimator(options);

           return new Promise(function (resolve) {
             contentReady(_this4, function () {
               animator.hide(_this4, function () {
                 _this4.style.display = 'none';
                 unlock();

                 callback();
                 resolve(_this4);
               });
             });
           });
         };

         return new Promise(function (resolve) {
           _this4._doorLock.waitUnlock(function () {
             return resolve(tryHide());
           });
         });
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$11);
         }
       }

       /**
        * @param {String} name
        * @param {Function} Animator
        */

     }, {
       key: 'onDeviceBackButton',
       get: function get() {
         return this._backButtonHandler;
       },
       set: function set(handler) {
         if (this._backButtonHandler) {
           this._backButtonHandler.destroy();
         }

         this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, handler);
       }
     }, {
       key: 'visible',
       get: function get() {
         return this.style.display !== 'none';
       }
     }], [{
       key: 'registerAnimator',
       value: function registerAnimator(name, Animator) {
         if (!(Animator.prototype instanceof ModalAnimator)) {
           throw new Error('"Animator" param must inherit OnsModalElement.ModalAnimator');
         }
         _animatorDict$2[name] = Animator;
       }
     }, {
       key: 'observedAttributes',
       get: function get() {
         return ['modifier'];
       }
     }, {
       key: 'ModalAnimator',
       get: function get() {
         return ModalAnimator;
       }
     }]);
     return ModalElement;
   }(BaseElement);

   customElements.define('ons-modal', ModalElement);

   var NavigatorTransitionAnimator = function () {

     /**
      * @param {Object} options
      * @param {String} options.timing
      * @param {Number} options.duration
      * @param {Number} options.delay
      */

     function NavigatorTransitionAnimator(options) {
       babelHelpers.classCallCheck(this, NavigatorTransitionAnimator);

       options = util.extend({
         timing: 'linear',
         duration: '0.4',
         delay: '0'
       }, options || {});

       this.timing = options.timing;
       this.duration = options.duration;
       this.delay = options.delay;
     }

     babelHelpers.createClass(NavigatorTransitionAnimator, [{
       key: 'push',
       value: function push(enterPage, leavePage, callback) {
         callback();
       }
     }, {
       key: 'pop',
       value: function pop(enterPage, leavePage, callback) {
         callback();
       }
     }], [{
       key: 'extend',
       value: function extend() {
         var properties = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];


         var extendedAnimator = this;
         var newAnimator = function newAnimator() {
           extendedAnimator.apply(this, arguments);
           util.extend(this, properties);
         };

         newAnimator.prototype = this.prototype;

         return newAnimator;
       }
     }]);
     return NavigatorTransitionAnimator;
   }();

   /**
    * Slide animator for navigator transition like iOS's screen slide transition.
    */

   var IOSSlideNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
     babelHelpers.inherits(IOSSlideNavigatorTransitionAnimator, _NavigatorTransitionA);

     function IOSSlideNavigatorTransitionAnimator(options) {
       babelHelpers.classCallCheck(this, IOSSlideNavigatorTransitionAnimator);

       options = util.extend({
         duration: 0.4,
         timing: 'ease',
         delay: 0
       }, options || {});

       var _this = babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(IOSSlideNavigatorTransitionAnimator).call(this, options));

       _this.backgroundMask = util.createElement('\n      <div style="position: absolute; width: 100%; height: 100%;\n        background-color: black; opacity: 0; z-index: 2"></div>\n    ');
       return _this;
     }

     babelHelpers.createClass(IOSSlideNavigatorTransitionAnimator, [{
       key: '_decompose',
       value: function _decompose(page) {
         var toolbar = page._getToolbarElement();
         var left = toolbar._getToolbarLeftItemsElement();
         var right = toolbar._getToolbarRightItemsElement();

         var excludeBackButton = function excludeBackButton(elements) {
           var result = [];

           for (var i = 0; i < elements.length; i++) {
             if (elements[i].nodeName.toLowerCase() !== 'ons-back-button') {
               result.push(elements[i]);
             }
           }

           return result;
         };

         var other = [].concat(left.children.length === 0 ? left : excludeBackButton(left.children)).concat(right.children.length === 0 ? right : excludeBackButton(right.children));

         return {
           toolbarCenter: toolbar._getToolbarCenterItemsElement(),
           backButtonIcon: toolbar._getToolbarBackButtonIconElement(),
           backButtonLabel: toolbar._getToolbarBackButtonLabelElement(),
           other: other,
           content: page._getContentElement(),
           background: page._getBackgroundElement(),
           toolbar: toolbar,
           bottomToolbar: page._getBottomToolbarElement()
         };
       }
     }, {
       key: '_shouldAnimateToolbar',
       value: function _shouldAnimateToolbar(enterPage, leavePage) {
         var bothPageHasToolbar = enterPage._canAnimateToolbar() && leavePage._canAnimateToolbar();

         var noMaterialToolbar = !enterPage._getToolbarElement().classList.contains('navigation-bar--material') && !leavePage._getToolbarElement().classList.contains('navigation-bar--material');

         return bothPageHasToolbar && noMaterialToolbar;
       }
     }, {
       key: '_calculateDelta',
       value: function _calculateDelta(element, decomposition) {
         var title = void 0,
             label = void 0;

         var pageRect = element.getBoundingClientRect();
         if (decomposition.backButtonLabel.classList.contains('back-button__label')) {
           var labelRect = decomposition.backButtonLabel.getBoundingClientRect();
           title = Math.round(pageRect.width / 2 - labelRect.width / 2 - labelRect.left);
         } else {
           title = Math.round(pageRect.width / 2 * 0.6);
         }

         if (decomposition.backButtonIcon.classList.contains('back-button__icon')) {
           label = decomposition.backButtonIcon.getBoundingClientRect().right - 2;
         }

         return { title: title, label: label };
       }

       /**
        * @param {Object} enterPage
        * @param {Object} leavePage
        * @param {Function} callback
        */

     }, {
       key: 'push',
       value: function push(enterPage, leavePage, callback) {
         var _this2 = this;

         this.backgroundMask.remove();
         leavePage.parentNode.insertBefore(this.backgroundMask, leavePage.nextSibling);

         contentReady(enterPage, function () {
           var enterPageDecomposition = _this2._decompose(enterPage);
           var leavePageDecomposition = _this2._decompose(leavePage);

           var delta = _this2._calculateDelta(leavePage, enterPageDecomposition);

           var maskClear = animit(_this2.backgroundMask).saveStyle().queue({
             opacity: 0,
             transform: 'translate3d(0, 0, 0)'
           }).wait(_this2.delay).queue({
             opacity: 0.05
           }, {
             duration: _this2.duration,
             timing: _this2.timing
           }).restoreStyle().queue(function (done) {
             _this2.backgroundMask.remove();
             done();
           });

           var shouldAnimateToolbar = _this2._shouldAnimateToolbar(enterPage, leavePage);

           if (shouldAnimateToolbar) {
             // TODO: Remove this fix
             var enterPageToolbarHeight = enterPageDecomposition.toolbar.getBoundingClientRect().height + 'px';
             _this2.backgroundMask.style.top = enterPageToolbarHeight;

             animit.runAll(maskClear, animit([enterPageDecomposition.content, enterPageDecomposition.bottomToolbar, enterPageDecomposition.background]).saveStyle().queue({
               css: {
                 transform: 'translate3D(100%, 0px, 0px)'
               },
               duration: 0
             }).wait(_this2.delay).queue({
               css: {
                 transform: 'translate3D(0px, 0px, 0px)'
               },
               duration: _this2.duration,
               timing: _this2.timing
             }).restoreStyle(), animit(enterPageDecomposition.toolbar).saveStyle().queue({
               css: {
                 opacity: 0
               },
               duration: 0
             }).queue({
               css: {
                 opacity: 1
               },
               duration: _this2.duration,
               timing: _this2.timing
             }).restoreStyle(), animit(enterPageDecomposition.background).queue({
               css: {
                 top: enterPageToolbarHeight
               },
               duration: 0
             }), animit(enterPageDecomposition.toolbarCenter).saveStyle().queue({
               css: {
                 transform: 'translate3d(125%, 0, 0)',
                 opacity: 1
               },
               duration: 0
             }).wait(_this2.delay).queue({
               css: {
                 transform: 'translate3d(0, 0, 0)',
                 opacity: 1.0
               },
               duration: _this2.duration,
               timing: _this2.timing
             }).restoreStyle(), animit(enterPageDecomposition.backButtonLabel).saveStyle().queue({
               css: {
                 transform: 'translate3d(' + delta.title + 'px, 0, 0)',
                 opacity: 0
               },
               duration: 0
             }).wait(_this2.delay).queue({
               css: {
                 transform: 'translate3d(0, 0, 0)',
                 opacity: 1.0
               },
               duration: _this2.duration,
               timing: _this2.timing
             }).restoreStyle(), animit(enterPageDecomposition.other).saveStyle().queue({
               css: { opacity: 0 },
               duration: 0
             }).wait(_this2.delay).queue({
               css: { opacity: 1 },
               duration: _this2.duration,
               timing: _this2.timing
             }).restoreStyle(), animit([leavePageDecomposition.content, leavePageDecomposition.bottomToolbar, leavePageDecomposition.background]).saveStyle().queue({
               css: {
                 transform: 'translate3D(0, 0, 0)'
               },
               duration: 0
             }).wait(_this2.delay).queue({
               css: {
                 transform: 'translate3D(-25%, 0px, 0px)'
               },
               duration: _this2.duration,
               timing: _this2.timing
             }).restoreStyle().queue(function (done) {
               callback();
               done();
             }), animit(leavePageDecomposition.toolbarCenter).saveStyle().queue({
               css: {
                 transform: 'translate3d(0, 0, 0)',
                 opacity: 1.0
               },
               duration: 0
             }).wait(_this2.delay).queue({
               css: {
                 transform: 'translate3d(-' + delta.title + 'px, 0, 0)',
                 opacity: 0
               },
               duration: _this2.duration,
               timing: _this2.timing
             }).restoreStyle(), animit(leavePageDecomposition.backButtonLabel).saveStyle().queue({
               css: {
                 transform: 'translate3d(0, 0, 0)',
                 opacity: 1.0
               },
               duration: 0
             }).wait(_this2.delay).queue({
               css: {
                 transform: 'translate3d(-' + delta.label + 'px, 0, 0)',
                 opacity: 0
               },
               duration: _this2.duration,
               timing: _this2.timing
             }).restoreStyle(), animit(leavePageDecomposition.other).saveStyle().queue({
               css: { opacity: 1 },
               duration: 0
             }).wait(_this2.delay).queue({
               css: { opacity: 0 },
               duration: _this2.duration,
               timing: _this2.timing
             }).restoreStyle());
           } else {

             animit.runAll(maskClear, animit(enterPage).saveStyle().queue({
               css: {
                 transform: 'translate3D(100%, 0px, 0px)'
               },
               duration: 0
             }).wait(_this2.delay).queue({
               css: {
                 transform: 'translate3D(0px, 0px, 0px)'
               },
               duration: _this2.duration,
               timing: _this2.timing
             }).restoreStyle(), animit(leavePage).saveStyle().queue({
               css: {
                 transform: 'translate3D(0, 0, 0)'
               },
               duration: 0
             }).wait(_this2.delay).queue({
               css: {
                 transform: 'translate3D(-25%, 0px, 0px)'
               },
               duration: _this2.duration,
               timing: _this2.timing
             }).restoreStyle().queue(function (done) {
               callback();
               done();
             }));
           }
         });
       }

       /**
        * @param {Object} enterPage
        * @param {Object} leavePage
        * @param {Function} done
        */

     }, {
       key: 'pop',
       value: function pop(enterPage, leavePage, done) {
         this.backgroundMask.remove();
         enterPage.parentNode.insertBefore(this.backgroundMask, enterPage.nextSibling);

         var enterPageDecomposition = this._decompose(enterPage);
         var leavePageDecomposition = this._decompose(leavePage);

         var delta = this._calculateDelta(leavePage, leavePageDecomposition);

         var maskClear = animit(this.backgroundMask).saveStyle().queue({
           opacity: 0.1,
           transform: 'translate3d(0, 0, 0)'
         }).wait(this.delay).queue({
           opacity: 0
         }, {
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           done();
         });

         var shouldAnimateToolbar = this._shouldAnimateToolbar(enterPage, leavePage);

         if (shouldAnimateToolbar) {
           var enterPageToolbarHeight = enterPageDecomposition.toolbar.getBoundingClientRect().height + 'px';
           this.backgroundMask.style.top = enterPageToolbarHeight;

           animit.runAll(maskClear, animit([enterPageDecomposition.content, enterPageDecomposition.bottomToolbar, enterPageDecomposition.background]).saveStyle().queue({
             css: {
               transform: 'translate3D(-25%, 0px, 0px)',
               opacity: 0.9
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3D(0px, 0px, 0px)',
               opacity: 1.0
             },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle(), animit(enterPageDecomposition.toolbarCenter).saveStyle().queue({
             css: {
               transform: 'translate3d(-' + delta.title + 'px, 0, 0)',
               opacity: 0
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3d(0, 0, 0)',
               opacity: 1.0
             },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle(), animit(enterPageDecomposition.backButtonLabel).saveStyle().queue({
             css: {
               transform: 'translate3d(-' + delta.label + 'px, 0, 0)'
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3d(0, 0, 0)'
             },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle(), animit(enterPageDecomposition.other).saveStyle().queue({
             css: { opacity: 0 },
             duration: 0
           }).wait(this.delay).queue({
             css: { opacity: 1 },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle(), animit(leavePageDecomposition.background).queue({
             css: {
               top: enterPageToolbarHeight
             },
             duration: 0
           }), animit([leavePageDecomposition.content, leavePageDecomposition.bottomToolbar, leavePageDecomposition.background]).queue({
             css: {
               transform: 'translate3D(0px, 0px, 0px)'
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3D(100%, 0px, 0px)'
             },
             duration: this.duration,
             timing: this.timing
           }).wait(0).queue(function (finish) {
             this.backgroundMask.remove();
             done();
             finish();
           }.bind(this)), animit(leavePageDecomposition.toolbar).queue({
             css: {
               opacity: 1
             },
             duration: 0
           }).queue({
             css: {
               opacity: 0
             },
             duration: this.duration,
             timing: this.timing
           }), animit(leavePageDecomposition.toolbarCenter).queue({
             css: {
               transform: 'translate3d(0, 0, 0)'
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3d(125%, 0, 0)'
             },
             duration: this.duration,
             timing: this.timing
           }), animit(leavePageDecomposition.backButtonLabel).queue({
             css: {
               transform: 'translate3d(0, 0, 0)',
               opacity: 1
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3d(' + delta.title + 'px, 0, 0)',
               opacity: 0
             },
             duration: this.duration,
             timing: this.timing
           }));
         } else {
           animit.runAll(maskClear, animit(enterPage).saveStyle().queue({
             css: {
               transform: 'translate3D(-25%, 0px, 0px)',
               opacity: 0.9
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3D(0px, 0px, 0px)',
               opacity: 1.0
             },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle(), animit(leavePage).queue({
             css: {
               transform: 'translate3D(0px, 0px, 0px)'
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3D(100%, 0px, 0px)'
             },
             duration: this.duration,
             timing: this.timing
           }).queue(function (finish) {
             this.backgroundMask.remove();
             done();
             finish();
           }.bind(this)));
         }
       }
     }]);
     return IOSSlideNavigatorTransitionAnimator;
   }(NavigatorTransitionAnimator);

   /**
    * Lift screen transition.
    */

   var IOSLiftNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
     babelHelpers.inherits(IOSLiftNavigatorTransitionAnimator, _NavigatorTransitionA);

     function IOSLiftNavigatorTransitionAnimator(options) {
       babelHelpers.classCallCheck(this, IOSLiftNavigatorTransitionAnimator);

       options = util.extend({
         duration: 0.4,
         timing: 'cubic-bezier(.1, .7, .1, 1)',
         delay: 0
       }, options || {});

       var _this = babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(IOSLiftNavigatorTransitionAnimator).call(this, options));

       _this.backgroundMask = util.createElement('\n      <div style="position: absolute; width: 100%; height: 100%;\n        background: linear-gradient(black, white);"></div>\n    ');
       return _this;
     }

     /**
      * @param {Object} enterPage
      * @param {Object} leavePage
      * @param {Function} callback
      */


     babelHelpers.createClass(IOSLiftNavigatorTransitionAnimator, [{
       key: 'push',
       value: function push(enterPage, leavePage, callback) {
         var _this2 = this;

         this.backgroundMask.remove();
         leavePage.parentNode.insertBefore(this.backgroundMask, leavePage);

         var maskClear = animit(this.backgroundMask).wait(this.delay + this.duration).queue(function (done) {
           _this2.backgroundMask.remove();
           done();
         });

         animit.runAll(maskClear, animit(enterPage).saveStyle().queue({
           css: {
             transform: 'translate3D(0, 100%, 0)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 0, 0)'
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }), animit(leavePage).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 1.0
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, -10%, 0)',
             opacity: 0.9
           },
           duration: this.duration,
           timing: this.timing
         }));
       }

       /**
        * @param {Object} enterPage
        * @param {Object} leavePage
        * @param {Function} callback
        */

     }, {
       key: 'pop',
       value: function pop(enterPage, leavePage, callback) {
         var _this3 = this;

         this.backgroundMask.remove();
         enterPage.parentNode.insertBefore(this.backgroundMask, enterPage);

         animit.runAll(animit(this.backgroundMask).wait(this.delay + this.duration).queue(function (done) {
           _this3.backgroundMask.remove();
           done();
         }), animit(enterPage).queue({
           css: {
             transform: 'translate3D(0, -10%, 0)',
             opacity: 0.9
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 1.0
           },
           duration: this.duration,
           timing: this.timing
         }).queue(function (done) {
           callback();
           done();
         }), animit(leavePage).queue({
           css: {
             transform: 'translate3D(0, 0, 0)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 100%, 0)'
           },
           duration: this.duration,
           timing: this.timing
         }));
       }
     }]);
     return IOSLiftNavigatorTransitionAnimator;
   }(NavigatorTransitionAnimator);

   /**
    * Fade-in screen transition.
    */

   var IOSFadeNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
     babelHelpers.inherits(IOSFadeNavigatorTransitionAnimator, _NavigatorTransitionA);

     function IOSFadeNavigatorTransitionAnimator(options) {
       babelHelpers.classCallCheck(this, IOSFadeNavigatorTransitionAnimator);

       options = util.extend({
         timing: 'linear',
         duration: '0.4',
         delay: '0'
       }, options || {});

       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(IOSFadeNavigatorTransitionAnimator).call(this, options));
     }

     /**
      * @param {Object} enterPage
      * @param {Object} leavePage
      * @param {Function} callback
      */


     babelHelpers.createClass(IOSFadeNavigatorTransitionAnimator, [{
       key: 'push',
       value: function push(enterPage, leavePage, callback) {

         animit.runAll(animit([enterPage._getContentElement(), enterPage._getBackgroundElement()]).saveStyle().queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 0
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 1
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }), animit(enterPage._getToolbarElement()).saveStyle().queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 0
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 1
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle());
       }

       /**
        * @param {Object} enterPage
        * @param {Object} leavePage
        * @param {Function} done
        */

     }, {
       key: 'pop',
       value: function pop(enterPage, leavePage, callback) {
         animit.runAll(animit([leavePage._getContentElement(), leavePage._getBackgroundElement()]).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 1
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 0
           },
           duration: this.duration,
           timing: this.timing
         }).queue(function (done) {
           callback();
           done();
         }), animit(leavePage._getToolbarElement()).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 1
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 0
           },
           duration: this.duration,
           timing: this.timing
         }));
       }
     }]);
     return IOSFadeNavigatorTransitionAnimator;
   }(NavigatorTransitionAnimator);

   /**
    * Slide animator for navigator transition.
    */

   var MDSlideNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
     babelHelpers.inherits(MDSlideNavigatorTransitionAnimator, _NavigatorTransitionA);

     function MDSlideNavigatorTransitionAnimator(options) {
       babelHelpers.classCallCheck(this, MDSlideNavigatorTransitionAnimator);

       options = util.extend({
         duration: 0.3,
         timing: 'cubic-bezier(.1, .7, .4, 1)',
         delay: 0
       }, options || {});

       var _this = babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(MDSlideNavigatorTransitionAnimator).call(this, options));

       _this.backgroundMask = util.createElement('\n      <div style="position: absolute; width: 100%; height: 100%; z-index: 2;\n        background-color: black; opacity: 0;"></div>\n    ');
       _this.blackMaskOpacity = 0.4;
       return _this;
     }

     /**
      * @param {Object} enterPage
      * @param {Object} leavePage
      * @param {Function} callback
      */


     babelHelpers.createClass(MDSlideNavigatorTransitionAnimator, [{
       key: 'push',
       value: function push(enterPage, leavePage, callback) {
         var _this2 = this;

         this.backgroundMask.remove();
         leavePage.parentElement.insertBefore(this.backgroundMask, leavePage.nextSibling);

         animit.runAll(animit(this.backgroundMask).saveStyle().queue({
           opacity: 0,
           transform: 'translate3d(0, 0, 0)'
         }).wait(this.delay).queue({
           opacity: this.blackMaskOpacity
         }, {
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           _this2.backgroundMask.remove();
           done();
         }), animit(enterPage).saveStyle().queue({
           css: {
             transform: 'translate3D(100%, 0, 0)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 0, 0)'
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle(), animit(leavePage).saveStyle().queue({
           css: {
             transform: 'translate3D(0, 0, 0)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(-45%, 0px, 0px)'
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().wait(0.2).queue(function (done) {
           callback();
           done();
         }));
       }

       /**
        * @param {Object} enterPage
        * @param {Object} leavePage
        * @param {Function} done
        */

     }, {
       key: 'pop',
       value: function pop(enterPage, leavePage, done) {
         var _this3 = this;

         this.backgroundMask.remove();
         enterPage.parentNode.insertBefore(this.backgroundMask, enterPage.nextSibling);

         animit.runAll(animit(this.backgroundMask).saveStyle().queue({
           opacity: this.blackMaskOpacity,
           transform: 'translate3d(0, 0, 0)'
         }).wait(this.delay).queue({
           opacity: 0
         }, {
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           _this3.backgroundMask.remove();
           done();
         }), animit(enterPage).saveStyle().queue({
           css: {
             transform: 'translate3D(-45%, 0px, 0px)',
             opacity: 0.9
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0px, 0px, 0px)',
             opacity: 1.0
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle(), animit(leavePage).queue({
           css: {
             transform: 'translate3D(0px, 0px, 0px)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(100%, 0px, 0px)'
           },
           duration: this.duration,
           timing: this.timing
         }).wait(0.2).queue(function (finish) {
           done();
           finish();
         }));
       }
     }]);
     return MDSlideNavigatorTransitionAnimator;
   }(NavigatorTransitionAnimator);

   /**
    * Lift screen transition.
    */

   var MDLiftNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
     babelHelpers.inherits(MDLiftNavigatorTransitionAnimator, _NavigatorTransitionA);

     function MDLiftNavigatorTransitionAnimator(options) {
       babelHelpers.classCallCheck(this, MDLiftNavigatorTransitionAnimator);

       options = util.extend({
         duration: 0.4,
         timing: 'cubic-bezier(.1, .7, .1, 1)',
         delay: 0.05
       }, options || {});

       var _this = babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(MDLiftNavigatorTransitionAnimator).call(this, options));

       _this.backgroundMask = util.createElement('\n      <div style="position: absolute; width: 100%; height: 100%;\n        background-color: black;"></div>\n    ');
       return _this;
     }

     /**
      * @param {Object} enterPage
      * @param {Object} leavePage
      * @param {Function} callback
      */


     babelHelpers.createClass(MDLiftNavigatorTransitionAnimator, [{
       key: 'push',
       value: function push(enterPage, leavePage, callback) {
         var _this2 = this;

         this.backgroundMask.remove();
         leavePage.parentNode.insertBefore(this.backgroundMask, leavePage);

         var maskClear = animit(this.backgroundMask).wait(this.delay + this.duration).queue(function (done) {
           _this2.backgroundMask.remove();
           done();
         });

         animit.runAll(maskClear, animit(enterPage).saveStyle().queue({
           css: {
             transform: 'translate3D(0, 100%, 0)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 0, 0)'
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }), animit(leavePage).queue({
           css: {
             opacity: 1.0
           },
           duration: 0
         }).queue({
           css: {
             opacity: 0.4
           },
           duration: this.duration,
           timing: this.timing
         }));
       }

       /**
        * @param {Object} enterPage
        * @param {Object} leavePage
        * @param {Function} callback
        */

     }, {
       key: 'pop',
       value: function pop(enterPage, leavePage, callback) {
         var _this3 = this;

         this.backgroundMask.remove();
         enterPage.parentNode.insertBefore(this.backgroundMask, enterPage);

         animit.runAll(animit(this.backgroundMask).wait(this.delay + this.duration).queue(function (done) {
           _this3.backgroundMask.remove();
           done();
         }), animit(enterPage).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 0.4
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 1.0
           },
           duration: this.duration,
           timing: this.timing
         }).queue(function (done) {
           callback();
           done();
         }), animit(leavePage).queue({
           css: {
             transform: 'translate3D(0, 0, 0)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 100%, 0)'
           },
           duration: this.duration,
           timing: this.timing
         }));
       }
     }]);
     return MDLiftNavigatorTransitionAnimator;
   }(NavigatorTransitionAnimator);

   /**
    * Fade-in + Lift screen transition.
    */

   var MDFadeNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
     babelHelpers.inherits(MDFadeNavigatorTransitionAnimator, _NavigatorTransitionA);

     function MDFadeNavigatorTransitionAnimator(options) {
       babelHelpers.classCallCheck(this, MDFadeNavigatorTransitionAnimator);

       options = util.extend({
         timing: 'ease-out',
         duration: '0.25',
         delay: '0'
       }, options || {});

       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(MDFadeNavigatorTransitionAnimator).call(this, options));
     }

     /**
      * @param {Object} enterPage
      * @param {Object} leavePage
      * @param {Function} callback
      */


     babelHelpers.createClass(MDFadeNavigatorTransitionAnimator, [{
       key: 'push',
       value: function push(enterPage, leavePage, callback) {

         animit.runAll(animit(enterPage).saveStyle().queue({
           css: {
             transform: 'translate3D(0, 42px, 0)',
             opacity: 0
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 1
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }

       /**
        * @param {Object} enterPage
        * @param {Object} leavePage
        * @param {Function} done
        */

     }, {
       key: 'pop',
       value: function pop(enterPage, leavePage, callback) {
         animit.runAll(animit(leavePage).queue({
           css: {
             transform: 'translate3D(0, 0, 0)'
           },
           duration: 0
         }).wait(0.15).queue({
           css: {
             transform: 'translate3D(0, 38px, 0)'
           },
           duration: this.duration,
           timing: this.timing
         }).queue(function (done) {
           callback();
           done();
         }), animit(leavePage).queue({
           css: {
             opacity: 1
           },
           duration: 0
         }).wait(0.04).queue({
           css: {
             opacity: 0
           },
           duration: this.duration,
           timing: this.timing
         }));
       }
     }]);
     return MDFadeNavigatorTransitionAnimator;
   }(NavigatorTransitionAnimator);

   var NoneNavigatorTransitionAnimator = function (_NavigatorTransitionA) {
     babelHelpers.inherits(NoneNavigatorTransitionAnimator, _NavigatorTransitionA);

     function NoneNavigatorTransitionAnimator(options) {
       babelHelpers.classCallCheck(this, NoneNavigatorTransitionAnimator);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(NoneNavigatorTransitionAnimator).call(this, options));
     }

     babelHelpers.createClass(NoneNavigatorTransitionAnimator, [{
       key: 'push',
       value: function push(enterPage, leavePage, callback) {
         callback();
       }
     }, {
       key: 'pop',
       value: function pop(enterPage, leavePage, callback) {
         callback();
       }
     }]);
     return NoneNavigatorTransitionAnimator;
   }(NavigatorTransitionAnimator);

   var _animatorDict$3 = {
     'default': function _default() {
       return platform.isAndroid() ? MDFadeNavigatorTransitionAnimator : IOSSlideNavigatorTransitionAnimator;
     },
     'slide': function slide() {
       return platform.isAndroid() ? MDSlideNavigatorTransitionAnimator : IOSSlideNavigatorTransitionAnimator;
     },
     'lift': function lift() {
       return platform.isAndroid() ? MDLiftNavigatorTransitionAnimator : IOSLiftNavigatorTransitionAnimator;
     },
     'fade': function fade() {
       return platform.isAndroid() ? MDFadeNavigatorTransitionAnimator : IOSFadeNavigatorTransitionAnimator;
     },
     'slide-ios': IOSSlideNavigatorTransitionAnimator,
     'slide-md': MDSlideNavigatorTransitionAnimator,
     'lift-ios': IOSLiftNavigatorTransitionAnimator,
     'lift-md': MDLiftNavigatorTransitionAnimator,
     'fade-ios': IOSFadeNavigatorTransitionAnimator,
     'fade-md': MDFadeNavigatorTransitionAnimator,
     'none': NoneNavigatorTransitionAnimator
   };

   var rewritables = {
     /**
      * @param {Element} navigatorSideElement
      * @param {Function} callback
      */

     ready: function ready(navigatorElement, callback) {
       callback();
     },


     /**
      * @param {Element} navigatorElement
      * @param {Element} target
      * @param {Object} options
      * @param {Function} callback
      */
     link: function link(navigatorElement, target, options, callback) {
       callback(target);
     }
   };

   /**
    * @element ons-navigator
    * @category navigation
    * @description
    *   [en]
    *     A component that provides page stack management and navigation. Stack navigation is the most common navigation pattern for mobile apps.
    *
    *     When a page is pushed on top of the stack it is displayed with a transition animation. When the user returns to the previous page the top page will be popped from the top of the stack and hidden with an opposite transition animation.
    *   [/en]
    *   [ja][/ja]
    * @codepen yrhtv
    * @tutorial vanilla/Reference/navigator
    * @guide multiple-page-navigation
    *   [en]Guide for page navigation[/en]
    *   [ja][/ja]
    * @guide templates
    *   [en]Defining multiple pages in single html[/en]
    *   [ja]1HTML[/ja]
    * @guide creating-a-page
    *   [en]Setting up a page in its `init` event[/en]
    *   [ja]Setting up a page in its `init` event[/ja]
    * @seealso ons-toolbar
    *   [en]The `<ons-toolbar>` component is used to display a toolbar on the top of a page.[/en]
    *   [ja][/ja]
    * @seealso ons-back-button
    *   [en]The `<ons-back-button>` component lets the user return to the previous page.[/en]
    *   [ja][/ja]
    * @example
    * <ons-navigator id="navigator">
    *   <ons-page>
    *     <ons-toolbar>
    *       <div class="center">
    *         Title
    *       </div>
    *     </ons-toolbar>
    *     <p>
    *       <ons-button
    *         onclick="document.getElementById('navigator').pushPage('page.html')">
    *         Push page
    *       </ons-button>
    *     </p>
    *   </ons-page>
    * </ons-navigator>
    *
    * <ons-template id="page.html">
    *   <ons-page>
    *     <ons-toolbar>
    *       <div class="left">
    *         <ons-back-button>Back</ons-back-button>
    *       </div>
    *       <div class="center">
    *         Another page
    *       </div>
    *     </ons-toolbar>
    *   </ons-page>
    * </ons-template>
    */

   var NavigatorElement = function (_BaseElement) {
     babelHelpers.inherits(NavigatorElement, _BaseElement);

     function NavigatorElement() {
       babelHelpers.classCallCheck(this, NavigatorElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(NavigatorElement).apply(this, arguments));
     }

     babelHelpers.createClass(NavigatorElement, [{
       key: 'init',
       value: function init() {
         this._isRunning = false;
         this._pageLoader = defaultPageLoader;

         this._updateAnimatorFactory();
       }

       /**
        * @property pageLoader
        * @type {PageLoader}
        * @description
        *   [en][/en]
        *   [ja]PageLoader[/ja]
        */

     }, {
       key: '_getPageTarget',
       value: function _getPageTarget() {
         return this._page || this.getAttribute('page');
       }

       /**
        * @property page
        * @type {*}
        * @description
        *   [en][/en]
        *   [ja]`page``page`[/ja]
        */

     }, {
       key: 'connectedCallback',
       value: function connectedCallback() {
         var _this2 = this;

         this.onDeviceBackButton = this._onDeviceBackButton.bind(this);

         rewritables.ready(this, function () {
           if (_this2.pages.length === 0 && _this2._getPageTarget()) {
             _this2.pushPage(_this2._getPageTarget(), { animation: 'none' });
           }if (_this2.pages.length > 0) {
             for (var i = 0; i < _this2.pages.length; i++) {
               if (_this2.pages[i].nodeName !== 'ONS-PAGE') {
                 throw new Error('The children of <ons-navigator> need to be of type <ons-page>');
               }
             }

             if (_this2.topPage) {
               setImmediate(function () {
                 _this2.topPage._show();
                 _this2._updateLastPageBackButton();
               });
             }
           } else {
             contentReady(_this2, function () {
               if (_this2.pages.length === 0 && _this2._getPageTarget()) {
                 _this2.pushPage(_this2._getPageTarget(), { animation: 'none' });
               }
             });
           }
         });
       }
     }, {
       key: '_updateAnimatorFactory',
       value: function _updateAnimatorFactory() {
         this._animatorFactory = new AnimatorFactory({
           animators: _animatorDict$3,
           baseClass: NavigatorTransitionAnimator,
           baseClassName: 'NavigatorTransitionAnimator',
           defaultAnimation: this.getAttribute('animation')
         });
       }
     }, {
       key: 'disconnectedCallback',
       value: function disconnectedCallback() {
         this._backButtonHandler.destroy();
         this._backButtonHandler = null;
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'animation') {
           this._updateAnimatorFactory();
         }
       }

       /**
        * @method popPage
        * @signature popPage([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]
        *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
        *
        *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"`.
        *   [/en]
        *   [ja][/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
        *   [ja]duration, delay, timinge.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
        * @param {Boolean} [options.refresh]
        *   [en]The previous page will be refreshed (destroyed and created again) before popPage action.[/en]
        *   [ja]popPagetrue[/ja]
        * @param {Function} [options.callback]
        *   [en]Function that is called when the transition has ended.[/en]
        *   [ja][/ja]
        * @param {Object} [options.data]
        *   [en]Custom data that will be stored in the new page element.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Promise which resolves to the revealed page.[/en]
        *   [ja]Promise[/ja]
        * @description
        *   [en]Pops the current page from the page stack. The previous page will be displayed.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'popPage',
       value: function popPage() {
         var _this3 = this;

         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         var _preparePageAndOption = this._preparePageAndOptions(null, options);

         options = _preparePageAndOption.options;


         var popUpdate = function popUpdate() {
           return new Promise(function (resolve) {
             _this3.pages[_this3.pages.length - 1]._destroy();
             resolve();
           });
         };

         if (!options.refresh) {
           return this._popPage(options, popUpdate);
         }

         var index = this.pages.length - 2;
         var oldPage = this.pages[index];

         if (!oldPage.name) {
           throw new Error('Refresh option cannot be used with pages directly inside the Navigator. Use ons-template instead.');
         }

         return new Promise(function (resolve) {
           var options = { page: oldPage.name, parent: _this3, params: oldPage.pushedOptions.data };
           _this3._pageLoader.load(options, function (_ref) {
             var element = _ref.element;
             var unload = _ref.unload;

             element = util.extend(element, {
               name: oldPage.name,
               data: oldPage.data,
               pushedOptions: oldPage.pushedOptions,
               unload: unload
             });

             rewritables.link(_this3, element, oldPage.options, function (element) {
               _this3.insertBefore(element, oldPage ? oldPage : null);
               oldPage._destroy();
               resolve();
             });
           });
         }).then(function () {
           return _this3._popPage(options, popUpdate);
         });
       }
     }, {
       key: '_popPage',
       value: function _popPage(options) {
         var _this4 = this;

         var update = arguments.length <= 1 || arguments[1] === undefined ? function () {
           return Promise.resolve();
         } : arguments[1];

         if (this._isRunning) {
           return Promise.reject('popPage is already running.');
         }

         if (this.pages.length <= 1) {
           return Promise.reject('ons-navigator\'s page stack is empty.');
         }

         if (this._emitPrePopEvent()) {
           return Promise.reject('Canceled in prepop event.');
         }

         var length = this.pages.length;

         this._isRunning = true;

         this.pages[length - 2].updateBackButton(length - 2 > 0);

         return new Promise(function (resolve) {
           var leavePage = _this4.pages[length - 1];
           var enterPage = _this4.pages[length - 2];
           enterPage.style.display = 'block';

           options.animation = options.animation || leavePage.pushedOptions.animation;
           options.animationOptions = util.extend({}, leavePage.pushedOptions.animationOptions, options.animationOptions || {});

           if (options.data) {
             enterPage.data = util.extend({}, enterPage.data || {}, options.data || {});
           }

           var callback = function callback() {
             update().then(function () {
               _this4._isRunning = false;

               enterPage._show();
               util.triggerElementEvent(_this4, 'postpop', { leavePage: leavePage, enterPage: enterPage, navigator: _this4 });

               if (typeof options.callback === 'function') {
                 options.callback();
               }

               resolve(enterPage);
             });
           };

           leavePage._hide();
           var animator = _this4._animatorFactory.newAnimator(options);
           animator.pop(_this4.pages[length - 2], _this4.pages[length - 1], callback);
         }).catch(function () {
           return _this4._isRunning = false;
         });
       }

       /**
        * @method pushPage
        * @signature pushPage(page, [options])
        * @param {String} page
        *   [en]Page URL. Can be either a HTML document or a template defined with the `<ons-template>` tag.[/en]
        *   [ja]pageURLons-templateid[/ja]
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {String} [options.page]
        *   [en]Page URL. Only necessary if `page` parameter is null or undefined.[/en]
        *   [ja][/ja]
        * @param {String} [options.pageHTML]
        *   [en]HTML code that will be computed as a new page. Overwrites `page` parameter.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]
        *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
        *
        *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"`.
        *   [/en]
        *   [ja][/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`[/en]
        *   [ja]duration, delay, timinge.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
        * @param {Function} [options.callback]
        *   [en]Function that is called when the transition has ended.[/en]
        *   [ja]pushPage()[/ja]
        * @param {Object} [options.data]
        *   [en]Custom data that will be stored in the new page element.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Promise which resolves to the pushed page.[/en]
        *   [ja]Promise[/ja]
        * @description
        *   [en]Pushes the specified page into the stack.[/en]
        *   [ja]page[/ja]
        */

     }, {
       key: 'pushPage',
       value: function pushPage(page) {
         var _this5 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         var _preparePageAndOption2 = this._preparePageAndOptions(page, options);

         page = _preparePageAndOption2.page;
         options = _preparePageAndOption2.options;


         var prepare = function prepare(element, unload) {
           _this5._verifyPageElement(element);
           element = util.extend(element, {
             name: options.page,
             data: options.data,
             unload: unload
           });
           element.style.display = 'none';
         };

         if (options.pageHTML) {
           return this._pushPage(options, function () {
             return new Promise(function (resolve) {
               instantPageLoader.load({ page: options.pageHTML, parent: _this5, params: options.data }, function (_ref2) {
                 var element = _ref2.element;
                 var unload = _ref2.unload;

                 prepare(element, unload);
                 resolve();
               });
             });
           });
         }

         return this._pushPage(options, function () {
           return new Promise(function (resolve) {
             _this5._pageLoader.load({ page: page, parent: _this5, params: options.data }, function (_ref3) {
               var element = _ref3.element;
               var unload = _ref3.unload;

               prepare(element, unload);
               resolve();
             });
           });
         });
       }
     }, {
       key: '_pushPage',
       value: function _pushPage() {
         var _this6 = this;

         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
         var update = arguments.length <= 1 || arguments[1] === undefined ? function () {
           return Promise.resolve();
         } : arguments[1];

         if (this._isRunning) {
           return Promise.reject('pushPage is already running.');
         }

         if (this._emitPrePushEvent()) {
           return Promise.reject('Canceled in prepush event.');
         }

         this._isRunning = true;

         var animationOptions = AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options'));
         options = util.extend({}, this.options || {}, { animationOptions: animationOptions }, options);

         var animator = this._animatorFactory.newAnimator(options);

         return update().then(function () {
           var pageLength = _this6.pages.length;

           var enterPage = _this6.pages[pageLength - 1];
           var leavePage = _this6.pages[pageLength - 2];

           if (enterPage.nodeName !== 'ONS-PAGE') {
             throw new Error('Only elements of type <ons-page> can be pushed to the navigator');
           }

           enterPage.updateBackButton(pageLength - 1);

           enterPage.pushedOptions = util.extend({}, enterPage.pushedOptions || {}, options || {});
           enterPage.data = util.extend({}, enterPage.data || {}, options.data || {});
           enterPage.name = enterPage.name || options.page;
           enterPage.unload = enterPage.unload || options.unload;

           return new Promise(function (resolve) {
             var done = function done() {
               _this6._isRunning = false;

               if (leavePage) {
                 leavePage.style.display = 'none';
               }

               setImmediate(function () {
                 return enterPage._show();
               });
               util.triggerElementEvent(_this6, 'postpush', { leavePage: leavePage, enterPage: enterPage, navigator: _this6 });

               if (typeof options.callback === 'function') {
                 options.callback();
               }

               resolve(enterPage);
             };

             enterPage.style.display = 'none';

             var push = function push() {
               enterPage.style.display = 'block';
               if (leavePage) {
                 leavePage._hide();
                 animator.push(enterPage, leavePage, done);
               } else {
                 done();
               }
             };

             options._linked ? push() : rewritables.link(_this6, enterPage, options, push);
           });
         }).catch(function (error) {
           _this6._isRunning = false;
           throw error;
         });
       }

       /**
        * @method replacePage
        * @signature replacePage(page, [options])
        * @return {Promise}
        *   [en]Promise which resolves to the new page.[/en]
        *   [ja]Promise[/ja]
        * @description
        *   [en]Replaces the current top page with the specified one. Extends `pushPage()` parameters.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'replacePage',
       value: function replacePage(page) {
         var _this7 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         return this.pushPage(page, options).then(function (resolvedValue) {
           if (_this7.pages.length > 1) {
             _this7.pages[_this7.pages.length - 2]._destroy();
           }
           _this7._updateLastPageBackButton();

           return Promise.resolve(resolvedValue);
         });
       }

       /**
        * @method insertPage
        * @signature insertPage(index, page, [options])
        * @param {Number} index
        *   [en]The index where it should be inserted.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Promise which resolves to the inserted page.[/en]
        *   [ja]Promise[/ja]
        * @description
        *   [en]Insert the specified page into the stack with at a position defined by the `index` argument. Extends `pushPage()` parameters.[/en]
        *   [ja]pageindex[/ja]
        */

     }, {
       key: 'insertPage',
       value: function insertPage(index, page) {
         var _this8 = this;

         var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

         var _preparePageAndOption3 = this._preparePageAndOptions(page, options);

         page = _preparePageAndOption3.page;
         options = _preparePageAndOption3.options;

         index = this._normalizeIndex(index);

         if (index >= this.pages.length) {
           return this.pushPage(page, options);
         }

         page = typeof options.pageHTML === 'string' ? options.pageHTML : page;
         var loader = typeof options.pageHTML === 'string' ? instantPageLoader : this._pageLoader;

         return new Promise(function (resolve) {
           loader.load({ page: page, parent: _this8 }, function (_ref4) {
             var element = _ref4.element;
             var unload = _ref4.unload;

             _this8._verifyPageElement(element);
             element = util.extend(element, {
               name: options.page,
               data: options.data,
               pushedOptions: options,
               unload: unload
             });

             options.animationOptions = util.extend({}, AnimatorFactory.parseAnimationOptionsString(_this8.getAttribute('animation-options')), options.animationOptions || {});

             element.style.display = 'none';
             _this8.insertBefore(element, _this8.pages[index]);
             _this8.topPage.updateBackButton(true);

             rewritables.link(_this8, element, options, function (element) {
               setTimeout(function () {
                 element = null;
                 resolve(_this8.pages[index]);
               }, 1000 / 60);
             });
           });
         });
       }

       /**
        * @method resetToPage
        * @signature resetToPage(page, [options])
        * @return {Promise}
        *   [en]Promise which resolves to the new top page.[/en]
        *   [ja]Promise[/ja]
        * @description
        *   [en]Clears page stack and adds the specified page to the stack. Extends `pushPage()` parameters.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'resetToPage',
       value: function resetToPage(page) {
         var _this9 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         var _preparePageAndOption4 = this._preparePageAndOptions(page, options);

         page = _preparePageAndOption4.page;
         options = _preparePageAndOption4.options;


         if (!options.animator && !options.animation) {
           options.animation = 'none';
         }

         var callback = options.callback;

         options.callback = function () {
           while (_this9.pages.length > 1) {
             _this9.pages[0]._destroy();
           }

           _this9.pages[0].updateBackButton(false);
           callback && callback();
         };

         if (!options.page && !options.pageHTML && this._getPageTarget()) {
           page = options.page = this._getPageTarget();
         }

         return this.pushPage(page, options);
       }

       /**
        * @method bringPageTop
        * @signature bringPageTop(item, [options])
        * @param {String|Number} item
        *   [en]Page URL or index of an existing page in navigator's stack.[/en]
        *   [ja]URLons-navigator[/ja]
        * @return {Promise}
        *   [en]Promise which resolves to the new top page.[/en]
        *   [ja]Promise[/ja]
        * @description
        *   [en]Brings the given page to the top of the page stack if it already exists or pushes it into the stack if doesn't. Extends `pushPage()` parameters.[/en]
        *   [ja]push[/ja]
        */

     }, {
       key: 'bringPageTop',
       value: function bringPageTop(item) {
         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         if (['number', 'string'].indexOf(typeof item === 'undefined' ? 'undefined' : babelHelpers.typeof(item)) === -1) {
           throw new Error('First argument must be a page name or the index of an existing page. You supplied ' + item);
         }
         var index = typeof item === 'number' ? this._normalizeIndex(item) : this._lastIndexOfPage(item);
         var page = this.pages[index];

         if (index < 0) {
           return this.pushPage(item, options);
         }

         var _preparePageAndOption5 = this._preparePageAndOptions(page, options);

         options = _preparePageAndOption5.options;


         if (index === this.pages.length - 1) {
           return Promise.resolve(page);
         }
         if (!page) {
           throw new Error('Failed to find item ' + item);
         }
         if (this._isRunning) {
           return Promise.reject('pushPage is already running.');
         }
         if (this._emitPrePushEvent()) {
           return Promise.reject('Canceled in prepush event.');
         }

         util.extend(options, {
           page: page.name,
           _linked: true
         });
         page.style.display = 'none';
         page.setAttribute('_skipinit', '');
         page.parentNode.appendChild(page);
         return this._pushPage(options);
       }
     }, {
       key: '_preparePageAndOptions',
       value: function _preparePageAndOptions(page) {
         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         if ((typeof options === 'undefined' ? 'undefined' : babelHelpers.typeof(options)) != 'object') {
           throw new Error('options must be an object. You supplied ' + options);
         }

         if ((page === null || page === undefined) && options.page) {
           page = options.page;
         }

         options = util.extend({}, this.options || {}, options, { page: page });

         return { page: page, options: options };
       }
     }, {
       key: '_updateLastPageBackButton',
       value: function _updateLastPageBackButton() {
         var index = this.pages.length - 1;
         if (index >= 0) {
           this.pages[index].updateBackButton(index > 0);
         }
       }
     }, {
       key: '_normalizeIndex',
       value: function _normalizeIndex(index) {
         return index >= 0 ? index : Math.abs(this.pages.length + index) % this.pages.length;
       }
     }, {
       key: '_onDeviceBackButton',
       value: function _onDeviceBackButton(event) {
         if (this.pages.length > 1) {
           this.popPage();
         } else {
           event.callParentHandler();
         }
       }
     }, {
       key: '_lastIndexOfPage',
       value: function _lastIndexOfPage(pageName) {
         var index = void 0;
         for (index = this.pages.length - 1; index >= 0; index--) {
           if (this.pages[index].name === pageName) {
             break;
           }
         }
         return index;
       }
     }, {
       key: '_emitPreEvent',
       value: function _emitPreEvent(name) {
         var data = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         var isCanceled = false;

         util.triggerElementEvent(this, 'pre' + name, util.extend({
           navigator: this,
           currentPage: this.pages[this.pages.length - 1],
           cancel: function cancel() {
             return isCanceled = true;
           }
         }, data));

         return isCanceled;
       }
     }, {
       key: '_emitPrePushEvent',
       value: function _emitPrePushEvent() {
         return this._emitPreEvent('push');
       }
     }, {
       key: '_emitPrePopEvent',
       value: function _emitPrePopEvent() {
         var l = this.pages.length;
         return this._emitPreEvent('pop', {
           leavePage: this.pages[l - 1],
           enterPage: this.pages[l - 2]
         });
       }

       // TODO: 

     }, {
       key: '_createPageElement',
       value: function _createPageElement(templateHTML) {
         var pageElement = util.createElement(internal.normalizePageHTML(templateHTML));
         this._verifyPageElement(pageElement);
         return pageElement;
       }

       /**
        * @param {Element} element
        */

     }, {
       key: '_verifyPageElement',
       value: function _verifyPageElement(element) {
         if (element.nodeName.toLowerCase() !== 'ons-page') {
           throw new Error('You must supply an "ons-page" element to "ons-navigator".');
         }
       }

       /**
        * @property onDeviceBackButton
        * @type {Object}
        * @description
        *   [en]Back-button handler.[/en]
        *   [ja][/ja]
        */

     }, {
       key: '_show',
       value: function _show() {
         if (this.topPage) {
           this.topPage._show();
         }
       }
     }, {
       key: '_hide',
       value: function _hide() {
         if (this.topPage) {
           this.topPage._hide();
         }
       }
     }, {
       key: '_destroy',
       value: function _destroy() {
         for (var i = this.pages.length - 1; i >= 0; i--) {
           this.pages[i]._destroy();
         }

         this.remove();
       }

       /**
        * @param {String} name
        * @param {Function} Animator
        */

     }, {
       key: 'animatorFactory',


       /**
        * @attribute page
        * @initonly
        * @type {String}
        * @description
        *   [en]First page to show when navigator is initialized.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute animation
        * @type {String}
        * @default default
        * @description
        *   [en]
        *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
        *
        *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"` depending on the platform.
        *   [/en]
        *   [ja][/ja]
        */

       /**
        * @attribute animation-options
        * @type {Expression}
        * @description
        *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`[/en]
        *  [ja]duration, timing, delaye.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`[/ja]
        */

       /**
        * @event prepush
        * @description
        *   [en]Fired just before a page is pushed.[/en]
        *   [ja]pagepush[/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.navigator
        *   [en]Component object.[/en]
        *   [ja][/ja]
        * @param {Object} event.currentPage
        *   [en]Current page object.[/en]
        *   [ja]page[/ja]
        * @param {Function} event.cancel
        *   [en]Call this function to cancel the push.[/en]
        *   [ja]push[/ja]
        */

       /**
        * @event prepop
        * @description
        *   [en]Fired just before a page is popped.[/en]
        *   [ja]pagepop[/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.navigator
        *   [en]Component object.[/en]
        *   [ja][/ja]
        * @param {Object} event.currentPage
        *   [en]Current page object.[/en]
        *   [ja]page[/ja]
        * @param {Function} event.cancel
        *   [en]Call this function to cancel the pop.[/en]
        *   [ja]pagepop[/ja]
        */

       /**
        * @event postpush
        * @description
        *   [en]Fired just after a page is pushed.[/en]
        *   [ja]pagepush[/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.navigator
        *   [en]Component object.[/en]
        *   [ja][/ja]
        * @param {Object} event.enterPage
        *   [en]Object of the next page.[/en]
        *   [ja]pushpage[/ja]
        * @param {Object} event.leavePage
        *   [en]Object of the previous page.[/en]
        *   [ja]page[/ja]
        */

       /**
        * @event postpop
        * @description
        *   [en]Fired just after a page is popped.[/en]
        *   [ja]pagepop[/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.navigator
        *   [en]Component object.[/en]
        *   [ja][/ja]
        * @param {Object} event.enterPage
        *   [en]Object of the next page.[/en]
        *   [ja]pop[/ja]
        * @param {Object} event.leavePage
        *   [en]Object of the previous page.[/en]
        *   [ja]pop[/ja]
        */

       get: function get() {
         return this._animatorFactory;
       }
     }, {
       key: 'pageLoader',
       get: function get() {
         return this._pageLoader;
       },
       set: function set(pageLoader) {
         if (!(pageLoader instanceof PageLoader)) {
           throw Error('First parameter must be an instance of PageLoader.');
         }
         this._pageLoader = pageLoader;
       }
     }, {
       key: 'page',
       get: function get() {
         return this._page;
       },
       set: function set(page) {
         this._page = page;
       }
     }, {
       key: 'onDeviceBackButton',
       get: function get() {
         return this._backButtonHandler;
       },
       set: function set(callback) {
         if (this._backButtonHandler) {
           this._backButtonHandler.destroy();
         }

         this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
       }

       /**
        * @property topPage
        * @readonly
        * @type {HTMLElement}
        * @description
        *   [en]Current top page element. Use this method to access options passed by `pushPage()`-like methods.[/en]
        *   [ja]pushPage()resetToPage()[/ja]
        */

     }, {
       key: 'topPage',
       get: function get() {
         return this.pages[this.pages.length - 1] || null;
       }

       /**
        * @property pages
        * @readonly
        * @type {Array}
        * @description
        *   [en]Copy of the navigator's page stack.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'pages',
       get: function get() {
         return util.arrayFrom(this.children).filter(function (n) {
           return n.tagName === 'ONS-PAGE';
         });
       }

       /**
        * @property options
        * @type {Object}
        * @description
        *   [en]Default options object. Attributes have priority over this property.[/en]
        *   [ja][/ja]
        */

       /**
        * @property options.animation
        * @type {String}
        * @description
        *   [en]
        *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
        *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"`.
        *   [/en]
        *   [ja][/ja]
        */

       /**
        * @property options.animationOptions
        * @type {String}
        * @description
        *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
        *   [ja]duration, delay, timinge.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
        */

       /**
        * @property options.callback
        * @type {String}
        * @description
        *   [en]Function that is called when the transition has ended.[/en]
        *   [ja][/ja]
        */

       /**
        * @property options.refresh
        * @default  false
        * @type {Boolean}
        * @description
        *   [en]If this parameter is `true`, the previous page will be refreshed (destroyed and created again) before `popPage()` action.[/en]
        *   [ja]popPagetrue[/ja]
        */

     }, {
       key: 'options',
       get: function get() {
         return this._options;
       },
       set: function set(object) {
         this._options = object;
       }
     }, {
       key: '_isRunning',
       set: function set(value) {
         this.setAttribute('_is-running', value ? 'true' : 'false');
       },
       get: function get() {
         return JSON.parse(this.getAttribute('_is-running'));
       }
     }], [{
       key: 'registerAnimator',
       value: function registerAnimator(name, Animator) {
         if (!(Animator.prototype instanceof NavigatorTransitionAnimator)) {
           throw new Error('"Animator" param must inherit NavigatorElement.NavigatorTransitionAnimator');
         }

         _animatorDict$3[name] = Animator;
       }
     }, {
       key: 'observedAttributes',
       get: function get() {
         return ['animation'];
       }
     }, {
       key: 'animators',
       get: function get() {
         return _animatorDict$3;
       }
     }, {
       key: 'NavigatorTransitionAnimator',
       get: function get() {
         return NavigatorTransitionAnimator;
       }
     }, {
       key: 'rewritables',
       get: function get() {
         return rewritables;
       }
     }]);
     return NavigatorElement;
   }(BaseElement);

   customElements.define('ons-navigator', NavigatorElement);

   var scheme$13 = {
     '': 'navigation-bar--*',
     '.navigation-bar__left': 'navigation-bar--*__left',
     '.navigation-bar__center': 'navigation-bar--*__center',
     '.navigation-bar__right': 'navigation-bar--*__right'
   };

   /**
    * @element ons-toolbar
    * @category page
    * @modifier material
    *   [en]Material Design toolbar.[/en]
    *   [ja][/ja]
    * @modifier transparent
    *   [en]Transparent toolbar[/en]
    *   [ja][/ja]
    * @description
    *   [en]
    *     Toolbar component that can be used with navigation.
    *
    *     Left, center and right container can be specified by class names.
    *
    *     This component will automatically displays as a Material Design toolbar when running on Android devices.
    *   [/en]
    *   [ja][/ja]
    * @codepen aHmGL
    * @tutorial vanilla/Reference/button
    * @guide adding-a-toolbar [en]Adding a toolbar[/en][ja][/ja]
    * @seealso ons-bottom-toolbar
    *   [en]The `<ons-bottom-toolbar>` displays a toolbar on the bottom of the page.[/en]
    *   [ja]ons-bottom-toolbar[/ja]
    * @seealso ons-back-button
    *   [en]The `<ons-back-button>` component displays a back button inside the toolbar.[/en]
    *   [ja]ons-back-button[/ja]
    * @seealso ons-toolbar-button
    *   [en]The `<ons-toolbar-button>` component displays a toolbar button inside the toolbar.[/en]
    *   [ja]ons-toolbar-button[/ja]
    * @example
    * <ons-page>
    *   <ons-toolbar>
    *     <div class="left">
    *       <ons-back-button>
    *         Back
    *       </ons-back-button>
    *     </div>
    *     <div class="center">
    *       Title
    *     </div>
    *     <div class="right">
    *       <ons-toolbar-button>
    *         <ons-icon icon="md-menu"></ons-icon>
    *       </ons-toolbar-button>
    *     </div>
    *   </ons-toolbar>
    * </ons-page>
    */

   var ToolbarElement = function (_BaseElement) {
     babelHelpers.inherits(ToolbarElement, _BaseElement);

     function ToolbarElement() {
       babelHelpers.classCallCheck(this, ToolbarElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ToolbarElement).apply(this, arguments));
     }

     babelHelpers.createClass(ToolbarElement, [{
       key: 'init',


       /**
        * @attribute inline
        * @initonly
        * @description
        *   [en]Display the toolbar as an inline element.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute modifier
        * @description
        *   [en]The appearance of the toolbar.[/en]
        *   [ja][/ja]
        */

       value: function init() {
         var _this2 = this;

         contentReady(this, function () {
           if (!_this2.hasAttribute('_compiled')) {
             _this2._compile();
           }
         });
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$13);
         }
       }

       /**
        * @return {HTMLElement}
        */

     }, {
       key: '_getToolbarLeftItemsElement',
       value: function _getToolbarLeftItemsElement() {
         return this.querySelector('.left') || internal.nullElement;
       }

       /**
        * @return {HTMLElement}
        */

     }, {
       key: '_getToolbarCenterItemsElement',
       value: function _getToolbarCenterItemsElement() {
         return this.querySelector('.center') || internal.nullElement;
       }

       /**
        * @return {HTMLElement}
        */

     }, {
       key: '_getToolbarRightItemsElement',
       value: function _getToolbarRightItemsElement() {
         return this.querySelector('.right') || internal.nullElement;
       }

       /**
        * @return {HTMLElement}
        */

     }, {
       key: '_getToolbarBackButtonLabelElement',
       value: function _getToolbarBackButtonLabelElement() {
         return this.querySelector('ons-back-button .back-button__label') || internal.nullElement;
       }

       /**
        * @return {HTMLElement}
        */

     }, {
       key: '_getToolbarBackButtonIconElement',
       value: function _getToolbarBackButtonIconElement() {
         return this.querySelector('ons-back-button .back-button__icon') || internal.nullElement;
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);
         this.classList.add('navigation-bar');
         this._ensureToolbarItemElements();
         ModifierUtil.initModifier(this, scheme$13);
         this.setAttribute('_compiled', '');
       }
     }, {
       key: '_ensureToolbarItemElements',
       value: function _ensureToolbarItemElements() {
         for (var i = this.childNodes.length - 1; i >= 0; i--) {
           // case of not element
           if (this.childNodes[i].nodeType != 1) {
             this.removeChild(this.childNodes[i]);
           }
         }

         var center = this._ensureToolbarElement('center');
         center.classList.add('navigation-bar__title');

         if (this.children.length !== 1 || !this.children[0].classList.contains('center')) {
           var left = this._ensureToolbarElement('left');
           var right = this._ensureToolbarElement('right');

           if (this.children[0] !== left || this.children[1] !== center || this.children[2] !== right) {
             this.appendChild(left);
             this.appendChild(center);
             this.appendChild(right);
           }
         }
       }
     }, {
       key: '_ensureToolbarElement',
       value: function _ensureToolbarElement(name) {
         var element = util.findChild(this, '.' + name) || util.create('.' + name);

         element.classList.add('navigation-bar__' + name);

         return element;
       }
     }], [{
       key: 'observedAttributes',
       get: function get() {
         return ['modifier'];
       }
     }]);
     return ToolbarElement;
   }(BaseElement);

   customElements.define('ons-toolbar', ToolbarElement);

   // ensures that 'ons-toolbar' element is registered

   var scheme$12 = {
     '': 'page--*',
     '.page__content': 'page--*__content',
     '.page__background': 'page--*__background'
   };

   var nullToolbarElement = document.createElement('ons-toolbar'); // requires that 'ons-toolbar' element is registered

   /**
    * @element ons-page
    * @category page
    * @modifier material
    *   [en]Material Design style[/en]
    *   [ja][/ja]
    * @description
    *   [en]
    *     This component defines the root of each page. If the content is large it will become scrollable.
    *
    *     A navigation bar can be added to the top of the page using the `<ons-toolbar>` element.
    *   [/en]
    *   [ja][/ja]
    * @tutorial vanilla/Reference/page
    * @guide creating-a-page
    *   [en]Setting up a page in its `init` event[/en]
    *   [ja]Setting up a page in its `init` event[/ja]
    * @guide templates
    *   [en]Defining multiple pages in single html[/en]
    *   [ja]1HTML[/ja]
    * @guide multiple-page-navigation
    *   [en]Managing multiple pages[/en]
    *   [ja][/ja]
    * @guide using-modifier [en]More details about the `modifier` attribute[/en][ja]modifier[/ja]
    * @seealso ons-toolbar
    *   [en]Use the `<ons-toolbar>` element to add a navigation bar to the top of the page.[/en]
    *   [ja][/ja]
    * @example
    * <ons-page>
    *   <ons-toolbar>
    *     <div class="left">
    *       <ons-back-button>Back</ons-back-button>
    *     </div>
    *     <div class="center">Title</div>
    *     <div class="right">
    *       <ons-toolbar-button>
    *         <ons-icon icon="md-menu"></ons-icon>
    *       </ons-toolbar-button>
    *     </div>
    *   </ons-toolbar>
    *
    *   <p>Page content</p>
    * </ons-page>
    * 
    * @example
    * <script>
    *   myApp.handler = function(done) {
    *     loadMore().then(done);
    *   }
    * </script>
    *
    * <ons-page on-infinite-scroll="myApp.handler">
    *   <ons-toolbar>
    *     <div class="center">List</div>
    *   </ons-toolbar>
    *
    *   <ons-list>
    *     <ons-list-item>#1</ons-list-item>
    *     <ons-list-item>#2</ons-list-item>
    *     <ons-list-item>#3</ons-list-item>
    *     ...
    *   </ons-list>
    * </ons-page>
    */

   var PageElement = function (_BaseElement) {
     babelHelpers.inherits(PageElement, _BaseElement);

     function PageElement() {
       babelHelpers.classCallCheck(this, PageElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(PageElement).apply(this, arguments));
     }

     babelHelpers.createClass(PageElement, [{
       key: 'init',


       /**
        * @event init
        * @description
        *   [en]Fired right after the page is attached.[/en]
        *   [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        */

       /**
        * @event show
        * @description
        *   [en]Fired right after the page is shown.[/en]
        *   [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        */

       /**
        * @event hide
        * @description
        *   [en]Fired right after the page is hidden.[/en]
        *   [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        */

       /**
        * @event destroy
        * @description
        *   [en]Fired right before the page is destroyed.[/en]
        *   [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        */

       /**
        * @attribute modifier
        * @type {String}
        * @description
        *   [en]Specify modifier name to specify custom styles.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute on-infinite-scroll
        * @type {String}
        * @description
        *   [en]Path of the function to be executed on infinite scrolling. Example: `app.loadData`. The function receives a done callback that must be called when it's finished.[/en]
        *   [ja][/ja]
        */

       value: function init() {
         var _this2 = this;

         this.classList.add('page');

         contentReady(this, function () {
           if (!_this2.hasAttribute('_compiled')) {
             _this2._compile();
           }

           _this2._isShown = false;
           _this2._contentElement = _this2._getContentElement();
           _this2._isMuted = _this2.hasAttribute('_muted');
           _this2._skipInit = _this2.hasAttribute('_skipinit');
           _this2.pushedOptions = {};
         });
       }
     }, {
       key: 'connectedCallback',
       value: function connectedCallback() {
         var _this3 = this;

         contentReady(this, function () {
           if (!_this3._isMuted) {
             if (_this3._skipInit) {
               _this3.removeAttribute('_skipinit');
             } else {
               setImmediate(function () {
                 return util.triggerElementEvent(_this3, 'init');
               });
             }
           }

           if (!util.hasAnyComponentAsParent(_this3)) {
             setImmediate(function () {
               return _this3._show();
             });
           }

           _this3._tryToFillStatusBar();

           if (_this3.hasAttribute('on-infinite-scroll')) {
             _this3.attributeChangedCallback('on-infinite-scroll', null, _this3.getAttribute('on-infinite-scroll'));
           }
         });
       }
     }, {
       key: 'updateBackButton',
       value: function updateBackButton(show) {
         if (this.backButton) {
           show ? this.backButton.show() : this.backButton.hide();
         }
       }
     }, {
       key: '_tryToFillStatusBar',
       value: function _tryToFillStatusBar() {
         var _this4 = this;

         internal.autoStatusBarFill(function () {
           var filled = util.findParent(_this4, function (e) {
             return e.hasAttribute('status-bar-fill');
           });
           util.toggleAttribute(_this4, 'status-bar-fill', !filled && (_this4._canAnimateToolbar() || !_this4._hasAPageControlChild()));
         });
       }
     }, {
       key: '_hasAPageControlChild',
       value: function _hasAPageControlChild() {
         return util.findChild(this._contentElement, function (e) {
           return e.nodeName.match(/ons-(splitter|sliding-menu|navigator|tabbar)/i);
         });
       }

       /**
        * @property onInfiniteScroll
        * @description
        *  [en]Function to be executed when scrolling to the bottom of the page. The function receives a done callback as an argument that must be called when it's finished.[/en]
        *  [ja][/ja]
        */

     }, {
       key: '_onScroll',
       value: function _onScroll() {
         var _this5 = this;

         var c = this._contentElement,
             overLimit = (c.scrollTop + c.clientHeight) / c.scrollHeight >= this._infiniteScrollLimit;

         if (this._onInfiniteScroll && !this._loadingContent && overLimit) {
           this._loadingContent = true;
           this._onInfiniteScroll(function () {
             return _this5._loadingContent = false;
           });
         }
       }

       /**
        * @property onDeviceBackButton
        * @type {Object}
        * @description
        *   [en]Back-button handler.[/en]
        *   [ja][/ja]
        */

     }, {
       key: '_getContentElement',


       /**
        * @return {HTMLElement}
        */
       value: function _getContentElement() {
         var result = util.findChild(this, '.page__content');
         if (result) {
           return result;
         }
         throw Error('fail to get ".page__content" element.');
       }

       /**
        * @return {Boolean}
        */

     }, {
       key: '_canAnimateToolbar',
       value: function _canAnimateToolbar() {
         if (util.findChild(this, 'ons-toolbar')) {
           return true;
         }
         return !!util.findChild(this._contentElement, function (el) {
           return util.match(el, 'ons-toolbar') && !el.hasAttribute('inline');
         });
       }

       /**
        * @return {HTMLElement}
        */

     }, {
       key: '_getBackgroundElement',
       value: function _getBackgroundElement() {
         var result = util.findChild(this, '.page__background');
         if (result) {
           return result;
         }
         throw Error('fail to get ".page__background" element.');
       }

       /**
        * @return {HTMLElement}
        */

     }, {
       key: '_getBottomToolbarElement',
       value: function _getBottomToolbarElement() {
         return util.findChild(this, 'ons-bottom-toolbar') || internal.nullElement;
       }

       /**
        * @return {HTMLElement}
        */

     }, {
       key: '_getToolbarElement',
       value: function _getToolbarElement() {
         return util.findChild(this, 'ons-toolbar') || nullToolbarElement;
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         var _this6 = this;

         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$12);
         } else if (name === '_muted') {
           this._isMuted = this.hasAttribute('_muted');
         } else if (name === '_skipinit') {
           this._skipInit = this.hasAttribute('_skipinit');
         } else if (name === 'on-infinite-scroll') {
           if (current === null) {
             this.onInfiniteScroll = null;
           } else {
             this.onInfiniteScroll = function (done) {
               var f = util.findFromPath(current);
               _this6.onInfiniteScroll = f;
               f(done);
             };
           }
         }
       }
     }, {
       key: '_compile',
       value: function _compile() {
         var _this7 = this;

         autoStyle.prepare(this);

         if (util.findChild(this, '.content')) {
           util.findChild(this, '.content').classList.add('page__content');
         }

         if (util.findChild(this, '.background')) {
           util.findChild(this, '.background').classList.add('page__background');
         }

         if (!util.findChild(this, '.page__content')) {
           (function () {
             var content = util.create('.page__content');

             util.arrayFrom(_this7.childNodes).forEach(function (node) {
               if (node.nodeType !== 1 || _this7._elementShouldBeMoved(node)) {
                 content.appendChild(node);
               }
             });

             var prevNode = util.findChild(_this7, '.page__background') || util.findChild(_this7, 'ons-toolbar');

             _this7.insertBefore(content, prevNode && prevNode.nextSibling);
           })();
         }

         if (!util.findChild(this, '.page__background')) {
           var background = util.create('.page__background');
           this.insertBefore(background, util.findChild(this, '.page__content'));
         }

         ModifierUtil.initModifier(this, scheme$12);

         this.setAttribute('_compiled', '');
       }
     }, {
       key: '_elementShouldBeMoved',
       value: function _elementShouldBeMoved(el) {
         if (el.classList.contains('page__background')) {
           return false;
         }
         var tagName = el.tagName.toLowerCase();
         if (tagName === 'ons-fab') {
           return !el.hasAttribute('position');
         }
         var fixedElements = ['ons-toolbar', 'ons-bottom-toolbar', 'ons-modal', 'ons-speed-dial'];
         return el.hasAttribute('inline') || fixedElements.indexOf(tagName) === -1;
       }
     }, {
       key: '_show',
       value: function _show() {
         if (!this._isShown && util.isAttached(this)) {
           this._isShown = true;

           if (!this._isMuted) {
             util.triggerElementEvent(this, 'show');
           }

           util.propagateAction(this._contentElement, '_show');
         }
       }
     }, {
       key: '_hide',
       value: function _hide() {
         if (this._isShown) {
           this._isShown = false;

           if (!this._isMuted) {
             util.triggerElementEvent(this, 'hide');
           }

           util.propagateAction(this._contentElement, '_hide');
         }
       }
     }, {
       key: '_destroy',
       value: function _destroy() {
         this._hide();

         if (!this._isMuted) {
           util.triggerElementEvent(this, 'destroy');
         }

         if (this.onDeviceBackButton) {
           this.onDeviceBackButton.destroy();
         }

         util.propagateAction(this._contentElement, '_destroy');

         if (this.unload instanceof Function) {
           this.unload();
         }

         this.remove();
       }

       /**
        * @property data
        * @type {*}
        * @description
        *   [en]User's custom data passed to `pushPage()`-like methods.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'name',
       set: function set(str) {
         this.setAttribute('name', str);
       },
       get: function get() {
         return this.getAttribute('name');
       }
     }, {
       key: 'backButton',
       get: function get() {
         return this.querySelector('ons-back-button');
       }
     }, {
       key: 'onInfiniteScroll',
       set: function set(value) {
         if (value === null) {
           this._onInfiniteScroll = null;
           this._contentElement.removeEventListener('scroll', this._boundOnScroll);
           return;
         }
         if (!(value instanceof Function)) {
           throw new Error('onInfiniteScroll must be a function or null');
         }
         if (!this._onInfiniteScroll) {
           this._infiniteScrollLimit = 0.9;
           this._boundOnScroll = this._onScroll.bind(this);
           this._contentElement.addEventListener('scroll', this._boundOnScroll);
         }
         this._onInfiniteScroll = value;
       },
       get: function get() {
         return this._onInfiniteScroll;
       }
     }, {
       key: 'onDeviceBackButton',
       get: function get() {
         return this._backButtonHandler;
       },
       set: function set(callback) {
         if (this._backButtonHandler) {
           this._backButtonHandler.destroy();
         }

         this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
       }
     }], [{
       key: 'observedAttributes',
       get: function get() {
         return ['modifier', '_muted', '_skipinit', 'on-infinite-scroll'];
       }
     }]);
     return PageElement;
   }(BaseElement);

   customElements.define('ons-page', PageElement);

   var PopoverAnimator = function () {

     /**
      * @param {Object} options
      * @param {String} options.timing
      * @param {Number} options.duration
      * @param {Number} options.delay
      */

     function PopoverAnimator() {
       var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
       babelHelpers.classCallCheck(this, PopoverAnimator);

       this.options = util.extend({
         timing: 'cubic-bezier(.1, .7, .4, 1)',
         duration: 0.2,
         delay: 0
       }, options);
     }

     babelHelpers.createClass(PopoverAnimator, [{
       key: 'show',
       value: function show(popover, callback) {
         callback();
       }
     }, {
       key: 'hide',
       value: function hide(popover, callback) {
         callback();
       }
     }, {
       key: '_animate',
       value: function _animate(element, _ref) {
         var from = _ref.from;
         var to = _ref.to;
         var options = _ref.options;
         var callback = _ref.callback;
         var _ref$restore = _ref.restore;
         var restore = _ref$restore === undefined ? false : _ref$restore;
         var animation = _ref.animation;

         options = util.extend({}, this.options, options);

         if (animation) {
           from = animation.from;
           to = animation.to;
         }

         animation = animit(element);
         if (restore) {
           animation = animation.saveStyle();
         }
         animation = animation.queue(from).wait(options.delay).queue({
           css: to,
           duration: options.duration,
           timing: options.timing
         });
         if (restore) {
           animation = animation.restoreStyle();
         }
         if (callback) {
           animation = animation.queue(function (done) {
             callback();
             done();
           });
         }
         return animation;
       }
     }, {
       key: '_animateAll',
       value: function _animateAll(element, animations) {
         var _this = this;

         Object.keys(animations).forEach(function (key) {
           return _this._animate(element[key], animations[key]).play();
         });
       }
     }]);
     return PopoverAnimator;
   }();

   var fade = {
     out: {
       from: { opacity: 1.0 },
       to: { opacity: 0 }
     },
     in: {
       from: { opacity: 0 },
       to: { opacity: 1.0 }
     }
   };

   var MDFadePopoverAnimator = function (_PopoverAnimator) {
     babelHelpers.inherits(MDFadePopoverAnimator, _PopoverAnimator);

     function MDFadePopoverAnimator() {
       babelHelpers.classCallCheck(this, MDFadePopoverAnimator);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(MDFadePopoverAnimator).apply(this, arguments));
     }

     babelHelpers.createClass(MDFadePopoverAnimator, [{
       key: 'show',
       value: function show(popover, callback) {
         this._animateAll(popover, {
           _mask: fade.in,
           _popover: { animation: fade.in, restore: true, callback: callback }
         });
       }
     }, {
       key: 'hide',
       value: function hide(popover, callback) {
         this._animateAll(popover, {
           _mask: fade.out,
           _popover: { animation: fade.out, restore: true, callback: callback }
         });
       }
     }]);
     return MDFadePopoverAnimator;
   }(PopoverAnimator);

   var IOSFadePopoverAnimator = function (_MDFadePopoverAnimato) {
     babelHelpers.inherits(IOSFadePopoverAnimator, _MDFadePopoverAnimato);

     function IOSFadePopoverAnimator() {
       babelHelpers.classCallCheck(this, IOSFadePopoverAnimator);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(IOSFadePopoverAnimator).apply(this, arguments));
     }

     babelHelpers.createClass(IOSFadePopoverAnimator, [{
       key: 'show',
       value: function show(popover, callback) {
         this._animateAll(popover, {
           _mask: fade.in,
           _popover: {
             from: {
               transform: 'scale3d(1.3, 1.3, 1.0)',
               opacity: 0
             },
             to: {
               transform: 'scale3d(1.0, 1.0,  1.0)',
               opacity: 1.0
             },
             restore: true,
             callback: callback
           }
         });
       }
     }]);
     return IOSFadePopoverAnimator;
   }(MDFadePopoverAnimator);

   var scheme$14 = {
     '.popover': 'popover--*',
     '.popover-mask': 'popover-mask--*',
     '.popover__container': 'popover__container--*',
     '.popover__content': 'popover__content--*',
     '.popover__arrow': 'popover__arrow--*'
   };

   var _animatorDict$4 = {
     'default': function _default() {
       return platform.isAndroid() ? MDFadePopoverAnimator : IOSFadePopoverAnimator;
     },
     'none': PopoverAnimator,
     'fade-ios': IOSFadePopoverAnimator,
     'fade-md': MDFadePopoverAnimator
   };

   var templateSource = util.createFragment('\n  <div class="popover-mask"></div>\n  <div class="popover__container">\n    <div class="popover__content"></div>\n    <div class="popover__arrow"></div>\n  </div>\n');

   var positions = {
     up: 'bottom',
     left: 'right',
     down: 'top',
     right: 'left'
   };

   var directions = Object.keys(positions);
   /**
    * @element ons-popover
    * @category dialog
    * @description
    *  [en]
    *    A component that displays a popover next to an element. The popover can be used to display extra information about a component or a tooltip.
    *
    *    To use the element it can either be attached directly to the `<body>` element or dynamically created from a template using the `ons.createPopover(template)` utility function and the `<ons-template>` tag.
    * 
    *    Another common way to use the popover is to display a menu when a button on the screen is tapped. For Material Design, popover looks exactly as a dropdown menu.
    *  [/en]
    *  [ja][/ja]
    * @codepen ZYYRKo
    * @tutorial vanilla/Reference/popover
    * @guide dialogs
    *  [en]Dialog components[/en]
    *  [ja]Dialog components[/ja]
    * @guide using-modifier [en]More details about the `modifier` attribute[/en][ja]modifier[/ja]
    * @example
    * <ons-button onclick="showPopover(this)">
    *   Click me!
    * </ons-button>
    *
    * <ons-popover direction="down" id="popover">
    *   <p>This is a popover!</p>
    * </ons-popover>
    *
    * <script>
    *   var showPopover = function(element) {
    *     var popover = document.getElementById('popover');
    *     popover.show(element);
    *   };
    * </script>
    */

   var PopoverElement = function (_BaseElement) {
     babelHelpers.inherits(PopoverElement, _BaseElement);

     function PopoverElement() {
       babelHelpers.classCallCheck(this, PopoverElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(PopoverElement).apply(this, arguments));
     }

     babelHelpers.createClass(PopoverElement, [{
       key: 'init',
       value: function init() {
         var _this2 = this;

         contentReady(this, function () {
           _this2._compile();
           _this2._initAnimatorFactory();
         });

         this._doorLock = new DoorLock();
         this._boundOnChange = this._onChange.bind(this);
         this._boundCancel = this._cancel.bind(this);
       }
     }, {
       key: '_initAnimatorFactory',
       value: function _initAnimatorFactory() {
         var factory = new AnimatorFactory({
           animators: _animatorDict$4,
           baseClass: PopoverAnimator,
           baseClassName: 'PopoverAnimator',
           defaultAnimation: this.getAttribute('animation') || 'default'
         });
         this._animator = function (options) {
           return factory.newAnimator(options);
         };
       }
     }, {
       key: '_positionPopover',
       value: function _positionPopover(target) {
         var radius = this._radius;
         var el = this._content;
         var margin = this._margin;

         var pos = target.getBoundingClientRect();
         var isMD = util.hasModifier(this, 'material');
         var cover = isMD && this.hasAttribute('cover-target');

         var distance = {
           top: pos.top - margin,
           left: pos.left - margin,
           right: window.innerWidth - pos.right - margin,
           bottom: window.innerHeight - pos.bottom - margin
         };

         var _calculateDirections2 = this._calculateDirections(distance);

         var vertical = _calculateDirections2.vertical;
         var primary = _calculateDirections2.primary;
         var secondary = _calculateDirections2.secondary;

         this._popover.classList.add('popover--' + primary);

         var offset = cover ? 0 : (vertical ? pos.height : pos.width) + (isMD ? 0 : 14);
         this.style[primary] = Math.max(0, distance[primary] + offset) + margin + 'px';
         el.style[primary] = 0;

         var l = vertical ? 'width' : 'height';
         var sizes = function (style) {
           return {
             width: parseInt(style.getPropertyValue('width')),
             height: parseInt(style.getPropertyValue('height'))
           };
         }(window.getComputedStyle(el));

         el.style[secondary] = Math.max(0, distance[secondary] - (sizes[l] - pos[l]) / 2) + 'px';
         this._arrow.style[secondary] = Math.max(radius, distance[secondary] + pos[l] / 2) + 'px';

         this._setTransformOrigin(distance, sizes, pos, primary);

         // Prevent animit from restoring the style.
         el.removeAttribute('data-animit-orig-style');
       }
     }, {
       key: '_setTransformOrigin',
       value: function _setTransformOrigin(distance, sizes, pos, primary) {
         var calc = function calc(a, o, l) {
           return primary === a ? sizes[l] / 2 : distance[a] + (primary === o ? -sizes[l] : sizes[l] - pos[l]) / 2;
         };
         var x = calc('left', 'right', 'width') + 'px';
         var y = calc('top', 'bottom', 'height') + 'px';

         util.extend(this._popover.style, {
           transformOrigin: x + ' ' + y,
           webkitTransformOriginX: x,
           webkitTransformOriginY: y
         });
       }
     }, {
       key: '_calculateDirections',
       value: function _calculateDirections(distance) {
         var options = (this.getAttribute('direction') || 'up down left right').split(/\s+/).map(function (e) {
           return positions[e];
         });
         var primary = options.sort(function (a, b) {
           return distance[a] - distance[b];
         })[0];
         var vertical = ['top', 'bottom'].indexOf(primary) !== -1;
         var secondary = void 0;

         if (vertical) {
           secondary = distance.left < distance.right ? 'left' : 'right';
         } else {
           secondary = distance.top < distance.bottom ? 'top' : 'bottom';
         }

         return { vertical: vertical, primary: primary, secondary: secondary };
       }
     }, {
       key: '_clearStyles',
       value: function _clearStyles() {
         var _this3 = this;

         ['top', 'bottom', 'left', 'right'].forEach(function (e) {
           _this3._arrow.style[e] = _this3._content.style[e] = _this3.style[e] = '';
           _this3._popover.classList.remove('popover--' + e);
         });
       }
     }, {
       key: '_onChange',
       value: function _onChange() {
         var _this4 = this;

         setImmediate(function () {
           if (_this4._currentTarget) {
             _this4._positionPopover(_this4._currentTarget);
           }
         });
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         if (this.classList.contains('popover')) {
           return;
         }

         this.classList.add('popover');

         var hasDefaultContainer = this._popover && this._content;

         if (hasDefaultContainer) {

           if (!this._mask) {
             var mask = document.createElement('div');
             mask.classList.add('popover-mask');
             this.insertBefore(mask, this.firstChild);
           }

           if (!this._arrow) {
             var arrow = document.createElement('div');
             arrow.classList.add('popover__arrow');
             this._popover.appendChild(arrow);
           }
         } else {

           var template = templateSource.cloneNode(true);
           var content = template.querySelector('.popover__content');

           while (this.childNodes[0]) {
             content.appendChild(this.childNodes[0]);
           }

           this.appendChild(template);
         }

         if (this.hasAttribute('style')) {
           this._popover.setAttribute('style', this.getAttribute('style'));
           this.removeAttribute('style');
         }

         if (this.hasAttribute('mask-color')) {
           this._mask.style.backgroundColor = this.getAttribute('mask-color');
         }

         ModifierUtil.initModifier(this, scheme$14);
       }
     }, {
       key: '_prepareAnimationOptions',
       value: function _prepareAnimationOptions(options) {
         if (options.animation && !(options.animation in _animatorDict$4)) {
           throw new Error('Animator ' + options.animation + ' is not registered.');
         }

         options.animationOptions = util.extend(AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')), options.animationOptions || {});
       }
     }, {
       key: '_executeAction',
       value: function _executeAction(actions) {
         var _this5 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         var callback = options.callback;
         var action = actions.action;
         var before = actions.before;
         var after = actions.after;


         this._prepareAnimationOptions(options);

         var canceled = false;
         util.triggerElementEvent(this, 'pre' + action, { // synchronous
           popover: this,
           cancel: function cancel() {
             return canceled = true;
           }
         });

         if (canceled) {
           return Promise.reject('Canceled in pre' + action + ' event.');
         }

         return new Promise(function (resolve) {
           _this5._doorLock.waitUnlock(function () {
             var unlock = _this5._doorLock.lock();

             before && before();

             contentReady(_this5, function () {
               _this5._animator(options)[action](_this5, function () {
                 after && after();

                 unlock();

                 util.triggerElementEvent(_this5, 'post' + action, { popover: _this5 });

                 callback && callback();
                 resolve(_this5);
               });
             });
           });
         });
       }

       /**
        * @method show
        * @signature show(target, [options])
        * @param {String|Event|HTMLElement} target
        *   [en]Target element. Can be either a CSS selector, an event object or a DOM element.[/en]
        *   [ja]CSSeventDOM[/ja]
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]Animation name.  Use one of `"fade-ios"`, `"fade-md"`, `"none"` and `"default"`.[/en]
        *   [ja]"fade-ios", "fade-md", "none", "default"[/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
        *   [ja]duration, delay, timinge.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
        * @param {Function} [options.callback]
        *   [en]This function is called after the popover has been revealed.[/en]
        *   [ja][/ja]
        * @description
        *   [en]Open the popover and point it at a target. The target can be either an event, a CSS selector or a DOM element..[/en]
        *   [ja]target$eventDOMCSS[/ja]
        * @return {Promise}
        *   [en]Resolves to the displayed element[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'show',
       value: function show(target) {
         var _this6 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         if (typeof target === 'string') {
           target = document.querySelector(target);
         } else if (target instanceof Event) {
           target = target.target;
         }
         if (!(target instanceof HTMLElement)) {
           throw new Error('Invalid target');
         }

         return this._executeAction({
           action: 'show',
           before: function before() {
             _this6.style.display = 'block';
             _this6._currentTarget = target;
             _this6._positionPopover(target);
           }
         }, options);
       }

       /**
        * @method hide
        * @signature hide([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]Animation name.  Use one of `"fade-ios"`, `"fade-md"`, `"none"` and `"default"`.[/en]
        *   [ja]"fade-ios", "fade-md", "none", "default"[/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
        *   [ja]duration, delay, timinge.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
        * @param {Function} [options.callback]
        *   [en]This functions is called after the popover has been hidden.[/en]
        *   [ja][/ja]
        * @description
        *   [en]Close the popover.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Resolves to the hidden element[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'hide',
       value: function hide() {
         var _this7 = this;

         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         return this._executeAction({
           action: 'hide',
           after: function after() {
             _this7.style.display = 'none';
             _this7._clearStyles();
           }
         }, options);
       }

       /**
        * @property visible
        * @readonly
        * @type {Boolean}
        * @description
        *   [en]Whether the element is visible or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: '_resetBackButtonHandler',
       value: function _resetBackButtonHandler() {
         var _this8 = this;

         // do we need this twice?
         this.onDeviceBackButton = function (e) {
           return _this8.cancelable ? _this8._cancel() : e.callParentHandler();
         };
       }
     }, {
       key: 'connectedCallback',
       value: function connectedCallback() {
         var _this9 = this;

         this._resetBackButtonHandler();

         contentReady(this, function () {
           _this9._margin = _this9._margin || parseInt(window.getComputedStyle(_this9).getPropertyValue('top'));
           _this9._radius = parseInt(window.getComputedStyle(_this9._content).getPropertyValue('border-top-left-radius'));

           _this9._mask.addEventListener('click', _this9._boundCancel, false);

           _this9._resetBackButtonHandler();

           window.addEventListener('resize', _this9._boundOnChange, false);
         });
       }
     }, {
       key: 'disconnectedCallback',
       value: function disconnectedCallback() {
         var _this10 = this;

         contentReady(this, function () {
           _this10._mask.removeEventListener('click', _this10._boundCancel, false);

           _this10._backButtonHandler.destroy();
           _this10._backButtonHandler = null;

           window.removeEventListener('resize', _this10._boundOnChange, false);
         });
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$14);
         }
         if (name === 'direction') {
           return this._boundOnChange();
         }
         if (name === 'animation') {
           this._initAnimatorFactory();
         }
       }
     }, {
       key: '_cancel',
       value: function _cancel() {
         var _this11 = this;

         if (this.cancelable) {
           this.hide({
             callback: function callback() {
               util.triggerElementEvent(_this11, 'dialog-cancel');
             }
           });
         }
       }

       /**
        * @param {String} name
        * @param {PopoverAnimator} Animator
        */

     }, {
       key: '_mask',


       /**
        * @event preshow
        * @description
        *   [en]Fired just before the popover is displayed.[/en]
        *   [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.popover
        *   [en]Component object.[/en]
        *   [ja][/ja]
        * @param {Function} event.cancel
        *   [en]Call this function to stop the popover from being shown.[/en]
        *   [ja][/ja]
        */

       /**
        * @event postshow
        * @description
        *   [en]Fired just after the popover is displayed.[/en]
        *   [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.popover
        *   [en]Component object.[/en]
        *   [ja][/ja]
        */

       /**
        * @event prehide
        * @description
        *   [en]Fired just before the popover is hidden.[/en]
        *   [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.popover
        *   [en]Component object.[/en]
        *   [ja][/ja]
        * @param {Function} event.cancel
        *   [en]Call this function to stop the popover from being hidden.[/en]
        *   [ja][/ja]
        */

       /**
        * @event posthide
        * @description
        *   [en]Fired just after the popover is hidden.[/en]
        *   [ja][/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.popover
        *   [en]Component object.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute modifier
        * @type {String}
        * @description
        *  [en]The appearance of the popover.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute direction
        * @type {String}
        * @description
        *  [en]
        *    A space separated list of directions. If more than one direction is specified,
        *    it will be chosen automatically. Valid directions are `"up"`, `"down"`, `"left"` and `"right"`.
        *  [/en]
        *  [ja]
        *    
        *    "up", "down", "left", "right"4
        *    
        *  [/ja]
        */

       /**
        * @attribute cancelable
        * @description
        *   [en]If this attribute is set the popover can be closed by tapping the background or by pressing the back button.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute cover-target
        * @description
        *   [en]If set the popover will cover the target on the screen.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute animation
        * @type {String}
        * @description
        *   [en]The animation used when showing an hiding the popover. Can be either `"none"`, `"default"`, `"fade-ios"` or `"fade-md"`.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute animation-options
        * @type {Expression}
        * @description
        *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
        *  [ja]duration, timing, delaye.g. {duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
        */

       /**
        * @attribute mask-color
        * @type {Color}
        * @description
        *   [en]Color of the background mask. Default is `"rgba(0, 0, 0, 0.2)"`.[/en]
        *   [ja]"rgba(0, 0, 0, 0.2)"[/ja]
        */

       get: function get() {
         return util.findChild(this, '.popover-mask');
       }
     }, {
       key: '_popover',
       get: function get() {
         return util.findChild(this, '.popover__container');
       }
     }, {
       key: '_content',
       get: function get() {
         return util.findChild(this._popover, '.popover__content');
       }
     }, {
       key: '_arrow',
       get: function get() {
         return util.findChild(this._popover, '.popover__arrow');
       }
     }, {
       key: 'visible',
       get: function get() {
         return window.getComputedStyle(this).getPropertyValue('display') !== 'none';
       }

       /**
        * @property cancelable
        * @type {Boolean}
        * @description
        *   [en]
        *     A boolean value that specifies whether the popover is cancelable or not.
        *
        *     When the popover is cancelable it can be closed by tapping the background or by pressing the back button on Android devices.
        *   [/en]
        *   [ja][/ja]
        */

     }, {
       key: 'cancelable',
       set: function set(value) {
         return util.toggleAttribute(this, 'cancelable', value);
       },
       get: function get() {
         return this.hasAttribute('cancelable');
       }

       /**
        * @property onDeviceBackButton
        * @type {Object}
        * @description
        *   [en]Back-button handler.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'onDeviceBackButton',
       get: function get() {
         return this._backButtonHandler;
       },
       set: function set(callback) {
         if (this._backButtonHandler) {
           this._backButtonHandler.destroy();
         }

         this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
       }
     }], [{
       key: 'registerAnimator',
       value: function registerAnimator(name, Animator) {
         if (!(Animator.prototype instanceof PopoverAnimator)) {
           throw new Error('"Animator" param must inherit PopoverAnimator');
         }
         _animatorDict$4[name] = Animator;
       }
     }, {
       key: 'observedAttributes',
       get: function get() {
         return ['modifier', 'direction', 'animation'];
       }
     }, {
       key: 'PopoverAnimator',
       get: function get() {
         return PopoverAnimator;
       }
     }]);
     return PopoverElement;
   }(BaseElement);

   customElements.define('ons-popover', PopoverElement);

   var scheme$15 = {
     '.progress-bar': 'progress-bar--*',
     '.progress-bar__primary': 'progress-bar__primary--*',
     '.progress-bar__secondary': 'progress-bar__secondary--*'
   };

   var template = util.createElement('\n  <div class="progress-bar">\n    <div class="progress-bar__secondary"></div>\n    <div class="progress-bar__primary"></div>\n  </div>\n');

   /**
    * @element ons-progress-bar
    * @category visual
    * @description
    *   [en]
    *     The component is used to display a linear progress bar. It can either display a progress bar that shows the user how much of a task has been completed. In the case where the percentage is not known it can be used to display an animated progress bar so the user can see that an operation is in progress.
    *   [/en]
    *   [ja][/ja]
    * @codepen zvQbGj
    * @tutorial vanilla/Reference/progress
    * @seealso ons-progress-circular
    *   [en]The `<ons-progress-circular>` component displays a circular progress indicator.[/en]
    *   [ja][/ja]
    * @example
    * <ons-progress-bar
    *  value="55"
    *  secondary-value="87">
    * </ons-progress-bar>
    *
    * <ons-progress-bar
    *  indeterminate>
    * </ons-progress-bar>
    */

   var ProgressBarElement = function (_BaseElement) {
     babelHelpers.inherits(ProgressBarElement, _BaseElement);

     function ProgressBarElement() {
       babelHelpers.classCallCheck(this, ProgressBarElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ProgressBarElement).apply(this, arguments));
     }

     babelHelpers.createClass(ProgressBarElement, [{
       key: 'init',


       /**
        * @attribute modifier
        * @type {String}
        * @description
        *   [en]Change the appearance of the progress indicator.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute value
        * @type {Number}
        * @description
        *   [en]Current progress. Should be a value between 0 and 100.[/en]
        *   [ja]0100[/ja]
        */

       /**
        * @attribute secondary-value
        * @type {Number}
        * @description
        *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
        *   [ja]0100[/ja]
        */

       /**
        * @attribute indeterminate
        * @description
        *   [en]If this attribute is set, an infinite looping animation will be shown.[/en]
        *   [ja][/ja]
        */

       value: function init() {
         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$15);
         } else if (name === 'value' || name === 'secondary-value') {
           this._updateValue();
         } else if (name === 'indeterminate') {
           this._updateDeterminate();
         }
       }
     }, {
       key: '_updateDeterminate',
       value: function _updateDeterminate() {
         if (this.hasAttribute('indeterminate')) {
           this._template.classList.add('progress-bar--indeterminate');
           this._template.classList.remove('progress-bar--determinate');
         } else {
           this._template.classList.add('progress-bar--determinate');
           this._template.classList.remove('progress-bar--indeterminate');
         }
       }
     }, {
       key: '_updateValue',
       value: function _updateValue() {
         this._primary.style.width = this.hasAttribute('value') ? this.getAttribute('value') + '%' : '0%';
         this._secondary.style.width = this.hasAttribute('secondary-value') ? this.getAttribute('secondary-value') + '%' : '0%';
       }

       /**
        * @property value
        * @type {Number}
        * @description
        *   [en]Current progress. Should be a value between 0 and 100.[/en]
        *   [ja]0100[/ja]
        */

     }, {
       key: '_compile',
       value: function _compile() {
         this._template = template.cloneNode(true);

         this._primary = this._template.childNodes[3];
         this._secondary = this._template.childNodes[1];

         this._updateDeterminate();
         this._updateValue();

         this.appendChild(this._template);

         ModifierUtil.initModifier(this, scheme$15);

         this.setAttribute('_compiled', '');
       }
     }, {
       key: 'value',
       set: function set(value) {
         if (typeof value !== 'number' || value < 0 || value > 100) {
           throw new Error('Invalid value');
         }

         this.setAttribute('value', Math.floor(value));
       },
       get: function get() {
         return parseInt(this.getAttribute('value') || '0');
       }

       /**
        * @property secondaryValue
        * @type {Number}
        * @description
        *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
        *   [ja]0100[/ja]
        */

     }, {
       key: 'secondaryValue',
       set: function set(value) {
         if (typeof value !== 'number' || value < 0 || value > 100) {
           throw new Error('Invalid value');
         }

         this.setAttribute('secondary-value', Math.floor(value));
       },
       get: function get() {
         return parseInt(this.getAttribute('secondary-value') || '0');
       }

       /**
        * @property indeterminate
        * @type {Boolean}
        * @description
        *   [en]If this property is `true`, an infinite looping animation will be shown.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'indeterminate',
       set: function set(value) {
         if (value) {
           this.setAttribute('indeterminate', '');
         } else {
           this.removeAttribute('indeterminate');
         }
       },
       get: function get() {
         return this.hasAttribute('indeterminate');
       }
     }], [{
       key: 'observedAttributes',
       get: function get() {
         return ['modifier', 'value', 'secondary-value', 'indeterminate'];
       }
     }]);
     return ProgressBarElement;
   }(BaseElement);

   customElements.define('ons-progress-bar', ProgressBarElement);

   var scheme$16 = {
     '.progress-circular': 'progress-circular--*',
     '.progress-circular__primary': 'progress-circular__primary--*',
     '.progress-circular__secondary': 'progress-circular__secondary--*'
   };

   var template$1 = util.createElement('\n  <svg class="progress-circular">\n    <circle class="progress-circular__secondary" cx="50%" cy="50%" r="40%" fill="none" stroke-width="10%" stroke-miterlimit="10"/>\n    <circle class="progress-circular__primary" cx="50%" cy="50%" r="40%" fill="none" stroke-width="10%" stroke-miterlimit="10"/>\n  </svg>\n');

   /**
    * @element ons-progress-circular
    * @category visual
    * @description
    *   [en]
    *     This component displays a circular progress indicator. It can either be used to show how much of a task has been completed or to show a looping animation to indicate that an operation is currently running.
    *   [/en]
    *   [ja][/ja]
    * @codepen EVzMjR
    * @tutorial vanilla/Reference/progress
    * @seealso ons-progress-bar
    *   [en]The `<ons-progress-bar>` component displays a bar progress indicator.[/en]
    *   [ja][/ja]
    * @example
    * <ons-progress-circular
    *  value="55"
    *  secondary-value="87">
    * </ons-progress-circular>
    *
    * <ons-progress-circular
    *  indeterminate>
    * </ons-progress-circular>
    */

   var ProgressCircularElement = function (_BaseElement) {
     babelHelpers.inherits(ProgressCircularElement, _BaseElement);

     function ProgressCircularElement() {
       babelHelpers.classCallCheck(this, ProgressCircularElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ProgressCircularElement).apply(this, arguments));
     }

     babelHelpers.createClass(ProgressCircularElement, [{
       key: 'init',


       /**
        * @attribute modifier
        * @type {String}
        * @description
        *   [en]Change the appearance of the progress indicator.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute value
        * @type {Number}
        * @description
        *   [en]Current progress. Should be a value between 0 and 100.[/en]
        *   [ja]0100[/ja]
        */

       /**
        * @attribute secondary-value
        * @type {Number}
        * @description
        *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
        *   [ja]0100[/ja]
        */

       /**
        * @attribute indeterminate
        * @description
        *   [en]If this attribute is set, an infinite looping animation will be shown.[/en]
        *   [ja][/ja]
        */

       value: function init() {
         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$16);
         } else if (name === 'value' || name === 'secondary-value') {
           this._updateValue();
         } else if (name === 'indeterminate') {
           this._updateDeterminate();
         }
       }
     }, {
       key: '_updateDeterminate',
       value: function _updateDeterminate() {
         if (this.hasAttribute('indeterminate')) {
           this._template.classList.add('progress-circular--indeterminate');
           this._template.classList.remove('progress-circular--determinate');
         } else {
           this._template.classList.add('progress-circular--determinate');
           this._template.classList.remove('progress-circular--indeterminate');
         }
       }
     }, {
       key: '_updateValue',
       value: function _updateValue() {
         if (this.hasAttribute('value')) {
           var per = Math.ceil(this.getAttribute('value') * 251.32 * 0.01);
           this._primary.style['stroke-dasharray'] = per + '%, 251.32%';
         }
         if (this.hasAttribute('secondary-value')) {
           var _per = Math.ceil(this.getAttribute('secondary-value') * 251.32 * 0.01);
           this._secondary.style['stroke-dasharray'] = _per + '%, 251.32%';
         }
       }

       /**
        * @property value
        * @type {Number}
        * @description
        *   [en]Current progress. Should be a value between 0 and 100.[/en]
        *   [ja]0100[/ja]
        */

     }, {
       key: '_compile',
       value: function _compile() {
         this._template = template$1.cloneNode(true);

         this._primary = this._template.childNodes[3];
         this._secondary = this._template.childNodes[1];

         this._updateDeterminate();
         this._updateValue();

         this.appendChild(this._template);

         ModifierUtil.initModifier(this, scheme$16);

         this.setAttribute('_compiled', '');
       }
     }, {
       key: 'value',
       set: function set(value) {
         if (typeof value !== 'number' || value < 0 || value > 100) {
           throw new Error('Invalid value');
         }

         this.setAttribute('value', Math.floor(value));
       },
       get: function get() {
         return parseInt(this.getAttribute('value') || '0');
       }

       /**
        * @property secondaryValue
        * @type {Number}
        * @description
        *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
        *   [ja]0100[/ja]
        */

     }, {
       key: 'secondaryValue',
       set: function set(value) {
         if (typeof value !== 'number' || value < 0 || value > 100) {
           throw new Error('Invalid value');
         }

         this.setAttribute('secondary-value', Math.floor(value));
       },
       get: function get() {
         return parseInt(this.getAttribute('secondary-value') || '0');
       }

       /**
        * @property indeterminate
        * @type {Boolean}
        * @description
        *   [en]If this property is `true`, an infinite looping animation will be shown.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'indeterminate',
       set: function set(value) {
         if (value) {
           this.setAttribute('indeterminate', '');
         } else {
           this.removeAttribute('indeterminate');
         }
       },
       get: function get() {
         return this.hasAttribute('indeterminate');
       }
     }], [{
       key: 'observedAttributes',
       get: function get() {
         return ['modifier', 'value', 'secondary-value', 'indeterminate'];
       }
     }]);
     return ProgressCircularElement;
   }(BaseElement);

   customElements.define('ons-progress-circular', ProgressCircularElement);

   var STATE_INITIAL = 'initial';
   var STATE_PREACTION = 'preaction';
   var STATE_ACTION = 'action';

   var removeTransform = function removeTransform(el) {
     el.style.transform = '';
     el.style.WebkitTransform = '';
     el.style.transition = '';
     el.style.WebkitTransition = '';
   };

   /**
    * @element ons-pull-hook
    * @category control
    * @description
    *   [en]
    *     Component that adds **Pull to refresh** functionality to an `<ons-page>` element.
    *
    *     It can be used to perform a task when the user pulls down at the top of the page. A common usage is to refresh the data displayed in a page.
    *   [/en]
    *   [ja][/ja]
    * @codepen WbJogM
    * @tutorial vanilla/Reference/pull-hook
    * @example
    * <ons-page>
    *   <ons-pull-hook>
    *     Release to refresh
    *   </ons-pull-hook>
    * </ons-page>
    *
    * <script>
    *   document.querySelector('ons-pull-hook').onAction = function(done) {
    *     setTimeout(done, 1000);
    *   };
    * </script>
    */

   var PullHookElement = function (_BaseElement) {
     babelHelpers.inherits(PullHookElement, _BaseElement);

     function PullHookElement() {
       babelHelpers.classCallCheck(this, PullHookElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(PullHookElement).apply(this, arguments));
     }

     babelHelpers.createClass(PullHookElement, [{
       key: 'init',


       /**
        * @event changestate
        * @description
        *   [en]Fired when the state is changed. The state can be either "initial", "preaction" or "action".[/en]
        *   [ja]"initial", "preaction", "action"[/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja][/ja]
        * @param {Object} event.pullHook
        *   [en]Component object.[/en]
        *   [ja][/ja]
        * @param {String} event.state
        *   [en]Current state.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute disabled
        * @description
        *   [en]If this attribute is set the "pull-to-refresh" functionality is disabled.[/en]
        *   [ja]disabled[/ja]
        */

       /**
        * @attribute height
        * @type {String}
        * @description
        *   [en]Specify the height of the component. When pulled down further than this value it will switch to the "preaction" state. The default value is "64px".[/en]
        *   [ja]pull down"preaction""64px"[/ja]
        */

       /**
        * @attribute threshold-height
        * @type {String}
        * @description
        *   [en]Specify the threshold height. The component automatically switches to the "action" state when pulled further than this value. The default value is "96px". A negative value or a value less than the height will disable this property.[/en]
        *   [ja]pull down"action"[/ja]
        */

       /**
        * @attribute fixed-content
        * @description
        *   [en]If this attribute is set the content of the page will not move when pulling.[/en]
        *   [ja][/ja]
        */

       value: function init() {
         this._boundOnDrag = this._onDrag.bind(this);
         this._boundOnDragStart = this._onDragStart.bind(this);
         this._boundOnDragEnd = this._onDragEnd.bind(this);
         this._boundOnScroll = this._onScroll.bind(this);

         this._setState(STATE_INITIAL, true);
       }
     }, {
       key: '_setStyle',
       value: function _setStyle() {
         var height = this.height;

         this.style.height = height + 'px';
         this.style.lineHeight = height + 'px';
         this.style.marginTop = '-1px';
         this._pageElement.style.marginTop = '-' + height + 'px';
       }
     }, {
       key: '_onScroll',
       value: function _onScroll(event) {
         var element = this._pageElement;

         if (element.scrollTop < 0) {
           element.scrollTop = 0;
         }
       }
     }, {
       key: '_generateTranslationTransform',
       value: function _generateTranslationTransform(scroll) {
         return 'translate3d(0px, ' + scroll + 'px, 0px)';
       }
     }, {
       key: '_onDrag',
       value: function _onDrag(event) {
         var _this2 = this;

         if (this.disabled) {
           return;
         }

         // Hack to make it work on Android 4.4 WebView. Scrolls manually near the top of the page so
         // there will be no inertial scroll when scrolling down. Allowing default scrolling will
         // kill all 'touchmove' events.
         if (platform.isAndroid()) {
           var element = this._pageElement;
           element.scrollTop = this._startScroll - event.gesture.deltaY;
           if (element.scrollTop < window.innerHeight && event.gesture.direction !== 'up') {
             event.gesture.preventDefault();
           }
         }

         if (this._currentTranslation === 0 && this._getCurrentScroll() === 0) {
           this._transitionDragLength = event.gesture.deltaY;

           var direction = event.gesture.interimDirection;
           if (direction === 'down') {
             this._transitionDragLength -= 1;
           } else {
             this._transitionDragLength += 1;
           }
         }

         var scroll = Math.max(event.gesture.deltaY - this._startScroll, 0);

         if (this._thresholdHeightEnabled() && scroll >= this.thresholdHeight) {
           event.gesture.stopDetect();

           setImmediate(function () {
             return _this2._finish();
           });
         } else if (scroll >= this.height) {
           this._setState(STATE_PREACTION);
         } else {
           this._setState(STATE_INITIAL);
         }

         event.stopPropagation();
         this._translateTo(scroll);
       }
     }, {
       key: '_onDragStart',
       value: function _onDragStart(event) {
         if (this.disabled) {
           return;
         }

         this._startScroll = this._getCurrentScroll();
       }
     }, {
       key: '_onDragEnd',
       value: function _onDragEnd(event) {
         if (this.disabled) {
           return;
         }

         if (this._currentTranslation > 0) {
           var scroll = this._currentTranslation;

           if (scroll > this.height) {
             this._finish();
           } else {
             this._translateTo(0, { animate: true });
           }
         }
       }

       /**
        * @property onAction
        * @type {Function}
        * @description
        *   [en]This will be called in the `action` state if it exists. The function will be given a `done` callback as it's first argument.[/en]
        *   [ja][/ja]
        */

     }, {
       key: '_finish',
       value: function _finish() {
         var _this3 = this;

         this._setState(STATE_ACTION);
         this._translateTo(this.height, { animate: true });
         var action = this.onAction || function (done) {
           return done();
         };
         action(function () {
           _this3._translateTo(0, { animate: true });
           _this3._setState(STATE_INITIAL);
         });
       }

       /**
        * @property height
        * @type {Number}
        * @description
        *   [en]The height of the pull hook in pixels. The default value is `64px`.[/en]
        *   [ja][/ja]
        */

     }, {
       key: '_thresholdHeightEnabled',
       value: function _thresholdHeightEnabled() {
         var th = this.thresholdHeight;
         return th > 0 && th >= this.height;
       }
     }, {
       key: '_setState',
       value: function _setState(state, noEvent) {
         var lastState = this._getState();

         this.setAttribute('state', state);

         if (!noEvent && lastState !== this._getState()) {
           util.triggerElementEvent(this, 'changestate', {
             pullHook: this,
             state: state,
             lastState: lastState
           });
         }
       }
     }, {
       key: '_getState',
       value: function _getState() {
         return this.getAttribute('state');
       }

       /**
        * @property state
        * @readonly
        * @type {String}
        * @description
        *   [en]Current state of the element.[/en]
        *   [ja][/ja]
        */

     }, {
       key: '_getCurrentScroll',
       value: function _getCurrentScroll() {
         return this._pageElement.scrollTop;
       }

       /**
        * @property pullDistance
        * @readonly
        * @type {Number}
        * @description
        *   [en]The current number of pixels the pull hook has moved.[/en]
        *   [ja][/ja]
        */

     }, {
       key: '_isContentFixed',
       value: function _isContentFixed() {
         return this.hasAttribute('fixed-content');
       }
     }, {
       key: '_getScrollableElement',
       value: function _getScrollableElement() {
         if (this._isContentFixed()) {
           return this;
         } else {
           return this._pageElement;
         }
       }

       /**
        * @param {Number} scroll
        * @param {Object} options
        * @param {Function} [options.callback]
        */

     }, {
       key: '_translateTo',
       value: function _translateTo(scroll) {
         var _this4 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         if (this._currentTranslation == 0 && scroll == 0) {
           return;
         }

         var done = function done() {
           if (scroll === 0) {
             var el = _this4._getScrollableElement();
             removeTransform(el);
           }

           if (options.callback) {
             options.callback();
           }
         };

         this._currentTranslation = scroll;

         if (options.animate) {
           animit(this._getScrollableElement()).queue({
             transform: this._generateTranslationTransform(scroll)
           }, {
             duration: 0.3,
             timing: 'cubic-bezier(.1, .7, .1, 1)'
           }).play(done);
         } else {
           animit(this._getScrollableElement()).queue({
             transform: this._generateTranslationTransform(scroll)
           }).play(done);
         }
       }
     }, {
       key: '_disableDragLock',
       value: function _disableDragLock() {
         // e2e tests need it
         this._dragLockDisabled = true;
         this._destroyEventListeners();
         this._createEventListeners();
       }
     }, {
       key: '_createEventListeners',
       value: function _createEventListeners() {
         this._gestureDetector = new GestureDetector(this._pageElement, {
           dragMinDistance: 1,
           dragDistanceCorrection: false,
           dragLockToAxis: !this._dragLockDisabled
         });

         // Bind listeners
         this._gestureDetector.on('dragup dragdown', this._boundOnDrag);
         this._gestureDetector.on('dragstart', this._boundOnDragStart);
         this._gestureDetector.on('dragend', this._boundOnDragEnd);

         this._pageElement.addEventListener('scroll', this._boundOnScroll, false);
       }
     }, {
       key: '_destroyEventListeners',
       value: function _destroyEventListeners() {
         if (this._gestureDetector) {
           this._gestureDetector.off('dragup dragdown', this._boundOnDrag);
           this._gestureDetector.off('dragstart', this._boundOnDragStart);
           this._gestureDetector.off('dragend', this._boundOnDragEnd);

           this._gestureDetector.dispose();
           this._gestureDetector = null;
         }

         this._pageElement.removeEventListener('scroll', this._boundOnScroll, false);
       }
     }, {
       key: 'connectedCallback',
       value: function connectedCallback() {
         this._currentTranslation = 0;
         this._pageElement = this.parentNode;

         this._createEventListeners();
         this._setStyle();
       }
     }, {
       key: 'disconnectedCallback',
       value: function disconnectedCallback() {
         this._pageElement.style.marginTop = '';

         this._destroyEventListeners();
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'height') {
           this._setStyle();
         }
       }
     }, {
       key: 'height',
       set: function set(value) {
         if (!util.isInteger(value)) {
           throw new Error('The height must be an integer');
         }

         this.setAttribute('height', value + 'px');
       },
       get: function get() {
         return parseInt(this.getAttribute('height') || '64', 10);
       }

       /**
        * @property thresholdHeight
        * @type {Number}
        * @description
        *   [en]The thresholdHeight of the pull hook in pixels. The default value is `96px`.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'thresholdHeight',
       set: function set(value) {
         if (!util.isInteger(value)) {
           throw new Error('The threshold height must be an integer');
         }

         this.setAttribute('threshold-height', value + 'px');
       },
       get: function get() {
         return parseInt(this.getAttribute('threshold-height') || '96', 10);
       }
     }, {
       key: 'state',
       get: function get() {
         return this._getState();
       }
     }, {
       key: 'pullDistance',
       get: function get() {
         return this._currentTranslation;
       }

       /**
        * @property disabled
        * @type {Boolean}
        * @description
        *   [en]Whether the element is disabled or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'disabled',
       set: function set(value) {
         return util.toggleAttribute(this, 'disabled', value);
       },
       get: function get() {
         return this.hasAttribute('disabled');
       }
     }], [{
       key: 'observedAttributes',
       get: function get() {
         return ['height'];
       }
     }, {
       key: 'STATE_INITIAL',
       get: function get() {
         return STATE_INITIAL;
       }
     }, {
       key: 'STATE_PREACTION',
       get: function get() {
         return STATE_PREACTION;
       }
     }, {
       key: 'STATE_ACTION',
       get: function get() {
         return STATE_ACTION;
       }
     }]);
     return PullHookElement;
   }(BaseElement);

   customElements.define('ons-pull-hook', PullHookElement);

   /**
    * @class AnimatorCSS - implementation of Animator class using css transitions
    */

   var AnimatorCSS = function () {
     babelHelpers.createClass(AnimatorCSS, [{
       key: 'animate',


       /**
        * @method animate
        * @desc main animation function
        * @param {Element} element
        * @param {Object} finalCSS
        * @param {number} [duration=200] - duration in milliseconds
        * @return {Object} result
        * @return {Function} result.then(callback) - sets a callback to be executed after the animation has stopped
        * @return {Function} result.stop(options) - stops the animation; if options.stopNext is true then it doesn't call the callback
        * @return {Function} result.finish(ms) - finishes the animation in the specified time in milliseconds
        * @return {Function} result.speed(ms) - sets the animation speed so that it finishes as if the original duration was the one specified here
        * @example
        * ````
        *  var result = animator.animate(el, {opacity: 0.5}, 1000);
        *
        *  el.addEventListener('click', function(e){
        *    result.speed(200).then(function(){
        *      console.log('done');
        *    });
        *  }, 300);
        * ````
        */
       value: function animate(el, final) {
         var duration = arguments.length <= 2 || arguments[2] === undefined ? 200 : arguments[2];

         var start = new Date().getTime(),
             initial = {},
             stopped = false,
             next = false,
             timeout = false,
             properties = Object.keys(final);

         var updateStyles = function updateStyles() {
           var s = window.getComputedStyle(el);
           properties.forEach(s.getPropertyValue.bind(s));
           s = el.offsetHeight;
         };

         var result = {
           stop: function stop() {
             var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

             timeout && clearTimeout(timeout);
             var k = Math.min(1, (new Date().getTime() - start) / duration);
             properties.forEach(function (i) {
               el.style[i] = (1 - k) * initial[i] + k * final[i] + (i == 'opacity' ? '' : 'px');
             });
             el.style.transitionDuration = '0s';

             if (options.stopNext) {
               next = false;
             } else if (!stopped) {
               stopped = true;
               next && next();
             }
             return result;
           },
           then: function then(cb) {
             next = cb;
             if (stopped) {
               next && next();
             }
             return result;
           },
           speed: function speed(newDuration) {
             if (internal.config.animationsDisabled) {
               newDuration = 0;
             }
             if (!stopped) {
               (function () {
                 timeout && clearTimeout(timeout);

                 var passed = new Date().getTime() - start;
                 var k = passed / duration;
                 var remaining = newDuration * (1 - k);

                 properties.forEach(function (i) {
                   el.style[i] = (1 - k) * initial[i] + k * final[i] + (i == 'opacity' ? '' : 'px');
                 });

                 updateStyles();

                 start = el.speedUpTime;
                 duration = remaining;

                 el.style.transitionDuration = duration / 1000 + 's';

                 properties.forEach(function (i) {
                   el.style[i] = final[i] + (i == 'opacity' ? '' : 'px');
                 });

                 timeout = setTimeout(result.stop, remaining);
               })();
             }
             return result;
           },
           finish: function finish() {
             var milliseconds = arguments.length <= 0 || arguments[0] === undefined ? 50 : arguments[0];

             var k = (new Date().getTime() - start) / duration;

             result.speed(milliseconds / (1 - k));
             return result;
           }
         };

         if (el.hasAttribute('disabled') || stopped || internal.config.animationsDisabled) {
           return result;
         }

         var style = window.getComputedStyle(el);
         properties.forEach(function (e) {
           var v = parseFloat(style.getPropertyValue(e));
           initial[e] = isNaN(v) ? 0 : v;
         });

         if (!stopped) {
           el.style.transitionProperty = properties.join(',');
           el.style.transitionDuration = duration / 1000 + 's';

           properties.forEach(function (e) {
             el.style[e] = final[e] + (e == 'opacity' ? '' : 'px');
           });
         }

         timeout = setTimeout(result.stop, duration);
         this._onStopAnimations(el, result.stop);

         return result;
       }
     }]);

     function AnimatorCSS() {
       babelHelpers.classCallCheck(this, AnimatorCSS);

       this._queue = [];
       this._index = 0;
     }

     babelHelpers.createClass(AnimatorCSS, [{
       key: '_onStopAnimations',
       value: function _onStopAnimations(el, listener) {
         var queue = this._queue;
         var i = this._index++;
         queue[el] = queue[el] || [];
         queue[el][i] = function (options) {
           delete queue[el][i];
           if (queue[el] && queue[el].length == 0) {
             delete queue[el];
           }
           return listener(options);
         };
       }

       /**
       * @method stopAnimations
       * @desc stops active animations on a specified element
       * @param {Element|Array} element - element or array of elements
       * @param {Object} [options={}]
       * @param {Boolean} [options.stopNext] - the callbacks after the animations won't be called if this option is true
       */

     }, {
       key: 'stopAnimations',
       value: function stopAnimations(el) {
         var _this = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         if (Array.isArray(el)) {
           return el.forEach(function (el) {
             _this.stopAnimations(el, options);
           });
         }

         (this._queue[el] || []).forEach(function (e) {
           e(options || {});
         });
       }

       /**
       * @method stopAll
       * @desc stops all active animations
       * @param {Object} [options={}]
       * @param {Boolean} [options.stopNext] - the callbacks after the animations won't be called if this option is true
       */

     }, {
       key: 'stopAll',
       value: function stopAll() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         this.stopAnimations(Object.keys(this._queue), options);
       }

       /**
       * @method fade
       * @desc fades the element (short version for animate(el, {opacity: 0}))
       * @param {Element} element
       * @param {number} [duration=200]
       */

     }, {
       key: 'fade',
       value: function fade(el) {
         var duration = arguments.length <= 1 || arguments[1] === undefined ? 200 : arguments[1];

         return this.animate(el, { opacity: 0 }, duration);
       }
     }]);
     return AnimatorCSS;
   }();

   /**
    * @element ons-ripple
    * @category visual
    * @description
    *   [en]
    *     Adds a Material Design "ripple" effect to an element. The ripple effect will spread from the position where the user taps.
    *
    *     Some elements such as `<ons-button>` and `<ons-fab>`  support a `ripple` attribute.
    *   [/en]
    *   [ja]DOM[/ja]
    * @codepen wKQWdZ
    * @tutorial vanilla/Reference/ripple
    * @guide cross-platform-styling
    *  [en]Cross platform styling[/en]
    *  [ja]Cross platform styling[/ja]
    * @example
    * <div class="my-div">
    *  <ons-ripple></ons-ripple>
    * </div>
    *
    * @example
    * <ons-button ripple>Click me!</ons-button>
    */

   var RippleElement = function (_BaseElement) {
     babelHelpers.inherits(RippleElement, _BaseElement);

     function RippleElement() {
       babelHelpers.classCallCheck(this, RippleElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(RippleElement).apply(this, arguments));
     }

     babelHelpers.createClass(RippleElement, [{
       key: 'init',


       /**
        * @attribute color
        * @type {String}
        * @description
        *   [en]Color of the ripple effect.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute background
        * @type {String}
        * @description
        *   [en]Color of the background.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute disabled
        * @description
        *   [en]If this attribute is set, the ripple effect will be disabled.[/en]
        *   [ja][/ja]
        */

       value: function init() {
         var _this2 = this;

         this.classList.add('ripple');
         if (!this.hasAttribute('_compiled')) {
           this._compile();
         } else {
           this._background = this.getElementsByClassName('ripple__background')[0];
           this._wave = this.getElementsByClassName('ripple__wave')[0];
         }

         this._animator = new AnimatorCSS();

         ['color', 'center', 'start-radius', 'background'].forEach(function (e) {
           _this2.attributeChangedCallback(e, null, _this2.getAttribute(e));
         });
       }
     }, {
       key: '_compile',
       value: function _compile() {
         var _this3 = this;

         ['_wave', '_background'].forEach(function (e) {
           _this3[e] = document.createElement('div');
           _this3[e].classList.add('ripple_' + e);
           _this3.appendChild(_this3[e]);
         });
         this.setAttribute('_compiled', '');
       }
     }, {
       key: '_calculateCoords',
       value: function _calculateCoords(e) {
         var x, y, h, w, r;
         var b = this.getBoundingClientRect();
         if (this._center) {
           x = b.width / 2;
           y = b.height / 2;
           r = Math.sqrt(x * x + y * y);
         } else {
           x = (e.clientX || e.changedTouches[0].clientX) - b.left;
           y = (e.clientY || e.changedTouches[0].clientY) - b.top;
           h = Math.max(y, b.height - y);
           w = Math.max(x, b.width - x);
           r = Math.sqrt(h * h + w * w);
         }
         return { x: x, y: y, r: r };
       }
     }, {
       key: '_rippleAnimation',
       value: function _rippleAnimation(e) {
         var duration = arguments.length <= 1 || arguments[1] === undefined ? 300 : arguments[1];
         var _animator = this._animator;
         var _wave = this._wave;
         var _background = this._background;

         var _minR = this._minR;

         var _calculateCoords2 = this._calculateCoords(e);

         var x = _calculateCoords2.x;
         var y = _calculateCoords2.y;
         var r = _calculateCoords2.r;


         _animator.stopAll({ stopNext: 1 });
         _animator.animate(_background, { opacity: 1 }, duration);

         util.extend(_wave.style, {
           opacity: 1,
           top: y - _minR + 'px',
           left: x - _minR + 'px',
           width: 2 * _minR + 'px',
           height: 2 * _minR + 'px'
         });

         return _animator.animate(_wave, {
           top: y - r,
           left: x - r,
           height: 2 * r,
           width: 2 * r
         }, duration);
       }
     }, {
       key: '_updateParent',
       value: function _updateParent() {
         if (!this._parentUpdated && this.parentNode) {
           var computedStyle = window.getComputedStyle(this.parentNode);
           if (computedStyle.getPropertyValue('position') === 'static') {
             this.parentNode.style.position = 'relative';
           }
           this._parentUpdated = true;
         }
       }
     }, {
       key: '_onTap',
       value: function _onTap(e) {
         var _this4 = this;

         if (!this.disabled) {
           this._updateParent();
           this._rippleAnimation(e.gesture.srcEvent).then(function () {
             _this4._animator.fade(_this4._wave);
             _this4._animator.fade(_this4._background);
           });
         }
       }
     }, {
       key: '_onHold',
       value: function _onHold(e) {
         if (!this.disabled) {
           this._updateParent();
           this._holding = this._rippleAnimation(e.gesture.srcEvent, 2000);
           document.addEventListener('release', this._boundOnRelease);
         }
       }
     }, {
       key: '_onRelease',
       value: function _onRelease(e) {
         var _this5 = this;

         if (this._holding) {
           this._holding.speed(300).then(function () {
             _this5._animator.stopAll({ stopNext: true });
             _this5._animator.fade(_this5._wave);
             _this5._animator.fade(_this5._background);
           });

           this._holding = false;
         }

         document.removeEventListener('release', this._boundOnRelease);
       }
     }, {
       key: '_onDragStart',
       value: function _onDragStart(e) {
         if (this._holding) {
           return this._onRelease(e);
         }
         if (['left', 'right'].indexOf(e.gesture.direction) != -1) {
           this._onTap(e);
         }
       }
     }, {
       key: 'connectedCallback',
       value: function connectedCallback() {
         this._parentNode = this.parentNode;
         this._boundOnTap = this._onTap.bind(this);
         this._boundOnHold = this._onHold.bind(this);
         this._boundOnDragStart = this._onDragStart.bind(this);
         this._boundOnRelease = this._onRelease.bind(this);

         if (internal.config.animationsDisabled) {
           this.disabled = true;
         } else {
           this._parentNode.addEventListener('tap', this._boundOnTap);
           this._parentNode.addEventListener('hold', this._boundOnHold);
           this._parentNode.addEventListener('dragstart', this._boundOnDragStart);
         }
       }
     }, {
       key: 'disconnectedCallback',
       value: function disconnectedCallback() {
         var pn = this._parentNode || this.parentNode;
         pn.removeEventListener('tap', this._boundOnTap);
         pn.removeEventListener('hold', this._boundOnHold);
         pn.removeEventListener('dragstart', this._boundOnDragStart);
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'start-radius') {
           this._minR = Math.max(0, parseFloat(current) || 0);
         }
         if (name === 'color' && current) {
           this._wave.style.background = current;
           if (!this.hasAttribute('background')) {
             this._background.style.background = current;
           }
         }
         if (name === 'background' && (current || last)) {
           if (current === 'none') {
             this._background.setAttribute('disabled', 'disabled');
             this._background.style.background = 'transparent';
           } else {
             if (this._background.hasAttribute('disabled')) {
               this._background.removeAttribute('disabled');
             }
             this._background.style.background = current;
           }
         }
         if (name === 'center') {
           this._center = current != null && current != 'false';
         }
       }

       /**
        * @property disabled
        * @type {Boolean}
        * @description
        *   [en]Whether the element is disabled or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'disabled',
       set: function set(value) {
         return util.toggleAttribute(this, 'disabled', value);
       },
       get: function get() {
         return this.hasAttribute('disabled');
       }
     }], [{
       key: 'observedAttributes',
       get: function get() {
         return ['start-radius', 'color', 'background', 'center'];
       }
     }]);
     return RippleElement;
   }(BaseElement);

   customElements.define('ons-ripple', RippleElement);

   /**
    * @element ons-row
    * @category grid
    * @description
    *   [en]Represents a row in the grid system. Use with `<ons-col>` to layout components.[/en]
    *   [ja]ons-col[/ja]
    * @codepen GgujC {wide}
    * @guide layouting
    *   [en]Layouting guide[/en]
    *   [ja][/ja]
    * @seealso ons-col
    *   [en]The `<ons-col>` component is used as children of `<ons-row>`.[/en]
    *   [ja]ons-col[/ja]
    * @note
    *   [en]For Android 4.3 and earlier, and iOS6 and earlier, when using mixed alignment with ons-row and ons-col, they may not be displayed correctly. You can use only one vertical-align.[/en]
    *   [ja]Android 4.3iOS 6OSons-rowons-colons-colvertical-alignvertical-align[/ja]
    * @example
    * <ons-row>
    *   <ons-col width="50px"><ons-icon icon="fa-twitter"></ons-icon></ons-col>
    *   <ons-col>Text</ons-col>
    * </ons-row>
    */

   /**
    * @attribute vertical-align
    * @type {String}
    * @description
    *   [en]Short hand attribute for aligning vertically. Valid values are top, bottom, and center.[/en]
    *   [ja]topbottomcenter[/ja]
    */

   var RowElement = function (_BaseElement) {
     babelHelpers.inherits(RowElement, _BaseElement);

     function RowElement() {
       babelHelpers.classCallCheck(this, RowElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(RowElement).apply(this, arguments));
     }

     return RowElement;
   }(BaseElement);

   customElements.define('ons-row', RowElement);

   var scheme$17 = {
     '': 'speed-dial__item--*'
   };

   /**
    * @element ons-speed-dial-item
    * @category control
    * @description
    *   [en]
    *     This component displays the child elements of the Material Design Speed dial component.
    *   [/en]
    *   [ja]
    *     Material DesignSpeed dial
    *   [/ja]
    * @codepen dYQYLg
    * @tutorial vanilla/Reference/speed-dial
    * @seealso ons-speed-dial
    *   [en]The `<ons-speed-dial>` component.[/en]
    *   [ja]ons-speed-dial[/ja]
    * @seealso ons-fab
    *   [en]ons-fab component[/en]
    *   [ja]ons-fab[/ja]
    * @example
    * <ons-speed-dial position="left bottom">
    *   <ons-fab>
    *     <ons-icon icon="fa-twitter"></ons-icon>
    *   </ons-fab>
    *   <ons-speed-dial-item>A</ons-speed-dial-item>
    *   <ons-speed-dial-item>B</ons-speed-dial-item>
    *   <ons-speed-dial-item>C</ons-speed-dial-item>
    * </ons-speed-dial>
    */

   var SpeedDialItemElement = function (_BaseElement) {
     babelHelpers.inherits(SpeedDialItemElement, _BaseElement);

     function SpeedDialItemElement() {
       babelHelpers.classCallCheck(this, SpeedDialItemElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(SpeedDialItemElement).apply(this, arguments));
     }

     babelHelpers.createClass(SpeedDialItemElement, [{
       key: 'init',


       /**
        * @attribute modifier
        * @type {String}
        * @description
        *   [en]The appearance of the component.[/en]
        *   [ja][/ja]
        */

       value: function init() {
         this._compile();
         this._boundOnClick = this._onClick.bind(this);
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         switch (name) {
           case 'modifier':
             ModifierUtil.onModifierChanged(last, current, this, scheme$17);
             break;
           case 'ripple':
             this._updateRipple();
         }
       }
     }, {
       key: 'connectedCallback',
       value: function connectedCallback() {
         this.addEventListener('click', this._boundOnClick, false);
       }
     }, {
       key: 'disconnectedCallback',
       value: function disconnectedCallback() {
         this.removeEventListener('click', this._boundOnClick, false);
       }
     }, {
       key: '_updateRipple',
       value: function _updateRipple() {
         util.updateRipple(this);
       }
     }, {
       key: '_onClick',
       value: function _onClick(e) {
         e.stopPropagation();
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         this.classList.add('fab');
         this.classList.add('fab--mini');
         this.classList.add('speed-dial__item');

         this._updateRipple();

         ModifierUtil.initModifier(this, scheme$17);
       }
     }], [{
       key: 'observedAttributes',
       get: function get() {
         return ['modifier', 'ripple'];
       }
     }]);
     return SpeedDialItemElement;
   }(BaseElement);

   customElements.define('ons-speed-dial-item', SpeedDialItemElement);

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */

   /**
    * Minimal utility library for manipulating element's style.
    */
   var styler = function styler(element, style) {
     return styler.css.apply(styler, arguments);
   };

   /**
    * Set element's style.
    *
    * @param {Element} element
    * @param {Object} styles
    * @return {Element}
    */
   styler.css = function (element, styles) {
     var keys = Object.keys(styles);
     keys.forEach(function (key) {
       if (key in element.style) {
         element.style[key] = styles[key];
       } else if (styler._prefix(key) in element.style) {
         element.style[styler._prefix(key)] = styles[key];
       } else {
         console.warn('No such style property: ' + key);
       }
     });
     return element;
   };

   /**
    * Add vendor prefix.
    *
    * @param {String} name
    * @return {String}
    */
   styler._prefix = function () {
     var styles = window.getComputedStyle(document.documentElement, '');
     var prefix = (Array.prototype.slice.call(styles).join('').match(/-(moz|webkit|ms)-/) || styles.OLink === '' && ['', 'o'])[1];

     return function (name) {
       return prefix + name.substr(0, 1).toUpperCase() + name.substr(1);
     };
   }();

   /**
    * @param {Element} element
    */
   styler.clear = function (element) {
     styler._clear(element);
   };

   /**
    * @param {Element} element
    */
   styler._clear = function (element) {
     var len = element.style.length;
     var style = element.style;
     var keys = [];
     for (var i = 0; i < len; i++) {
       keys.push(style[i]);
     }

     keys.forEach(function (key) {
       style[key] = '';
     });
   };

   var scheme$18 = {
     '': 'speed-dial--*'
   };

   /**
    * @element ons-speed-dial
    * @category control
    * @description
    *   [en]
    *     Element that displays a Material Design Speed Dialog component. It is useful when there are more than one primary action that can be performed in a page.
    *
    *     The Speed dial looks like a `<ons-fab>` element but will expand a menu when tapped.
    *   [/en]
    *   [ja][/ja]
    * @codepen dYQYLg
    * @tutorial vanilla/Reference/speed-dial
    * @seealso ons-speed-dial-item
    *   [en]The `<ons-speed-dial-item>` represents a menu item.[/en]
    *   [ja]ons-speed-dial-item[/ja]
    * @seealso ons-fab
    *   [en]ons-fab component[/en]
    *   [ja]ons-fab[/ja]
    * @example
    * <ons-speed-dial position="left bottom">
    *   <ons-fab>
    *     <ons-icon icon="fa-twitter"></ons-icon>
    *   </ons-fab>
    *   <ons-speed-dial-item>A</ons-speed-dial-item>
    *   <ons-speed-dial-item>B</ons-speed-dial-item>
    *   <ons-speed-dial-item>C</ons-speed-dial-item>
    * </ons-speed-dial>
    */

   var SpeedDialElement = function (_BaseElement) {
     babelHelpers.inherits(SpeedDialElement, _BaseElement);

     function SpeedDialElement() {
       babelHelpers.classCallCheck(this, SpeedDialElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(SpeedDialElement).apply(this, arguments));
     }

     babelHelpers.createClass(SpeedDialElement, [{
       key: 'init',


       /**
        * @event open
        * @description
        *   [en]Fired when the menu items are shown.[/en]
        *   [ja][/ja]
        */

       /**
        * @event close
        * @description
        *   [en]Fired when the menu items are hidden.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute modifier
        * @type {String}
        * @description
        *   [en]The appearance of the component.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute position
        * @type {String}
        * @description
        *   [en]
        *     Specify the vertical and horizontal position of the component.
        *     I.e. to display it in the top right corner specify "right top".
        *     Choose from "right", "left", "top" and "bottom".
        *   [/en]
        *   [ja]
        *     
        *     "right top"
        *     rightlefttopbottom
        *   [/ja]
        */

       /**
        * @attribute direction
        * @type {String}
        * @description
        *   [en]Specify the direction the items are displayed. Possible values are "up", "down", "left" and "right".[/en]
        *   [ja]
        *     up, down, left, right
        *   [/ja]
        */

       /**
        * @attribute disabled
        * @description
        *   [en]Specify if button should be disabled.[/en]
        *   [ja][/ja]
        */

       value: function init() {
         var _this2 = this;

         contentReady(this, function () {
           _this2._compile();
         });

         this._shown = true;
         this._itemShown = false;
         this._boundOnClick = this._onClick.bind(this);
       }
     }, {
       key: '_compile',
       value: function _compile() {
         if (!this.classList.contains('speed__dial')) {
           this.classList.add('speed__dial');
           autoStyle.prepare(this);
           this._updateRipple();
           ModifierUtil.initModifier(this, scheme$18);

           if (this.hasAttribute('direction')) {
             this._updateDirection(this.getAttribute('direction'));
           } else {
             this._updateDirection('up');
           }
         }

         this._updatePosition();
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         var _this3 = this;

         switch (name) {
           case 'modifier':
             ModifierUtil.onModifierChanged(last, current, this, scheme$18);
             break;
           case 'ripple':
             contentReady(this, function () {
               return _this3._updateRipple();
             });
             break;
           case 'direction':
             contentReady(this, function () {
               return _this3._updateDirection(current);
             });
             break;
           case 'position':
             contentReady(this, function () {
               return _this3._updatePosition();
             });
             break;
         }
       }
     }, {
       key: 'connectedCallback',
       value: function connectedCallback() {
         this.addEventListener('click', this._boundOnClick, false);
       }
     }, {
       key: 'disconnectedCallback',
       value: function disconnectedCallback() {
         this.removeEventListener('click', this._boundOnClick, false);
       }
     }, {
       key: '_onClick',
       value: function _onClick(e) {
         if (!this.disabled && this._shown) {
           this.toggleItems();
         }
       }
     }, {
       key: '_show',
       value: function _show() {
         if (!this.inline) {
           this.show();
         }
       }
     }, {
       key: '_hide',
       value: function _hide() {
         if (!this.inline) {
           this.hide();
         }
       }
     }, {
       key: '_updateRipple',
       value: function _updateRipple() {
         var fab = util.findChild(this, 'ons-fab');

         if (fab) {
           this.hasAttribute('ripple') ? fab.setAttribute('ripple', '') : fab.removeAttribute('ripple');
         }
       }
     }, {
       key: '_updateDirection',
       value: function _updateDirection(direction) {
         var children = this.items;
         for (var i = 0; i < children.length; i++) {
           styler(children[i], {
             transitionDelay: 25 * i + 'ms',
             bottom: 'auto',
             right: 'auto',
             top: 'auto',
             left: 'auto'
           });
         }
         switch (direction) {
           case 'up':
             for (var _i = 0; _i < children.length; _i++) {
               children[_i].style.bottom = 72 + 56 * _i + 'px';
               children[_i].style.right = '8px';
             }
             break;
           case 'down':
             for (var _i2 = 0; _i2 < children.length; _i2++) {
               children[_i2].style.top = 72 + 56 * _i2 + 'px';
               children[_i2].style.left = '8px';
             }
             break;
           case 'left':
             for (var _i3 = 0; _i3 < children.length; _i3++) {
               children[_i3].style.top = '8px';
               children[_i3].style.right = 72 + 56 * _i3 + 'px';
             }
             break;
           case 'right':
             for (var _i4 = 0; _i4 < children.length; _i4++) {
               children[_i4].style.top = '8px';
               children[_i4].style.left = 72 + 56 * _i4 + 'px';
             }
             break;
           default:
             throw new Error('Argument must be one of up, down, left or right.');
         }
       }
     }, {
       key: '_updatePosition',
       value: function _updatePosition() {
         var position = this.getAttribute('position');
         this.classList.remove('fab--top__left', 'fab--bottom__right', 'fab--bottom__left', 'fab--top__right', 'fab--top__center', 'fab--bottom__center');
         switch (position) {
           case 'top right':
           case 'right top':
             this.classList.add('fab--top__right');
             break;
           case 'top left':
           case 'left top':
             this.classList.add('fab--top__left');
             break;
           case 'bottom right':
           case 'right bottom':
             this.classList.add('fab--bottom__right');
             break;
           case 'bottom left':
           case 'left bottom':
             this.classList.add('fab--bottom__left');
             break;
           case 'center top':
           case 'top center':
             this.classList.add('fab--top__center');
             break;
           case 'center bottom':
           case 'bottom center':
             this.classList.add('fab--bottom__center');
             break;
           default:
             break;
         }
       }

       /**
        * @method show
        * @signature show()
        * @description
        *   [en]Show the speed dial.[/en]
        *   [ja]Speed dial[/ja]
        */

     }, {
       key: 'show',
       value: function show() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         this.querySelector('ons-fab').show();
         this._shown = true;
       }

       /**
        * @method hide
        * @signature hide()
        * @description
        *   [en]Hide the speed dial.[/en]
        *   [ja]Speed dial[/ja]
        */

     }, {
       key: 'hide',
       value: function hide() {
         var _this4 = this;

         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         this.hideItems();
         setTimeout(function () {
           _this4.querySelector('ons-fab').hide();
         }, 200);
         this._shown = false;
       }

       /**
        * @method showItems
        * @signature showItems()
        * @description
        *   [en]Show the speed dial items.[/en]
        *   [ja]Speed dial[/ja]
        */

     }, {
       key: 'showItems',
       value: function showItems() {

         if (this.hasAttribute('direction')) {
           this._updateDirection(this.getAttribute('direction'));
         } else {
           this._updateDirection('up');
         }

         if (!this._itemShown) {
           var children = this.items;
           for (var i = 0; i < children.length; i++) {
             styler(children[i], {
               transform: 'scale(1)',
               transitionDelay: 25 * i + 'ms'
             });
           }
         }
         this._itemShown = true;

         util.triggerElementEvent(this, 'open');
       }

       /**
        * @method hideItems
        * @signature hideItems()
        * @description
        *   [en]Hide the speed dial items.[/en]
        *   [ja]Speed dial[/ja]
        */

     }, {
       key: 'hideItems',
       value: function hideItems() {
         if (this._itemShown) {
           var children = this.items;
           for (var i = 0; i < children.length; i++) {
             styler(children[i], {
               transform: 'scale(0)',
               transitionDelay: 25 * (children.length - i) + 'ms'
             });
           }
         }
         this._itemShown = false;
         util.triggerElementEvent(this, 'close');
       }

       /**
        * @property disabled
        * @type {Boolean}
        * @description
        *   [en]Whether the element is disabled or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'isOpen',


       /**
        * @method isOpen
        * @signature isOpen()
        * @description
        *   [en]Returns whether the menu is open or not.[/en]
        *   [ja][/ja]
        */
       value: function isOpen() {
         return this._itemShown;
       }

       /**
        * @method toggle
        * @signature toggle()
        * @description
        *   [en]Toggle visibility.[/en]
        *   [ja]Speed dial[/ja]
        */

     }, {
       key: 'toggle',
       value: function toggle() {
         this.visible ? this.hide() : this.show();
       }

       /**
        * @method toggleItems
        * @signature toggleItems()
        * @description
        *   [en]Toggle item visibility.[/en]
        *   [ja]Speed dial[/ja]
        */

     }, {
       key: 'toggleItems',
       value: function toggleItems() {
         if (this.isOpen()) {
           this.hideItems();
         } else {
           this.showItems();
         }
       }
     }, {
       key: 'items',
       get: function get() {
         return util.arrayFrom(this.querySelectorAll('ons-speed-dial-item'));
       }
     }, {
       key: 'disabled',
       set: function set(value) {
         if (value) {
           this.hideItems();
         }
         util.arrayFrom(this.children).forEach(function (e) {
           util.match(e, '.fab') && util.toggleAttribute(e, 'disabled', value);
         });

         return util.toggleAttribute(this, 'disabled', value);
       },
       get: function get() {
         return this.hasAttribute('disabled');
       }

       /**
        * @property inline
        * @readonly
        * @type {Boolean}
        * @description
        *   [en]Whether the element is inline or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'inline',
       get: function get() {
         return this.hasAttribute('inline');
       }

       /**
        * @property visible
        * @readonly
        * @type {Boolean}
        * @description
        *   [en]Whether the element is visible or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'visible',
       get: function get() {
         return this._shown && this.style.display !== 'none';
       }
     }], [{
       key: 'observedAttributes',
       get: function get() {
         return ['modifier', 'ripple', 'direction', 'position'];
       }
     }]);
     return SpeedDialElement;
   }(BaseElement);

   customElements.define('ons-speed-dial', SpeedDialElement);

   var rewritables$1 = {
     /**
      * @param {Element} element
      * @param {Function} callback
      */

     ready: function ready(element, callback) {
       setImmediate(callback);
     },


     /**
      * @param {Element} element
      * @param {HTMLFragment} target
      * @param {Object} options
      * @param {Function} callback
      */
     link: function link(element, target, options, callback) {
       callback(target);
     }
   };

   /**
    * @element ons-splitter-content
    * @category menu
    * @description
    *  [en]
    *    The `<ons-splitter-content>` element is used as a child element of `<ons-splitter>`.
    *
    *    It contains the main content of the page while `<ons-splitter-side>` contains the list.
    *  [/en]
    *  [ja]ons-splitter-contentons-splitter[/ja]
    * @codepen rOQOML
    * @tutorial vanilla/Reference/splitter
    * @guide multiple-page-navigation
    *  [en]Managing multiple pages.[/en]
    *  [ja]Managing multiple pages[/ja]
    * @seealso ons-splitter
    *  [en]The `<ons-splitter>` component is the parent element.[/en]
    *  [ja]ons-splitter[/ja]
    * @seealso ons-splitter-side
    *  [en]The `<ons-splitter-side>` component contains the menu.[/en]
    *  [ja]ons-splitter-side[/ja]
    * @example
    * <ons-splitter>
    *   <ons-splitter-content>
    *     ...
    *   </ons-splitter-content>
    *
    *   <ons-splitter-side side="left" width="80%" collapse>
    *     ...
    *   </ons-splitter-side>
    * </ons-splitter>
    */

   var SplitterContentElement = function (_BaseElement) {
     babelHelpers.inherits(SplitterContentElement, _BaseElement);

     function SplitterContentElement() {
       babelHelpers.classCallCheck(this, SplitterContentElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(SplitterContentElement).apply(this, arguments));
     }

     babelHelpers.createClass(SplitterContentElement, [{
       key: 'init',


       /**
        * @attribute page
        * @type {String}
        * @description
        *   [en]
        *     The url of the content page. If this attribute is used the content will be loaded from a `<ons-template>` tag or a remote file.
        *
        *     It is also possible to put `<ons-page>` element as a child of the element.
        *   [/en]
        *   [ja]ons-splitter-contentURL[/ja]
        */

       value: function init() {
         var _this2 = this;

         this._page = null;
         this._pageLoader = defaultPageLoader;

         contentReady(this, function () {
           var page = _this2._getPageTarget();

           if (page) {
             _this2.load(page);
           }
         });
       }
     }, {
       key: 'connectedCallback',
       value: function connectedCallback() {
         if (!util.match(this.parentNode, 'ons-splitter')) {
           throw new Error('"ons-splitter-content" must have "ons-splitter" as parentNode.');
         }
       }
     }, {
       key: '_getPageTarget',
       value: function _getPageTarget() {
         return this._page || this.getAttribute('page');
       }
     }, {
       key: 'disconnectedCallback',
       value: function disconnectedCallback() {}
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {}

       /**
        * @property page
        * @type {HTMLElement}
        * @description
        *   [en]The page to load in the splitter content.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'load',


       /**
        * @method load
        * @signature load(page, [options])
        * @param {String} page, [options]
        *   [en]Page URL. Can be either an HTML document or an `<ons-template>` id.[/en]
        *   [ja]pageURLons-templateid[/ja]
        * @param {Object} [options]
        * @param {Function} [options.callback]
        * @description
        *   [en]Show the page specified in `page` in the content.[/en]
        *   [ja]URL[/ja]
        * @return {Promise}
        *   [en]Resolves to the new `<ons-page>` element[/en]
        *   [ja]`<ons-page>`Promise[/ja]
        */
       value: function load(page) {
         var _this3 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         this._page = page;
         var callback = options.callback || function () {};

         return new Promise(function (resolve) {
           _this3._pageLoader.load({ page: page, parent: _this3, replace: true }, function (_ref) {
             var element = _ref.element;
             var unload = _ref.unload;

             rewritables$1.link(_this3, element, options, function (fragment) {
               setImmediate(function () {
                 return _this3._show();
               });
               callback();

               resolve(_this3.firstChild);
             });
           });
         });
       }
     }, {
       key: '_show',
       value: function _show() {
         util.propagateAction(this, '_show');
       }
     }, {
       key: '_hide',
       value: function _hide() {
         util.propagateAction(this, '_hide');
       }
     }, {
       key: '_destroy',
       value: function _destroy() {
         util.propagateAction(this, '_destroy');
         this.remove();
       }
     }, {
       key: 'page',
       get: function get() {
         return this._page;
       }

       /**
        * @param {*} page
        */
       ,
       set: function set(page) {
         this._page = page;
       }

       /**
        * @property pageLoader
        * @type {Function}
        * @description
        *   [en]Page element loaded in the splitter content.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'pageLoader',
       get: function get() {
         return this._pageLoader;
       },
       set: function set(loader) {
         if (!(loader instanceof PageLoader)) {
           throw Error('First parameter must be an instance of PageLoader');
         }
         this._pageLoader = loader;
       }
     }], [{
       key: 'observedAttributes',
       get: function get() {
         return [];
       }
     }, {
       key: 'rewritables',
       get: function get() {
         return rewritables$1;
       }
     }]);
     return SplitterContentElement;
   }(BaseElement);

   customElements.define('ons-splitter-content', SplitterContentElement);

   var SplitterMaskElement = function (_BaseElement) {
     babelHelpers.inherits(SplitterMaskElement, _BaseElement);

     function SplitterMaskElement() {
       babelHelpers.classCallCheck(this, SplitterMaskElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(SplitterMaskElement).apply(this, arguments));
     }

     babelHelpers.createClass(SplitterMaskElement, [{
       key: 'init',
       value: function init() {
         this._boundOnClick = this._onClick.bind(this);
       }
     }, {
       key: '_onClick',
       value: function _onClick(event) {
         if (util.match(this.parentNode, 'ons-splitter')) {
           this.parentNode._sides.forEach(function (side) {
             return side.close('left').catch(function () {});
           });
         }
         event.stopPropagation();
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {}
     }, {
       key: 'connectedCallback',
       value: function connectedCallback() {
         this.addEventListener('click', this._boundOnClick);
       }
     }, {
       key: 'disconnectedCallback',
       value: function disconnectedCallback() {
         this.removeEventListener('click', this._boundOnClick);
       }
     }], [{
       key: 'observedAttributes',
       get: function get() {
         return [];
       }
     }]);
     return SplitterMaskElement;
   }(BaseElement);

   customElements.define('ons-splitter-mask', SplitterMaskElement);

   var SplitterAnimator = function () {
     function SplitterAnimator() {
       var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
       babelHelpers.classCallCheck(this, SplitterAnimator);

       this._options = {
         timing: 'cubic-bezier(.1, .7, .1, 1)',
         duration: '0.3',
         delay: '0'
       };
       this.updateOptions(options);
     }

     babelHelpers.createClass(SplitterAnimator, [{
       key: 'updateOptions',
       value: function updateOptions() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         util.extend(this._options, options);
         this._timing = this._options.timing;
         this._duration = this._options.duration;
         this._delay = this._options.delay;
       }

       /**
        * @param {Element} sideElement
        */

     }, {
       key: 'activate',
       value: function activate(sideElement) {
         var _this = this;

         var splitter = sideElement.parentNode;

         contentReady(splitter, function () {
           _this._side = sideElement;
           _this._content = splitter.content;
           _this._mask = splitter.mask;
         });
       }
     }, {
       key: 'inactivate',
       value: function inactivate() {
         this._content = this._side = this._mask = null;
       }
     }, {
       key: 'translate',
       value: function translate(distance) {
         animit(this._side).queue({
           transform: 'translate3d(' + (this.minus + distance) + 'px, 0px, 0px)'
         }).play();
       }

       /**
        * @param {Function} done
        */

     }, {
       key: 'open',
       value: function open(done) {
         animit.runAll(animit(this._side).wait(this._delay).queue({
           transform: 'translate3d(' + this.minus + '100%, 0px, 0px)'
         }, {
           duration: this._duration,
           timing: this._timing
         }).queue(function (callback) {
           callback();
           done && done();
         }), animit(this._mask).wait(this._delay).queue({
           display: 'block'
         }).queue({
           opacity: '1'
         }, {
           duration: this._duration,
           timing: 'linear'
         }));
       }

       /**
        * @param {Function} done
        */

     }, {
       key: 'close',
       value: function close(done) {
         var _this2 = this;

         animit.runAll(animit(this._side).wait(this._delay).queue({
           transform: 'translate3d(0px, 0px, 0px)'
         }, {
           duration: this._duration,
           timing: this._timing
         }).queue(function (callback) {
           _this2._side.style.webkitTransition = '';
           done && done();
           callback();
         }), animit(this._mask).wait(this._delay).queue({
           opacity: '0'
         }, {
           duration: this._duration,
           timing: 'linear'
         }).queue({
           display: 'none'
         }));
       }
     }, {
       key: 'minus',
       get: function get() {
         return this._side._side === 'right' ? '-' : '';
       }
     }]);
     return SplitterAnimator;
   }();

   var _animatorDict$5 = {
     default: SplitterAnimator,
     overlay: SplitterAnimator
   };

   /**
    * @element ons-splitter
    * @category menu
    * @description
    *  [en]
    *    A component that enables responsive layout by implementing both a two-column layout and a sliding menu layout.
    *
    *    It can be configured to automatically expand into a column layout on large screens and collapse the menu on smaller screens. When the menu is collapsed the user can open it by swiping.
    *  [/en]
    *  [ja][/ja]
    * @codepen rOQOML
    * @tutorial vanilla/Reference/splitter
    * @guide multiple-page-navigation
    *  [en]Managing multiple pages.[/en]
    *  [ja]Managing multiple pages[/ja]
    * @seealso ons-splitter-content
    *  [en]The `<ons-splitter-content>` component contains the main content of the page.[/en]
    *  [ja]ons-splitter-content[/ja]
    * @seealso ons-splitter-side
    *  [en]The `<ons-splitter-side>` component contains the menu.[/en]
    *  [ja]ons-splitter-side[/ja]
    * @example
    * <ons-splitter id="splitter">
    *   <ons-splitter-content>
    *     ...
    *   </ons-splitter-content>
    *
    *   <ons-splitter-side side="left" width="80%" collapse swipeable>
    *     ...
    *   </ons-splitter-side>
    * </ons-splitter>
    *
    * <script>
    *   var splitter = document.getElementById('splitter');
    *   splitter.left.open();
    * </script>
    */

   var SplitterElement = function (_BaseElement) {
     babelHelpers.inherits(SplitterElement, _BaseElement);

     function SplitterElement() {
       babelHelpers.classCallCheck(this, SplitterElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(SplitterElement).apply(this, arguments));
     }

     babelHelpers.createClass(SplitterElement, [{
       key: '_getSide',
       value: function _getSide(side) {
         var element = util.findChild(this, function (e) {
           return util.match(e, 'ons-splitter-side') && e.getAttribute('side') === side;
         });
         return element;
       }

       /**
        * @property left
        * @readonly
        * @type {HTMLElement}
        * @description
        *   [en]Left `<ons-splitter-side>` element.[/en]
        *   [ja][/ja]
        */

     }, {
       key: '_onDeviceBackButton',
       value: function _onDeviceBackButton(event) {
         this._sides.some(function (s) {
           return s.isOpen ? s.close() : false;
         }) || event.callParentHandler();
       }
     }, {
       key: '_onModeChange',
       value: function _onModeChange(e) {
         var _this2 = this;

         if (e.target.parentNode) {
           contentReady(this, function () {
             _this2._layout();
           });
         }
       }
     }, {
       key: '_layout',
       value: function _layout() {
         var _this3 = this;

         this._sides.forEach(function (side) {
           _this3.content.style[side._side] = side.mode === 'split' ? side._width : 0;
         });
       }
     }, {
       key: 'init',
       value: function init() {
         var _this4 = this;

         this._boundOnModeChange = this._onModeChange.bind(this);

         contentReady(this, function () {
           _this4._compile();
           _this4._layout();
         });
       }
     }, {
       key: '_compile',
       value: function _compile() {
         if (!this.mask) {
           this.appendChild(document.createElement('ons-splitter-mask'));
         }
       }
     }, {
       key: 'connectedCallback',
       value: function connectedCallback() {
         this.onDeviceBackButton = this._onDeviceBackButton.bind(this);
         this.addEventListener('modechange', this._boundOnModeChange, false);
       }
     }, {
       key: 'disconnectedCallback',
       value: function disconnectedCallback() {
         this._backButtonHandler.destroy();
         this._backButtonHandler = null;
         this.removeEventListener('modechange', this._boundOnModeChange, false);
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {}
     }, {
       key: '_show',
       value: function _show() {
         util.propagateAction(this, '_show');
       }
     }, {
       key: '_hide',
       value: function _hide() {
         util.propagateAction(this, '_hide');
       }
     }, {
       key: '_destroy',
       value: function _destroy() {
         util.propagateAction(this, '_destroy');
         this.remove();
       }
     }, {
       key: 'left',
       get: function get() {
         return this._getSide('left');
       }
       /**
        * @property right
        * @readonly
        * @type {HTMLElement}
        * @description
        *   [en]Right `<ons-splitter-side>` element.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'right',
       get: function get() {
         return this._getSide('right');
       }
     }, {
       key: '_sides',
       get: function get() {
         return [this.left, this.right].filter(function (e) {
           return e;
         });
       }
       /**
        * @property content
        * @readonly
        * @type {HTMLElement}
        * @description
        *   [en]The `<ons-splitter-content>` element.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'content',
       get: function get() {
         return util.findChild(this, 'ons-splitter-content');
       }
     }, {
       key: 'mask',
       get: function get() {
         return util.findChild(this, 'ons-splitter-mask');
       }

       /**
        * @property onDeviceBackButton
        * @type {Object}
        * @description
        *   [en]Back-button handler.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'onDeviceBackButton',
       get: function get() {
         return this._backButtonHandler;
       },
       set: function set(callback) {
         if (this._backButtonHandler) {
           this._backButtonHandler.destroy();
         }

         this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
       }
     }], [{
       key: 'registerAnimator',
       value: function registerAnimator(name, Animator) {
         if (!(Animator instanceof SplitterAnimator)) {
           throw new Error('Animator parameter must be an instance of SplitterAnimator.');
         }
         _animatorDict$5[name] = Animator;
       }
     }, {
       key: 'SplitterAnimator',
       get: function get() {
         return SplitterAnimator;
       }
     }, {
       key: 'animators',
       get: function get() {
         return _animatorDict$5;
       }
     }]);
     return SplitterElement;
   }(BaseElement);

   customElements.define('ons-splitter', SplitterElement);

   var SPLIT_MODE = 'split';
   var COLLAPSE_MODE = 'collapse';
   var CLOSED_STATE = 'closed';
   var OPEN_STATE = 'open';
   var CHANGING_STATE = 'changing';

   var WATCHED_ATTRIBUTES = ['animation', 'width', 'side', 'collapse', 'swipeable', 'swipe-target-width', 'animation-options', 'open-threshold'];

   var rewritables$2 = {
     /**
      * @param {Element} splitterSideElement
      * @param {Function} callback
      */

     ready: function ready(splitterSideElement, callback) {
       setImmediate(callback);
     },


     /**
      * @param {Element} splitterSideElement
      * @param {HTMLFragment} target
      * @param {Object} options
      * @param {Function} callback
      */
     link: function link(splitterSideElement, target, options, callback) {
       callback(target);
     }
   };

   var CollapseDetection = function () {
     function CollapseDetection(element, target) {
       babelHelpers.classCallCheck(this, CollapseDetection);

       this._element = element;
       this._boundOnChange = this._onChange.bind(this);
       target && this.changeTarget(target);
     }

     babelHelpers.createClass(CollapseDetection, [{
       key: 'changeTarget',
       value: function changeTarget(target) {
         this.disable();
         this._target = target;
         if (target) {
           this._orientation = ['portrait', 'landscape'].indexOf(target) !== -1;
           this.activate();
         }
       }
     }, {
       key: '_match',
       value: function _match(value) {
         if (this._orientation) {
           return this._target === (value.isPortrait ? 'portrait' : 'landscape');
         }
         return value.matches;
       }
     }, {
       key: '_onChange',
       value: function _onChange(value) {
         this._element._updateMode(this._match(value) ? COLLAPSE_MODE : SPLIT_MODE);
       }
     }, {
       key: 'activate',
       value: function activate() {
         if (this._orientation) {
           orientation.on('change', this._boundOnChange);
           this._onChange({ isPortrait: orientation.isPortrait() });
         } else {
           this._queryResult = window.matchMedia(this._target);
           this._queryResult.addListener(this._boundOnChange);
           this._onChange(this._queryResult);
         }
       }
     }, {
       key: 'disable',
       value: function disable() {
         if (this._orientation) {
           orientation.off('change', this._boundOnChange);
         } else if (this._queryResult) {
           this._queryResult.removeListener(this._boundOnChange);
           this._queryResult = null;
         }
       }
     }]);
     return CollapseDetection;
   }();

   var widthToPx = function widthToPx(width, parent) {
     var value = parseInt(width, 10);
     var px = /px/.test(width);

     return px ? value : Math.round(parent.offsetWidth * value / 100);
   };

   var CollapseMode = function () {
     babelHelpers.createClass(CollapseMode, [{
       key: '_animator',
       get: function get() {
         return this._element._animator;
       }
     }]);

     function CollapseMode(element) {
       babelHelpers.classCallCheck(this, CollapseMode);

       this._active = false;
       this._state = CLOSED_STATE;
       this._element = element;
       this._lock = new DoorLock();
     }

     babelHelpers.createClass(CollapseMode, [{
       key: 'isOpen',
       value: function isOpen() {
         return this._active && this._state !== CLOSED_STATE;
       }
     }, {
       key: 'handleGesture',
       value: function handleGesture(e) {
         if (!this._active || this._lock.isLocked() || this._isOpenOtherSideMenu()) {
           return;
         }
         if (e.type === 'dragstart') {
           this._onDragStart(e);
         } else if (!this._ignoreDrag) {
           e.type === 'dragend' ? this._onDragEnd(e) : this._onDrag(e);
         }
       }
     }, {
       key: '_onDragStart',
       value: function _onDragStart(event) {
         var scrolling = !/left|right/.test(event.gesture.direction);
         var distance = this._element._side === 'left' ? event.gesture.center.clientX : window.innerWidth - event.gesture.center.clientX;
         var area = this._element._swipeTargetWidth;
         var isOpen = this.isOpen();
         this._ignoreDrag = scrolling || area && distance > area && !isOpen;

         this._width = widthToPx(this._element._width, this._element.parentNode);
         this._startDistance = this._distance = isOpen ? this._width : 0;
       }
     }, {
       key: '_onDrag',
       value: function _onDrag(event) {
         event.gesture.preventDefault();
         var delta = this._element._side === 'left' ? event.gesture.deltaX : -event.gesture.deltaX;
         var distance = Math.max(0, Math.min(this._width, this._startDistance + delta));
         if (distance !== this._distance) {
           this._animator.translate(distance);
           this._distance = distance;
           this._state = CHANGING_STATE;
         }
       }
     }, {
       key: '_onDragEnd',
       value: function _onDragEnd(event) {
         var distance = this._distance;
         var width = this._width;
         var el = this._element;

         var direction = event.gesture.interimDirection;
         var shouldOpen = el._side !== direction && distance > width * el._threshold;
         this.executeAction(shouldOpen ? 'open' : 'close');
         this._ignoreDrag = true;
       }
     }, {
       key: 'layout',
       value: function layout() {
         if (this._active && this._state === OPEN_STATE) {
           this._animator.open();
         }
       }

       // enter collapse mode

     }, {
       key: 'enterMode',
       value: function enterMode() {
         if (!this._active) {
           this._active = true;
           this.layout();
         }
       }

       // exit collapse mode

     }, {
       key: 'exitMode',
       value: function exitMode() {
         this._active = false;
       }
     }, {
       key: '_isOpenOtherSideMenu',
       value: function _isOpenOtherSideMenu() {
         var _this = this;

         return util.arrayFrom(this._element.parentElement.children).some(function (e) {
           return util.match(e, 'ons-splitter-side') && e !== _this._element && e.isOpen;
         });
       }

       /**
        * @param {String} name - 'open' or 'close'
        * @param {Object} [options]
        * @param {Function} [options.callback]
        * @param {Boolean} [options.withoutAnimation]
        * @return {Promise} Resolves to the splitter side element or false if not in collapse mode
        */

     }, {
       key: 'executeAction',
       value: function executeAction(name) {
         var _this2 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         var FINAL_STATE = name === 'open' ? OPEN_STATE : CLOSED_STATE;

         if (!this._active) {
           return Promise.resolve(false);
         }

         if (this._state === FINAL_STATE) {
           return Promise.resolve(this._element);
         }
         if (this._lock.isLocked()) {
           return Promise.reject('Splitter side is locked.');
         }
         if (name === 'open' && this._isOpenOtherSideMenu()) {
           return Promise.reject('Another menu is already open.');
         }
         if (this._element._emitEvent('pre' + name)) {
           return Promise.reject('Canceled in pre' + name + ' event.');
         }

         var callback = options.callback;
         var unlock = this._lock.lock();
         var done = function done() {
           _this2._state = FINAL_STATE;
           _this2.layout();
           unlock();
           _this2._element._emitEvent('post' + name);
           callback && callback();
         };

         if (options.withoutAnimation) {
           done();
           return Promise.resolve(this._element);
         }
         this._state = CHANGING_STATE;
         return new Promise(function (resolve) {
           _this2._animator[name](function () {
             done();
             resolve(_this2._element);
           });
         });
       }
     }]);
     return CollapseMode;
   }();

   /**
    * @element ons-splitter-side
    * @category menu
    * @description
    *  [en]
    *    The `<ons-splitter-side>` element is used as a child element of `<ons-splitter>`.
    *
    *    It will be displayed on either the left or right side of the `<ons-splitter-content>` element.
    *
    *    It supports two modes: collapsed and split. When it's in collapsed mode it will be hidden from view and can be displayed when the user swipes the screen or taps a button. In split mode the element is always shown. It can be configured to automatically switch between the two modes depending on the screen size.
    *  [/en]
    *  [ja]ons-splitter-sideons-splitter[/ja]
    * @codepen rOQOML
    * @tutorial vanilla/Reference/splitter
    * @guide multiple-page-navigation
    *  [en]Managing multiple pages.[/en]
    *  [ja]Managing multiple pages[/ja]
    * @seealso ons-splitter
    *  [en]The `<ons-splitter>` is the parent component.[/en]
    *  [ja]ons-splitter[/ja]
    * @seealso ons-splitter-content
    *  [en]The `<ons-splitter-content>` component contains the main content of the page.[/en]
    *  [ja]ons-splitter-content[/ja]
    * @example
    * <ons-splitter>
    *   <ons-splitter-content>
    *     ...
    *   </ons-splitter-content>
    *
    *   <ons-splitter-side side="left" width="80%" collapse>
    *     ...
    *   </ons-splitter-side>
    * </ons-splitter>
    */


   var SplitterSideElement = function (_BaseElement) {
     babelHelpers.inherits(SplitterSideElement, _BaseElement);

     function SplitterSideElement() {
       babelHelpers.classCallCheck(this, SplitterSideElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(SplitterSideElement).apply(this, arguments));
     }

     babelHelpers.createClass(SplitterSideElement, [{
       key: 'init',


       /**
        * @event modechange
        * @description
        *   [en]Fired just after the component's mode changes.[/en]
        *   [ja][/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja][/ja]
        * @param {Object} event.side
        *   [en]Component object.[/en]
        *   [ja][/ja]
        * @param {String} event.mode
        *   [en]Returns the current mode. Can be either `"collapse"` or `"split"`.[/en]
        *   [ja][/ja]
        */

       /**
        * @event preopen
        * @description
        *   [en]Fired just before the sliding menu is opened.[/en]
        *   [ja][/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja][/ja]
        * @param {Function} event.cancel
        *   [en]Call to cancel opening sliding menu.[/en]
        *   [ja][/ja]
        * @param {Object} event.side
        *   [en]Component object.[/en]
        *   [ja][/ja]
        */

       /**
        * @event postopen
        * @description
        *   [en]Fired just after the sliding menu is opened.[/en]
        *   [ja][/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja][/ja]
        * @param {Object} event.side
        *   [en]Component object.[/en]
        *   [ja][/ja]
        */

       /**
        * @event preclose
        * @description
        *   [en]Fired just before the sliding menu is closed.[/en]
        *   [ja][/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja][/ja]
        * @param {Object} event.side
        *   [en]Component object.[/en]
        *   [ja][/ja]
        * @param {Function} event.cancel
        *   [en]Call to cancel opening sliding-menu.[/en]
        *   [ja][/ja]
        */

       /**
        * @event postclose
        * @description
        *   [en]Fired just after the sliding menu is closed.[/en]
        *   [ja][/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja][/ja]
        * @param {Object} event.side
        *   [en]Component object.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute animation
        * @type {String}
        * @default  default
        * @description
        *  [en]Specify the animation. Use one of `"overlay"`, and `"default"`.[/en]
        *  [ja]"overlay", "default"[/ja]
        */

       /**
        * @attribute animation-options
        * @type {Expression}
        * @description
        *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
        *  [ja]duration, timing, delaye.g. {duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
        */

       /**
        * @attribute open-threshold
        * @type {Number}
        * @default  0.3
        * @description
        *  [en]Specify how much the menu needs to be swiped before opening. A value between `0` and `1`.[/en]
        *  [ja]010.3[/ja]
        */

       /**
        * @attribute collapse
        * @type {String}
        * @description
        *   [en]
        *     Specify the collapse behavior. Valid values are `"portrait"`, `"landscape"` or a media query.
        *     The strings `"portrait"` and `"landscape"` means the view will collapse when device is in landscape or portrait orientation.
        *     If the value is a media query, the view will collapse when the media query resolves to `true`.
        *     If the value is not defined, the view always be in `"collapse"` mode.
        *   [/en]
        *   [ja]
        *     portrait, landscapewidth #px
        *     portraitlandscape
        *     
        *     collapse
        *   [/ja]
        */

       /**
        * @attribute swipe-target-width
        * @type {String}
        * @description
        *   [en]The width of swipeable area calculated from the edge (in pixels). Use this to enable swipe only when the finger touch on the screen edge.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute width
        * @type {String}
        * @description
        *   [en]Can be specified in either pixels or as a percentage, e.g. `90%` or `200px`.[/en]
        *   [ja]px%eg. 90%, 200px[/ja]
        */

       /**
        * @attribute side
        * @type {String}
        * @default left
        * @description
        *   [en]Specify which side of the screen the `<ons-splitter-side>` element is located. Possible values are `"left"` and `"right"`.[/en]
        *   [ja]"left""right"[/ja]
        */

       /**
        * @attribute mode
        * @type {String}
        * @description
        *   [en]Current mode. Possible values are `"collapse"` or `"split"`. This attribute is read only.[/en]
        *   [ja]"collapse""split"[/ja]
        */

       /**
        * @attribute page
        * @initonly
        * @type {String}
        * @description
        *   [en]The URL of the menu page.[/en]
        *   [ja]ons-splitter-sideURL[/ja]
        */

       /**
        * @attribute swipeable
        * @type {Boolean}
        * @description
        *   [en]Whether to enable swipe interaction on collapse mode.[/en]
        *   [ja]collapse[/ja]
        */

       value: function init() {
         var _this4 = this;

         this._page = null;
         this._pageLoader = defaultPageLoader;
         this._collapseMode = new CollapseMode(this);
         this._collapseDetection = new CollapseDetection(this);

         this._animatorFactory = new AnimatorFactory({
           animators: SplitterElement.animators,
           baseClass: SplitterAnimator,
           baseClassName: 'SplitterAnimator',
           defaultAnimation: this.getAttribute('animation')
         });
         this._boundHandleGesture = function (e) {
           return _this4._collapseMode.handleGesture(e);
         };
         this._watchedAttributes = WATCHED_ATTRIBUTES;
         contentReady(this, function () {
           rewritables$2.ready(_this4, function () {
             var page = _this4._getPageTarget();

             if (page) {
               _this4.load(page);
             }
           });
         });
       }
     }, {
       key: 'connectedCallback',
       value: function connectedCallback() {
         var _this5 = this;

         if (!util.match(this.parentNode, 'ons-splitter')) {
           throw new Error('Parent must be an ons-splitter element.');
         }

         this._gestureDetector = new GestureDetector(this.parentElement, { dragMinDistance: 1 });

         contentReady(this, function () {
           _this5._watchedAttributes.forEach(function (e) {
             return _this5._update(e);
           });
         });

         if (!this.hasAttribute('side')) {
           this.setAttribute('side', 'left');
         }
       }
     }, {
       key: '_getPageTarget',
       value: function _getPageTarget() {
         return this._page || this.getAttribute('page');
       }
     }, {
       key: 'disconnectedCallback',
       value: function disconnectedCallback() {
         this._collapseDetection.disable();
         this._gestureDetector.dispose();
         this._gestureDetector = null;
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         this._update(name, current);
       }
     }, {
       key: '_update',
       value: function _update(name, value) {
         name = '_update' + name.split('-').map(function (e) {
           return e[0].toUpperCase() + e.slice(1);
         }).join('');
         return this[name](value);
       }
     }, {
       key: '_emitEvent',
       value: function _emitEvent(name) {
         if (name.slice(0, 3) !== 'pre') {
           return util.triggerElementEvent(this, name, { side: this });
         }
         var isCanceled = false;

         util.triggerElementEvent(this, name, {
           side: this,
           cancel: function cancel() {
             return isCanceled = true;
           }
         });

         return isCanceled;
       }
     }, {
       key: '_updateCollapse',
       value: function _updateCollapse() {
         var value = arguments.length <= 0 || arguments[0] === undefined ? this.getAttribute('collapse') : arguments[0];

         if (value === null || value === 'split') {
           this._collapseDetection.disable();
           return this._updateMode(SPLIT_MODE);
         }
         if (value === '' || value === 'collapse') {
           this._collapseDetection.disable();
           return this._updateMode(COLLAPSE_MODE);
         }

         this._collapseDetection.changeTarget(value);
       }

       // readonly attribute for the users

     }, {
       key: '_updateMode',
       value: function _updateMode(mode) {
         if (mode !== this._mode) {
           this._mode = mode;
           this._collapseMode[mode === COLLAPSE_MODE ? 'enterMode' : 'exitMode']();
           this.setAttribute('mode', mode);

           util.triggerElementEvent(this, 'modechange', { side: this, mode: mode });
         }
       }
     }, {
       key: '_updateOpenThreshold',
       value: function _updateOpenThreshold() {
         var threshold = arguments.length <= 0 || arguments[0] === undefined ? this.getAttribute('open-threshold') : arguments[0];

         this._threshold = Math.max(0, Math.min(1, parseFloat(threshold) || 0.3));
       }
     }, {
       key: '_updateSwipeable',
       value: function _updateSwipeable() {
         var swipeable = arguments.length <= 0 || arguments[0] === undefined ? this.getAttribute('swipeable') : arguments[0];

         var action = swipeable === null ? 'off' : 'on';

         if (this._gestureDetector) {
           this._gestureDetector[action]('dragstart dragleft dragright dragend', this._boundHandleGesture);
         }
       }
     }, {
       key: '_updateSwipeTargetWidth',
       value: function _updateSwipeTargetWidth() {
         var value = arguments.length <= 0 || arguments[0] === undefined ? this.getAttribute('swipe-target-width') : arguments[0];

         this._swipeTargetWidth = Math.max(0, parseInt(value) || 0);
       }
     }, {
       key: '_updateWidth',
       value: function _updateWidth() {
         this.style.width = this._width;
       }
     }, {
       key: '_updateSide',
       value: function _updateSide() {
         var side = arguments.length <= 0 || arguments[0] === undefined ? this.getAttribute('side') : arguments[0];

         this._side = side === 'right' ? side : 'left';
       }
     }, {
       key: '_updateAnimation',
       value: function _updateAnimation() {
         var animation = arguments.length <= 0 || arguments[0] === undefined ? this.getAttribute('animation') : arguments[0];

         this._animator = this._animatorFactory.newAnimator({ animation: animation });
         this._animator.activate(this);
       }
     }, {
       key: '_updateAnimationOptions',
       value: function _updateAnimationOptions() {
         var value = arguments.length <= 0 || arguments[0] === undefined ? this.getAttribute('animation-options') : arguments[0];

         this._animator.updateOptions(AnimatorFactory.parseAnimationOptionsString(value));
       }

       /**
        * @property page
        * @type {*}
        * @description
        *   [en]Page location to load in the splitter side.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'open',


       /**
        * @method open
        * @signature open([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {Function} [options.callback]
        *   [en]This function will be called after the menu has been opened.[/en]
        *   [ja][/ja]
        * @description
        *   [en]Open menu in collapse mode.[/en]
        *   [ja]collapseons-splitter-side[/ja]
        * @return {Promise}
        *   [en]Resolves to the splitter side element or false if not in collapse mode[/en]
        *   [ja][/ja]
        */
       value: function open() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         return this._collapseMode.executeAction('open', options);
       }

       /**
        * @method close
        * @signature close([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {Function} [options.callback]
        *   [en]This function will be called after the menu has been closed.[/en]
        *   [ja][/ja]
        * @description
        *   [en]Close menu in collapse mode.[/en]
        *   [ja]collapseons-splitter-side[/ja]
        * @return {Promise}
        *   [en]Resolves to the splitter side element or false if not in collapse mode[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'close',
       value: function close() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         return this._collapseMode.executeAction('close', options);
       }

       /**
        * @method toggle
        * @signature toggle([options])
        * @param {Object} [options]
        * @description
        *   [en]Opens if it's closed. Closes if it's open.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Resolves to the splitter side element or false if not in collapse mode[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'toggle',
       value: function toggle() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         return this.isOpen ? this.close(options) : this.open(options);
       }

       /**
        * @method load
        * @signature load(page, [options])
        * @param {String} page
        *   [en]Page URL. Can be either an HTML document or an <ons-template>.[/en]
        *   [ja]pageURLons-templateid[/ja]
        * @param {Object} [options]
        * @param {Function} [options.callback]
        * @description
        *   [en]Show the page specified in pageUrl in the right section[/en]
        *   [ja]URL[/ja]
        * @return {Promise}
        *   [en]Resolves to the new page element[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'load',
       value: function load(page) {
         var _this6 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         this._page = page;
         var callback = options.callback || function () {};

         return new Promise(function (resolve) {
           _this6._pageLoader.load({ page: page, parent: _this6, replace: true }, function (_ref) {
             var element = _ref.element;
             var unload = _ref.unload;

             rewritables$2.link(_this6, element, options, function (fragment) {
               setImmediate(function () {
                 return _this6._show();
               });
               callback();

               resolve(_this6.firstChild);
             });
           });
         });
       }
     }, {
       key: '_show',
       value: function _show() {
         util.propagateAction(this, '_show');
       }
     }, {
       key: '_hide',
       value: function _hide() {
         util.propagateAction(this, '_hide');
       }
     }, {
       key: '_destroy',
       value: function _destroy() {
         util.propagateAction(this, '_destroy');
         this.remove();
       }
     }, {
       key: '_width',
       get: function get() {
         var width = this.getAttribute('width');
         return (/^\d+(px|%)$/.test(width) ? width : '80%'
         );
       },
       set: function set(value) {
         this.setAttribute('width', value);
       }
     }, {
       key: 'page',
       get: function get() {
         return this._page;
       }

       /**
        * @param {*} page
        */
       ,
       set: function set(page) {
         this._page = page;
       }

       /**
        * @property pageLoader
        * @description
        *   [en][/en]
        *   [ja][/ja]
        */

     }, {
       key: 'pageLoader',
       get: function get() {
         return this._pageLoader;
       },
       set: function set(loader) {
         if (!(loader instanceof PageLoader)) {
           throw Error('First parameter must be an instance of PageLoader.');
         }
         this._pageLoader = loader;
       }

       /**
        * @property mode
        * @readonly
        * @type {String}
        * @description
        *   [en]Current mode. Possible values are "split", "collapse", "closed", "open" or "changing".[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'mode',
       get: function get() {
         return this._mode;
       }

       /**
        * @property isOpen
        * @type {Boolean}
        * @readonly
        * @description
        *   [en]This value is `true` when the menu is open..[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'isOpen',
       get: function get() {
         return this._collapseMode.isOpen();
       }
     }], [{
       key: 'observedAttributes',
       get: function get() {
         return WATCHED_ATTRIBUTES;
       }
     }, {
       key: 'rewritables',
       get: function get() {
         return rewritables$2;
       }
     }]);
     return SplitterSideElement;
   }(BaseElement);

   customElements.define('ons-splitter-side', SplitterSideElement);

   var scheme$19 = {
     '': 'switch--*',
     '.switch__input': 'switch--*__input',
     '.switch__handle': 'switch--*__handle',
     '.switch__toggle': 'switch--*__toggle'
   };

   var template$2 = util.createFragment('\n  <input type="checkbox" class="switch__input">\n  <div class="switch__toggle">\n    <div class="switch__handle">\n      <div class="switch__touch"></div>\n    </div>\n  </div>\n');

   var locations = {
     ios: [1, 21],
     material: [0, 16]
   };

   /**
    * @element ons-switch
    * @category form
    * @description
    *   [en]
    *     Switch component. The switch can be toggled both by dragging and tapping.
    *
    *     Will automatically displays a Material Design switch on Android devices.
    *   [/en]
    *   [ja][/ja]
    * @modifier material
    *   [en]Material Design switch[/en]
    *   [ja][/ja]
    * @codepen LpXZQQ
    * @tutorial vanilla/Reference/switch
    * @guide adding-page-content
    *   [en]Using form components[/en]
    *   [ja][/ja]
    * @guide using-modifier [en]More details about the `modifier` attribute[/en][ja]modifier[/ja]
    * @example
    * <ons-switch checked></ons-switch>
    * <ons-switch disabled></ons-switch>
    * <ons-switch modifier="material"></ons-switch>
    */

   var SwitchElement = function (_BaseElement) {
     babelHelpers.inherits(SwitchElement, _BaseElement);

     function SwitchElement() {
       babelHelpers.classCallCheck(this, SwitchElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(SwitchElement).apply(this, arguments));
     }

     babelHelpers.createClass(SwitchElement, [{
       key: 'init',
       value: function init() {
         var _this2 = this;

         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }

         this._checkbox = this.querySelector('.switch__input');
         this._handle = this.querySelector('.switch__handle');

         ['checked', 'disabled', 'modifier', 'name', 'input-id'].forEach(function (e) {
           _this2.attributeChangedCallback(e, null, _this2.getAttribute(e));
         });
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         this.classList.add('switch');

         this.appendChild(template$2.cloneNode(true));

         this.setAttribute('_compiled', '');
       }
     }, {
       key: 'disconnectedCallback',
       value: function disconnectedCallback() {
         this._checkbox.removeEventListener('change', this._onChange);
         this.removeEventListener('dragstart', this._onDragStart);
         this.removeEventListener('hold', this._onHold);
         this.removeEventListener('tap', this.click);
         this.removeEventListener('click', this._onClick);
         this._gestureDetector.dispose();
       }
     }, {
       key: 'connectedCallback',
       value: function connectedCallback() {
         this._checkbox.addEventListener('change', this._onChange);
         this._gestureDetector = new GestureDetector(this, { dragMinDistance: 1, holdTimeout: 251 });
         this.addEventListener('dragstart', this._onDragStart);
         this.addEventListener('hold', this._onHold);
         this.addEventListener('tap', this.click);
         this._boundOnRelease = this._onRelease.bind(this);
         this.addEventListener('click', this._onClick);
       }
     }, {
       key: '_onChange',
       value: function _onChange() {
         if (this.checked) {
           this.parentNode.setAttribute('checked', '');
         } else {
           this.parentNode.removeAttribute('checked');
         }
       }
     }, {
       key: '_onClick',
       value: function _onClick(ev) {
         if (ev.target.classList.contains('switch__touch')) {
           ev.preventDefault();
         }
       }
     }, {
       key: 'click',
       value: function click() {
         if (!this.disabled) {
           this.checked = !this.checked;
         }
       }
     }, {
       key: '_getPosition',
       value: function _getPosition(e) {
         var l = this._locations;
         return Math.min(l[1], Math.max(l[0], this._startX + e.gesture.deltaX));
       }
     }, {
       key: '_onHold',
       value: function _onHold(e) {
         if (!this.disabled) {
           this.classList.add('switch--active');
           document.addEventListener('release', this._boundOnRelease);
         }
       }
     }, {
       key: '_onDragStart',
       value: function _onDragStart(e) {
         if (this.disabled || ['left', 'right'].indexOf(e.gesture.direction) === -1) {
           this.classList.remove('switch--active');
           return;
         }

         e.stopPropagation();

         this.classList.add('switch--active');
         this._startX = this._locations[this.checked ? 1 : 0]; // - e.gesture.deltaX;

         this.addEventListener('drag', this._onDrag);
         document.addEventListener('release', this._boundOnRelease);
       }
     }, {
       key: '_onDrag',
       value: function _onDrag(e) {
         e.gesture.srcEvent.preventDefault();
         this._handle.style.left = this._getPosition(e) + 'px';
       }
     }, {
       key: '_onRelease',
       value: function _onRelease(e) {
         var l = this._locations;
         var position = this._getPosition(e);

         this.checked = position >= (l[0] + l[1]) / 2;

         this.removeEventListener('drag', this._onDrag);
         document.removeEventListener('release', this._boundOnRelease);

         this._handle.style.left = '';
         this.classList.remove('switch--active');
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         switch (name) {
           case 'modifier':
             this._isMaterial = (current || '').indexOf('material') !== -1;
             this._locations = locations[this._isMaterial ? 'material' : 'ios'];
             ModifierUtil.onModifierChanged(last, current, this, scheme$19);
             break;
           case 'input-id':
             this._checkbox.id = current;
             break;
           case 'checked':
             this._checkbox.checked = current !== null;
             util.toggleAttribute(this._checkbox, name, current !== null);
             break;
           case 'disabled':
             util.toggleAttribute(this._checkbox, name, current !== null);
         }
       }
     }, {
       key: 'checked',


       /**
        * @event change
        * @description
        *   [en]Fired when the switch is toggled.[/en]
        *   [ja]ON/OFF[/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja][/ja]
        * @param {Object} event.switch
        *   [en]Switch object.[/en]
        *   [ja]Switch[/ja]
        * @param {Boolean} event.value
        *   [en]Current value.[/en]
        *   [ja][/ja]
        * @param {Boolean} event.isInteractive
        *   [en]True if the change was triggered by the user clicking on the switch.[/en]
        *   [ja]true[/ja]
        */

       /**
        * @attribute modifier
        * @type {String}
        * @description
        *  [en]The appearance of the switch.[/en]
        *  [ja][/ja]
        */

       /**
        * @attribute disabled
        * @description
        *   [en]Whether the switch is be disabled.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute checked
        * @description
        *   [en]Whether the switch is checked.[/en]
        *   [ja]ON[/ja]
        */

       /**
        * @attribute input-id
        * @type {String}
        * @description
        *  [en]Specify the `id` attribute of the inner `<input>` element. This is useful when using `<label for="...">` elements.[/en]
        *  [ja][/ja]
        */

       /**
        * @property checked
        * @type {Boolean}
        * @description
        *   [en]This value is `true` if the switch is checked.[/en]
        *   [ja]ON`true`[/ja]
        */

       get: function get() {
         return this._checkbox.checked;
       },
       set: function set(value) {
         if (!!value !== this._checkbox.checked) {
           this._checkbox.click();
           this._checkbox.checked = !!value;
           return util.toggleAttribute(this, 'checked', this.checked);
         }
       }

       /**
        * @property disabled
        * @type {Boolean}
        * @description
        *   [en]Whether the element is disabled or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'disabled',
       get: function get() {
         return this._checkbox.disabled;
       },
       set: function set(value) {
         this._checkbox.disabled = value;
         return util.toggleAttribute(this, 'disabled', this.disabled);
       }

       /**
        * @property checkbox
        * @readonly
        * @type {HTMLElement}
        * @description
        *   [en]The underlying checkbox element.[/en]
        *   [ja]checkbox[/ja]
        */

     }, {
       key: 'checkbox',
       get: function get() {
         return this._checkbox;
       }
     }], [{
       key: 'observedAttributes',
       get: function get() {
         return ['modifier', 'input-id', 'checked', 'disabled'];
       }
     }]);
     return SwitchElement;
   }(BaseElement);

   customElements.define('ons-switch', SwitchElement);

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */

   var TabbarAnimator = function () {

     /**
      * @param {Object} options
      * @param {String} options.timing
      * @param {Number} options.duration
      * @param {Number} options.delay
      */

     function TabbarAnimator() {
       var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
       babelHelpers.classCallCheck(this, TabbarAnimator);

       this.timing = options.timing || 'linear';
       this.duration = options.duration !== undefined ? options.duration : '0.4';
       this.delay = options.delay !== undefined ? options.delay : '0';
     }

     /**
      * @param {Element} enterPage ons-page element
      * @param {Element} leavePage ons-page element
      * @param {Number} enterPageIndex
      * @param {Number} leavePageIndex
      * @param {Function} done
      */


     babelHelpers.createClass(TabbarAnimator, [{
       key: 'apply',
       value: function apply(enterPage, leavePage, enterPageIndex, leavePageIndex, done) {
         throw new Error('This method must be implemented.');
       }
     }]);
     return TabbarAnimator;
   }();

   var TabbarNoneAnimator = function (_TabbarAnimator) {
     babelHelpers.inherits(TabbarNoneAnimator, _TabbarAnimator);

     function TabbarNoneAnimator() {
       babelHelpers.classCallCheck(this, TabbarNoneAnimator);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(TabbarNoneAnimator).apply(this, arguments));
     }

     babelHelpers.createClass(TabbarNoneAnimator, [{
       key: 'apply',
       value: function apply(enterPage, leavePage, enterIndex, leaveIndex, done) {
         setTimeout(done, 1000 / 60);
       }
     }]);
     return TabbarNoneAnimator;
   }(TabbarAnimator);

   var TabbarFadeAnimator = function (_TabbarAnimator2) {
     babelHelpers.inherits(TabbarFadeAnimator, _TabbarAnimator2);

     function TabbarFadeAnimator(options) {
       babelHelpers.classCallCheck(this, TabbarFadeAnimator);

       options.timing = options.timing !== undefined ? options.timing : 'linear';
       options.duration = options.duration !== undefined ? options.duration : '0.4';
       options.delay = options.delay !== undefined ? options.delay : '0';

       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(TabbarFadeAnimator).call(this, options));
     }

     babelHelpers.createClass(TabbarFadeAnimator, [{
       key: 'apply',
       value: function apply(enterPage, leavePage, enterPageIndex, leavePageIndex, done) {
         animit.runAll(animit(enterPage).saveStyle().queue({
           transform: 'translate3D(0, 0, 0)',
           opacity: 0
         }).wait(this.delay).queue({
           transform: 'translate3D(0, 0, 0)',
           opacity: 1
         }, {
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (callback) {
           done();
           callback();
         }), animit(leavePage).queue({
           transform: 'translate3D(0, 0, 0)',
           opacity: 1
         }).wait(this.delay).queue({
           transform: 'translate3D(0, 0, 0)',
           opacity: 0
         }, {
           duration: this.duration,
           timing: this.timing
         }));
       }
     }]);
     return TabbarFadeAnimator;
   }(TabbarAnimator);

   var TabbarSlideAnimator = function (_TabbarAnimator3) {
     babelHelpers.inherits(TabbarSlideAnimator, _TabbarAnimator3);

     function TabbarSlideAnimator(options) {
       babelHelpers.classCallCheck(this, TabbarSlideAnimator);

       options.timing = options.timing !== undefined ? options.timing : 'ease-in';
       options.duration = options.duration !== undefined ? options.duration : '0.15';
       options.delay = options.delay !== undefined ? options.delay : '0';

       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(TabbarSlideAnimator).call(this, options));
     }

     /**
      * @param {jqLite} enterPage
      * @param {jqLite} leavePage
      */


     babelHelpers.createClass(TabbarSlideAnimator, [{
       key: 'apply',
       value: function apply(enterPage, leavePage, enterIndex, leaveIndex, done) {
         var sgn = enterIndex > leaveIndex;

         animit.runAll(animit(enterPage).saveStyle().queue({
           transform: 'translate3D(' + (sgn ? '' : '-') + '100%, 0, 0)'
         }).wait(this.delay).queue({
           transform: 'translate3D(0, 0, 0)'
         }, {
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (callback) {
           done();
           callback();
         }), animit(leavePage).queue({
           transform: 'translate3D(0, 0, 0)'
         }).wait(this.delay).queue({
           transform: 'translate3D(' + (sgn ? '-' : '') + '100%, 0, 0)'
         }, {
           duration: this.duration,
           timing: this.timing
         }));
       }
     }]);
     return TabbarSlideAnimator;
   }(TabbarAnimator);

   var scheme$21 = {
     '.tab-bar__content': 'tab-bar--*__content',
     '.tab-bar': 'tab-bar--*'
   };

   var _animatorDict$6 = {
     'default': TabbarNoneAnimator,
     'fade': TabbarFadeAnimator,
     'slide': TabbarSlideAnimator,
     'none': TabbarNoneAnimator
   };

   var rewritables$3 = {
     /**
      * @param {Element} tabbarElement
      * @param {Function} callback
      */

     ready: function ready(tabbarElement, callback) {
       callback();
     },


     /**
      * @param {Element} tabbarElement
      * @param {Element} target
      * @param {Object} options
      * @param {Function} callback
      */
     link: function link(tabbarElement, target, options, callback) {
       callback(target);
     },


     /**
      * @param {Element} tabbarElement
      * @param {Element} target
      * @param {Function} callback
      */
     unlink: function unlink(tabbarElement, target, callback) {
       callback(target);
     }
   };

   var generateId$1 = function () {
     var i = 0;
     return function () {
       return 'ons-tabbar-gen-' + i++;
     };
   }();

   /**
    * @element ons-tabbar
    * @category tabbar
    * @description
    *   [en]A component to display a tab bar on the bottom of a page. Used with `<ons-tab>` to manage pages using tabs.[/en]
    *   [ja]ons-tab[/ja]
    * @codepen pGuDL
    * @tutorial vanilla/Reference/tabbar
    * @guide multiple-page-navigation
    *  [en]Managing multiple pages.[/en]
    *  [ja]Managing multiple pages[/ja]
    * @guide templates
    *   [en]Defining multiple pages in single html[/en]
    *   [ja]1HTML[/ja]
    * @seealso ons-tab
    *   [en]The `<ons-tab>` component.[/en]
    *   [ja]ons-tab[/ja]
    * @seealso ons-page
    *   [en]The `<ons-page>` component.[/en]
    *   [ja]ons-page[/ja]
    * @example
    * <ons-tabbar>
    *   <ons-tab
    *     page="home.html"
    *     label="Home"
    *     active>
    *   </ons-tab>
    *   <ons-tab
    *     page="settings.html"
    *     label="Settings"
    *     active>
    *   </ons-tab>
    * </ons-tabbar>
    *
    * <ons-template id="home.html">
    *   ...
    * </ons-template>
    *
    * <ons-template id="settings.html">
    *   ...
    * </ons-template>
    */

   var TabbarElement = function (_BaseElement) {
     babelHelpers.inherits(TabbarElement, _BaseElement);

     function TabbarElement() {
       babelHelpers.classCallCheck(this, TabbarElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(TabbarElement).apply(this, arguments));
     }

     babelHelpers.createClass(TabbarElement, [{
       key: 'init',


       /**
        * @event prechange
        * @description
        *   [en]Fires just before the tab is changed.[/en]
        *   [ja][/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja][/ja]
        * @param {Number} event.index
        *   [en]Current index.[/en]
        *   [ja]ons-tab[/ja]
        * @param {Object} event.tabItem
        *   [en]Tab item object.[/en]
        *   [ja]tabItem[/ja]
        * @param {Function} event.cancel
        *   [en]Call this function to cancel the change event.[/en]
        *   [ja][/ja]
        */

       /**
        * @event postchange
        * @description
        *   [en]Fires just after the tab is changed.[/en]
        *   [ja][/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja][/ja]
        * @param {Number} event.index
        *   [en]Current index.[/en]
        *   [ja]ons-tab[/ja]
        * @param {Object} event.tabItem
        *   [en]Tab item object.[/en]
        *   [ja]tabItem[/ja]
        */

       /**
        * @event reactive
        * @description
        *   [en]Fires if the already open tab is tapped again.[/en]
        *   [ja][/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja][/ja]
        * @param {Number} event.index
        *   [en]Current index.[/en]
        *   [ja]ons-tab[/ja]
        * @param {Object} event.tabItem
        *   [en]Tab item object.[/en]
        *   [ja]tabItem[/ja]
        */

       /**
        * @attribute animation
        * @type {String}
        * @default none
        * @description
        *   [en]Animation name. Available values are `"none"`, `"slide"` and `"fade"`. Default is `"none"`.[/en]
        *   [ja]"none""fade""slide""none"[/ja]
        */

       /**
        * @attribute animation-options
        * @type {Expression}
        * @description
        *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
        *  [ja]duration, timing, delaye.g. {duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
        */

       /**
        * @attribute position
        * @initonly
        * @type {String}
        * @default bottom
        * @description
        *   [en]Tabbar's position. Available values are `"bottom"` and `"top"`. Use `"auto"` to choose position depending on platform (iOS bottom, Android top).[/en]
        *   [ja]"bottom""top""bottom"[/ja]
        */

       value: function init() {
         var _this2 = this;

         this._tabbarId = generateId$1();

         contentReady(this, function () {
           _this2._compile();

           var content = _this2._contentElement;
           for (var i = 0; i < content.children.length; i++) {
             content.children[i].style.display = 'none';
           }

           var activeIndex = _this2.getAttribute('activeIndex');

           var tabbar = _this2._tabbarElement;
           if (activeIndex && tabbar.children.length > activeIndex) {
             tabbar.children[activeIndex].setAttribute('active', 'true');
           }

           autoStyle.prepare(_this2);
           ModifierUtil.initModifier(_this2, scheme$21);

           _this2._animatorFactory = new AnimatorFactory({
             animators: _animatorDict$6,
             baseClass: TabbarAnimator,
             baseClassName: 'TabbarAnimator',
             defaultAnimation: _this2.getAttribute('animation')
           });
         });
       }
     }, {
       key: 'connectedCallback',
       value: function connectedCallback() {
         var _this3 = this;

         contentReady(this, function () {
           return _this3._updatePosition();
         });
       }
     }, {
       key: '_compile',
       value: function _compile() {
         if (this._contentElement && this._tabbarElement) {
           var content = util.findChild(this, '.tab-bar__content');
           var bar = util.findChild(this, '.tab-bar');

           content.classList.add('ons-tab-bar__content');
           bar.classList.add('ons-tab-bar__footer');
           bar.classList.add('ons-tabbar-inner');
         } else {

           var _content = util.create('.ons-tab-bar__content.tab-bar__content');
           var tabbar = util.create('.tab-bar.ons-tab-bar__footer.ons-tabbar-inner');

           while (this.firstChild) {
             tabbar.appendChild(this.firstChild);
           }

           this.appendChild(_content);
           this.appendChild(tabbar);
         }
       }
     }, {
       key: '_updatePosition',
       value: function _updatePosition() {
         var _this4 = this;

         var position = arguments.length <= 0 || arguments[0] === undefined ? this.getAttribute('position') : arguments[0];

         var top = this._top = position === 'top' || position === 'auto' && platform.isAndroid();
         var action = top ? util.addModifier : util.removeModifier;

         action(this, 'top');

         var page = util.findParent(this, 'ons-page');
         if (page) {
           this.style.top = top ? window.getComputedStyle(page._getContentElement(), null).getPropertyValue('padding-top') : '';

           if (util.match(page.firstChild, 'ons-toolbar')) {
             action(page.firstChild, 'noshadow');
           }
         }

         internal.autoStatusBarFill(function () {
           var filled = util.findParent(_this4, function (e) {
             return e.hasAttribute('status-bar-fill');
           });
           util.toggleAttribute(_this4, 'status-bar-fill', top && !filled);
         });
       }
     }, {
       key: '_getTabbarElement',
       value: function _getTabbarElement() {
         return util.findChild(this, '.tab-bar');
       }

       /**
        * @method loadPage
        * @signature loadPage(url, [options])
        * @param {String} url
        *   [en]Page URL. Can be either an HTML document or an `<ons-template>` id.[/en]
        *   [ja]pageURLons-templateid[/ja]
        * @description
        *   [en]Displays a new page without changing the active index.[/en]
        *   [ja][/ja]
        * @param {Object} [options]
        *   [en][/en]
        *   [ja][/ja]
        * @param {Object} [options.animation]
        *   [en][/en]
        *   [ja][/ja]
        * @param {Object} [options.callback]
        *   [en][/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Resolves to the new page element.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'loadPage',
       value: function loadPage(page) {
         var _this5 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         return new Promise(function (resolve) {
           var tab = _this5._tabbarElement.children[0] || new TabElement();
           tab._loadPage(page, _this5._contentElement, function (pageElement) {
             resolve(_this5._loadPageDOMAsync(pageElement, options));
           });
         });
       }

       /**
        * @param {Element} pageElement
        * @param {Object} [options]
        * @param {Object} [options.animation]
        * @param {Object} [options.callback]
        * @return {Promise} Resolves to the new page element.
        */

     }, {
       key: '_loadPageDOMAsync',
       value: function _loadPageDOMAsync(pageElement) {
         var _this6 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         return new Promise(function (resolve) {
           rewritables$3.link(_this6, pageElement, options, function (pageElement) {
             _this6._contentElement.appendChild(pageElement);

             if (_this6.getActiveTabIndex() !== -1) {
               resolve(_this6._switchPage(pageElement, options));
             } else {
               if (options.callback instanceof Function) {
                 options.callback();
               }

               _this6._oldPageElement = pageElement;
               resolve(pageElement);
             }
           });
         });
       }

       /**
        * @return {String}
        */

     }, {
       key: 'getTabbarId',
       value: function getTabbarId() {
         return this._tabbarId;
       }

       /**
        * @return {Element/null}
        */

     }, {
       key: '_getCurrentPageElement',
       value: function _getCurrentPageElement() {
         var pages = this._contentElement.children;
         var page = null;
         for (var i = 0; i < pages.length; i++) {
           if (pages[i].style.display !== 'none') {
             page = pages[i];
             break;
           }
         }

         if (page && page.nodeName.toLowerCase() !== 'ons-page') {
           throw new Error('Invalid state: page element must be a "ons-page" element.');
         }

         return page;
       }
     }, {
       key: '_switchPage',


       /**
        * @param {Element} element
        * @param {Object} options
        * @param {String} [options.animation]
        * @param {Function} [options.callback]
        * @param {Object} [options.animationOptions]
        * @param {Number} options.selectedTabIndex
        * @param {Number} options.previousTabIndex
        * @return {Promise} Resolves to the new page element.
        */
       value: function _switchPage(element, options) {
         var oldPageElement = this._oldPageElement || internal.nullElement;
         this._oldPageElement = element;
         var animator = this._animatorFactory.newAnimator(options);

         return new Promise(function (resolve) {
           if (oldPageElement !== internal.nullElement) {
             oldPageElement._hide();
           }

           animator.apply(element, oldPageElement, options.selectedTabIndex, options.previousTabIndex, function () {
             if (oldPageElement !== internal.nullElement) {
               oldPageElement.style.display = 'none';
             }

             element.style.display = 'block';
             element._show();

             if (options.callback instanceof Function) {
               options.callback();
             }

             resolve(element);
           });
         });
       }

       /**
        * @method setActiveTab
        * @signature setActiveTab(index, [options])
        * @param {Number} index
        *   [en]Tab index.[/en]
        *   [ja][/ja]
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja][/ja]
        * @param {Boolean} [options.keepPage]
        *   [en]If true the page will not be changed.[/en]
        *   [ja]pagetrue[/ja]
        * @param {String} [options.animation]
        *   [en]Animation name. Available animations are `"fade"`, `"slide"` and `"none"`.[/en]
        *   [ja]`"fade"``"slide"``"none"`[/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
        *   [ja]duration, delay, timinge.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
        * @description
        *   [en]Show specified tab page. Animations and other options can be specified by the second parameter.[/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Resolves to the new page element.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'setActiveTab',
       value: function setActiveTab(index) {
         var _this7 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         if (options && (typeof options === 'undefined' ? 'undefined' : babelHelpers.typeof(options)) != 'object') {
           throw new Error('options must be an object. You supplied ' + options);
         }

         options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

         if (!options.animation && this.hasAttribute('animation')) {
           options.animation = this.getAttribute('animation');
         }

         var previousTab = this._getActiveTabElement(),
             selectedTab = this._getTabElement(index),
             previousTabIndex = this.getActiveTabIndex(),
             selectedTabIndex = index,
             previousPageElement = this._getCurrentPageElement();

         if (!selectedTab) {
           return Promise.reject('Specified index does not match any tab.');
         }

         if (selectedTabIndex === previousTabIndex) {
           util.triggerElementEvent(this, 'reactive', {
             index: selectedTabIndex,
             tabItem: selectedTab
           });

           return Promise.resolve(previousPageElement);
         }

         var canceled = false;

         util.triggerElementEvent(this, 'prechange', {
           index: selectedTabIndex,
           tabItem: selectedTab,
           cancel: function cancel() {
             return canceled = true;
           }
         });

         if (canceled) {
           selectedTab.setInactive();
           if (previousTab) {
             previousTab.setActive();
           }
           return Promise.reject('Canceled in prechange event.');
         }

         selectedTab.setActive();

         var needLoad = !options.keepPage;

         util.arrayFrom(this._getTabbarElement().children).forEach(function (tab) {
           if (tab != selectedTab) {
             tab.setInactive();
           } else {
             if (!needLoad) {
               util.triggerElementEvent(_this7, 'postchange', {
                 index: selectedTabIndex,
                 tabItem: selectedTab
               });
             }
           }
         });

         if (needLoad) {
           var _ret = function () {
             var removeElement = false;

             if (!previousTab && previousPageElement || previousTab && previousTab._pageElement !== previousPageElement) {
               removeElement = true;
             }

             var params = {
               callback: function callback() {
                 util.triggerElementEvent(_this7, 'postchange', {
                   index: selectedTabIndex,
                   tabItem: selectedTab
                 });

                 if (options.callback instanceof Function) {
                   options.callback();
                 }
               },
               previousTabIndex: previousTabIndex,
               selectedTabIndex: selectedTabIndex
             };

             if (options.animation) {
               params.animation = options.animation;
             }

             params.animationOptions = options.animationOptions || {};

             var link = function link(element, callback) {
               rewritables$3.link(_this7, element, options, callback);
             };

             return {
               v: new Promise(function (resolve) {
                 selectedTab._loadPageElement(_this7._contentElement, function (pageElement) {
                   pageElement.style.display = 'block';
                   resolve(_this7._loadPersistentPageDOM(pageElement, params));
                 }, link);
               })
             };
           }();

           if ((typeof _ret === 'undefined' ? 'undefined' : babelHelpers.typeof(_ret)) === "object") return _ret.v;
         } else {
           return new Promise(function (resolve) {
             _this7._contentElement.appendChild(selectedTab.pageElement);
             selectedTab.pageElement.style.display = 'block';
             resolve(_this7._loadPersistentPageDOM(selectedTab.pageElement, params));
           });
         }
       }

       /**
        * @param {Element} element
        * @param {Object} options
        * @param {Object} options.animation
        */

     }, {
       key: '_loadPersistentPageDOM',
       value: function _loadPersistentPageDOM(element) {
         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];


         if (!util.isAttached(element)) {
           this._contentElement.appendChild(element);
         }

         element.removeAttribute('style');
         return this._switchPage(element, options);
       }

       /**
        * @method setTabbarVisibility
        * @signature setTabbarVisibility(visible)
        * @param {Boolean} visible
        * @description
        *   [en]Used to hide or show the tab bar.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'setTabbarVisibility',
       value: function setTabbarVisibility(visible) {
         this._contentElement.style[this._top ? 'top' : 'bottom'] = visible ? '' : '0px';
         this._getTabbarElement().style.display = visible ? '' : 'none';
       }

       /**
        * @method getActiveTabIndex
        * @signature getActiveTabIndex()
        * @return {Number}
        *   [en]The index of the currently active tab.[/en]
        *   [ja][/ja]
        * @description
        *   [en]Returns tab index on current active tab. If active tab is not found, returns -1.[/en]
        *   [ja]-1[/ja]
        */

     }, {
       key: 'getActiveTabIndex',
       value: function getActiveTabIndex() {
         var tabs = this._getTabbarElement().children;

         for (var i = 0; i < tabs.length; i++) {
           if (tabs[i] instanceof TabElement && tabs[i].isActive && tabs[i].isActive()) {
             return i;
           }
         }

         return -1;
       }

       /**
        * @return {Number} When active tab is not found, returns -1.
        */

     }, {
       key: '_getActiveTabElement',
       value: function _getActiveTabElement() {
         return this._getTabElement(this.getActiveTabIndex());
       }

       /**
        * @return {Element}
        */

     }, {
       key: '_getTabElement',
       value: function _getTabElement(index) {
         return this._getTabbarElement().children[index];
       }
     }, {
       key: 'disconnectedCallback',
       value: function disconnectedCallback() {}
     }, {
       key: '_show',
       value: function _show() {
         var currentPageElement = this._getCurrentPageElement();
         if (currentPageElement) {
           currentPageElement._show();
         }
       }
     }, {
       key: '_hide',
       value: function _hide() {
         var currentPageElement = this._getCurrentPageElement();
         if (currentPageElement) {
           currentPageElement._hide();
         }
       }
     }, {
       key: '_destroy',
       value: function _destroy() {
         var pages = this._contentElement.children;
         for (var i = pages.length - 1; i >= 0; i--) {
           pages[i]._destroy();
         }
         this.remove();
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$21);
         }
       }
     }, {
       key: '_contentElement',
       get: function get() {
         return util.findChild(this, '.tab-bar__content');
       }
     }, {
       key: '_tabbarElement',
       get: function get() {
         return util.findChild(this, '.tab-bar');
       }
     }, {
       key: 'pages',
       get: function get() {
         return util.arrayFrom(this._contentElement.children);
       }
     }], [{
       key: 'registerAnimator',


       /**
        * @param {String} name
        * @param {Function} Animator
        */
       value: function registerAnimator(name, Animator) {
         if (!(Animator.prototype instanceof TabbarAnimator)) {
           throw new Error('"Animator" param must inherit TabbarElement.TabbarAnimator');
         }
         _animatorDict$6[name] = Animator;
       }
     }, {
       key: 'observedAttributes',
       get: function get() {
         return ['modifier'];
       }
     }, {
       key: 'rewritables',
       get: function get() {
         return rewritables$3;
       }
     }, {
       key: 'TabbarAnimator',
       get: function get() {
         return TabbarAnimator;
       }
     }]);
     return TabbarElement;
   }(BaseElement);

   customElements.define('ons-tabbar', TabbarElement);

   var scheme$20 = {
     '': 'tab-bar--*__item',
     '.tab-bar__button': 'tab-bar--*__button'
   };
   var templateSource$1 = util.createElement('\n  <div>\n    <input type="radio" style="display: none">\n    <button class="tab-bar__button tab-bar-inner"></button>\n  </div>\n');
   var defaultInnerTemplateSource = util.createElement('\n  <div>\n    <div class="tab-bar__icon">\n      <ons-icon icon="ion-cloud"></ons-icon>\n    </div>\n    <div class="tab-bar__label">label</div>\n  </div>\n');

   /**
    * @element ons-tab
    * @category tabbar
    * @description
    *   [en]Represents a tab inside tab bar. Each `<ons-tab>` represents a page.[/en]
    *   [ja]
    *     ons-tab
    *     ons-tab
    *   [/ja]
    * @codepen pGuDL
    * @tutorial vanilla/Reference/tabbar
    * @guide multiple-page-navigation
    *   [en]Managing multiple pages.[/en]
    *   [ja]Managing multiple pages[/ja]]
    * @guide templates
    *   [en]Defining multiple pages in single html[/en]
    *   [ja]1HTML[/ja]
    * @seealso ons-tabbar
    *   [en]ons-tabbar component[/en]
    *   [ja]ons-tabbar[/ja]
    * @seealso ons-page
    *   [en]ons-page component[/en]
    *   [ja]ons-page[/ja]
    * @seealso ons-icon
    *   [en]ons-icon component[/en]
    *   [ja]ons-icon[/ja]
    * @example
    * <ons-tabbar>
    *   <ons-tab
    *     page="home.html"
    *     label="Home"
    *     active>
    *   </ons-tab>
    *   <ons-tab
    *     page="settings.html"
    *     label="Settings"
    *     active>
    *   </ons-tab>
    * </ons-tabbar>
    *
    * <ons-template id="home.html">
    *   ...
    * </ons-template>
    *
    * <ons-template id="settings.html">
    *   ...
    * </ons-template>

    */

   var TabElement = function (_BaseElement) {
     babelHelpers.inherits(TabElement, _BaseElement);

     function TabElement() {
       babelHelpers.classCallCheck(this, TabElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(TabElement).apply(this, arguments));
     }

     babelHelpers.createClass(TabElement, [{
       key: 'init',


       /**
        * @attribute page
        * @initonly
        * @type {String}
        * @description
        *   [en]The page that is displayed when the tab is tapped.[/en]
        *   [ja]ons-tabURL[/ja]
        */

       /**
        * @attribute icon
        * @type {String}
        * @description
        *   [en]
        *     The icon name for the tab. Can specify the same icon name as `<ons-icon>`.
        *     If you need to use your own icon, create a CSS class with `background-image` or any CSS properties and specify the name of your CSS class here.
        *   [/en]
        *   [ja]
        *     ons-icon
        *     background-imageCSS
        *   [/ja]
        */

       /**
        * @attribute active-icon
        * @type {String}
        * @description
        *   [en]The name of the icon when the tab is active.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute label
        * @type {String}
        * @description
        *   [en]The label of the tab item.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute active
        * @description
        *   [en]This attribute should be set to the tab that is active by default.[/en]
        *   [ja][/ja]
        */

       value: function init() {
         var _this2 = this;

         this._pageLoader = defaultPageLoader;
         this._page = null;

         if (this.hasAttribute('label') || this.hasAttribute('icon')) {
           if (!this.hasAttribute('_compiled')) {
             this._compile();
           }
         } else {
           contentReady(this, function () {
             if (!_this2.hasAttribute('_compiled')) {
               _this2._compile();
             }
           });
         }

         this._boundOnClick = this._onClick.bind(this);
       }
     }, {
       key: '_getPageTarget',
       value: function _getPageTarget() {
         return this.page || this.getAttribute('page');
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         var fragment = document.createDocumentFragment();
         var hasChildren = false;

         while (this.childNodes[0]) {
           var node = this.childNodes[0];
           this.removeChild(node);
           fragment.appendChild(node);

           if (node.nodeType == Node.ELEMENT_NODE) {
             hasChildren = true;
           }
         }

         var template = templateSource$1.cloneNode(true);
         while (template.children[0]) {
           this.appendChild(template.children[0]);
         }
         this.classList.add('tab-bar__item');

         var button = util.findChild(this, '.tab-bar__button');

         if (hasChildren) {
           button.appendChild(fragment);
           this._hasDefaultTemplate = false;
         } else {
           this._hasDefaultTemplate = true;
           this._updateDefaultTemplate();
         }

         ModifierUtil.initModifier(this, scheme$20);
         this._updateRipple();

         this.setAttribute('_compiled', '');
       }
     }, {
       key: '_updateRipple',
       value: function _updateRipple() {
         // util.updateRipple(this.querySelector('.tab-bar__button'), this);
       }
     }, {
       key: '_updateDefaultTemplate',
       value: function _updateDefaultTemplate() {
         if (!this._hasDefaultTemplate) {
           return;
         }

         var button = util.findChild(this, '.tab-bar__button');

         if (button.children.length == 0) {
           var template = defaultInnerTemplateSource.cloneNode(true);
           while (template.children[0]) {
             button.appendChild(template.children[0]);
           }

           if (!button.querySelector('.tab-bar__icon')) {
             button.insertBefore(template.querySelector('.tab-bar__icon'), button.firstChild);
           }

           if (!button.querySelector('.tab-bar__label')) {
             button.appendChild(template.querySelector('.tab-bar__label'));
           }
         }

         var self = this;
         var icon = this.getAttribute('icon');
         var label = this.getAttribute('label');

         if (typeof icon === 'string') {
           getIconElement().setAttribute('icon', icon);
         } else {
           var wrapper = button.querySelector('.tab-bar__icon');
           if (wrapper) {
             wrapper.remove();
           }
         }

         if (typeof label === 'string') {
           getLabelElement().textContent = label;
         } else {
           var _label = getLabelElement();
           if (_label) {
             _label.remove();
           }
         }

         function getLabelElement() {
           return self.querySelector('.tab-bar__label');
         }

         function getIconElement() {
           return self.querySelector('ons-icon');
         }
       }
     }, {
       key: '_onClick',
       value: function _onClick() {
         var tabbar = this._findTabbarElement();
         if (tabbar) {
           tabbar.setActiveTab(this._findTabIndex());
         }
       }
     }, {
       key: 'setActive',
       value: function setActive() {
         var radio = util.findChild(this, 'input');
         radio.checked = true;
         this.classList.add('active');

         util.arrayFrom(this.querySelectorAll('[ons-tab-inactive], ons-tab-inactive')).forEach(function (element) {
           return element.style.display = 'none';
         });
         util.arrayFrom(this.querySelectorAll('[ons-tab-active], ons-tab-active')).forEach(function (element) {
           return element.style.display = 'inherit';
         });
       }
     }, {
       key: 'setInactive',
       value: function setInactive() {
         var radio = util.findChild(this, 'input');
         radio.checked = false;
         this.classList.remove('active');

         util.arrayFrom(this.querySelectorAll('[ons-tab-inactive], ons-tab-inactive')).forEach(function (element) {
           return element.style.display = 'inherit';
         });
         util.arrayFrom(this.querySelectorAll('[ons-tab-active], ons-tab-active')).forEach(function (element) {
           return element.style.display = 'none';
         });
       }

       /**
        * @param {Element} parent
        * @param {Function} callback
        * @param {Function} link
        */

     }, {
       key: '_loadPageElement',
       value: function _loadPageElement(parent, callback, link) {
         var _this3 = this;

         if (!this._loadedPage && !this._getPageTarget()) {
           var pages = this._findTabbarElement().pages;
           var index = this._findTabIndex();
           callback(pages[index]);
         } else if (!this._loadedPage) {
           this._pageLoader.load({ page: this._getPageTarget(), parent: parent }, function (page) {
             _this3._loadedPage = page;
             link(page.element, function (element) {
               page.element = element;
               callback(page.element);
             });
           });
         } else {
           callback(this._loadedPage.element);
         }
       }
     }, {
       key: '_loadPage',
       value: function _loadPage(page, parent, callback) {
         this._pageLoader.load({ page: page, parent: parent }, function (page) {
           callback(page.element);
         });
       }
     }, {
       key: 'isActive',


       /**
        * @return {Boolean}
        */
       value: function isActive() {
         return this.classList.contains('active');
       }
     }, {
       key: 'disconnectedCallback',
       value: function disconnectedCallback() {
         this.removeEventListener('click', this._boundOnClick, false);
         if (this._loadedPage) {
           this._loadedPage.unload();
           this._loadedPage = null;
         }
       }
     }, {
       key: 'connectedCallback',
       value: function connectedCallback() {
         var _this4 = this;

         contentReady(this, function () {
           _this4._ensureElementPosition();

           var tabbar = _this4._findTabbarElement();

           if (tabbar.hasAttribute('modifier')) {
             var prefix = _this4.hasAttribute('modifier') ? _this4.getAttribute('modifier') + ' ' : '';
             _this4.setAttribute('modifier', prefix + tabbar.getAttribute('modifier'));
           }

           if (_this4.hasAttribute('active')) {
             (function () {
               var tabIndex = _this4._findTabIndex();

               TabbarElement.rewritables.ready(tabbar, function () {
                 setImmediate(function () {
                   return tabbar.setActiveTab(tabIndex, { animation: 'none' });
                 });
               });
             })();
           } else {
             var onReady = function onReady() {
               if (_this4._getPageTarget()) {
                 _this4._loadPageElement(tabbar._contentElement, function (pageElement) {
                   pageElement.style.display = 'none';
                   tabbar._contentElement.appendChild(pageElement);
                 }, function (pageElement, done) {
                   TabbarElement.rewritables.link(tabbar, pageElement, {}, function (element) {
                     return done(element);
                   });
                 });
               }
             };
             TabbarElement.rewritables.ready(tabbar, onReady);
           }

           _this4.addEventListener('click', _this4._boundOnClick, false);
         });
       }
     }, {
       key: '_findTabbarElement',
       value: function _findTabbarElement() {
         if (this.parentNode && this.parentNode.nodeName.toLowerCase() === 'ons-tabbar') {
           return this.parentNode;
         }

         if (this.parentNode.parentNode && this.parentNode.parentNode.nodeName.toLowerCase() === 'ons-tabbar') {
           return this.parentNode.parentNode;
         }

         return null;
       }
     }, {
       key: '_findTabIndex',
       value: function _findTabIndex() {
         var elements = this.parentNode.children;
         for (var i = 0; i < elements.length; i++) {
           if (this === elements[i]) {
             return i;
           }
         }
       }
     }, {
       key: '_ensureElementPosition',
       value: function _ensureElementPosition() {
         if (!this._findTabbarElement()) {
           throw new Error('This ons-tab element is must be child of ons-tabbar element.');
         }
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         var _this5 = this;

         switch (name) {
           case 'modifier':
             contentReady(this, function () {
               return ModifierUtil.onModifierChanged(last, current, _this5, scheme$20);
             });
             break;
           case 'ripple':
             contentReady(this, function () {
               return _this5._updateRipple();
             });
             break;
           case 'icon':
           case 'label':
             contentReady(this, function () {
               return _this5._updateDefaultTemplate();
             });
             break;
           case 'page':
             if (typeof current === 'string') {
               this._page = current;
             }
             break;
         }
       }
     }, {
       key: 'page',
       set: function set(page) {
         this._page = page;
       },
       get: function get() {
         return this._page;
       }
     }, {
       key: 'pageLoader',
       set: function set(loader) {
         if (!(loader instanceof PageLoader)) {
           throw Error('First parameter must be an instance of PageLoader.');
         }
         this._pageLoader = loader;
       },
       get: function get() {
         return this._pageLoader;
       }
     }, {
       key: 'pageElement',
       get: function get() {
         if (this._loadedPage) {
           return this._loadedPage.element;
         }

         var tabbar = this._findTabbarElement();
         var index = this._findTabIndex();

         return tabbar._contentElement.children[index];
       }
     }], [{
       key: 'observedAttributes',
       get: function get() {
         return ['modifier', 'ripple', 'icon', 'label', 'page'];
       }
     }]);
     return TabElement;
   }(BaseElement);

   customElements.define('ons-tab', TabElement);

   var scheme$22 = { '': 'toolbar-button--*' };

   /**
    * @element ons-toolbar-button
    * @category page
    * @modifier material
    *   [en]Material Design toolbar button.[/en]
    *   [ja][/ja]
    * @modifier outline
    *   [en]A button with an outline.[/en]
    *   [ja][/ja]
    * @description
    *   [en]Button component for ons-toolbar and ons-bottom-toolbar.[/en]
    *   [ja]ons-toolbarons-bottom-toolbar[/ja]
    * @codepen aHmGL
    * @tutorial vanilla/Reference/button
    * @guide adding-a-toolbar
    *   [en]Adding a toolbar[/en]
    *   [ja][/ja]
    * @seealso ons-toolbar
    *   [en]The `<ons-toolbar>` component displays a navigation bar at the top of a page.[/en]
    *   [ja]ons-toolbar[/ja]
    * @seealso ons-back-button
    *   [en]The `<ons-back-button>` displays a back button in the navigation bar.[/en]
    *   [ja]ons-back-button[/ja]
    * @example
    * <ons-toolbar>
    *   <div class="left">
    *     <ons-toolbar-button>
    *       Button
    *     </ons-toolbar-button>
    *   </div>
    *   <div class="center">
    *     Title
    *   </div>
    *   <div class="right">
    *     <ons-toolbar-button>
    *       <ons-icon icon="ion-navicon" size="28px"></ons-icon>
    *     </ons-toolbar-button>
    *   </div>
    * </ons-toolbar>
    */

   var ToolbarButtonElement = function (_BaseElement) {
     babelHelpers.inherits(ToolbarButtonElement, _BaseElement);

     function ToolbarButtonElement() {
       babelHelpers.classCallCheck(this, ToolbarButtonElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ToolbarButtonElement).apply(this, arguments));
     }

     babelHelpers.createClass(ToolbarButtonElement, [{
       key: 'init',


       /**
        * @attribute modifier
        * @type {String}
        * @description
        *   [en]The appearance of the button.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute disabled
        * @description
        *   [en]Specify if button should be disabled.[/en]
        *   [ja][/ja]
        */

       value: function init() {
         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }
       }

       /**
        * @property disabled
        * @type {Boolean}
        * @description
        *   [en]Whether the element is disabled or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         this.classList.add('toolbar-button');

         ModifierUtil.initModifier(this, scheme$22);

         this.setAttribute('_compiled', '');
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$22);
         }
       }
     }, {
       key: 'disabled',
       set: function set(value) {
         return util.toggleAttribute(this, 'disabled', value);
       },
       get: function get() {
         return this.hasAttribute('disabled');
       }
     }], [{
       key: 'observedAttributes',
       get: function get() {
         return ['modifier'];
       }
     }]);
     return ToolbarButtonElement;
   }(BaseElement);

   customElements.define('ons-toolbar-button', ToolbarButtonElement);

   var scheme$23 = {
     '.range': 'range--*',
     '.range__left': 'range--*__left'
   };

   var templateSource$2 = util.createElement('<div>\n  <div class="range__left"></div>\n  <input type="range" class="range">\n</div>');

   var INPUT_ATTRIBUTES$1 = ['autofocus', 'disabled', 'inputmode', 'max', 'min', 'name', 'placeholder', 'readonly', 'size', 'step', 'validator', 'value'];

   /**
    * @element ons-range
    * @category form
    * @modifier material
    *   [en]Material Design slider[/en]
    *   [ja][/ja]
    * @description
    *   [en]
    *     Range input component. Used to display a draggable slider.
    *
    *     Works very similar to the `<input type="range">` element.
    *   [/en]
    *   [ja][/ja]
    * @codepen xZQomM
    * @tutorial vanilla/Reference/range
    * @guide using-modifier [en]More details about the `modifier` attribute[/en][ja]modifier[/ja]
    * @seealso ons-input
    *   [en]The `<ons-input>` component is used to display text inputs, radio buttons and checkboxes.[/en]
    *   [ja][/ja]
    * @example
    * <ons-range value="20"></ons-range>
    * <ons-range modifier="material" value="10"></range>
    */

   var RangeElement = function (_BaseElement) {
     babelHelpers.inherits(RangeElement, _BaseElement);

     function RangeElement() {
       babelHelpers.classCallCheck(this, RangeElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(RangeElement).apply(this, arguments));
     }

     babelHelpers.createClass(RangeElement, [{
       key: 'init',
       value: function init() {
         var _this2 = this;

         contentReady(this, function () {
           if (!_this2.hasAttribute('_compiled')) {
             _this2._compile();
           }

           _this2._updateBoundAttributes();
           _this2._onChange();
         });
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         if (!(util.findChild(this, '.range__left') && util.findChild(this, 'input'))) {
           var template = templateSource$2.cloneNode(true);
           while (template.children[0]) {
             this.appendChild(template.children[0]);
           }
         }

         ModifierUtil.initModifier(this, scheme$23);

         this.setAttribute('_compiled', '');
       }
     }, {
       key: '_onChange',
       value: function _onChange() {
         this._left.style.width = 100 * this._ratio + '%';
       }
     }, {
       key: '_onDragstart',
       value: function _onDragstart(e) {
         e.stopPropagation();
         e.gesture.stopPropagation();
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         var _this3 = this;

         if (name === 'modifier') {
           ModifierUtil.onModifierChanged(last, current, this, scheme$23);
         } else if (INPUT_ATTRIBUTES$1.indexOf(name) >= 0) {
           contentReady(this, function () {
             _this3._updateBoundAttributes();

             if (name === 'min' || name === 'max') {
               _this3._onChange();
             }
           });
         }
       }
     }, {
       key: 'connectedCallback',
       value: function connectedCallback() {
         this.addEventListener('dragstart', this._onDragstart);
         this.addEventListener('input', this._onChange);
       }
     }, {
       key: 'disconnectedCallback',
       value: function disconnectedCallback() {
         this.removeEventListener('dragstart', this._onDragstart);
         this.removeEventListener('input', this._onChange);
       }
     }, {
       key: '_updateBoundAttributes',
       value: function _updateBoundAttributes() {
         var _this4 = this;

         INPUT_ATTRIBUTES$1.forEach(function (attr) {
           if (_this4.hasAttribute(attr)) {
             _this4._input.setAttribute(attr, _this4.getAttribute(attr));
           } else {
             _this4._input.removeAttribute(attr);
           }
         });
       }
     }, {
       key: '_ratio',
       get: function get() {
         // Returns the current ratio.
         var min = this._input.min === '' ? 0 : parseInt(this._input.min);
         var max = this._input.max === '' ? 100 : parseInt(this._input.max);

         return (this.value - min) / (max - min);
       }
     }, {
       key: '_input',
       get: function get() {
         return this.querySelector('input');
       }
     }, {
       key: '_left',
       get: function get() {
         return this.querySelector('.range__left');
       }

       /**
        * @property disabled
        * @type {Boolean}
        * @description
        *   [en]Whether the element is disabled or not.[/en]
        *   [ja]`true`[/ja]
        */

     }, {
       key: 'disabled',
       set: function set(value) {
         return util.toggleAttribute(this, 'disabled', value);
       },
       get: function get() {
         return this.hasAttribute('disabled');
       }

       /**
        * @property value
        * @type {Number}
        * @description
        *   [en]Current value.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'value',
       get: function get() {
         return this._input.value;
       },
       set: function set(val) {
         var _this5 = this;

         contentReady(this, function () {
           _this5._input.value = val;
           _this5._onChange();
         });
       }
     }], [{
       key: 'observedAttributes',
       get: function get() {
         return ['modifier'].concat(INPUT_ATTRIBUTES$1);
       }
     }]);
     return RangeElement;
   }(BaseElement);

   customElements.define('ons-range', RangeElement);

   ons.TemplateElement = TemplateElement;
   ons.IfElement = IfElement;
   ons.AlertDialogElement = AlertDialogElement;
   ons.BackButtonElement = BackButtonElement;
   ons.BottomToolbarElement = BottomToolbarElement;
   ons.ButtonElement = ButtonElement;
   ons.CarouselItemElement = CarouselItemElement;
   ons.CarouselElement = CarouselElement;
   ons.ColElement = ColElement;
   ons.DialogElement = DialogElement;
   ons.FabElement = FabElement;
   ons.GestureDetectorElement = GestureDetectorElement;
   ons.IconElement = IconElement;
   ons.LazyRepeatElement = LazyRepeatElement;
   ons.ListHeaderElement = ListHeaderElement;
   ons.ListItemElement = ListItemElement;
   ons.ListElement = ListElement;
   ons.InputElement = InputElement;
   ons.ModalElement = ModalElement;
   ons.NavigatorElement = NavigatorElement;
   ons.PageElement = PageElement;
   ons.PopoverElement = PopoverElement;
   ons.ProgressBarElement = ProgressBarElement;
   ons.ProgressCircularElement = ProgressCircularElement;
   ons.PullHookElement = PullHookElement;
   ons.RippleElement = RippleElement;
   ons.RowElement = RowElement;
   ons.SpeedDialItemElement = SpeedDialItemElement;
   ons.SpeedDialElement = SpeedDialElement;
   ons.SplitterContentElement = SplitterContentElement;
   ons.SplitterMaskElement = SplitterMaskElement;
   ons.SplitterSideElement = SplitterSideElement;
   ons.SplitterElement = SplitterElement;
   ons.SwitchElement = SwitchElement;
   ons.TabElement = TabElement;
   ons.TabbarElement = TabbarElement;
   ons.ToolbarButtonElement = ToolbarButtonElement;
   ons.ToolbarElement = ToolbarElement;
   ons.RangeElement = RangeElement;

   // fastclick
   window.addEventListener('load', function () {
     ons.fastClick = FastClick.attach(document.body);
   }, false);

   // ons._defaultDeviceBackButtonHandler
   window.addEventListener('DOMContentLoaded', function () {
     ons._deviceBackButtonDispatcher.enable();
     ons._defaultDeviceBackButtonHandler = ons._deviceBackButtonDispatcher.createHandler(window.document.body, function () {
       navigator.app.exitApp();
     });
     document.body._gestureDetector = new ons.GestureDetector(document.body);
   }, false);

   // setup loading placeholder
   ons.ready(function () {
     ons._setupLoadingPlaceHolders();
   });

   // viewport.js
   new Viewport().setup();

   return ons;

}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkN1c3RvbUV2ZW50LmpzIiwiTXV0YXRpb25PYnNlcnZlci5qcyIsImFuaW1pdC5qcyIsImNoaWxkTm9kZVJlbW92ZS5qcyIsImNsYXNzTGlzdC5qcyIsImRvY3VtZW50LXJlZ2lzdGVyLWVsZW1lbnQubWF4LmpzIiwiZmFzdGNsaWNrLXBhdGNoZWQuanMiLCJpbm5lckhUTUwuanMiLCJtaWNyb2V2ZW50LmpzIiwicHJvbWlzZS5qcyIsInNldEltbWVkaWF0ZS5qcyIsInZpZXdwb3J0LmpzIiwid2luc3RvcmUtanNjb21wYXQuanMiLCJvbnMvYW5pbWF0aW9uLW9wdGlvbnMtcGFyc2VyLmpzIiwib25zL3V0aWwuanMiLCJvbnMvZ2VzdHVyZS1kZXRlY3Rvci5qcyIsIm9ucy9wbGF0Zm9ybS5qcyIsIm9ucy9ub3RpZmljYXRpb24uanMiLCJvbnMvcGFnZS1hdHRyaWJ1dGUtZXhwcmVzc2lvbi5qcyIsIm9ucy9pbnRlcm5hbC9pbnRlcm5hbC5qcyIsIm9ucy9pbnRlcm5hbC9hbmltYXRvci1mYWN0b3J5LmpzIiwib25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwuanMiLCJvbnMvaW50ZXJuYWwvbGF6eS1yZXBlYXQuanMiLCJvbnMvaW50ZXJuYWwvaW5kZXguanMiLCJvbnMvb3JpZW50YXRpb24uanMiLCJvbnMvc29mdHdhcmUta2V5Ym9hcmQuanMiLCJvbnMvZGV2aWNlLWJhY2stYnV0dG9uLWRpc3BhdGNoZXIuanMiLCJvbnMvYXV0b3N0eWxlLmpzIiwib25zL2Rvb3Jsb2NrLmpzIiwib25zL2NvbnRlbnQtcmVhZHkuanMiLCJvbnMvcGFnZS1sb2FkZXIuanMiLCJvbnMvb25zLmpzIiwib25zL2Jhc2UtZWxlbWVudC5qcyIsImVsZW1lbnRzL29ucy10ZW1wbGF0ZS5qcyIsImVsZW1lbnRzL29ucy1pZi5qcyIsImVsZW1lbnRzL29ucy1hbGVydC1kaWFsb2cvYW5pbWF0b3IuanMiLCJlbGVtZW50cy9vbnMtYWxlcnQtZGlhbG9nL2luZGV4LmpzIiwiZWxlbWVudHMvb25zLWJhY2stYnV0dG9uLmpzIiwiZWxlbWVudHMvb25zLWJvdHRvbS10b29sYmFyLmpzIiwiZWxlbWVudHMvb25zLWJ1dHRvbi5qcyIsImVsZW1lbnRzL29ucy1jYXJvdXNlbC1pdGVtLmpzIiwiZWxlbWVudHMvb25zLWNhcm91c2VsLmpzIiwiZWxlbWVudHMvb25zLWNvbC5qcyIsImVsZW1lbnRzL29ucy1kaWFsb2cvYW5pbWF0b3IuanMiLCJlbGVtZW50cy9vbnMtZGlhbG9nL2luZGV4LmpzIiwiZWxlbWVudHMvb25zLWZhYi5qcyIsImVsZW1lbnRzL29ucy1nZXN0dXJlLWRldGVjdG9yLmpzIiwiZWxlbWVudHMvb25zLWljb24uanMiLCJlbGVtZW50cy9vbnMtbGF6eS1yZXBlYXQuanMiLCJlbGVtZW50cy9vbnMtbGlzdC1oZWFkZXIuanMiLCJlbGVtZW50cy9vbnMtbGlzdC1pdGVtLmpzIiwiZWxlbWVudHMvb25zLWxpc3QuanMiLCJlbGVtZW50cy9vbnMtaW5wdXQuanMiLCJlbGVtZW50cy9vbnMtbW9kYWwvYW5pbWF0b3IuanMiLCJlbGVtZW50cy9vbnMtbW9kYWwvZmFkZS1hbmltYXRvci5qcyIsImVsZW1lbnRzL29ucy1tb2RhbC9pbmRleC5qcyIsImVsZW1lbnRzL29ucy1uYXZpZ2F0b3IvYW5pbWF0b3IuanMiLCJlbGVtZW50cy9vbnMtbmF2aWdhdG9yL2lvcy1zbGlkZS1hbmltYXRvci5qcyIsImVsZW1lbnRzL29ucy1uYXZpZ2F0b3IvaW9zLWxpZnQtYW5pbWF0b3IuanMiLCJlbGVtZW50cy9vbnMtbmF2aWdhdG9yL2lvcy1mYWRlLWFuaW1hdG9yLmpzIiwiZWxlbWVudHMvb25zLW5hdmlnYXRvci9tZC1zbGlkZS1hbmltYXRvci5qcyIsImVsZW1lbnRzL29ucy1uYXZpZ2F0b3IvbWQtbGlmdC1hbmltYXRvci5qcyIsImVsZW1lbnRzL29ucy1uYXZpZ2F0b3IvbWQtZmFkZS1hbmltYXRvci5qcyIsImVsZW1lbnRzL29ucy1uYXZpZ2F0b3Ivbm9uZS1hbmltYXRvci5qcyIsImVsZW1lbnRzL29ucy1uYXZpZ2F0b3IvaW5kZXguanMiLCJlbGVtZW50cy9vbnMtdG9vbGJhci5qcyIsImVsZW1lbnRzL29ucy1wYWdlLmpzIiwiZWxlbWVudHMvb25zLXBvcG92ZXIvYW5pbWF0b3IuanMiLCJlbGVtZW50cy9vbnMtcG9wb3Zlci9pbmRleC5qcyIsImVsZW1lbnRzL29ucy1wcm9ncmVzcy1iYXIuanMiLCJlbGVtZW50cy9vbnMtcHJvZ3Jlc3MtY2lyY3VsYXIuanMiLCJlbGVtZW50cy9vbnMtcHVsbC1ob29rLmpzIiwiZWxlbWVudHMvb25zLXJpcHBsZS9hbmltYXRvci1jc3MuanMiLCJlbGVtZW50cy9vbnMtcmlwcGxlL2luZGV4LmpzIiwiZWxlbWVudHMvb25zLXJvdy5qcyIsImVsZW1lbnRzL29ucy1zcGVlZC1kaWFsLWl0ZW0uanMiLCJsaWIvc3R5bGVyLmpzIiwiZWxlbWVudHMvb25zLXNwZWVkLWRpYWwuanMiLCJlbGVtZW50cy9vbnMtc3BsaXR0ZXItY29udGVudC5qcyIsImVsZW1lbnRzL29ucy1zcGxpdHRlci1tYXNrLmpzIiwiZWxlbWVudHMvb25zLXNwbGl0dGVyL2FuaW1hdG9yLmpzIiwiZWxlbWVudHMvb25zLXNwbGl0dGVyL2luZGV4LmpzIiwiZWxlbWVudHMvb25zLXNwbGl0dGVyLXNpZGUuanMiLCJlbGVtZW50cy9vbnMtc3dpdGNoLmpzIiwiZWxlbWVudHMvb25zLXRhYmJhci9hbmltYXRvci5qcyIsImVsZW1lbnRzL29ucy10YWJiYXIvaW5kZXguanMiLCJlbGVtZW50cy9vbnMtdGFiLmpzIiwiZWxlbWVudHMvb25zLXRvb2xiYXItYnV0dG9uLmpzIiwiZWxlbWVudHMvb25zLXJhbmdlLmpzIiwic2V0dXAuanMiXSwibmFtZXMiOlsiYW5pbWF0aW9uT3B0aW9uc1BhcnNlIiwiRXZlbnQiLCJ1dGlsIiwib25zUGxhdGZvcm0iLCJQYWdlQXR0cmlidXRlRXhwcmVzc2lvbiIsImFuaW1hdGlvbk9wdGlvbnNQYXJzZXIiLCJzY2hlbWUiLCJfYW5pbWF0b3JEaWN0IiwidGVtcGxhdGUiLCJBbmltYXRvciIsInJld3JpdGFibGVzIiwiZ2VuZXJhdGVJZCIsInRlbXBsYXRlU291cmNlIiwiSU5QVVRfQVRUUklCVVRFUyJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM3VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3RsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNoUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3gyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzd6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3RPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3RNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQzFKQSxJQUFNLFNBQVMsU0FBVCxNQUFTO0FBQUEsR0FBQSxTQUFV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QUFKLEdBQW9CLGFBQXBCO0FBQ0EsR0FBQSxJQUFJLFVBQUosR0FBaUIsVUFBakI7QUFDQSxHQUFBLElBQUksYUFBSixHQUFvQixhQUFwQjtBQUNBLEdBQUEsSUFBSSxvQkFBSixHQUEyQixvQkFBM0I7QUFDQSxHQUFBLElBQUksY0FBSixHQUFxQixjQUFyQjtBQUNBLEdBQUEsSUFBSSxZQUFKLEdBQW1CLFlBQW5COzs7QUFHQSxHQUFBLE9BQU8sZ0JBQVAsQ0FBd0IsTUFBeEIsRUFBZ0MsWUFBTTtBQUNsQyxHQUFBLE1BQUksU0FBSixHQUFnQixVQUFVLE1BQVYsQ0FBaUIsU0FBUyxJQUExQixDQUFoQjtBQUNILEdBQUEsQ0FGRCxFQUVHLEtBRkg7OztBQUtBLEdBQUEsT0FBTyxnQkFBUCxDQUF3QixrQkFBeEIsRUFBNEMsWUFBTTtBQUNoRCxHQUFBLE1BQUksMkJBQUosQ0FBZ0MsTUFBaEM7QUFDQSxHQUFBLE1BQUksK0JBQUosR0FBc0MsSUFBSSwyQkFBSixDQUFnQyxhQUFoQyxDQUE4QyxPQUFPLFFBQVAsQ0FBZ0IsSUFBOUQsRUFBb0UsWUFBTTtBQUM5RyxHQUFBLGNBQVUsR0FBVixDQUFjLE9BQWQ7QUFDRCxHQUFBLEdBRnFDLENBQXRDO0FBR0EsR0FBQSxXQUFTLElBQVQsQ0FBYyxnQkFBZCxHQUFpQyxJQUFJLElBQUksZUFBUixDQUF3QixTQUFTLElBQWpDLENBQWpDO0FBQ0QsR0FBQSxDQU5ELEVBTUcsS0FOSDs7O0FBU0EsR0FBQSxJQUFJLEtBQUosQ0FBVSxZQUFXO0FBQ25CLEdBQUEsTUFBSSx5QkFBSjtBQUNELEdBQUEsQ0FGRDs7O0FBS0EsR0FBQSxJQUFJLFFBQUosR0FBZSxLQUFmIiwiZmlsZSI6Im9uc2VudWkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpZiAoIXdpbmRvdy5DdXN0b21FdmVudCkge1xuICAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIEN1c3RvbUV2ZW50O1xuXG4gICAgQ3VzdG9tRXZlbnQgPSBmdW5jdGlvbihldmVudCwgcGFyYW1zKSB7XG4gICAgICB2YXIgZXZ0O1xuICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHtcbiAgICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICAgIGNhbmNlbGFibGU6IGZhbHNlLFxuICAgICAgICBkZXRhaWw6IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIik7XG4gICAgICBldnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUsIHBhcmFtcy5kZXRhaWwpO1xuICAgICAgcmV0dXJuIGV2dDtcbiAgICB9O1xuXG4gICAgQ3VzdG9tRXZlbnQucHJvdG90eXBlID0gd2luZG93LkV2ZW50LnByb3RvdHlwZTtcblxuICAgIHdpbmRvdy5DdXN0b21FdmVudCA9IEN1c3RvbUV2ZW50O1xuICB9KSgpO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE0IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG4vLyBAdmVyc2lvbiAwLjcuMjJcbmlmICh0eXBlb2YgV2Vha01hcCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuICAgIHZhciBjb3VudGVyID0gRGF0ZS5ub3coKSAlIDFlOTtcbiAgICB2YXIgV2Vha01hcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5uYW1lID0gXCJfX3N0XCIgKyAoTWF0aC5yYW5kb20oKSAqIDFlOSA+Pj4gMCkgKyAoY291bnRlcisrICsgXCJfX1wiKTtcbiAgICB9O1xuICAgIFdlYWtNYXAucHJvdG90eXBlID0ge1xuICAgICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGtleVt0aGlzLm5hbWVdO1xuICAgICAgICBpZiAoZW50cnkgJiYgZW50cnlbMF0gPT09IGtleSkgZW50cnlbMV0gPSB2YWx1ZTsgZWxzZSBkZWZpbmVQcm9wZXJ0eShrZXksIHRoaXMubmFtZSwge1xuICAgICAgICAgIHZhbHVlOiBbIGtleSwgdmFsdWUgXSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIGVudHJ5O1xuICAgICAgICByZXR1cm4gKGVudHJ5ID0ga2V5W3RoaXMubmFtZV0pICYmIGVudHJ5WzBdID09PSBrZXkgPyBlbnRyeVsxXSA6IHVuZGVmaW5lZDtcbiAgICAgIH0sXG4gICAgICBcImRlbGV0ZVwiOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0ga2V5W3RoaXMubmFtZV07XG4gICAgICAgIGlmICghZW50cnkgfHwgZW50cnlbMF0gIT09IGtleSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBlbnRyeVswXSA9IGVudHJ5WzFdID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICBoYXM6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB2YXIgZW50cnkgPSBrZXlbdGhpcy5uYW1lXTtcbiAgICAgICAgaWYgKCFlbnRyeSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gZW50cnlbMF0gPT09IGtleTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdpbmRvdy5XZWFrTWFwID0gV2Vha01hcDtcbiAgfSkoKTtcbn1cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuICBpZiAoZ2xvYmFsLkpzTXV0YXRpb25PYnNlcnZlcikge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcmVnaXN0cmF0aW9uc1RhYmxlID0gbmV3IFdlYWtNYXAoKTtcbiAgdmFyIHNldEltbWVkaWF0ZTtcbiAgaWYgKC9UcmlkZW50fEVkZ2UvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICBzZXRJbW1lZGlhdGUgPSBzZXRUaW1lb3V0O1xuICB9IGVsc2UgaWYgKHdpbmRvdy5zZXRJbW1lZGlhdGUpIHtcbiAgICBzZXRJbW1lZGlhdGUgPSB3aW5kb3cuc2V0SW1tZWRpYXRlO1xuICB9IGVsc2Uge1xuICAgIHZhciBzZXRJbW1lZGlhdGVRdWV1ZSA9IFtdO1xuICAgIHZhciBzZW50aW5lbCA9IFN0cmluZyhNYXRoLnJhbmRvbSgpKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGUuZGF0YSA9PT0gc2VudGluZWwpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gc2V0SW1tZWRpYXRlUXVldWU7XG4gICAgICAgIHNldEltbWVkaWF0ZVF1ZXVlID0gW107XG4gICAgICAgIHF1ZXVlLmZvckVhY2goZnVuY3Rpb24oZnVuYykge1xuICAgICAgICAgIGZ1bmMoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oZnVuYykge1xuICAgICAgc2V0SW1tZWRpYXRlUXVldWUucHVzaChmdW5jKTtcbiAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZShzZW50aW5lbCwgXCIqXCIpO1xuICAgIH07XG4gIH1cbiAgdmFyIGlzU2NoZWR1bGVkID0gZmFsc2U7XG4gIHZhciBzY2hlZHVsZWRPYnNlcnZlcnMgPSBbXTtcbiAgZnVuY3Rpb24gc2NoZWR1bGVDYWxsYmFjayhvYnNlcnZlcikge1xuICAgIHNjaGVkdWxlZE9ic2VydmVycy5wdXNoKG9ic2VydmVyKTtcbiAgICBpZiAoIWlzU2NoZWR1bGVkKSB7XG4gICAgICBpc1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICBzZXRJbW1lZGlhdGUoZGlzcGF0Y2hDYWxsYmFja3MpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB3cmFwSWZOZWVkZWQobm9kZSkge1xuICAgIHJldHVybiB3aW5kb3cuU2hhZG93RE9NUG9seWZpbGwgJiYgd2luZG93LlNoYWRvd0RPTVBvbHlmaWxsLndyYXBJZk5lZWRlZChub2RlKSB8fCBub2RlO1xuICB9XG4gIGZ1bmN0aW9uIGRpc3BhdGNoQ2FsbGJhY2tzKCkge1xuICAgIGlzU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgdmFyIG9ic2VydmVycyA9IHNjaGVkdWxlZE9ic2VydmVycztcbiAgICBzY2hlZHVsZWRPYnNlcnZlcnMgPSBbXTtcbiAgICBvYnNlcnZlcnMuc29ydChmdW5jdGlvbihvMSwgbzIpIHtcbiAgICAgIHJldHVybiBvMS51aWRfIC0gbzIudWlkXztcbiAgICB9KTtcbiAgICB2YXIgYW55Tm9uRW1wdHkgPSBmYWxzZTtcbiAgICBvYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbihvYnNlcnZlcikge1xuICAgICAgdmFyIHF1ZXVlID0gb2JzZXJ2ZXIudGFrZVJlY29yZHMoKTtcbiAgICAgIHJlbW92ZVRyYW5zaWVudE9ic2VydmVyc0ZvcihvYnNlcnZlcik7XG4gICAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIG9ic2VydmVyLmNhbGxiYWNrXyhxdWV1ZSwgb2JzZXJ2ZXIpO1xuICAgICAgICBhbnlOb25FbXB0eSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGFueU5vbkVtcHR5KSBkaXNwYXRjaENhbGxiYWNrcygpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZVRyYW5zaWVudE9ic2VydmVyc0ZvcihvYnNlcnZlcikge1xuICAgIG9ic2VydmVyLm5vZGVzXy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldChub2RlKTtcbiAgICAgIGlmICghcmVnaXN0cmF0aW9ucykgcmV0dXJuO1xuICAgICAgcmVnaXN0cmF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHJlZ2lzdHJhdGlvbikge1xuICAgICAgICBpZiAocmVnaXN0cmF0aW9uLm9ic2VydmVyID09PSBvYnNlcnZlcikgcmVnaXN0cmF0aW9uLnJlbW92ZVRyYW5zaWVudE9ic2VydmVycygpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZm9yRWFjaEFuY2VzdG9yQW5kT2JzZXJ2ZXJFbnF1ZXVlUmVjb3JkKHRhcmdldCwgY2FsbGJhY2spIHtcbiAgICBmb3IgKHZhciBub2RlID0gdGFyZ2V0OyBub2RlOyBub2RlID0gbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICB2YXIgcmVnaXN0cmF0aW9ucyA9IHJlZ2lzdHJhdGlvbnNUYWJsZS5nZXQobm9kZSk7XG4gICAgICBpZiAocmVnaXN0cmF0aW9ucykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlZ2lzdHJhdGlvbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgcmVnaXN0cmF0aW9uID0gcmVnaXN0cmF0aW9uc1tqXTtcbiAgICAgICAgICB2YXIgb3B0aW9ucyA9IHJlZ2lzdHJhdGlvbi5vcHRpb25zO1xuICAgICAgICAgIGlmIChub2RlICE9PSB0YXJnZXQgJiYgIW9wdGlvbnMuc3VidHJlZSkgY29udGludWU7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGNhbGxiYWNrKG9wdGlvbnMpO1xuICAgICAgICAgIGlmIChyZWNvcmQpIHJlZ2lzdHJhdGlvbi5lbnF1ZXVlKHJlY29yZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIHVpZENvdW50ZXIgPSAwO1xuICBmdW5jdGlvbiBKc011dGF0aW9uT2JzZXJ2ZXIoY2FsbGJhY2spIHtcbiAgICB0aGlzLmNhbGxiYWNrXyA9IGNhbGxiYWNrO1xuICAgIHRoaXMubm9kZXNfID0gW107XG4gICAgdGhpcy5yZWNvcmRzXyA9IFtdO1xuICAgIHRoaXMudWlkXyA9ICsrdWlkQ291bnRlcjtcbiAgfVxuICBKc011dGF0aW9uT2JzZXJ2ZXIucHJvdG90eXBlID0ge1xuICAgIG9ic2VydmU6IGZ1bmN0aW9uKHRhcmdldCwgb3B0aW9ucykge1xuICAgICAgdGFyZ2V0ID0gd3JhcElmTmVlZGVkKHRhcmdldCk7XG4gICAgICBpZiAoIW9wdGlvbnMuY2hpbGRMaXN0ICYmICFvcHRpb25zLmF0dHJpYnV0ZXMgJiYgIW9wdGlvbnMuY2hhcmFjdGVyRGF0YSB8fCBvcHRpb25zLmF0dHJpYnV0ZU9sZFZhbHVlICYmICFvcHRpb25zLmF0dHJpYnV0ZXMgfHwgb3B0aW9ucy5hdHRyaWJ1dGVGaWx0ZXIgJiYgb3B0aW9ucy5hdHRyaWJ1dGVGaWx0ZXIubGVuZ3RoICYmICFvcHRpb25zLmF0dHJpYnV0ZXMgfHwgb3B0aW9ucy5jaGFyYWN0ZXJEYXRhT2xkVmFsdWUgJiYgIW9wdGlvbnMuY2hhcmFjdGVyRGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldCh0YXJnZXQpO1xuICAgICAgaWYgKCFyZWdpc3RyYXRpb25zKSByZWdpc3RyYXRpb25zVGFibGUuc2V0KHRhcmdldCwgcmVnaXN0cmF0aW9ucyA9IFtdKTtcbiAgICAgIHZhciByZWdpc3RyYXRpb247XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZ2lzdHJhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHJlZ2lzdHJhdGlvbnNbaV0ub2JzZXJ2ZXIgPT09IHRoaXMpIHtcbiAgICAgICAgICByZWdpc3RyYXRpb24gPSByZWdpc3RyYXRpb25zW2ldO1xuICAgICAgICAgIHJlZ2lzdHJhdGlvbi5yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgICByZWdpc3RyYXRpb24ub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghcmVnaXN0cmF0aW9uKSB7XG4gICAgICAgIHJlZ2lzdHJhdGlvbiA9IG5ldyBSZWdpc3RyYXRpb24odGhpcywgdGFyZ2V0LCBvcHRpb25zKTtcbiAgICAgICAgcmVnaXN0cmF0aW9ucy5wdXNoKHJlZ2lzdHJhdGlvbik7XG4gICAgICAgIHRoaXMubm9kZXNfLnB1c2godGFyZ2V0KTtcbiAgICAgIH1cbiAgICAgIHJlZ2lzdHJhdGlvbi5hZGRMaXN0ZW5lcnMoKTtcbiAgICB9LFxuICAgIGRpc2Nvbm5lY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5ub2Rlc18uZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldChub2RlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWdpc3RyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHJlZ2lzdHJhdGlvbiA9IHJlZ2lzdHJhdGlvbnNbaV07XG4gICAgICAgICAgaWYgKHJlZ2lzdHJhdGlvbi5vYnNlcnZlciA9PT0gdGhpcykge1xuICAgICAgICAgICAgcmVnaXN0cmF0aW9uLnJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgICAgICAgcmVnaXN0cmF0aW9ucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgICAgdGhpcy5yZWNvcmRzXyA9IFtdO1xuICAgIH0sXG4gICAgdGFrZVJlY29yZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNvcHlPZlJlY29yZHMgPSB0aGlzLnJlY29yZHNfO1xuICAgICAgdGhpcy5yZWNvcmRzXyA9IFtdO1xuICAgICAgcmV0dXJuIGNvcHlPZlJlY29yZHM7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBNdXRhdGlvblJlY29yZCh0eXBlLCB0YXJnZXQpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRoaXMuYWRkZWROb2RlcyA9IFtdO1xuICAgIHRoaXMucmVtb3ZlZE5vZGVzID0gW107XG4gICAgdGhpcy5wcmV2aW91c1NpYmxpbmcgPSBudWxsO1xuICAgIHRoaXMubmV4dFNpYmxpbmcgPSBudWxsO1xuICAgIHRoaXMuYXR0cmlidXRlTmFtZSA9IG51bGw7XG4gICAgdGhpcy5hdHRyaWJ1dGVOYW1lc3BhY2UgPSBudWxsO1xuICAgIHRoaXMub2xkVmFsdWUgPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGNvcHlNdXRhdGlvblJlY29yZChvcmlnaW5hbCkge1xuICAgIHZhciByZWNvcmQgPSBuZXcgTXV0YXRpb25SZWNvcmQob3JpZ2luYWwudHlwZSwgb3JpZ2luYWwudGFyZ2V0KTtcbiAgICByZWNvcmQuYWRkZWROb2RlcyA9IG9yaWdpbmFsLmFkZGVkTm9kZXMuc2xpY2UoKTtcbiAgICByZWNvcmQucmVtb3ZlZE5vZGVzID0gb3JpZ2luYWwucmVtb3ZlZE5vZGVzLnNsaWNlKCk7XG4gICAgcmVjb3JkLnByZXZpb3VzU2libGluZyA9IG9yaWdpbmFsLnByZXZpb3VzU2libGluZztcbiAgICByZWNvcmQubmV4dFNpYmxpbmcgPSBvcmlnaW5hbC5uZXh0U2libGluZztcbiAgICByZWNvcmQuYXR0cmlidXRlTmFtZSA9IG9yaWdpbmFsLmF0dHJpYnV0ZU5hbWU7XG4gICAgcmVjb3JkLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IG9yaWdpbmFsLmF0dHJpYnV0ZU5hbWVzcGFjZTtcbiAgICByZWNvcmQub2xkVmFsdWUgPSBvcmlnaW5hbC5vbGRWYWx1ZTtcbiAgICByZXR1cm4gcmVjb3JkO1xuICB9XG4gIHZhciBjdXJyZW50UmVjb3JkLCByZWNvcmRXaXRoT2xkVmFsdWU7XG4gIGZ1bmN0aW9uIGdldFJlY29yZCh0eXBlLCB0YXJnZXQpIHtcbiAgICByZXR1cm4gY3VycmVudFJlY29yZCA9IG5ldyBNdXRhdGlvblJlY29yZCh0eXBlLCB0YXJnZXQpO1xuICB9XG4gIGZ1bmN0aW9uIGdldFJlY29yZFdpdGhPbGRWYWx1ZShvbGRWYWx1ZSkge1xuICAgIGlmIChyZWNvcmRXaXRoT2xkVmFsdWUpIHJldHVybiByZWNvcmRXaXRoT2xkVmFsdWU7XG4gICAgcmVjb3JkV2l0aE9sZFZhbHVlID0gY29weU11dGF0aW9uUmVjb3JkKGN1cnJlbnRSZWNvcmQpO1xuICAgIHJlY29yZFdpdGhPbGRWYWx1ZS5vbGRWYWx1ZSA9IG9sZFZhbHVlO1xuICAgIHJldHVybiByZWNvcmRXaXRoT2xkVmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gY2xlYXJSZWNvcmRzKCkge1xuICAgIGN1cnJlbnRSZWNvcmQgPSByZWNvcmRXaXRoT2xkVmFsdWUgPSB1bmRlZmluZWQ7XG4gIH1cbiAgZnVuY3Rpb24gcmVjb3JkUmVwcmVzZW50c0N1cnJlbnRNdXRhdGlvbihyZWNvcmQpIHtcbiAgICByZXR1cm4gcmVjb3JkID09PSByZWNvcmRXaXRoT2xkVmFsdWUgfHwgcmVjb3JkID09PSBjdXJyZW50UmVjb3JkO1xuICB9XG4gIGZ1bmN0aW9uIHNlbGVjdFJlY29yZChsYXN0UmVjb3JkLCBuZXdSZWNvcmQpIHtcbiAgICBpZiAobGFzdFJlY29yZCA9PT0gbmV3UmVjb3JkKSByZXR1cm4gbGFzdFJlY29yZDtcbiAgICBpZiAocmVjb3JkV2l0aE9sZFZhbHVlICYmIHJlY29yZFJlcHJlc2VudHNDdXJyZW50TXV0YXRpb24obGFzdFJlY29yZCkpIHJldHVybiByZWNvcmRXaXRoT2xkVmFsdWU7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gUmVnaXN0cmF0aW9uKG9ic2VydmVyLCB0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnRyYW5zaWVudE9ic2VydmVkTm9kZXMgPSBbXTtcbiAgfVxuICBSZWdpc3RyYXRpb24ucHJvdG90eXBlID0ge1xuICAgIGVucXVldWU6IGZ1bmN0aW9uKHJlY29yZCkge1xuICAgICAgdmFyIHJlY29yZHMgPSB0aGlzLm9ic2VydmVyLnJlY29yZHNfO1xuICAgICAgdmFyIGxlbmd0aCA9IHJlY29yZHMubGVuZ3RoO1xuICAgICAgaWYgKHJlY29yZHMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgbGFzdFJlY29yZCA9IHJlY29yZHNbbGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciByZWNvcmRUb1JlcGxhY2VMYXN0ID0gc2VsZWN0UmVjb3JkKGxhc3RSZWNvcmQsIHJlY29yZCk7XG4gICAgICAgIGlmIChyZWNvcmRUb1JlcGxhY2VMYXN0KSB7XG4gICAgICAgICAgcmVjb3Jkc1tsZW5ndGggLSAxXSA9IHJlY29yZFRvUmVwbGFjZUxhc3Q7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2hlZHVsZUNhbGxiYWNrKHRoaXMub2JzZXJ2ZXIpO1xuICAgICAgfVxuICAgICAgcmVjb3Jkc1tsZW5ndGhdID0gcmVjb3JkO1xuICAgIH0sXG4gICAgYWRkTGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuYWRkTGlzdGVuZXJzXyh0aGlzLnRhcmdldCk7XG4gICAgfSxcbiAgICBhZGRMaXN0ZW5lcnNfOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZXMpIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUF0dHJNb2RpZmllZFwiLCB0aGlzLCB0cnVlKTtcbiAgICAgIGlmIChvcHRpb25zLmNoYXJhY3RlckRhdGEpIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNoYXJhY3RlckRhdGFNb2RpZmllZFwiLCB0aGlzLCB0cnVlKTtcbiAgICAgIGlmIChvcHRpb25zLmNoaWxkTGlzdCkgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwiRE9NTm9kZUluc2VydGVkXCIsIHRoaXMsIHRydWUpO1xuICAgICAgaWYgKG9wdGlvbnMuY2hpbGRMaXN0IHx8IG9wdGlvbnMuc3VidHJlZSkgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwiRE9NTm9kZVJlbW92ZWRcIiwgdGhpcywgdHJ1ZSk7XG4gICAgfSxcbiAgICByZW1vdmVMaXN0ZW5lcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcnNfKHRoaXMudGFyZ2V0KTtcbiAgICB9LFxuICAgIHJlbW92ZUxpc3RlbmVyc186IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlcykgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQXR0ck1vZGlmaWVkXCIsIHRoaXMsIHRydWUpO1xuICAgICAgaWYgKG9wdGlvbnMuY2hhcmFjdGVyRGF0YSkgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCIsIHRoaXMsIHRydWUpO1xuICAgICAgaWYgKG9wdGlvbnMuY2hpbGRMaXN0KSBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJET01Ob2RlSW5zZXJ0ZWRcIiwgdGhpcywgdHJ1ZSk7XG4gICAgICBpZiAob3B0aW9ucy5jaGlsZExpc3QgfHwgb3B0aW9ucy5zdWJ0cmVlKSBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJET01Ob2RlUmVtb3ZlZFwiLCB0aGlzLCB0cnVlKTtcbiAgICB9LFxuICAgIGFkZFRyYW5zaWVudE9ic2VydmVyOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICBpZiAobm9kZSA9PT0gdGhpcy50YXJnZXQpIHJldHVybjtcbiAgICAgIHRoaXMuYWRkTGlzdGVuZXJzXyhub2RlKTtcbiAgICAgIHRoaXMudHJhbnNpZW50T2JzZXJ2ZWROb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgdmFyIHJlZ2lzdHJhdGlvbnMgPSByZWdpc3RyYXRpb25zVGFibGUuZ2V0KG5vZGUpO1xuICAgICAgaWYgKCFyZWdpc3RyYXRpb25zKSByZWdpc3RyYXRpb25zVGFibGUuc2V0KG5vZGUsIHJlZ2lzdHJhdGlvbnMgPSBbXSk7XG4gICAgICByZWdpc3RyYXRpb25zLnB1c2godGhpcyk7XG4gICAgfSxcbiAgICByZW1vdmVUcmFuc2llbnRPYnNlcnZlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRyYW5zaWVudE9ic2VydmVkTm9kZXMgPSB0aGlzLnRyYW5zaWVudE9ic2VydmVkTm9kZXM7XG4gICAgICB0aGlzLnRyYW5zaWVudE9ic2VydmVkTm9kZXMgPSBbXTtcbiAgICAgIHRyYW5zaWVudE9ic2VydmVkTm9kZXMuZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzXyhub2RlKTtcbiAgICAgICAgdmFyIHJlZ2lzdHJhdGlvbnMgPSByZWdpc3RyYXRpb25zVGFibGUuZ2V0KG5vZGUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZ2lzdHJhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAocmVnaXN0cmF0aW9uc1tpXSA9PT0gdGhpcykge1xuICAgICAgICAgICAgcmVnaXN0cmF0aW9ucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG4gICAgaGFuZGxlRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICBzd2l0Y2ggKGUudHlwZSkge1xuICAgICAgIGNhc2UgXCJET01BdHRyTW9kaWZpZWRcIjpcbiAgICAgICAgdmFyIG5hbWUgPSBlLmF0dHJOYW1lO1xuICAgICAgICB2YXIgbmFtZXNwYWNlID0gZS5yZWxhdGVkTm9kZS5uYW1lc3BhY2VVUkk7XG4gICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgdmFyIHJlY29yZCA9IG5ldyBnZXRSZWNvcmQoXCJhdHRyaWJ1dGVzXCIsIHRhcmdldCk7XG4gICAgICAgIHJlY29yZC5hdHRyaWJ1dGVOYW1lID0gbmFtZTtcbiAgICAgICAgcmVjb3JkLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gZS5hdHRyQ2hhbmdlID09PSBNdXRhdGlvbkV2ZW50LkFERElUSU9OID8gbnVsbCA6IGUucHJldlZhbHVlO1xuICAgICAgICBmb3JFYWNoQW5jZXN0b3JBbmRPYnNlcnZlckVucXVldWVSZWNvcmQodGFyZ2V0LCBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25zLmF0dHJpYnV0ZXMpIHJldHVybjtcbiAgICAgICAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVGaWx0ZXIgJiYgb3B0aW9ucy5hdHRyaWJ1dGVGaWx0ZXIubGVuZ3RoICYmIG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyLmluZGV4T2YobmFtZSkgPT09IC0xICYmIG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyLmluZGV4T2YobmFtZXNwYWNlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlT2xkVmFsdWUpIHJldHVybiBnZXRSZWNvcmRXaXRoT2xkVmFsdWUob2xkVmFsdWUpO1xuICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgIGNhc2UgXCJET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcIjpcbiAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICB2YXIgcmVjb3JkID0gZ2V0UmVjb3JkKFwiY2hhcmFjdGVyRGF0YVwiLCB0YXJnZXQpO1xuICAgICAgICB2YXIgb2xkVmFsdWUgPSBlLnByZXZWYWx1ZTtcbiAgICAgICAgZm9yRWFjaEFuY2VzdG9yQW5kT2JzZXJ2ZXJFbnF1ZXVlUmVjb3JkKHRhcmdldCwgZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucy5jaGFyYWN0ZXJEYXRhKSByZXR1cm47XG4gICAgICAgICAgaWYgKG9wdGlvbnMuY2hhcmFjdGVyRGF0YU9sZFZhbHVlKSByZXR1cm4gZ2V0UmVjb3JkV2l0aE9sZFZhbHVlKG9sZFZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgICBjYXNlIFwiRE9NTm9kZVJlbW92ZWRcIjpcbiAgICAgICAgdGhpcy5hZGRUcmFuc2llbnRPYnNlcnZlcihlLnRhcmdldCk7XG5cbiAgICAgICBjYXNlIFwiRE9NTm9kZUluc2VydGVkXCI6XG4gICAgICAgIHZhciBjaGFuZ2VkTm9kZSA9IGUudGFyZ2V0O1xuICAgICAgICB2YXIgYWRkZWROb2RlcywgcmVtb3ZlZE5vZGVzO1xuICAgICAgICBpZiAoZS50eXBlID09PSBcIkRPTU5vZGVJbnNlcnRlZFwiKSB7XG4gICAgICAgICAgYWRkZWROb2RlcyA9IFsgY2hhbmdlZE5vZGUgXTtcbiAgICAgICAgICByZW1vdmVkTm9kZXMgPSBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRlZE5vZGVzID0gW107XG4gICAgICAgICAgcmVtb3ZlZE5vZGVzID0gWyBjaGFuZ2VkTm9kZSBdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2aW91c1NpYmxpbmcgPSBjaGFuZ2VkTm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgIHZhciBuZXh0U2libGluZyA9IGNoYW5nZWROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICB2YXIgcmVjb3JkID0gZ2V0UmVjb3JkKFwiY2hpbGRMaXN0XCIsIGUudGFyZ2V0LnBhcmVudE5vZGUpO1xuICAgICAgICByZWNvcmQuYWRkZWROb2RlcyA9IGFkZGVkTm9kZXM7XG4gICAgICAgIHJlY29yZC5yZW1vdmVkTm9kZXMgPSByZW1vdmVkTm9kZXM7XG4gICAgICAgIHJlY29yZC5wcmV2aW91c1NpYmxpbmcgPSBwcmV2aW91c1NpYmxpbmc7XG4gICAgICAgIHJlY29yZC5uZXh0U2libGluZyA9IG5leHRTaWJsaW5nO1xuICAgICAgICBmb3JFYWNoQW5jZXN0b3JBbmRPYnNlcnZlckVucXVldWVSZWNvcmQoZS5yZWxhdGVkTm9kZSwgZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucy5jaGlsZExpc3QpIHJldHVybjtcbiAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNsZWFyUmVjb3JkcygpO1xuICAgIH1cbiAgfTtcbiAgZ2xvYmFsLkpzTXV0YXRpb25PYnNlcnZlciA9IEpzTXV0YXRpb25PYnNlcnZlcjtcbiAgaWYgKCFnbG9iYWwuTXV0YXRpb25PYnNlcnZlcikge1xuICAgIGdsb2JhbC5NdXRhdGlvbk9ic2VydmVyID0gSnNNdXRhdGlvbk9ic2VydmVyO1xuICAgIEpzTXV0YXRpb25PYnNlcnZlci5faXNQb2x5ZmlsbGVkID0gdHJ1ZTtcbiAgfVxufSkoc2VsZik7IiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuXG4vKipcbiAqIE1pbmltYWwgYW5pbWF0aW9uIGxpYnJhcnkgZm9yIG1hbmFnaW5nIGNzcyB0cmFuc2l0aW9uIG9uIG1vYmlsZSBicm93c2Vycy5cbiAqL1xud2luZG93LmFuaW1pdCA9IChmdW5jdGlvbigpe1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIFRJTUVPVVRfUkFUSU8gPSAxLjQ7XG5cbiAgdmFyIHV0aWwgPSB7XG4gIH07XG5cbiAgLy8gY2FwaXRhbGl6ZSBzdHJpbmdcbiAgdXRpbC5jYXBpdGFsaXplID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbiAgfTtcblxuICAvKipcbiAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5wcm9wZXJ0eVxuICAqIEBwYXJhbSB7RmxvYXR9IHBhcmFtcy5kdXJhdGlvblxuICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMudGltaW5nXG4gICovXG4gIHV0aWwuYnVpbGRUcmFuc2l0aW9uVmFsdWUgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICBwYXJhbXMucHJvcGVydHkgPSBwYXJhbXMucHJvcGVydHkgfHwgJ2FsbCc7XG4gICAgcGFyYW1zLmR1cmF0aW9uID0gcGFyYW1zLmR1cmF0aW9uIHx8IDAuNDtcbiAgICBwYXJhbXMudGltaW5nID0gcGFyYW1zLnRpbWluZyB8fCAnbGluZWFyJztcblxuICAgIHZhciBwcm9wcyA9IHBhcmFtcy5wcm9wZXJ0eS5zcGxpdCgvICsvKTtcblxuICAgIHJldHVybiBwcm9wcy5tYXAoZnVuY3Rpb24ocHJvcCkge1xuICAgICAgcmV0dXJuIHByb3AgKyAnICcgKyBwYXJhbXMuZHVyYXRpb24gKyAncyAnICsgcGFyYW1zLnRpbWluZztcbiAgICB9KS5qb2luKCcsICcpO1xuICB9O1xuXG4gIC8qKlxuICAqIEFkZCBhbiBldmVudCBoYW5kbGVyIG9uIFwidHJhbnNpdGlvbmVuZFwiIGV2ZW50LlxuICAqL1xuICB1dGlsLm9uY2VPblRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbihlbGVtZW50LCBjYWxsYmFjaykge1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge307XG4gICAgfVxuXG4gICAgdmFyIGZuID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGlmIChlbGVtZW50ID09IGV2ZW50LnRhcmdldCkge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXJzKCk7XG5cbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJlbW92ZUxpc3RlbmVycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdXRpbC5fdHJhbnNpdGlvbkVuZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBmbiwgZmFsc2UpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHV0aWwuX3RyYW5zaXRpb25FbmRFdmVudHMuZm9yRWFjaChmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGZuLCBmYWxzZSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVtb3ZlTGlzdGVuZXJzO1xuICB9O1xuXG4gIHV0aWwuX3RyYW5zaXRpb25FbmRFdmVudHMgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICBpZiAoJ29udHJhbnNpdGlvbmVuZCcgaW4gd2luZG93KSB7XG4gICAgICByZXR1cm4gWyd0cmFuc2l0aW9uZW5kJ107XG4gICAgfVxuXG4gICAgaWYgKCdvbndlYmtpdHRyYW5zaXRpb25lbmQnIGluIHdpbmRvdykge1xuICAgICAgcmV0dXJuIFsnd2Via2l0VHJhbnNpdGlvbkVuZCddO1xuICAgIH1cblxuICAgIGlmICh1dGlsLnZlbmRvclByZWZpeCA9PT0gJ3dlYmtpdCcgfHwgdXRpbC52ZW5kb3JQcmVmaXggPT09ICdvJyB8fCB1dGlsLnZlbmRvclByZWZpeCA9PT0gJ21veicgfHwgdXRpbC52ZW5kb3JQcmVmaXggPT09ICdtcycpIHtcbiAgICAgIHJldHVybiBbdXRpbC52ZW5kb3JQcmVmaXggKyAnVHJhbnNpdGlvbkVuZCcsICd0cmFuc2l0aW9uZW5kJ107XG4gICAgfVxuXG4gICAgcmV0dXJuIFtdO1xuICB9KSgpO1xuXG4gIHV0aWwuX2Nzc1Byb3BlcnR5RGljdCA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnJyk7XG4gICAgdmFyIGRpY3QgPSB7fTtcbiAgICB2YXIgYSA9ICdBJy5jaGFyQ29kZUF0KDApO1xuICAgIHZhciB6ID0gJ3onLmNoYXJDb2RlQXQoMCk7XG5cbiAgICB2YXIgdXBwZXIgPSBmdW5jdGlvbihzKSB7XG4gICAgICByZXR1cm4gcy5zdWJzdHIoMSkudG9VcHBlckNhc2UoKTtcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblxuICAgICAgdmFyIGtleSA9IHN0eWxlc1tpXVxuICAgICAgICAucmVwbGFjZSgvXltcXC1dKy8sICcnKVxuICAgICAgICAucmVwbGFjZSgvW1xcLV1bYS16XS9nLCB1cHBlcilcbiAgICAgICAgLnJlcGxhY2UoL15tb3ovLCAnTW96Jyk7XG5cbiAgICAgIGlmIChhIDw9IGtleS5jaGFyQ29kZUF0KDApICYmIHogPj0ga2V5LmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgICAgaWYgKGtleSAhPT0gJ2Nzc1RleHQnICYmIGtleSAhPT0gJ3BhcmVudFRleHQnKSB7XG4gICAgICAgICAgZGljdFtrZXldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkaWN0O1xuICB9KSgpO1xuXG4gIHV0aWwuaGFzQ3NzUHJvcGVydHkgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUgaW4gdXRpbC5fY3NzUHJvcGVydHlEaWN0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBWZW5kb3IgcHJlZml4IGZvciBjc3MgcHJvcGVydHkuXG4gICAqL1xuICB1dGlsLnZlbmRvclByZWZpeCA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnJyksXG4gICAgcHJlID0gKEFycmF5LnByb3RvdHlwZS5zbGljZVxuICAgICAgLmNhbGwoc3R5bGVzKVxuICAgICAgLmpvaW4oJycpXG4gICAgICAubWF0Y2goLy0obW96fHdlYmtpdHxtcyktLykgfHwgKHN0eWxlcy5PTGluayA9PT0gJycgJiYgWycnLCAnbyddKVxuICAgIClbMV07XG4gICAgcmV0dXJuIHByZTtcbiAgfSkoKTtcblxuICB1dGlsLmZvcmNlTGF5b3V0QXRPbmNlID0gZnVuY3Rpb24oZWxlbWVudHMsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5iYXRjaEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAvLyBmb3JjZSBsYXlvdXRcbiAgICAgICAgZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICB9KTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgdXRpbC5iYXRjaEltbWVkaWF0ZSA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgY2FsbGJhY2tzID0gW107XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgIGlmIChjYWxsYmFja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgY29uY3JlYXRlQ2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgICAgICAgIGNhbGxiYWNrcyA9IFtdO1xuICAgICAgICAgIGNvbmNyZWF0ZUNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIH07XG4gIH0pKCk7XG5cbiAgdXRpbC5iYXRjaEFuaW1hdGlvbkZyYW1lID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBjYWxsYmFja3MgPSBbXTtcblxuICAgIHZhciByYWYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgIGlmIChjYWxsYmFja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJhZihmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgY29uY3JlYXRlQ2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgICAgICAgIGNhbGxiYWNrcyA9IFtdO1xuICAgICAgICAgIGNvbmNyZWF0ZUNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIH07XG4gIH0pKCk7XG5cbiAgdXRpbC50cmFuc2l0aW9uUHJvcGVydHlOYW1lID0gKGZ1bmN0aW9uKCkge1xuICAgIGlmICh1dGlsLmhhc0Nzc1Byb3BlcnR5KCd0cmFuc2l0aW9uRHVyYXRpb24nKSkge1xuICAgICAgcmV0dXJuICd0cmFuc2l0aW9uJztcbiAgICB9XG5cbiAgICBpZiAodXRpbC5oYXNDc3NQcm9wZXJ0eSh1dGlsLnZlbmRvclByZWZpeCArICdUcmFuc2l0aW9uRHVyYXRpb24nKSkge1xuICAgICAgcmV0dXJuIHV0aWwudmVuZG9yUHJlZml4ICsgJ1RyYW5zaXRpb24nO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGF0ZScpO1xuICB9KSgpO1xuXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICovXG4gIHZhciBBbmltaXQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEFuaW1pdCkpIHtcbiAgICAgIHJldHVybiBuZXcgQW5pbWl0KGVsZW1lbnQpO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgIHRoaXMuZWxlbWVudHMgPSBbZWxlbWVudF07XG4gICAgfSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZWxlbWVudCkgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50O1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBhcnJheSBvciBhbiBpbnN0YW5jZSBvZiBIVE1MRWxlbWVudC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLnRyYW5zaXRpb25RdWV1ZSA9IFtdO1xuICAgIHRoaXMubGFzdFN0eWxlQXR0cmlidXRlRGljdCA9IFtdO1xuICB9O1xuXG4gIEFuaW1pdC5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0FycmF5fVxuICAgICAqL1xuICAgIHRyYW5zaXRpb25RdWV1ZTogdW5kZWZpbmVkLFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtBcnJheX1cbiAgICAgKi9cbiAgICBlbGVtZW50czogdW5kZWZpbmVkLFxuXG4gICAgLyoqXG4gICAgICogU3RhcnQgYW5pbWF0aW9uIHNlcXVlbmNlIHdpdGggcGFzc2VkIGFuaW1hdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqL1xuICAgIHBsYXk6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvblF1ZXVlLnB1c2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGFydEFuaW1hdGlvbigpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUXVldWUgdHJhbnNpdGlvbiBhbmltYXRpb25zIG9yIG90aGVyIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogZS5nLiBhbmltaXQoZWx0KS5xdWV1ZSh7Y29sb3I6ICdyZWQnfSlcbiAgICAgKiBlLmcuIGFuaW1pdChlbHQpLnF1ZXVlKHtjb2xvcjogJ3JlZCd9LCB7ZHVyYXRpb246IDAuNH0pXG4gICAgICogZS5nLiBhbmltaXQoZWx0KS5xdWV1ZSh7Y3NzOiB7Y29sb3I6ICdyZWQnfSwgZHVyYXRpb246IDAuMn0pXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdHxBbmltaXQuVHJhbnNpdGlvbnxGdW5jdGlvbn0gdHJhbnNpdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKi9cbiAgICBxdWV1ZTogZnVuY3Rpb24odHJhbnNpdGlvbiwgb3B0aW9ucykge1xuICAgICAgdmFyIHF1ZXVlID0gdGhpcy50cmFuc2l0aW9uUXVldWU7XG5cbiAgICAgIGlmICh0cmFuc2l0aW9uICYmIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucy5jc3MgPSB0cmFuc2l0aW9uO1xuICAgICAgICB0cmFuc2l0aW9uID0gbmV3IEFuaW1pdC5UcmFuc2l0aW9uKG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoISh0cmFuc2l0aW9uIGluc3RhbmNlb2YgRnVuY3Rpb24gfHwgdHJhbnNpdGlvbiBpbnN0YW5jZW9mIEFuaW1pdC5UcmFuc2l0aW9uKSkge1xuICAgICAgICBpZiAodHJhbnNpdGlvbi5jc3MpIHtcbiAgICAgICAgICB0cmFuc2l0aW9uID0gbmV3IEFuaW1pdC5UcmFuc2l0aW9uKHRyYW5zaXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyYW5zaXRpb24gPSBuZXcgQW5pbWl0LlRyYW5zaXRpb24oe1xuICAgICAgICAgICAgY3NzOiB0cmFuc2l0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRyYW5zaXRpb24gaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICBxdWV1ZS5wdXNoKHRyYW5zaXRpb24pO1xuICAgICAgfSBlbHNlIGlmICh0cmFuc2l0aW9uIGluc3RhbmNlb2YgQW5pbWl0LlRyYW5zaXRpb24pIHtcbiAgICAgICAgcXVldWUucHVzaCh0cmFuc2l0aW9uLmJ1aWxkKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUXVldWUgdHJhbnNpdGlvbiBhbmltYXRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGbG9hdH0gc2Vjb25kc1xuICAgICAqL1xuICAgIHdhaXQ6IGZ1bmN0aW9uKHNlY29uZHMpIHtcbiAgICAgIGlmIChzZWNvbmRzID4gMCkge1xuICAgICAgICB0aGlzLnRyYW5zaXRpb25RdWV1ZS5wdXNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGRvbmUsIDEwMDAgKiBzZWNvbmRzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzYXZlU3R5bGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB0aGlzLnRyYW5zaXRpb25RdWV1ZS5wdXNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KSB7XG4gICAgICAgICAgdmFyIGNzcyA9IHRoaXMubGFzdFN0eWxlQXR0cmlidXRlRGljdFtpbmRleF0gPSB7fTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudC5zdHlsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3NzW2VsZW1lbnQuc3R5bGVbaV1dID0gZWxlbWVudC5zdHlsZVtlbGVtZW50LnN0eWxlW2ldXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlIGVsZW1lbnQncyBzdHlsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge0Zsb2F0fSBbb3B0aW9ucy5kdXJhdGlvbl1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGltaW5nXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50cmFuc2l0aW9uXVxuICAgICAqL1xuICAgIHJlc3RvcmVTdHlsZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIGlmIChvcHRpb25zLnRyYW5zaXRpb24gJiYgIW9wdGlvbnMuZHVyYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm9wdGlvbnMuZHVyYXRpb25cIiBpcyByZXF1aXJlZCB3aGVuIFwib3B0aW9ucy50cmFuc2l0aW9uXCIgaXMgZW5hYmxlZC4nKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRyYW5zaXRpb25OYW1lID0gdXRpbC50cmFuc2l0aW9uUHJvcGVydHlOYW1lO1xuXG4gICAgICBpZiAob3B0aW9ucy50cmFuc2l0aW9uIHx8IChvcHRpb25zLmR1cmF0aW9uICYmIG9wdGlvbnMuZHVyYXRpb24gPiAwKSkge1xuICAgICAgICB2YXIgdHJhbnNpdGlvblZhbHVlID0gb3B0aW9ucy50cmFuc2l0aW9uIHx8ICgnYWxsICcgKyBvcHRpb25zLmR1cmF0aW9uICsgJ3MgJyArIChvcHRpb25zLnRpbWluZyB8fCAnbGluZWFyJykpO1xuXG4gICAgICAgIHRoaXMudHJhbnNpdGlvblF1ZXVlLnB1c2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgICAgdmFyIHRpbWVvdXRJZDtcblxuICAgICAgICAgIHZhciBjbGVhclRyYW5zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlW3RyYW5zaXRpb25OYW1lXSA9ICcnO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIGFkZCBcInRyYW5zaXRpb25lbmRcIiBldmVudCBoYW5kbGVyXG4gICAgICAgICAgdmFyIHJlbW92ZUxpc3RlbmVycyA9IHV0aWwub25jZU9uVHJhbnNpdGlvbkVuZChlbGVtZW50c1swXSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgICAgIGNsZWFyVHJhbnNpdGlvbigpO1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gZm9yIGZhaWwgc2FmZS5cbiAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICBjbGVhclRyYW5zaXRpb24oKTtcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICB9LCBvcHRpb25zLmR1cmF0aW9uICogMTAwMCAqIFRJTUVPVVRfUkFUSU8pO1xuXG4gICAgICAgICAgLy8gdHJhbnNpdGlvbiBhbmQgc3R5bGUgc2V0dGluZ3NcbiAgICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KSB7XG5cbiAgICAgICAgICAgIHZhciBjc3MgPSBzZWxmLmxhc3RTdHlsZUF0dHJpYnV0ZURpY3RbaW5kZXhdO1xuXG4gICAgICAgICAgICBpZiAoIWNzcykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Jlc3RvcmVTdHlsZSgpOiBUaGUgc3R5bGUgaXMgbm90IHNhdmVkLiBJbnZva2Ugc2F2ZVN0eWxlKCkgYmVmb3JlLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLmxhc3RTdHlsZUF0dHJpYnV0ZURpY3RbaW5kZXhdID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICB2YXIgbmFtZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbGVtZW50LnN0eWxlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgIG5hbWUgPSBlbGVtZW50LnN0eWxlW2ldO1xuICAgICAgICAgICAgICBpZiAoY3NzW25hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjc3NbbmFtZV0gPSAnJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlW3RyYW5zaXRpb25OYW1lXSA9IHRyYW5zaXRpb25WYWx1ZTtcblxuICAgICAgICAgICAgT2JqZWN0LmtleXMoY3NzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICBpZiAoa2V5ICE9PSB0cmFuc2l0aW9uTmFtZSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVba2V5XSA9IGNzc1trZXldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVt0cmFuc2l0aW9uTmFtZV0gPSB0cmFuc2l0aW9uVmFsdWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uUXVldWUucHVzaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgICAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgIC8vIENsZWFyIHRyYW5zaXRpb24gYW5pbWF0aW9uIHNldHRpbmdzLlxuICAgICAgICBzZWxmLmVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCwgaW5kZXgpIHtcbiAgICAgICAgICBlbGVtZW50LnN0eWxlW3RyYW5zaXRpb25OYW1lXSA9ICdub25lJztcblxuICAgICAgICAgIHZhciBjc3MgPSBzZWxmLmxhc3RTdHlsZUF0dHJpYnV0ZURpY3RbaW5kZXhdO1xuXG4gICAgICAgICAgaWYgKCFjc3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVzdG9yZVN0eWxlKCk6IFRoZSBzdHlsZSBpcyBub3Qgc2F2ZWQuIEludm9rZSBzYXZlU3R5bGUoKSBiZWZvcmUuJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZi5sYXN0U3R5bGVBdHRyaWJ1dGVEaWN0W2luZGV4XSA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuYW1lID0gJyc7IGkgPCBlbGVtZW50LnN0eWxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBuYW1lID0gZWxlbWVudC5zdHlsZVtpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3NzW2VsZW1lbnQuc3R5bGVbaV1dID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICBjc3NbZWxlbWVudC5zdHlsZVtpXV0gPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBPYmplY3Qua2V5cyhjc3MpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlW2tleV0gPSBjc3Nba2V5XTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RhcnQgYW5pbWF0aW9uIHNlcXVlbmNlLlxuICAgICAqL1xuICAgIHN0YXJ0QW5pbWF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2RlcXVldWVUcmFuc2l0aW9uKCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfZGVxdWV1ZVRyYW5zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRyYW5zaXRpb24gPSB0aGlzLnRyYW5zaXRpb25RdWV1ZS5zaGlmdCgpO1xuICAgICAgaWYgKHRoaXMuX2N1cnJlbnRUcmFuc2l0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ3VycmVudCB0cmFuc2l0aW9uIGV4aXN0cy4nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2N1cnJlbnRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBjYWxsZWQgPSBmYWxzZTtcblxuICAgICAgdmFyIGRvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICAgIHNlbGYuX2N1cnJlbnRUcmFuc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHNlbGYuX2RlcXVldWVUcmFuc2l0aW9uKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0YXRlOiBUaGlzIGNhbGxiYWNrIGlzIGNhbGxlZCB0d2ljZS4nKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgICAgdHJhbnNpdGlvbi5jYWxsKHRoaXMsIGRvbmUpO1xuICAgICAgfVxuICAgIH1cblxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FuaW1pdH0gYXJndW1lbnRzXG4gICAqL1xuICBBbmltaXQucnVuQWxsID0gZnVuY3Rpb24oLyogYXJndW1lbnRzLi4uICovKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3VtZW50c1tpXS5wbGF5KCk7XG4gICAgfVxuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7RmxvYXR9IFtvcHRpb25zLmR1cmF0aW9uXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucHJvcGVydHldXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50aW1pbmddXG4gICAqL1xuICBBbmltaXQuVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMub3B0aW9ucy5kdXJhdGlvbiA9IHRoaXMub3B0aW9ucy5kdXJhdGlvbiB8fCAwO1xuICAgIHRoaXMub3B0aW9ucy50aW1pbmcgPSB0aGlzLm9wdGlvbnMudGltaW5nIHx8ICdsaW5lYXInO1xuICAgIHRoaXMub3B0aW9ucy5jc3MgPSB0aGlzLm9wdGlvbnMuY3NzIHx8IHt9O1xuICAgIHRoaXMub3B0aW9ucy5wcm9wZXJ0eSA9IHRoaXMub3B0aW9ucy5wcm9wZXJ0eSB8fCAnYWxsJztcbiAgfTtcblxuICBBbmltaXQuVHJhbnNpdGlvbi5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICovXG4gICAgYnVpbGQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5vcHRpb25zLmNzcykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucy5jc3MgaXMgcmVxdWlyZWQuJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjc3MgPSBjcmVhdGVBY3R1YWxDc3NQcm9wcyh0aGlzLm9wdGlvbnMuY3NzKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kdXJhdGlvbiA+IDApIHtcbiAgICAgICAgdmFyIHRyYW5zaXRpb25WYWx1ZSA9IHV0aWwuYnVpbGRUcmFuc2l0aW9uVmFsdWUodGhpcy5vcHRpb25zKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgICAgdmFyIHRpbWVvdXQgPSBzZWxmLm9wdGlvbnMuZHVyYXRpb24gKiAxMDAwICogVElNRU9VVF9SQVRJTztcbiAgICAgICAgICB2YXIgdGltZW91dElkO1xuXG4gICAgICAgICAgdmFyIHJlbW92ZUxpc3RlbmVycyA9IHV0aWwub25jZU9uVHJhbnNpdGlvbkVuZChlbGVtZW50c1swXSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIH0sIHRpbWVvdXQpO1xuXG4gICAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlW3V0aWwudHJhbnNpdGlvblByb3BlcnR5TmFtZV0gPSB0cmFuc2l0aW9uVmFsdWU7XG5cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGNzcykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbbmFtZV0gPSBjc3NbbmFtZV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmR1cmF0aW9uIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cztcblxuICAgICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVt1dGlsLnRyYW5zaXRpb25Qcm9wZXJ0eU5hbWVdID0gJyc7XG5cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGNzcykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbbmFtZV0gPSBjc3NbbmFtZV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB1dGlsLmZvcmNlTGF5b3V0QXRPbmNlKGVsZW1lbnRzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdXRpbC5iYXRjaEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1dGlsLmJhdGNoQW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY3JlYXRlQWN0dWFsQ3NzUHJvcHMoY3NzKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgICAgICBPYmplY3Qua2V5cyhjc3MpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGNzc1tuYW1lXTtcblxuICAgICAgICAgIGlmICh1dGlsLmhhc0Nzc1Byb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICByZXN1bHRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcHJlZml4ZWQgPSB1dGlsLnZlbmRvclByZWZpeCArIHV0aWwuY2FwaXRhbGl6ZShuYW1lKTtcbiAgICAgICAgICBpZiAodXRpbC5oYXNDc3NQcm9wZXJ0eShwcmVmaXhlZCkpIHtcbiAgICAgICAgICAgIHJlc3VsdFtwcmVmaXhlZF0gPSB2YWx1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0W3ByZWZpeGVkXSA9IHZhbHVlO1xuICAgICAgICAgICAgcmVzdWx0W25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgfVxuICB9O1xuXG5cbiAgcmV0dXJuIEFuaW1pdDtcbn0pKCk7XG4iLCIvKlxyXG4gKiBjaGlsZE5vZGUucmVtb3ZlIG1ldGhvZCBwb2x5ZmlsbCBmb3IgSUUuXHJcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DaGlsZE5vZGUvcmVtb3ZlXHJcbiAqL1xyXG5cclxuKGZ1bmN0aW9uKCkge1xyXG5cdGlmICghKCdyZW1vdmUnIGluIEVsZW1lbnQucHJvdG90eXBlKSkge1xyXG5cdCAgRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKSB7XHJcblx0ICAgIGlmICh0aGlzLnBhcmVudE5vZGUpIHtcclxuXHQgICAgXHR0aGlzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcyk7XHJcblx0ICAgIH1cclxuXHQgIH07XHJcblx0fVxyXG59KSgpO1xyXG4iLCIvKlxyXG4gKiBjbGFzc0xpc3QuanM6IENyb3NzLWJyb3dzZXIgZnVsbCBlbGVtZW50LmNsYXNzTGlzdCBpbXBsZW1lbnRhdGlvbi5cclxuICogMS4xLjIwMTUwMzEyXHJcbiAqXHJcbiAqIEJ5IEVsaSBHcmV5LCBodHRwOi8vZWxpZ3JleS5jb21cclxuICogTGljZW5zZTogRGVkaWNhdGVkIHRvIHRoZSBwdWJsaWMgZG9tYWluLlxyXG4gKiAgIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZWxpZ3JleS9jbGFzc0xpc3QuanMvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZFxyXG4gKi9cclxuXHJcbi8qZ2xvYmFsIHNlbGYsIGRvY3VtZW50LCBET01FeGNlcHRpb24gKi9cclxuXHJcbi8qISBAc291cmNlIGh0dHA6Ly9wdXJsLmVsaWdyZXkuY29tL2dpdGh1Yi9jbGFzc0xpc3QuanMvYmxvYi9tYXN0ZXIvY2xhc3NMaXN0LmpzICovXHJcblxyXG5pZiAoXCJkb2N1bWVudFwiIGluIHNlbGYpIHtcclxuXHJcbi8vIEZ1bGwgcG9seWZpbGwgZm9yIGJyb3dzZXJzIHdpdGggbm8gY2xhc3NMaXN0IHN1cHBvcnRcclxuLy8gSW5jbHVkaW5nIElFIDwgRWRnZSBtaXNzaW5nIFNWR0VsZW1lbnQuY2xhc3NMaXN0XHJcbmlmICghKFwiY2xhc3NMaXN0XCIgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIl9cIikpXHJcbiAgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TICYmICEoXCJjbGFzc0xpc3RcIiBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFwiZ1wiKSkpIHtcclxuXHJcbihmdW5jdGlvbiAodmlldykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5pZiAoISgnRWxlbWVudCcgaW4gdmlldykpIHJldHVybjtcclxuXHJcbnZhclxyXG4gICAgY2xhc3NMaXN0UHJvcCA9IFwiY2xhc3NMaXN0XCJcclxuICAsIHByb3RvUHJvcCA9IFwicHJvdG90eXBlXCJcclxuICAsIGVsZW1DdHJQcm90byA9IHZpZXcuRWxlbWVudFtwcm90b1Byb3BdXHJcbiAgLCBvYmpDdHIgPSBPYmplY3RcclxuICAsIHN0clRyaW0gPSBTdHJpbmdbcHJvdG9Qcm9wXS50cmltIHx8IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLnJlcGxhY2UoL15cXHMrfFxccyskL2csIFwiXCIpO1xyXG4gIH1cclxuICAsIGFyckluZGV4T2YgPSBBcnJheVtwcm90b1Byb3BdLmluZGV4T2YgfHwgZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgIHZhclxyXG4gICAgICAgIGkgPSAwXHJcbiAgICAgICwgbGVuID0gdGhpcy5sZW5ndGhcclxuICAgIDtcclxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiAtMTtcclxuICB9XHJcbiAgLy8gVmVuZG9yczogcGxlYXNlIGFsbG93IGNvbnRlbnQgY29kZSB0byBpbnN0YW50aWF0ZSBET01FeGNlcHRpb25zXHJcbiAgLCBET01FeCA9IGZ1bmN0aW9uICh0eXBlLCBtZXNzYWdlKSB7XHJcbiAgICB0aGlzLm5hbWUgPSB0eXBlO1xyXG4gICAgdGhpcy5jb2RlID0gRE9NRXhjZXB0aW9uW3R5cGVdO1xyXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcclxuICB9XHJcbiAgLCBjaGVja1Rva2VuQW5kR2V0SW5kZXggPSBmdW5jdGlvbiAoY2xhc3NMaXN0LCB0b2tlbikge1xyXG4gICAgaWYgKHRva2VuID09PSBcIlwiKSB7XHJcbiAgICAgIHRocm93IG5ldyBET01FeChcclxuICAgICAgICAgIFwiU1lOVEFYX0VSUlwiXHJcbiAgICAgICAgLCBcIkFuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZFwiXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICBpZiAoL1xccy8udGVzdCh0b2tlbikpIHtcclxuICAgICAgdGhyb3cgbmV3IERPTUV4KFxyXG4gICAgICAgICAgXCJJTlZBTElEX0NIQVJBQ1RFUl9FUlJcIlxyXG4gICAgICAgICwgXCJTdHJpbmcgY29udGFpbnMgYW4gaW52YWxpZCBjaGFyYWN0ZXJcIlxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyckluZGV4T2YuY2FsbChjbGFzc0xpc3QsIHRva2VuKTtcclxuICB9XHJcbiAgLCBDbGFzc0xpc3QgPSBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgdmFyXHJcbiAgICAgICAgdHJpbW1lZENsYXNzZXMgPSBzdHJUcmltLmNhbGwoZWxlbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiKVxyXG4gICAgICAsIGNsYXNzZXMgPSB0cmltbWVkQ2xhc3NlcyA/IHRyaW1tZWRDbGFzc2VzLnNwbGl0KC9cXHMrLykgOiBbXVxyXG4gICAgICAsIGkgPSAwXHJcbiAgICAgICwgbGVuID0gY2xhc3Nlcy5sZW5ndGhcclxuICAgIDtcclxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgdGhpcy5wdXNoKGNsYXNzZXNbaV0pO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fdXBkYXRlQ2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICBlbGVtLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHRoaXMudG9TdHJpbmcoKSk7XHJcbiAgICB9O1xyXG4gIH1cclxuICAsIGNsYXNzTGlzdFByb3RvID0gQ2xhc3NMaXN0W3Byb3RvUHJvcF0gPSBbXVxyXG4gICwgY2xhc3NMaXN0R2V0dGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIG5ldyBDbGFzc0xpc3QodGhpcyk7XHJcbiAgfVxyXG47XHJcbi8vIE1vc3QgRE9NRXhjZXB0aW9uIGltcGxlbWVudGF0aW9ucyBkb24ndCBhbGxvdyBjYWxsaW5nIERPTUV4Y2VwdGlvbidzIHRvU3RyaW5nKClcclxuLy8gb24gbm9uLURPTUV4Y2VwdGlvbnMuIEVycm9yJ3MgdG9TdHJpbmcoKSBpcyBzdWZmaWNpZW50IGhlcmUuXHJcbkRPTUV4W3Byb3RvUHJvcF0gPSBFcnJvcltwcm90b1Byb3BdO1xyXG5jbGFzc0xpc3RQcm90by5pdGVtID0gZnVuY3Rpb24gKGkpIHtcclxuICByZXR1cm4gdGhpc1tpXSB8fCBudWxsO1xyXG59O1xyXG5jbGFzc0xpc3RQcm90by5jb250YWlucyA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG4gIHRva2VuICs9IFwiXCI7XHJcbiAgcmV0dXJuIGNoZWNrVG9rZW5BbmRHZXRJbmRleCh0aGlzLCB0b2tlbikgIT09IC0xO1xyXG59O1xyXG5jbGFzc0xpc3RQcm90by5hZGQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyXHJcbiAgICAgIHRva2VucyA9IGFyZ3VtZW50c1xyXG4gICAgLCBpID0gMFxyXG4gICAgLCBsID0gdG9rZW5zLmxlbmd0aFxyXG4gICAgLCB0b2tlblxyXG4gICAgLCB1cGRhdGVkID0gZmFsc2VcclxuICA7XHJcbiAgZG8ge1xyXG4gICAgdG9rZW4gPSB0b2tlbnNbaV0gKyBcIlwiO1xyXG4gICAgaWYgKGNoZWNrVG9rZW5BbmRHZXRJbmRleCh0aGlzLCB0b2tlbikgPT09IC0xKSB7XHJcbiAgICAgIHRoaXMucHVzaCh0b2tlbik7XHJcbiAgICAgIHVwZGF0ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuICB3aGlsZSAoKytpIDwgbCk7XHJcblxyXG4gIGlmICh1cGRhdGVkKSB7XHJcbiAgICB0aGlzLl91cGRhdGVDbGFzc05hbWUoKTtcclxuICB9XHJcbn07XHJcbmNsYXNzTGlzdFByb3RvLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXJcclxuICAgICAgdG9rZW5zID0gYXJndW1lbnRzXHJcbiAgICAsIGkgPSAwXHJcbiAgICAsIGwgPSB0b2tlbnMubGVuZ3RoXHJcbiAgICAsIHRva2VuXHJcbiAgICAsIHVwZGF0ZWQgPSBmYWxzZVxyXG4gICAgLCBpbmRleFxyXG4gIDtcclxuICBkbyB7XHJcbiAgICB0b2tlbiA9IHRva2Vuc1tpXSArIFwiXCI7XHJcbiAgICBpbmRleCA9IGNoZWNrVG9rZW5BbmRHZXRJbmRleCh0aGlzLCB0b2tlbik7XHJcbiAgICB3aGlsZSAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgIHRoaXMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgdXBkYXRlZCA9IHRydWU7XHJcbiAgICAgIGluZGV4ID0gY2hlY2tUb2tlbkFuZEdldEluZGV4KHRoaXMsIHRva2VuKTtcclxuICAgIH1cclxuICB9XHJcbiAgd2hpbGUgKCsraSA8IGwpO1xyXG5cclxuICBpZiAodXBkYXRlZCkge1xyXG4gICAgdGhpcy5fdXBkYXRlQ2xhc3NOYW1lKCk7XHJcbiAgfVxyXG59O1xyXG5jbGFzc0xpc3RQcm90by50b2dnbGUgPSBmdW5jdGlvbiAodG9rZW4sIGZvcmNlKSB7XHJcbiAgdG9rZW4gKz0gXCJcIjtcclxuXHJcbiAgdmFyXHJcbiAgICAgIHJlc3VsdCA9IHRoaXMuY29udGFpbnModG9rZW4pXHJcbiAgICAsIG1ldGhvZCA9IHJlc3VsdCA/XHJcbiAgICAgIGZvcmNlICE9PSB0cnVlICYmIFwicmVtb3ZlXCJcclxuICAgIDpcclxuICAgICAgZm9yY2UgIT09IGZhbHNlICYmIFwiYWRkXCJcclxuICA7XHJcblxyXG4gIGlmIChtZXRob2QpIHtcclxuICAgIHRoaXNbbWV0aG9kXSh0b2tlbik7XHJcbiAgfVxyXG5cclxuICBpZiAoZm9yY2UgPT09IHRydWUgfHwgZm9yY2UgPT09IGZhbHNlKSB7XHJcbiAgICByZXR1cm4gZm9yY2U7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiAhcmVzdWx0O1xyXG4gIH1cclxufTtcclxuY2xhc3NMaXN0UHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIHRoaXMuam9pbihcIiBcIik7XHJcbn07XHJcblxyXG5pZiAob2JqQ3RyLmRlZmluZVByb3BlcnR5KSB7XHJcbiAgdmFyIGNsYXNzTGlzdFByb3BEZXNjID0ge1xyXG4gICAgICBnZXQ6IGNsYXNzTGlzdEdldHRlclxyXG4gICAgLCBlbnVtZXJhYmxlOiB0cnVlXHJcbiAgICAsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gIH07XHJcbiAgdHJ5IHtcclxuICAgIG9iakN0ci5kZWZpbmVQcm9wZXJ0eShlbGVtQ3RyUHJvdG8sIGNsYXNzTGlzdFByb3AsIGNsYXNzTGlzdFByb3BEZXNjKTtcclxuICB9IGNhdGNoIChleCkgeyAvLyBJRSA4IGRvZXNuJ3Qgc3VwcG9ydCBlbnVtZXJhYmxlOnRydWVcclxuICAgIGlmIChleC5udW1iZXIgPT09IC0weDdGRjVFQzU0KSB7XHJcbiAgICAgIGNsYXNzTGlzdFByb3BEZXNjLmVudW1lcmFibGUgPSBmYWxzZTtcclxuICAgICAgb2JqQ3RyLmRlZmluZVByb3BlcnR5KGVsZW1DdHJQcm90bywgY2xhc3NMaXN0UHJvcCwgY2xhc3NMaXN0UHJvcERlc2MpO1xyXG4gICAgfVxyXG4gIH1cclxufSBlbHNlIGlmIChvYmpDdHJbcHJvdG9Qcm9wXS5fX2RlZmluZUdldHRlcl9fKSB7XHJcbiAgZWxlbUN0clByb3RvLl9fZGVmaW5lR2V0dGVyX18oY2xhc3NMaXN0UHJvcCwgY2xhc3NMaXN0R2V0dGVyKTtcclxufVxyXG5cclxufShzZWxmKSk7XHJcblxyXG59IGVsc2Uge1xyXG4vLyBUaGVyZSBpcyBmdWxsIG9yIHBhcnRpYWwgbmF0aXZlIGNsYXNzTGlzdCBzdXBwb3J0LCBzbyBqdXN0IGNoZWNrIGlmIHdlIG5lZWRcclxuLy8gdG8gbm9ybWFsaXplIHRoZSBhZGQvcmVtb3ZlIGFuZCB0b2dnbGUgQVBJcy5cclxuXHJcbihmdW5jdGlvbiAoKSB7XHJcbiAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gIHZhciB0ZXN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJfXCIpO1xyXG5cclxuICB0ZXN0RWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiYzFcIiwgXCJjMlwiKTtcclxuXHJcbiAgLy8gUG9seWZpbGwgZm9yIElFIDEwLzExIGFuZCBGaXJlZm94IDwyNiwgd2hlcmUgY2xhc3NMaXN0LmFkZCBhbmRcclxuICAvLyBjbGFzc0xpc3QucmVtb3ZlIGV4aXN0IGJ1dCBzdXBwb3J0IG9ubHkgb25lIGFyZ3VtZW50IGF0IGEgdGltZS5cclxuICBpZiAoIXRlc3RFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhcImMyXCIpKSB7XHJcbiAgICB2YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24obWV0aG9kKSB7XHJcbiAgICAgIHZhciBvcmlnaW5hbCA9IERPTVRva2VuTGlzdC5wcm90b3R5cGVbbWV0aG9kXTtcclxuXHJcbiAgICAgIERPTVRva2VuTGlzdC5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHRva2VuKSB7XHJcbiAgICAgICAgdmFyIGksIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgdG9rZW4gPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICBvcmlnaW5hbC5jYWxsKHRoaXMsIHRva2VuKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgY3JlYXRlTWV0aG9kKCdhZGQnKTtcclxuICAgIGNyZWF0ZU1ldGhvZCgncmVtb3ZlJyk7XHJcbiAgfVxyXG5cclxuICB0ZXN0RWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKFwiYzNcIiwgZmFsc2UpO1xyXG5cclxuICAvLyBQb2x5ZmlsbCBmb3IgSUUgMTAgYW5kIEZpcmVmb3ggPDI0LCB3aGVyZSBjbGFzc0xpc3QudG9nZ2xlIGRvZXMgbm90XHJcbiAgLy8gc3VwcG9ydCB0aGUgc2Vjb25kIGFyZ3VtZW50LlxyXG4gIGlmICh0ZXN0RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJjM1wiKSkge1xyXG4gICAgdmFyIF90b2dnbGUgPSBET01Ub2tlbkxpc3QucHJvdG90eXBlLnRvZ2dsZTtcclxuXHJcbiAgICBET01Ub2tlbkxpc3QucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uKHRva2VuLCBmb3JjZSkge1xyXG4gICAgICBpZiAoMSBpbiBhcmd1bWVudHMgJiYgIXRoaXMuY29udGFpbnModG9rZW4pID09PSAhZm9yY2UpIHtcclxuICAgICAgICByZXR1cm4gZm9yY2U7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIF90b2dnbGUuY2FsbCh0aGlzLCB0b2tlbik7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gIH1cclxuXHJcbiAgdGVzdEVsZW1lbnQgPSBudWxsO1xyXG59KCkpO1xyXG5cclxufVxyXG5cclxufVxyXG5cclxuIiwiLyohXG5cbkNvcHlyaWdodCAoQykgMjAxNC0yMDE2IGJ5IEFuZHJlYSBHaWFtbWFyY2hpIC0gQFdlYlJlZmxlY3Rpb25cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLlxuXG4qL1xuKGZ1bmN0aW9uKHdpbmRvdywgZG9jdW1lbnQsIE9iamVjdCwgUkVHSVNURVJfRUxFTUVOVCl7J3VzZSBzdHJpY3QnO1xudmFyIGh0bWxDbGFzcyA9IChmdW5jdGlvbiAoaW5mbykge1xuICAvLyAoQykgQW5kcmVhIEdpYW1tYXJjaGkgLSBAV2ViUmVmbGVjdGlvbiAtIE1JVCBTdHlsZVxuICB2YXJcbiAgICBjYXRjaENsYXNzID0gL15bQS1aXStbYS16XS8sXG4gICAgZmlsdGVyQnkgPSBmdW5jdGlvbiAocmUpIHtcbiAgICAgIHZhciBhcnIgPSBbXSwgdGFnO1xuICAgICAgZm9yICh0YWcgaW4gcmVnaXN0ZXIpIHtcbiAgICAgICAgaWYgKHJlLnRlc3QodGFnKSkgYXJyLnB1c2godGFnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICBhZGQgPSBmdW5jdGlvbiAoQ2xhc3MsIHRhZykge1xuICAgICAgdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAoISh0YWcgaW4gcmVnaXN0ZXIpKSB7XG4gICAgICAgIHJlZ2lzdGVyW0NsYXNzXSA9IChyZWdpc3RlcltDbGFzc10gfHwgW10pLmNvbmNhdCh0YWcpO1xuICAgICAgICByZWdpc3Rlclt0YWddID0gKHJlZ2lzdGVyW3RhZy50b1VwcGVyQ2FzZSgpXSA9IENsYXNzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlZ2lzdGVyID0gKE9iamVjdC5jcmVhdGUgfHwgT2JqZWN0KShudWxsKSxcbiAgICBodG1sQ2xhc3MgPSB7fSxcbiAgICBpLCBzZWN0aW9uLCB0YWdzLCBDbGFzc1xuICA7XG4gIGZvciAoc2VjdGlvbiBpbiBpbmZvKSB7XG4gICAgZm9yIChDbGFzcyBpbiBpbmZvW3NlY3Rpb25dKSB7XG4gICAgICB0YWdzID0gaW5mb1tzZWN0aW9uXVtDbGFzc107XG4gICAgICByZWdpc3RlcltDbGFzc10gPSB0YWdzO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHRhZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVnaXN0ZXJbdGFnc1tpXS50b0xvd2VyQ2FzZSgpXSA9XG4gICAgICAgIHJlZ2lzdGVyW3RhZ3NbaV0udG9VcHBlckNhc2UoKV0gPSBDbGFzcztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaHRtbENsYXNzLmdldCA9IGZ1bmN0aW9uIGdldCh0YWdPckNsYXNzKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0YWdPckNsYXNzID09PSAnc3RyaW5nJyA/XG4gICAgICAocmVnaXN0ZXJbdGFnT3JDbGFzc10gfHwgKGNhdGNoQ2xhc3MudGVzdCh0YWdPckNsYXNzKSA/IFtdIDogJycpKSA6XG4gICAgICBmaWx0ZXJCeSh0YWdPckNsYXNzKTtcbiAgfTtcbiAgaHRtbENsYXNzLnNldCA9IGZ1bmN0aW9uIHNldCh0YWcsIENsYXNzKSB7XG4gICAgcmV0dXJuIChjYXRjaENsYXNzLnRlc3QodGFnKSA/XG4gICAgICBhZGQodGFnLCBDbGFzcykgOlxuICAgICAgYWRkKENsYXNzLCB0YWcpXG4gICAgKSwgaHRtbENsYXNzO1xuICB9O1xuICByZXR1cm4gaHRtbENsYXNzO1xufSh7XG4gIFwiY29sbGVjdGlvbnNcIjoge1xuICAgIFwiSFRNTEFsbENvbGxlY3Rpb25cIjogW1xuICAgICAgXCJhbGxcIlxuICAgIF0sXG4gICAgXCJIVE1MQ29sbGVjdGlvblwiOiBbXG4gICAgICBcImZvcm1zXCJcbiAgICBdLFxuICAgIFwiSFRNTEZvcm1Db250cm9sc0NvbGxlY3Rpb25cIjogW1xuICAgICAgXCJlbGVtZW50c1wiXG4gICAgXSxcbiAgICBcIkhUTUxPcHRpb25zQ29sbGVjdGlvblwiOiBbXG4gICAgICBcIm9wdGlvbnNcIlxuICAgIF1cbiAgfSxcbiAgXCJlbGVtZW50c1wiOiB7XG4gICAgXCJFbGVtZW50XCI6IFtcbiAgICAgIFwiZWxlbWVudFwiXG4gICAgXSxcbiAgICBcIkhUTUxBbmNob3JFbGVtZW50XCI6IFtcbiAgICAgIFwiYVwiXG4gICAgXSxcbiAgICBcIkhUTUxBcHBsZXRFbGVtZW50XCI6IFtcbiAgICAgIFwiYXBwbGV0XCJcbiAgICBdLFxuICAgIFwiSFRNTEFyZWFFbGVtZW50XCI6IFtcbiAgICAgIFwiYXJlYVwiXG4gICAgXSxcbiAgICBcIkhUTUxBdHRhY2htZW50RWxlbWVudFwiOiBbXG4gICAgICBcImF0dGFjaG1lbnRcIlxuICAgIF0sXG4gICAgXCJIVE1MQXVkaW9FbGVtZW50XCI6IFtcbiAgICAgIFwiYXVkaW9cIlxuICAgIF0sXG4gICAgXCJIVE1MQlJFbGVtZW50XCI6IFtcbiAgICAgIFwiYnJcIlxuICAgIF0sXG4gICAgXCJIVE1MQmFzZUVsZW1lbnRcIjogW1xuICAgICAgXCJiYXNlXCJcbiAgICBdLFxuICAgIFwiSFRNTEJvZHlFbGVtZW50XCI6IFtcbiAgICAgIFwiYm9keVwiXG4gICAgXSxcbiAgICBcIkhUTUxCdXR0b25FbGVtZW50XCI6IFtcbiAgICAgIFwiYnV0dG9uXCJcbiAgICBdLFxuICAgIFwiSFRNTENhbnZhc0VsZW1lbnRcIjogW1xuICAgICAgXCJjYW52YXNcIlxuICAgIF0sXG4gICAgXCJIVE1MQ29udGVudEVsZW1lbnRcIjogW1xuICAgICAgXCJjb250ZW50XCJcbiAgICBdLFxuICAgIFwiSFRNTERMaXN0RWxlbWVudFwiOiBbXG4gICAgICBcImRsXCJcbiAgICBdLFxuICAgIFwiSFRNTERhdGFFbGVtZW50XCI6IFtcbiAgICAgIFwiZGF0YVwiXG4gICAgXSxcbiAgICBcIkhUTUxEYXRhTGlzdEVsZW1lbnRcIjogW1xuICAgICAgXCJkYXRhbGlzdFwiXG4gICAgXSxcbiAgICBcIkhUTUxEZXRhaWxzRWxlbWVudFwiOiBbXG4gICAgICBcImRldGFpbHNcIlxuICAgIF0sXG4gICAgXCJIVE1MRGlhbG9nRWxlbWVudFwiOiBbXG4gICAgICBcImRpYWxvZ1wiXG4gICAgXSxcbiAgICBcIkhUTUxEaXJlY3RvcnlFbGVtZW50XCI6IFtcbiAgICAgIFwiZGlyXCJcbiAgICBdLFxuICAgIFwiSFRNTERpdkVsZW1lbnRcIjogW1xuICAgICAgXCJkaXZcIlxuICAgIF0sXG4gICAgXCJIVE1MRG9jdW1lbnRcIjogW1xuICAgICAgXCJkb2N1bWVudFwiXG4gICAgXSxcbiAgICBcIkhUTUxFbGVtZW50XCI6IFtcbiAgICAgIFwiZWxlbWVudFwiLFxuICAgICAgXCJhYmJyXCIsXG4gICAgICBcImFkZHJlc3NcIixcbiAgICAgIFwiYXJ0aWNsZVwiLFxuICAgICAgXCJhc2lkZVwiLFxuICAgICAgXCJiXCIsXG4gICAgICBcImJkaVwiLFxuICAgICAgXCJiZG9cIixcbiAgICAgIFwiY2l0ZVwiLFxuICAgICAgXCJjb2RlXCIsXG4gICAgICBcImNvbW1hbmRcIixcbiAgICAgIFwiZGRcIixcbiAgICAgIFwiZGZuXCIsXG4gICAgICBcImR0XCIsXG4gICAgICBcImVtXCIsXG4gICAgICBcImZpZ2NhcHRpb25cIixcbiAgICAgIFwiZmlndXJlXCIsXG4gICAgICBcImZvb3RlclwiLFxuICAgICAgXCJoZWFkZXJcIixcbiAgICAgIFwiaVwiLFxuICAgICAgXCJrYmRcIixcbiAgICAgIFwibWFya1wiLFxuICAgICAgXCJuYXZcIixcbiAgICAgIFwibm9zY3JpcHRcIixcbiAgICAgIFwicnBcIixcbiAgICAgIFwicnRcIixcbiAgICAgIFwicnVieVwiLFxuICAgICAgXCJzXCIsXG4gICAgICBcInNhbXBcIixcbiAgICAgIFwic2VjdGlvblwiLFxuICAgICAgXCJzbWFsbFwiLFxuICAgICAgXCJzdHJvbmdcIixcbiAgICAgIFwic3ViXCIsXG4gICAgICBcInN1bW1hcnlcIixcbiAgICAgIFwic3VwXCIsXG4gICAgICBcInVcIixcbiAgICAgIFwidmFyXCIsXG4gICAgICBcIndiclwiXG4gICAgXSxcbiAgICBcIkhUTUxFbWJlZEVsZW1lbnRcIjogW1xuICAgICAgXCJlbWJlZFwiXG4gICAgXSxcbiAgICBcIkhUTUxGaWVsZFNldEVsZW1lbnRcIjogW1xuICAgICAgXCJmaWVsZHNldFwiXG4gICAgXSxcbiAgICBcIkhUTUxGb250RWxlbWVudFwiOiBbXG4gICAgICBcImZvbnRcIlxuICAgIF0sXG4gICAgXCJIVE1MRm9ybUVsZW1lbnRcIjogW1xuICAgICAgXCJmb3JtXCJcbiAgICBdLFxuICAgIFwiSFRNTEZyYW1lRWxlbWVudFwiOiBbXG4gICAgICBcImZyYW1lXCJcbiAgICBdLFxuICAgIFwiSFRNTEZyYW1lU2V0RWxlbWVudFwiOiBbXG4gICAgICBcImZyYW1lc2V0XCJcbiAgICBdLFxuICAgIFwiSFRNTEhSRWxlbWVudFwiOiBbXG4gICAgICBcImhyXCJcbiAgICBdLFxuICAgIFwiSFRNTEhlYWRFbGVtZW50XCI6IFtcbiAgICAgIFwiaGVhZFwiXG4gICAgXSxcbiAgICBcIkhUTUxIZWFkaW5nRWxlbWVudFwiOiBbXG4gICAgICBcImgxXCIsXG4gICAgICBcImgyXCIsXG4gICAgICBcImgzXCIsXG4gICAgICBcImg0XCIsXG4gICAgICBcImg1XCIsXG4gICAgICBcImg2XCJcbiAgICBdLFxuICAgIFwiSFRNTEh0bWxFbGVtZW50XCI6IFtcbiAgICAgIFwiaHRtbFwiXG4gICAgXSxcbiAgICBcIkhUTUxJRnJhbWVFbGVtZW50XCI6IFtcbiAgICAgIFwiaWZyYW1lXCJcbiAgICBdLFxuICAgIFwiSFRNTEltYWdlRWxlbWVudFwiOiBbXG4gICAgICBcImltZ1wiXG4gICAgXSxcbiAgICBcIkhUTUxJbnB1dEVsZW1lbnRcIjogW1xuICAgICAgXCJpbnB1dFwiXG4gICAgXSxcbiAgICBcIkhUTUxLZXlnZW5FbGVtZW50XCI6IFtcbiAgICAgIFwia2V5Z2VuXCJcbiAgICBdLFxuICAgIFwiSFRNTExJRWxlbWVudFwiOiBbXG4gICAgICBcImxpXCJcbiAgICBdLFxuICAgIFwiSFRNTExhYmVsRWxlbWVudFwiOiBbXG4gICAgICBcImxhYmVsXCJcbiAgICBdLFxuICAgIFwiSFRNTExlZ2VuZEVsZW1lbnRcIjogW1xuICAgICAgXCJsZWdlbmRcIlxuICAgIF0sXG4gICAgXCJIVE1MTGlua0VsZW1lbnRcIjogW1xuICAgICAgXCJsaW5rXCJcbiAgICBdLFxuICAgIFwiSFRNTE1hcEVsZW1lbnRcIjogW1xuICAgICAgXCJtYXBcIlxuICAgIF0sXG4gICAgXCJIVE1MTWFycXVlZUVsZW1lbnRcIjogW1xuICAgICAgXCJtYXJxdWVlXCJcbiAgICBdLFxuICAgIFwiSFRNTE1lZGlhRWxlbWVudFwiOiBbXG4gICAgICBcIm1lZGlhXCJcbiAgICBdLFxuICAgIFwiSFRNTE1lbnVFbGVtZW50XCI6IFtcbiAgICAgIFwibWVudVwiXG4gICAgXSxcbiAgICBcIkhUTUxNZW51SXRlbUVsZW1lbnRcIjogW1xuICAgICAgXCJtZW51aXRlbVwiXG4gICAgXSxcbiAgICBcIkhUTUxNZXRhRWxlbWVudFwiOiBbXG4gICAgICBcIm1ldGFcIlxuICAgIF0sXG4gICAgXCJIVE1MTWV0ZXJFbGVtZW50XCI6IFtcbiAgICAgIFwibWV0ZXJcIlxuICAgIF0sXG4gICAgXCJIVE1MTW9kRWxlbWVudFwiOiBbXG4gICAgICBcImRlbFwiLFxuICAgICAgXCJpbnNcIlxuICAgIF0sXG4gICAgXCJIVE1MT0xpc3RFbGVtZW50XCI6IFtcbiAgICAgIFwib2xcIlxuICAgIF0sXG4gICAgXCJIVE1MT2JqZWN0RWxlbWVudFwiOiBbXG4gICAgICBcIm9iamVjdFwiXG4gICAgXSxcbiAgICBcIkhUTUxPcHRHcm91cEVsZW1lbnRcIjogW1xuICAgICAgXCJvcHRncm91cFwiXG4gICAgXSxcbiAgICBcIkhUTUxPcHRpb25FbGVtZW50XCI6IFtcbiAgICAgIFwib3B0aW9uXCJcbiAgICBdLFxuICAgIFwiSFRNTE91dHB1dEVsZW1lbnRcIjogW1xuICAgICAgXCJvdXRwdXRcIlxuICAgIF0sXG4gICAgXCJIVE1MUGFyYWdyYXBoRWxlbWVudFwiOiBbXG4gICAgICBcInBcIlxuICAgIF0sXG4gICAgXCJIVE1MUGFyYW1FbGVtZW50XCI6IFtcbiAgICAgIFwicGFyYW1cIlxuICAgIF0sXG4gICAgXCJIVE1MUGljdHVyZUVsZW1lbnRcIjogW1xuICAgICAgXCJwaWN0dXJlXCJcbiAgICBdLFxuICAgIFwiSFRNTFByZUVsZW1lbnRcIjogW1xuICAgICAgXCJwcmVcIlxuICAgIF0sXG4gICAgXCJIVE1MUHJvZ3Jlc3NFbGVtZW50XCI6IFtcbiAgICAgIFwicHJvZ3Jlc3NcIlxuICAgIF0sXG4gICAgXCJIVE1MUXVvdGVFbGVtZW50XCI6IFtcbiAgICAgIFwiYmxvY2txdW90ZVwiLFxuICAgICAgXCJxXCIsXG4gICAgICBcInF1b3RlXCJcbiAgICBdLFxuICAgIFwiSFRNTFNjcmlwdEVsZW1lbnRcIjogW1xuICAgICAgXCJzY3JpcHRcIlxuICAgIF0sXG4gICAgXCJIVE1MU2VsZWN0RWxlbWVudFwiOiBbXG4gICAgICBcInNlbGVjdFwiXG4gICAgXSxcbiAgICBcIkhUTUxTaGFkb3dFbGVtZW50XCI6IFtcbiAgICAgIFwic2hhZG93XCJcbiAgICBdLFxuICAgIFwiSFRNTFNsb3RFbGVtZW50XCI6IFtcbiAgICAgIFwic2xvdFwiXG4gICAgXSxcbiAgICBcIkhUTUxTb3VyY2VFbGVtZW50XCI6IFtcbiAgICAgIFwic291cmNlXCJcbiAgICBdLFxuICAgIFwiSFRNTFNwYW5FbGVtZW50XCI6IFtcbiAgICAgIFwic3BhblwiXG4gICAgXSxcbiAgICBcIkhUTUxTdHlsZUVsZW1lbnRcIjogW1xuICAgICAgXCJzdHlsZVwiXG4gICAgXSxcbiAgICBcIkhUTUxUYWJsZUNhcHRpb25FbGVtZW50XCI6IFtcbiAgICAgIFwiY2FwdGlvblwiXG4gICAgXSxcbiAgICBcIkhUTUxUYWJsZUNlbGxFbGVtZW50XCI6IFtcbiAgICAgIFwidGRcIixcbiAgICAgIFwidGhcIlxuICAgIF0sXG4gICAgXCJIVE1MVGFibGVDb2xFbGVtZW50XCI6IFtcbiAgICAgIFwiY29sXCIsXG4gICAgICBcImNvbGdyb3VwXCJcbiAgICBdLFxuICAgIFwiSFRNTFRhYmxlRWxlbWVudFwiOiBbXG4gICAgICBcInRhYmxlXCJcbiAgICBdLFxuICAgIFwiSFRNTFRhYmxlUm93RWxlbWVudFwiOiBbXG4gICAgICBcInRyXCJcbiAgICBdLFxuICAgIFwiSFRNTFRhYmxlU2VjdGlvbkVsZW1lbnRcIjogW1xuICAgICAgXCJ0aGVhZFwiLFxuICAgICAgXCJ0Ym9keVwiLFxuICAgICAgXCJ0Zm9vdFwiXG4gICAgXSxcbiAgICBcIkhUTUxUZW1wbGF0ZUVsZW1lbnRcIjogW1xuICAgICAgXCJ0ZW1wbGF0ZVwiXG4gICAgXSxcbiAgICBcIkhUTUxUZXh0QXJlYUVsZW1lbnRcIjogW1xuICAgICAgXCJ0ZXh0YXJlYVwiXG4gICAgXSxcbiAgICBcIkhUTUxUaW1lRWxlbWVudFwiOiBbXG4gICAgICBcInRpbWVcIlxuICAgIF0sXG4gICAgXCJIVE1MVGl0bGVFbGVtZW50XCI6IFtcbiAgICAgIFwidGl0bGVcIlxuICAgIF0sXG4gICAgXCJIVE1MVHJhY2tFbGVtZW50XCI6IFtcbiAgICAgIFwidHJhY2tcIlxuICAgIF0sXG4gICAgXCJIVE1MVUxpc3RFbGVtZW50XCI6IFtcbiAgICAgIFwidWxcIlxuICAgIF0sXG4gICAgXCJIVE1MVW5rbm93bkVsZW1lbnRcIjogW1xuICAgICAgXCJ1bmtub3duXCIsXG4gICAgICBcInZoZ3JvdXB2XCIsXG4gICAgICBcInZrZXlnZW5cIlxuICAgIF0sXG4gICAgXCJIVE1MVmlkZW9FbGVtZW50XCI6IFtcbiAgICAgIFwidmlkZW9cIlxuICAgIF1cbiAgfSxcbiAgXCJub2Rlc1wiOiB7XG4gICAgXCJBdHRyXCI6IFtcbiAgICAgIFwibm9kZVwiXG4gICAgXSxcbiAgICBcIkF1ZGlvXCI6IFtcbiAgICAgIFwiYXVkaW9cIlxuICAgIF0sXG4gICAgXCJDREFUQVNlY3Rpb25cIjogW1xuICAgICAgXCJub2RlXCJcbiAgICBdLFxuICAgIFwiQ2hhcmFjdGVyRGF0YVwiOiBbXG4gICAgICBcIm5vZGVcIlxuICAgIF0sXG4gICAgXCJDb21tZW50XCI6IFtcbiAgICAgIFwiI2NvbW1lbnRcIlxuICAgIF0sXG4gICAgXCJEb2N1bWVudFwiOiBbXG4gICAgICBcIiNkb2N1bWVudFwiXG4gICAgXSxcbiAgICBcIkRvY3VtZW50RnJhZ21lbnRcIjogW1xuICAgICAgXCIjZG9jdW1lbnQtZnJhZ21lbnRcIlxuICAgIF0sXG4gICAgXCJEb2N1bWVudFR5cGVcIjogW1xuICAgICAgXCJub2RlXCJcbiAgICBdLFxuICAgIFwiSFRNTERvY3VtZW50XCI6IFtcbiAgICAgIFwiI2RvY3VtZW50XCJcbiAgICBdLFxuICAgIFwiSW1hZ2VcIjogW1xuICAgICAgXCJpbWdcIlxuICAgIF0sXG4gICAgXCJPcHRpb25cIjogW1xuICAgICAgXCJvcHRpb25cIlxuICAgIF0sXG4gICAgXCJQcm9jZXNzaW5nSW5zdHJ1Y3Rpb25cIjogW1xuICAgICAgXCJub2RlXCJcbiAgICBdLFxuICAgIFwiU2hhZG93Um9vdFwiOiBbXG4gICAgICBcIiNzaGFkb3ctcm9vdFwiXG4gICAgXSxcbiAgICBcIlRleHRcIjogW1xuICAgICAgXCIjdGV4dFwiXG4gICAgXSxcbiAgICBcIlhNTERvY3VtZW50XCI6IFtcbiAgICAgIFwieG1sXCJcbiAgICBdXG4gIH1cbn0pKTtcblxuXG5cbi8vIERPIE5PVCBVU0UgVEhJUyBGSUxFIERJUkVDVExZLCBJVCBXT04nVCBXT1JLXG4vLyBUSElTIElTIEEgUFJPSkVDVCBCQVNFRCBPTiBBIEJVSUxEIFNZU1RFTVxuLy8gVEhJUyBGSUxFIElTIEpVU1QgV1JBUFBFRCBVUCBSRVNVTFRJTkcgSU5cbi8vIGJ1aWxkL2RvY3VtZW50LXJlZ2lzdGVyLWVsZW1lbnQuanNcbi8vIGFuZCBpdHMgLm1heC5qcyBjb3VudGVyIHBhcnRcblxudmFyXG4gIC8vIElFIDwgMTEgb25seSArIG9sZCBXZWJLaXQgZm9yIGF0dHJpYnV0ZXMgKyBmZWF0dXJlIGRldGVjdGlvblxuICBFWFBBTkRPX1VJRCA9ICdfXycgKyBSRUdJU1RFUl9FTEVNRU5UICsgKE1hdGgucmFuZG9tKCkgKiAxMGU0ID4+IDApLFxuXG4gIC8vIHNob3J0Y3V0cyBhbmQgY29zdGFudHNcbiAgQUREX0VWRU5UX0xJU1RFTkVSID0gJ2FkZEV2ZW50TGlzdGVuZXInLFxuICBBVFRBQ0hFRCA9ICdhdHRhY2hlZCcsXG4gIENBTExCQUNLID0gJ0NhbGxiYWNrJyxcbiAgREVUQUNIRUQgPSAnZGV0YWNoZWQnLFxuICBFWFRFTkRTID0gJ2V4dGVuZHMnLFxuXG4gIEFUVFJJQlVURV9DSEFOR0VEX0NBTExCQUNLID0gJ2F0dHJpYnV0ZUNoYW5nZWQnICsgQ0FMTEJBQ0ssXG4gIEFUVEFDSEVEX0NBTExCQUNLID0gQVRUQUNIRUQgKyBDQUxMQkFDSyxcbiAgQ09OTkVDVEVEX0NBTExCQUNLID0gJ2Nvbm5lY3RlZCcgKyBDQUxMQkFDSyxcbiAgRElTQ09OTkVDVEVEX0NBTExCQUNLID0gJ2Rpc2Nvbm5lY3RlZCcgKyBDQUxMQkFDSyxcbiAgQ1JFQVRFRF9DQUxMQkFDSyA9ICdjcmVhdGVkJyArIENBTExCQUNLLFxuICBERVRBQ0hFRF9DQUxMQkFDSyA9IERFVEFDSEVEICsgQ0FMTEJBQ0ssXG5cbiAgQURESVRJT04gPSAnQURESVRJT04nLFxuICBNT0RJRklDQVRJT04gPSAnTU9ESUZJQ0FUSU9OJyxcbiAgUkVNT1ZBTCA9ICdSRU1PVkFMJyxcblxuICBET01fQVRUUl9NT0RJRklFRCA9ICdET01BdHRyTW9kaWZpZWQnLFxuICBET01fQ09OVEVOVF9MT0FERUQgPSAnRE9NQ29udGVudExvYWRlZCcsXG4gIERPTV9TVUJUUkVFX01PRElGSUVEID0gJ0RPTVN1YnRyZWVNb2RpZmllZCcsXG5cbiAgUFJFRklYX1RBRyA9ICc8JyxcbiAgUFJFRklYX0lTID0gJz0nLFxuXG4gIC8vIHZhbGlkIGFuZCBpbnZhbGlkIG5vZGUgbmFtZXNcbiAgdmFsaWROYW1lID0gL15bQS1aXVtBLVowLTldKig/Oi1bQS1aMC05XSspKyQvLFxuICBpbnZhbGlkTmFtZXMgPSBbXG4gICAgJ0FOTk9UQVRJT04tWE1MJyxcbiAgICAnQ09MT1ItUFJPRklMRScsXG4gICAgJ0ZPTlQtRkFDRScsXG4gICAgJ0ZPTlQtRkFDRS1TUkMnLFxuICAgICdGT05ULUZBQ0UtVVJJJyxcbiAgICAnRk9OVC1GQUNFLUZPUk1BVCcsXG4gICAgJ0ZPTlQtRkFDRS1OQU1FJyxcbiAgICAnTUlTU0lORy1HTFlQSCdcbiAgXSxcblxuICAvLyByZWdpc3RlcmVkIHR5cGVzIGFuZCB0aGVpciBwcm90b3R5cGVzXG4gIHR5cGVzID0gW10sXG4gIHByb3RvcyA9IFtdLFxuXG4gIC8vIHRvIHF1ZXJ5IHN1Ym5vZGVzXG4gIHF1ZXJ5ID0gJycsXG5cbiAgLy8gaHRtbCBzaG9ydGN1dCB1c2VkIHRvIGZlYXR1cmUgZGV0ZWN0XG4gIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcblxuICAvLyBFUzUgaW5saW5lIGhlbHBlcnMgfHwgYmFzaWMgcGF0Y2hlc1xuICBpbmRleE9mID0gdHlwZXMuaW5kZXhPZiB8fCBmdW5jdGlvbiAodikge1xuICAgIGZvcih2YXIgaSA9IHRoaXMubGVuZ3RoOyBpLS0gJiYgdGhpc1tpXSAhPT0gdjspe31cbiAgICByZXR1cm4gaTtcbiAgfSxcblxuICAvLyBvdGhlciBoZWxwZXJzIC8gc2hvcnRjdXRzXG4gIE9QID0gT2JqZWN0LnByb3RvdHlwZSxcbiAgaE9QID0gT1AuaGFzT3duUHJvcGVydHksXG4gIGlQTyA9IE9QLmlzUHJvdG90eXBlT2YsXG5cbiAgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksXG4gIGVtcHR5ID0gW10sXG4gIGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICBnT1BOID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMsXG4gIGdQTyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZixcbiAgc1BPID0gT2JqZWN0LnNldFByb3RvdHlwZU9mLFxuXG4gIC8vIGpzaGludCBwcm90bzogdHJ1ZVxuICBoYXNQcm90byA9ICEhT2JqZWN0Ll9fcHJvdG9fXyxcblxuICAvLyBWMSBoZWxwZXJzXG4gIGZpeEdldENsYXNzID0gZmFsc2UsXG4gIERSRUNFVjEgPSAnX19kcmVDRXYxJyxcbiAgY3VzdG9tRWxlbWVudHMgPSB3aW5kb3cuY3VzdG9tRWxlbWVudHMsXG4gIHVzYWJsZUN1c3RvbUVsZW1lbnRzID0gISEoXG4gICAgY3VzdG9tRWxlbWVudHMgJiZcbiAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUgJiZcbiAgICBjdXN0b21FbGVtZW50cy5nZXQgJiZcbiAgICBjdXN0b21FbGVtZW50cy53aGVuRGVmaW5lZFxuICApLFxuICBEaWN0ID0gT2JqZWN0LmNyZWF0ZSB8fCBPYmplY3QsXG4gIE1hcCA9IHdpbmRvdy5NYXAgfHwgZnVuY3Rpb24gTWFwKCkge1xuICAgIHZhciBLID0gW10sIFYgPSBbXSwgaTtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gVltpbmRleE9mLmNhbGwoSywgayldO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgICAgaSA9IGluZGV4T2YuY2FsbChLLCBrKTtcbiAgICAgICAgaWYgKGkgPCAwKSBWW0sucHVzaChrKSAtIDFdID0gdjtcbiAgICAgICAgZWxzZSBWW2ldID0gdjtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBQcm9taXNlID0gd2luZG93LlByb21pc2UgfHwgZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyXG4gICAgICBub3RpZnkgPSBbXSxcbiAgICAgIGRvbmUgPSBmYWxzZSxcbiAgICAgIHAgPSB7XG4gICAgICAgICdjYXRjaCc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfSxcbiAgICAgICAgJ3RoZW4nOiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICBub3RpZnkucHVzaChjYik7XG4gICAgICAgICAgaWYgKGRvbmUpIHNldFRpbWVvdXQocmVzb2x2ZSwgMSk7XG4gICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICA7XG4gICAgZnVuY3Rpb24gcmVzb2x2ZSh2YWx1ZSkge1xuICAgICAgZG9uZSA9IHRydWU7XG4gICAgICB3aGlsZSAobm90aWZ5Lmxlbmd0aCkgbm90aWZ5LnNoaWZ0KCkodmFsdWUpO1xuICAgIH1cbiAgICBmbihyZXNvbHZlKTtcbiAgICByZXR1cm4gcDtcbiAgfSxcbiAganVzdENyZWF0ZWQgPSBmYWxzZSxcbiAgY29uc3RydWN0b3JzID0gRGljdChudWxsKSxcbiAgd2FpdGluZ0xpc3QgPSBEaWN0KG51bGwpLFxuICBub2RlTmFtZXMgPSBuZXcgTWFwKCksXG4gIHNlY29uZEFyZ3VtZW50ID0gU3RyaW5nLFxuXG4gIC8vIHVzZWQgdG8gY3JlYXRlIHVuaXF1ZSBpbnN0YW5jZXNcbiAgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBCcmlkZ2UocHJvdG8pIHtcbiAgICAvLyBzaWxseSBicm9rZW4gcG9seWZpbGwgcHJvYmFibHkgZXZlciB1c2VkIGJ1dCBzaG9ydCBlbm91Z2ggdG8gd29ya1xuICAgIHJldHVybiBwcm90byA/ICgoQnJpZGdlLnByb3RvdHlwZSA9IHByb3RvKSwgbmV3IEJyaWRnZSgpKSA6IHRoaXM7XG4gIH0sXG5cbiAgLy8gd2lsbCBzZXQgdGhlIHByb3RvdHlwZSBpZiBwb3NzaWJsZVxuICAvLyBvciBjb3B5IG92ZXIgYWxsIHByb3BlcnRpZXNcbiAgc2V0UHJvdG90eXBlID0gc1BPIHx8IChcbiAgICBoYXNQcm90byA/XG4gICAgICBmdW5jdGlvbiAobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfSA6IChcbiAgICAoZ09QTiAmJiBnT1BEKSA/XG4gICAgICAoZnVuY3Rpb24oKXtcbiAgICAgICAgZnVuY3Rpb24gc2V0UHJvcGVydGllcyhvLCBwKSB7XG4gICAgICAgICAgZm9yICh2YXJcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIG5hbWVzID0gZ09QTihwKSxcbiAgICAgICAgICAgIGkgPSAwLCBsZW5ndGggPSBuYW1lcy5sZW5ndGg7XG4gICAgICAgICAgICBpIDwgbGVuZ3RoOyBpKytcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGtleSA9IG5hbWVzW2ldO1xuICAgICAgICAgICAgaWYgKCFoT1AuY2FsbChvLCBrZXkpKSB7XG4gICAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KG8sIGtleSwgZ09QRChwLCBrZXkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvLCBwKSB7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgc2V0UHJvcGVydGllcyhvLCBwKTtcbiAgICAgICAgICB9IHdoaWxlICgocCA9IGdQTyhwKSkgJiYgIWlQTy5jYWxsKHAsIG8pKTtcbiAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgfTtcbiAgICAgIH0oKSkgOlxuICAgICAgZnVuY3Rpb24gKG8sIHApIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHApIHtcbiAgICAgICAgICBvW2tleV0gPSBwW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG87XG4gICAgICB9XG4gICkpLFxuXG4gIC8vIERPTSBzaG9ydGN1dHMgYW5kIGhlbHBlcnMsIGlmIGFueVxuXG4gIE11dGF0aW9uT2JzZXJ2ZXIgPSB3aW5kb3cuTXV0YXRpb25PYnNlcnZlciB8fFxuICAgICAgICAgICAgICAgICAgICAgd2luZG93LldlYktpdE11dGF0aW9uT2JzZXJ2ZXIsXG5cbiAgSFRNTEVsZW1lbnRQcm90b3R5cGUgPSAoXG4gICAgd2luZG93LkhUTUxFbGVtZW50IHx8XG4gICAgd2luZG93LkVsZW1lbnQgfHxcbiAgICB3aW5kb3cuTm9kZVxuICApLnByb3RvdHlwZSxcblxuICBJRTggPSAhaVBPLmNhbGwoSFRNTEVsZW1lbnRQcm90b3R5cGUsIGRvY3VtZW50RWxlbWVudCksXG5cbiAgc2FmZVByb3BlcnR5ID0gSUU4ID8gZnVuY3Rpb24gKG8sIGssIGQpIHtcbiAgICBvW2tdID0gZC52YWx1ZTtcbiAgICByZXR1cm4gbztcbiAgfSA6IGRlZmluZVByb3BlcnR5LFxuXG4gIGlzVmFsaWROb2RlID0gSUU4ID9cbiAgICBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IDE7XG4gICAgfSA6XG4gICAgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiBpUE8uY2FsbChIVE1MRWxlbWVudFByb3RvdHlwZSwgbm9kZSk7XG4gICAgfSxcblxuICB0YXJnZXRzID0gSUU4ICYmIFtdLFxuXG4gIGNsb25lTm9kZSA9IEhUTUxFbGVtZW50UHJvdG90eXBlLmNsb25lTm9kZSxcbiAgZGlzcGF0Y2hFdmVudCA9IEhUTUxFbGVtZW50UHJvdG90eXBlLmRpc3BhdGNoRXZlbnQsXG4gIGdldEF0dHJpYnV0ZSA9IEhUTUxFbGVtZW50UHJvdG90eXBlLmdldEF0dHJpYnV0ZSxcbiAgaGFzQXR0cmlidXRlID0gSFRNTEVsZW1lbnRQcm90b3R5cGUuaGFzQXR0cmlidXRlLFxuICByZW1vdmVBdHRyaWJ1dGUgPSBIVE1MRWxlbWVudFByb3RvdHlwZS5yZW1vdmVBdHRyaWJ1dGUsXG4gIHNldEF0dHJpYnV0ZSA9IEhUTUxFbGVtZW50UHJvdG90eXBlLnNldEF0dHJpYnV0ZSxcblxuICAvLyByZXBsYWNlZCBsYXRlciBvblxuICBjcmVhdGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCxcbiAgcGF0Y2hlZENyZWF0ZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50LFxuXG4gIC8vIHNoYXJlZCBvYnNlcnZlciBmb3IgYWxsIGF0dHJpYnV0ZXNcbiAgYXR0cmlidXRlc09ic2VydmVyID0gTXV0YXRpb25PYnNlcnZlciAmJiB7XG4gICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICAgIGF0dHJpYnV0ZU9sZFZhbHVlOiB0cnVlXG4gIH0sXG5cbiAgLy8gdXNlZnVsIHRvIGRldGVjdCBvbmx5IGlmIHRoZXJlJ3Mgbm8gTXV0YXRpb25PYnNlcnZlclxuICBET01BdHRyTW9kaWZpZWQgPSBNdXRhdGlvbk9ic2VydmVyIHx8IGZ1bmN0aW9uKGUpIHtcbiAgICBkb2VzTm90U3VwcG9ydERPTUF0dHJNb2RpZmllZCA9IGZhbHNlO1xuICAgIGRvY3VtZW50RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgRE9NX0FUVFJfTU9ESUZJRUQsXG4gICAgICBET01BdHRyTW9kaWZpZWRcbiAgICApO1xuICB9LFxuXG4gIC8vIHdpbGwgYm90aCBiZSB1c2VkIHRvIG1ha2UgRE9NTm9kZUluc2VydGVkIGFzeW5jaHJvbm91c1xuICBhc2FwUXVldWUsXG4gIGFzYXBUaW1lciA9IDAsXG5cbiAgLy8gaW50ZXJuYWwgZmxhZ3NcbiAgc2V0TGlzdGVuZXIgPSBmYWxzZSxcbiAgZG9lc05vdFN1cHBvcnRET01BdHRyTW9kaWZpZWQgPSB0cnVlLFxuICBkcm9wRG9tQ29udGVudExvYWRlZCA9IHRydWUsXG5cbiAgLy8gbmVlZGVkIGZvciB0aGUgaW5uZXJIVE1MIGhlbHBlclxuICBub3RGcm9tSW5uZXJIVE1MSGVscGVyID0gdHJ1ZSxcblxuICAvLyBvcHRpb25hbGx5IGRlZmluZWQgbGF0ZXIgb25cbiAgb25TdWJ0cmVlTW9kaWZpZWQsXG4gIGNhbGxET01BdHRyTW9kaWZpZWQsXG4gIGdldEF0dHJpYnV0ZXNNaXJyb3IsXG4gIG9ic2VydmVyLFxuXG4gIC8vIGJhc2VkIG9uIHNldHRpbmcgcHJvdG90eXBlIGNhcGFiaWxpdHlcbiAgLy8gd2lsbCBjaGVjayBwcm90byBvciB0aGUgZXhwYW5kbyBhdHRyaWJ1dGVcbiAgLy8gaW4gb3JkZXIgdG8gc2V0dXAgdGhlIG5vZGUgb25jZVxuICBwYXRjaElmTm90QWxyZWFkeSxcbiAgcGF0Y2hcbjtcblxuLy8gb25seSBpZiBuZWVkZWRcbmlmICghKFJFR0lTVEVSX0VMRU1FTlQgaW4gZG9jdW1lbnQpKSB7XG5cbiAgaWYgKHNQTyB8fCBoYXNQcm90bykge1xuICAgICAgcGF0Y2hJZk5vdEFscmVhZHkgPSBmdW5jdGlvbiAobm9kZSwgcHJvdG8pIHtcbiAgICAgICAgaWYgKCFpUE8uY2FsbChwcm90bywgbm9kZSkpIHtcbiAgICAgICAgICBzZXR1cE5vZGUobm9kZSwgcHJvdG8pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcGF0Y2ggPSBzZXR1cE5vZGU7XG4gIH0gZWxzZSB7XG4gICAgICBwYXRjaElmTm90QWxyZWFkeSA9IGZ1bmN0aW9uIChub2RlLCBwcm90bykge1xuICAgICAgICBpZiAoIW5vZGVbRVhQQU5ET19VSURdKSB7XG4gICAgICAgICAgbm9kZVtFWFBBTkRPX1VJRF0gPSBPYmplY3QodHJ1ZSk7XG4gICAgICAgICAgc2V0dXBOb2RlKG5vZGUsIHByb3RvKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHBhdGNoID0gcGF0Y2hJZk5vdEFscmVhZHk7XG4gIH1cblxuICBpZiAoSUU4KSB7XG4gICAgZG9lc05vdFN1cHBvcnRET01BdHRyTW9kaWZpZWQgPSBmYWxzZTtcbiAgICAoZnVuY3Rpb24gKCl7XG4gICAgICB2YXJcbiAgICAgICAgZGVzY3JpcHRvciA9IGdPUEQoSFRNTEVsZW1lbnRQcm90b3R5cGUsIEFERF9FVkVOVF9MSVNURU5FUiksXG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIgPSBkZXNjcmlwdG9yLnZhbHVlLFxuICAgICAgICBwYXRjaGVkUmVtb3ZlQXR0cmlidXRlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICB2YXIgZSA9IG5ldyBDdXN0b21FdmVudChET01fQVRUUl9NT0RJRklFRCwge2J1YmJsZXM6IHRydWV9KTtcbiAgICAgICAgICBlLmF0dHJOYW1lID0gbmFtZTtcbiAgICAgICAgICBlLnByZXZWYWx1ZSA9IGdldEF0dHJpYnV0ZS5jYWxsKHRoaXMsIG5hbWUpO1xuICAgICAgICAgIGUubmV3VmFsdWUgPSBudWxsO1xuICAgICAgICAgIGVbUkVNT1ZBTF0gPSBlLmF0dHJDaGFuZ2UgPSAyO1xuICAgICAgICAgIHJlbW92ZUF0dHJpYnV0ZS5jYWxsKHRoaXMsIG5hbWUpO1xuICAgICAgICAgIGRpc3BhdGNoRXZlbnQuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgfSxcbiAgICAgICAgcGF0Y2hlZFNldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgIHZhclxuICAgICAgICAgICAgaGFkID0gaGFzQXR0cmlidXRlLmNhbGwodGhpcywgbmFtZSksXG4gICAgICAgICAgICBvbGQgPSBoYWQgJiYgZ2V0QXR0cmlidXRlLmNhbGwodGhpcywgbmFtZSksXG4gICAgICAgICAgICBlID0gbmV3IEN1c3RvbUV2ZW50KERPTV9BVFRSX01PRElGSUVELCB7YnViYmxlczogdHJ1ZX0pXG4gICAgICAgICAgO1xuICAgICAgICAgIHNldEF0dHJpYnV0ZS5jYWxsKHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICBlLmF0dHJOYW1lID0gbmFtZTtcbiAgICAgICAgICBlLnByZXZWYWx1ZSA9IGhhZCA/IG9sZCA6IG51bGw7XG4gICAgICAgICAgZS5uZXdWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIGlmIChoYWQpIHtcbiAgICAgICAgICAgIGVbTU9ESUZJQ0FUSU9OXSA9IGUuYXR0ckNoYW5nZSA9IDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVbQURESVRJT05dID0gZS5hdHRyQ2hhbmdlID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGlzcGF0Y2hFdmVudC5jYWxsKHRoaXMsIGUpO1xuICAgICAgICB9LFxuICAgICAgICBvblByb3BlcnR5Q2hhbmdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAvLyBqc2hpbnQgZXFudWxsOnRydWVcbiAgICAgICAgICB2YXJcbiAgICAgICAgICAgIG5vZGUgPSBlLmN1cnJlbnRUYXJnZXQsXG4gICAgICAgICAgICBzdXBlclNlY3JldCA9IG5vZGVbRVhQQU5ET19VSURdLFxuICAgICAgICAgICAgcHJvcGVydHlOYW1lID0gZS5wcm9wZXJ0eU5hbWUsXG4gICAgICAgICAgICBldmVudFxuICAgICAgICAgIDtcbiAgICAgICAgICBpZiAoc3VwZXJTZWNyZXQuaGFzT3duUHJvcGVydHkocHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgc3VwZXJTZWNyZXQgPSBzdXBlclNlY3JldFtwcm9wZXJ0eU5hbWVdO1xuICAgICAgICAgICAgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoRE9NX0FUVFJfTU9ESUZJRUQsIHtidWJibGVzOiB0cnVlfSk7XG4gICAgICAgICAgICBldmVudC5hdHRyTmFtZSA9IHN1cGVyU2VjcmV0Lm5hbWU7XG4gICAgICAgICAgICBldmVudC5wcmV2VmFsdWUgPSBzdXBlclNlY3JldC52YWx1ZSB8fCBudWxsO1xuICAgICAgICAgICAgZXZlbnQubmV3VmFsdWUgPSAoc3VwZXJTZWNyZXQudmFsdWUgPSBub2RlW3Byb3BlcnR5TmFtZV0gfHwgbnVsbCk7XG4gICAgICAgICAgICBpZiAoZXZlbnQucHJldlZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgZXZlbnRbQURESVRJT05dID0gZXZlbnQuYXR0ckNoYW5nZSA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBldmVudFtNT0RJRklDQVRJT05dID0gZXZlbnQuYXR0ckNoYW5nZSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXNwYXRjaEV2ZW50LmNhbGwobm9kZSwgZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgO1xuICAgICAgZGVzY3JpcHRvci52YWx1ZSA9IGZ1bmN0aW9uICh0eXBlLCBoYW5kbGVyLCBjYXB0dXJlKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB0eXBlID09PSBET01fQVRUUl9NT0RJRklFRCAmJlxuICAgICAgICAgIHRoaXNbQVRUUklCVVRFX0NIQU5HRURfQ0FMTEJBQ0tdICYmXG4gICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUgIT09IHBhdGNoZWRTZXRBdHRyaWJ1dGVcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhpc1tFWFBBTkRPX1VJRF0gPSB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IHtcbiAgICAgICAgICAgICAgbmFtZTogJ2NsYXNzJyxcbiAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuY2xhc3NOYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSA9IHBhdGNoZWRTZXRBdHRyaWJ1dGU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUgPSBwYXRjaGVkUmVtb3ZlQXR0cmlidXRlO1xuICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIuY2FsbCh0aGlzLCAncHJvcGVydHljaGFuZ2UnLCBvblByb3BlcnR5Q2hhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRFdmVudExpc3RlbmVyLmNhbGwodGhpcywgdHlwZSwgaGFuZGxlciwgY2FwdHVyZSk7XG4gICAgICB9O1xuICAgICAgZGVmaW5lUHJvcGVydHkoSFRNTEVsZW1lbnRQcm90b3R5cGUsIEFERF9FVkVOVF9MSVNURU5FUiwgZGVzY3JpcHRvcik7XG4gICAgfSgpKTtcbiAgfSBlbHNlIGlmICghTXV0YXRpb25PYnNlcnZlcikge1xuICAgIGRvY3VtZW50RWxlbWVudFtBRERfRVZFTlRfTElTVEVORVJdKERPTV9BVFRSX01PRElGSUVELCBET01BdHRyTW9kaWZpZWQpO1xuICAgIGRvY3VtZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoRVhQQU5ET19VSUQsIDEpO1xuICAgIGRvY3VtZW50RWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoRVhQQU5ET19VSUQpO1xuICAgIGlmIChkb2VzTm90U3VwcG9ydERPTUF0dHJNb2RpZmllZCkge1xuICAgICAgb25TdWJ0cmVlTW9kaWZpZWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXJcbiAgICAgICAgICBub2RlID0gdGhpcyxcbiAgICAgICAgICBvbGRBdHRyaWJ1dGVzLFxuICAgICAgICAgIG5ld0F0dHJpYnV0ZXMsXG4gICAgICAgICAga2V5XG4gICAgICAgIDtcbiAgICAgICAgaWYgKG5vZGUgPT09IGUudGFyZ2V0KSB7XG4gICAgICAgICAgb2xkQXR0cmlidXRlcyA9IG5vZGVbRVhQQU5ET19VSURdO1xuICAgICAgICAgIG5vZGVbRVhQQU5ET19VSURdID0gKG5ld0F0dHJpYnV0ZXMgPSBnZXRBdHRyaWJ1dGVzTWlycm9yKG5vZGUpKTtcbiAgICAgICAgICBmb3IgKGtleSBpbiBuZXdBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBpZiAoIShrZXkgaW4gb2xkQXR0cmlidXRlcykpIHtcbiAgICAgICAgICAgICAgLy8gYXR0cmlidXRlIHdhcyBhZGRlZFxuICAgICAgICAgICAgICByZXR1cm4gY2FsbERPTUF0dHJNb2RpZmllZChcbiAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIG9sZEF0dHJpYnV0ZXNba2V5XSxcbiAgICAgICAgICAgICAgICBuZXdBdHRyaWJ1dGVzW2tleV0sXG4gICAgICAgICAgICAgICAgQURESVRJT05cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmV3QXR0cmlidXRlc1trZXldICE9PSBvbGRBdHRyaWJ1dGVzW2tleV0pIHtcbiAgICAgICAgICAgICAgLy8gYXR0cmlidXRlIHdhcyBjaGFuZ2VkXG4gICAgICAgICAgICAgIHJldHVybiBjYWxsRE9NQXR0ck1vZGlmaWVkKFxuICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgb2xkQXR0cmlidXRlc1trZXldLFxuICAgICAgICAgICAgICAgIG5ld0F0dHJpYnV0ZXNba2V5XSxcbiAgICAgICAgICAgICAgICBNT0RJRklDQVRJT05cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gY2hlY2tpbmcgaWYgaXQgaGFzIGJlZW4gcmVtb3ZlZFxuICAgICAgICAgIGZvciAoa2V5IGluIG9sZEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGlmICghKGtleSBpbiBuZXdBdHRyaWJ1dGVzKSkge1xuICAgICAgICAgICAgICAvLyBhdHRyaWJ1dGUgcmVtb3ZlZFxuICAgICAgICAgICAgICByZXR1cm4gY2FsbERPTUF0dHJNb2RpZmllZChcbiAgICAgICAgICAgICAgICAyLFxuICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIG9sZEF0dHJpYnV0ZXNba2V5XSxcbiAgICAgICAgICAgICAgICBuZXdBdHRyaWJ1dGVzW2tleV0sXG4gICAgICAgICAgICAgICAgUkVNT1ZBTFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNhbGxET01BdHRyTW9kaWZpZWQgPSBmdW5jdGlvbiAoXG4gICAgICAgIGF0dHJDaGFuZ2UsXG4gICAgICAgIGN1cnJlbnRUYXJnZXQsXG4gICAgICAgIGF0dHJOYW1lLFxuICAgICAgICBwcmV2VmFsdWUsXG4gICAgICAgIG5ld1ZhbHVlLFxuICAgICAgICBhY3Rpb25cbiAgICAgICkge1xuICAgICAgICB2YXIgZSA9IHtcbiAgICAgICAgICBhdHRyQ2hhbmdlOiBhdHRyQ2hhbmdlLFxuICAgICAgICAgIGN1cnJlbnRUYXJnZXQ6IGN1cnJlbnRUYXJnZXQsXG4gICAgICAgICAgYXR0ck5hbWU6IGF0dHJOYW1lLFxuICAgICAgICAgIHByZXZWYWx1ZTogcHJldlZhbHVlLFxuICAgICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZVxuICAgICAgICB9O1xuICAgICAgICBlW2FjdGlvbl0gPSBhdHRyQ2hhbmdlO1xuICAgICAgICBvbkRPTUF0dHJNb2RpZmllZChlKTtcbiAgICAgIH07XG4gICAgICBnZXRBdHRyaWJ1dGVzTWlycm9yID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgZm9yICh2YXJcbiAgICAgICAgICBhdHRyLCBuYW1lLFxuICAgICAgICAgIHJlc3VsdCA9IHt9LFxuICAgICAgICAgIGF0dHJpYnV0ZXMgPSBub2RlLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgaSA9IDAsIGxlbmd0aCA9IGF0dHJpYnV0ZXMubGVuZ3RoO1xuICAgICAgICAgIGkgPCBsZW5ndGg7IGkrK1xuICAgICAgICApIHtcbiAgICAgICAgICBhdHRyID0gYXR0cmlidXRlc1tpXTtcbiAgICAgICAgICBuYW1lID0gYXR0ci5uYW1lO1xuICAgICAgICAgIGlmIChuYW1lICE9PSAnc2V0QXR0cmlidXRlJykge1xuICAgICAgICAgICAgcmVzdWx0W25hbWVdID0gYXR0ci52YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IGFzIGVudW1lcmFibGUsIHdyaXRhYmxlIGFuZCBjb25maWd1cmFibGVcbiAgZG9jdW1lbnRbUkVHSVNURVJfRUxFTUVOVF0gPSBmdW5jdGlvbiByZWdpc3RlckVsZW1lbnQodHlwZSwgb3B0aW9ucykge1xuICAgIHVwcGVyVHlwZSA9IHR5cGUudG9VcHBlckNhc2UoKTtcbiAgICBpZiAoIXNldExpc3RlbmVyKSB7XG4gICAgICAvLyBvbmx5IGZpcnN0IHRpbWUgZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50IGlzIHVzZWRcbiAgICAgIC8vIHdlIG5lZWQgdG8gc2V0IHRoaXMgbGlzdGVuZXJcbiAgICAgIC8vIHNldHRpbmcgaXQgYnkgZGVmYXVsdCBtaWdodCBzbG93IGRvd24gZm9yIG5vIHJlYXNvblxuICAgICAgc2V0TGlzdGVuZXIgPSB0cnVlO1xuICAgICAgaWYgKE11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgICAgb2JzZXJ2ZXIgPSAoZnVuY3Rpb24oYXR0YWNoZWQsIGRldGFjaGVkKXtcbiAgICAgICAgICBmdW5jdGlvbiBjaGVja0VtQWxsKGxpc3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbGlzdC5sZW5ndGg7IGkgPCBsZW5ndGg7IGNhbGxiYWNrKGxpc3RbaSsrXSkpe31cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uIChyZWNvcmRzKSB7XG4gICAgICAgICAgICBmb3IgKHZhclxuICAgICAgICAgICAgICBjdXJyZW50LCBub2RlLCBuZXdWYWx1ZSxcbiAgICAgICAgICAgICAgaSA9IDAsIGxlbmd0aCA9IHJlY29yZHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKytcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBjdXJyZW50ID0gcmVjb3Jkc1tpXTtcbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnQudHlwZSA9PT0gJ2NoaWxkTGlzdCcpIHtcbiAgICAgICAgICAgICAgICBjaGVja0VtQWxsKGN1cnJlbnQuYWRkZWROb2RlcywgYXR0YWNoZWQpO1xuICAgICAgICAgICAgICAgIGNoZWNrRW1BbGwoY3VycmVudC5yZW1vdmVkTm9kZXMsIGRldGFjaGVkKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlID0gY3VycmVudC50YXJnZXQ7XG4gICAgICAgICAgICAgICAgaWYgKG5vdEZyb21Jbm5lckhUTUxIZWxwZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgbm9kZVtBVFRSSUJVVEVfQ0hBTkdFRF9DQUxMQkFDS10gJiZcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5hdHRyaWJ1dGVOYW1lICE9PSAnc3R5bGUnKSB7XG4gICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IGdldEF0dHJpYnV0ZS5jYWxsKG5vZGUsIGN1cnJlbnQuYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgICAgICAgICBpZiAobmV3VmFsdWUgIT09IGN1cnJlbnQub2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZVtBVFRSSUJVVEVfQ0hBTkdFRF9DQUxMQkFDS10oXG4gICAgICAgICAgICAgICAgICAgICAgY3VycmVudC5hdHRyaWJ1dGVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQub2xkVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfShleGVjdXRlQWN0aW9uKEFUVEFDSEVEKSwgZXhlY3V0ZUFjdGlvbihERVRBQ0hFRCkpKTtcbiAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShcbiAgICAgICAgICBkb2N1bWVudCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgICAgICBzdWJ0cmVlOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXNhcFF1ZXVlID0gW107XG4gICAgICAgIGRvY3VtZW50W0FERF9FVkVOVF9MSVNURU5FUl0oJ0RPTU5vZGVJbnNlcnRlZCcsIG9uRE9NTm9kZShBVFRBQ0hFRCkpO1xuICAgICAgICBkb2N1bWVudFtBRERfRVZFTlRfTElTVEVORVJdKCdET01Ob2RlUmVtb3ZlZCcsIG9uRE9NTm9kZShERVRBQ0hFRCkpO1xuICAgICAgfVxuXG4gICAgICBkb2N1bWVudFtBRERfRVZFTlRfTElTVEVORVJdKERPTV9DT05URU5UX0xPQURFRCwgb25SZWFkeVN0YXRlQ2hhbmdlKTtcbiAgICAgIGRvY3VtZW50W0FERF9FVkVOVF9MSVNURU5FUl0oJ3JlYWR5c3RhdGVjaGFuZ2UnLCBvblJlYWR5U3RhdGVDaGFuZ2UpO1xuXG4gICAgICBIVE1MRWxlbWVudFByb3RvdHlwZS5jbG9uZU5vZGUgPSBmdW5jdGlvbiAoZGVlcCkge1xuICAgICAgICB2YXJcbiAgICAgICAgICBub2RlID0gY2xvbmVOb2RlLmNhbGwodGhpcywgISFkZWVwKSxcbiAgICAgICAgICBpID0gZ2V0VHlwZUluZGV4KG5vZGUpXG4gICAgICAgIDtcbiAgICAgICAgaWYgKC0xIDwgaSkgcGF0Y2gobm9kZSwgcHJvdG9zW2ldKTtcbiAgICAgICAgaWYgKGRlZXApIGxvb3BBbmRTZXR1cChub2RlLnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICgtMiA8IChcbiAgICAgIGluZGV4T2YuY2FsbCh0eXBlcywgUFJFRklYX0lTICsgdXBwZXJUeXBlKSArXG4gICAgICBpbmRleE9mLmNhbGwodHlwZXMsIFBSRUZJWF9UQUcgKyB1cHBlclR5cGUpXG4gICAgKSkge1xuICAgICAgdGhyb3dUeXBlRXJyb3IodHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKCF2YWxpZE5hbWUudGVzdCh1cHBlclR5cGUpIHx8IC0xIDwgaW5kZXhPZi5jYWxsKGludmFsaWROYW1lcywgdXBwZXJUeXBlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdHlwZSAnICsgdHlwZSArICcgaXMgaW52YWxpZCcpO1xuICAgIH1cblxuICAgIHZhclxuICAgICAgY29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBleHRlbmRpbmcgP1xuICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobm9kZU5hbWUsIHVwcGVyVHlwZSkgOlxuICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobm9kZU5hbWUpO1xuICAgICAgfSxcbiAgICAgIG9wdCA9IG9wdGlvbnMgfHwgT1AsXG4gICAgICBleHRlbmRpbmcgPSBoT1AuY2FsbChvcHQsIEVYVEVORFMpLFxuICAgICAgbm9kZU5hbWUgPSBleHRlbmRpbmcgPyBvcHRpb25zW0VYVEVORFNdLnRvVXBwZXJDYXNlKCkgOiB1cHBlclR5cGUsXG4gICAgICB1cHBlclR5cGUsXG4gICAgICBpXG4gICAgO1xuXG4gICAgaWYgKGV4dGVuZGluZyAmJiAtMSA8IChcbiAgICAgIGluZGV4T2YuY2FsbCh0eXBlcywgUFJFRklYX1RBRyArIG5vZGVOYW1lKVxuICAgICkpIHtcbiAgICAgIHRocm93VHlwZUVycm9yKG5vZGVOYW1lKTtcbiAgICB9XG5cbiAgICBpID0gdHlwZXMucHVzaCgoZXh0ZW5kaW5nID8gUFJFRklYX0lTIDogUFJFRklYX1RBRykgKyB1cHBlclR5cGUpIC0gMTtcblxuICAgIHF1ZXJ5ID0gcXVlcnkuY29uY2F0KFxuICAgICAgcXVlcnkubGVuZ3RoID8gJywnIDogJycsXG4gICAgICBleHRlbmRpbmcgPyBub2RlTmFtZSArICdbaXM9XCInICsgdHlwZS50b0xvd2VyQ2FzZSgpICsgJ1wiXScgOiBub2RlTmFtZVxuICAgICk7XG5cbiAgICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSAoXG4gICAgICBwcm90b3NbaV0gPSBoT1AuY2FsbChvcHQsICdwcm90b3R5cGUnKSA/XG4gICAgICAgIG9wdC5wcm90b3R5cGUgOlxuICAgICAgICBjcmVhdGUoSFRNTEVsZW1lbnRQcm90b3R5cGUpXG4gICAgKTtcblxuICAgIGxvb3BBbmRWZXJpZnkoXG4gICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5KSxcbiAgICAgIEFUVEFDSEVEXG4gICAgKTtcblxuICAgIHJldHVybiBjb25zdHJ1Y3RvcjtcbiAgfTtcblxuICBkb2N1bWVudC5jcmVhdGVFbGVtZW50ID0gKHBhdGNoZWRDcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGxvY2FsTmFtZSwgdHlwZUV4dGVuc2lvbikge1xuICAgIHZhclxuICAgICAgaXMgPSBnZXRJcyh0eXBlRXh0ZW5zaW9uKSxcbiAgICAgIG5vZGUgPSBpcyA/XG4gICAgICAgIGNyZWF0ZUVsZW1lbnQuY2FsbChkb2N1bWVudCwgbG9jYWxOYW1lLCBzZWNvbmRBcmd1bWVudChpcykpIDpcbiAgICAgICAgY3JlYXRlRWxlbWVudC5jYWxsKGRvY3VtZW50LCBsb2NhbE5hbWUpLFxuICAgICAgbmFtZSA9ICcnICsgbG9jYWxOYW1lLFxuICAgICAgaSA9IGluZGV4T2YuY2FsbChcbiAgICAgICAgdHlwZXMsXG4gICAgICAgIChpcyA/IFBSRUZJWF9JUyA6IFBSRUZJWF9UQUcpICtcbiAgICAgICAgKGlzIHx8IG5hbWUpLnRvVXBwZXJDYXNlKClcbiAgICAgICksXG4gICAgICBzZXR1cCA9IC0xIDwgaVxuICAgIDtcbiAgICBpZiAoaXMpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdpcycsIGlzID0gaXMudG9Mb3dlckNhc2UoKSk7XG4gICAgICBpZiAoc2V0dXApIHtcbiAgICAgICAgc2V0dXAgPSBpc0luUVNBKG5hbWUudG9VcHBlckNhc2UoKSwgaXMpO1xuICAgICAgfVxuICAgIH1cbiAgICBub3RGcm9tSW5uZXJIVE1MSGVscGVyID0gIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQuaW5uZXJIVE1MSGVscGVyO1xuICAgIGlmIChzZXR1cCkgcGF0Y2gobm9kZSwgcHJvdG9zW2ldKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfSk7XG5cbn1cblxuZnVuY3Rpb24gQVNBUCgpIHtcbiAgdmFyIHF1ZXVlID0gYXNhcFF1ZXVlLnNwbGljZSgwLCBhc2FwUXVldWUubGVuZ3RoKTtcbiAgYXNhcFRpbWVyID0gMDtcbiAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuICAgIHF1ZXVlLnNoaWZ0KCkuY2FsbChcbiAgICAgIG51bGwsIHF1ZXVlLnNoaWZ0KClcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxvb3BBbmRWZXJpZnkobGlzdCwgYWN0aW9uKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBsaXN0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmVyaWZ5QW5kU2V0dXBBbmRBY3Rpb24obGlzdFtpXSwgYWN0aW9uKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsb29wQW5kU2V0dXAobGlzdCkge1xuICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbGlzdC5sZW5ndGgsIG5vZGU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIG5vZGUgPSBsaXN0W2ldO1xuICAgIHBhdGNoKG5vZGUsIHByb3Rvc1tnZXRUeXBlSW5kZXgobm9kZSldKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBleGVjdXRlQWN0aW9uKGFjdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBpZiAoaXNWYWxpZE5vZGUobm9kZSkpIHtcbiAgICAgIHZlcmlmeUFuZFNldHVwQW5kQWN0aW9uKG5vZGUsIGFjdGlvbik7XG4gICAgICBsb29wQW5kVmVyaWZ5KFxuICAgICAgICBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpLFxuICAgICAgICBhY3Rpb25cbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRUeXBlSW5kZXgodGFyZ2V0KSB7XG4gIHZhclxuICAgIGlzID0gZ2V0QXR0cmlidXRlLmNhbGwodGFyZ2V0LCAnaXMnKSxcbiAgICBub2RlTmFtZSA9IHRhcmdldC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpLFxuICAgIGkgPSBpbmRleE9mLmNhbGwoXG4gICAgICB0eXBlcyxcbiAgICAgIGlzID9cbiAgICAgICAgICBQUkVGSVhfSVMgKyBpcy50b1VwcGVyQ2FzZSgpIDpcbiAgICAgICAgICBQUkVGSVhfVEFHICsgbm9kZU5hbWVcbiAgICApXG4gIDtcbiAgcmV0dXJuIGlzICYmIC0xIDwgaSAmJiAhaXNJblFTQShub2RlTmFtZSwgaXMpID8gLTEgOiBpO1xufVxuXG5mdW5jdGlvbiBpc0luUVNBKG5hbWUsIHR5cGUpIHtcbiAgcmV0dXJuIC0xIDwgcXVlcnkuaW5kZXhPZihuYW1lICsgJ1tpcz1cIicgKyB0eXBlICsgJ1wiXScpO1xufVxuXG5mdW5jdGlvbiBvbkRPTUF0dHJNb2RpZmllZChlKSB7XG4gIHZhclxuICAgIG5vZGUgPSBlLmN1cnJlbnRUYXJnZXQsXG4gICAgYXR0ckNoYW5nZSA9IGUuYXR0ckNoYW5nZSxcbiAgICBhdHRyTmFtZSA9IGUuYXR0ck5hbWUsXG4gICAgdGFyZ2V0ID0gZS50YXJnZXRcbiAgO1xuICBpZiAobm90RnJvbUlubmVySFRNTEhlbHBlciAmJlxuICAgICAgKCF0YXJnZXQgfHwgdGFyZ2V0ID09PSBub2RlKSAmJlxuICAgICAgbm9kZVtBVFRSSUJVVEVfQ0hBTkdFRF9DQUxMQkFDS10gJiZcbiAgICAgIGF0dHJOYW1lICE9PSAnc3R5bGUnICYmXG4gICAgICBlLnByZXZWYWx1ZSAhPT0gZS5uZXdWYWx1ZSkge1xuICAgIG5vZGVbQVRUUklCVVRFX0NIQU5HRURfQ0FMTEJBQ0tdKFxuICAgICAgYXR0ck5hbWUsXG4gICAgICBhdHRyQ2hhbmdlID09PSBlW0FERElUSU9OXSA/IG51bGwgOiBlLnByZXZWYWx1ZSxcbiAgICAgIGF0dHJDaGFuZ2UgPT09IGVbUkVNT1ZBTF0gPyBudWxsIDogZS5uZXdWYWx1ZVxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25ET01Ob2RlKGFjdGlvbikge1xuICB2YXIgZXhlY3V0b3IgPSBleGVjdXRlQWN0aW9uKGFjdGlvbik7XG4gIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgIGFzYXBRdWV1ZS5wdXNoKGV4ZWN1dG9yLCBlLnRhcmdldCk7XG4gICAgaWYgKGFzYXBUaW1lcikgY2xlYXJUaW1lb3V0KGFzYXBUaW1lcik7XG4gICAgYXNhcFRpbWVyID0gc2V0VGltZW91dChBU0FQLCAxKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gb25SZWFkeVN0YXRlQ2hhbmdlKGUpIHtcbiAgaWYgKGRyb3BEb21Db250ZW50TG9hZGVkKSB7XG4gICAgZHJvcERvbUNvbnRlbnRMb2FkZWQgPSBmYWxzZTtcbiAgICBlLmN1cnJlbnRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihET01fQ09OVEVOVF9MT0FERUQsIG9uUmVhZHlTdGF0ZUNoYW5nZSk7XG4gIH1cbiAgbG9vcEFuZFZlcmlmeShcbiAgICAoZS50YXJnZXQgfHwgZG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpLFxuICAgIGUuZGV0YWlsID09PSBERVRBQ0hFRCA/IERFVEFDSEVEIDogQVRUQUNIRURcbiAgKTtcbiAgaWYgKElFOCkgcHVyZ2UoKTtcbn1cblxuZnVuY3Rpb24gcGF0Y2hlZFNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkge1xuICAvLyBqc2hpbnQgdmFsaWR0aGlzOnRydWVcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZXRBdHRyaWJ1dGUuY2FsbChzZWxmLCBuYW1lLCB2YWx1ZSk7XG4gIG9uU3VidHJlZU1vZGlmaWVkLmNhbGwoc2VsZiwge3RhcmdldDogc2VsZn0pO1xufVxuXG5mdW5jdGlvbiBzZXR1cE5vZGUobm9kZSwgcHJvdG8pIHtcbiAgc2V0UHJvdG90eXBlKG5vZGUsIHByb3RvKTtcbiAgaWYgKG9ic2VydmVyKSB7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShub2RlLCBhdHRyaWJ1dGVzT2JzZXJ2ZXIpO1xuICB9IGVsc2Uge1xuICAgIGlmIChkb2VzTm90U3VwcG9ydERPTUF0dHJNb2RpZmllZCkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUgPSBwYXRjaGVkU2V0QXR0cmlidXRlO1xuICAgICAgbm9kZVtFWFBBTkRPX1VJRF0gPSBnZXRBdHRyaWJ1dGVzTWlycm9yKG5vZGUpO1xuICAgICAgbm9kZVtBRERfRVZFTlRfTElTVEVORVJdKERPTV9TVUJUUkVFX01PRElGSUVELCBvblN1YnRyZWVNb2RpZmllZCk7XG4gICAgfVxuICAgIG5vZGVbQUREX0VWRU5UX0xJU1RFTkVSXShET01fQVRUUl9NT0RJRklFRCwgb25ET01BdHRyTW9kaWZpZWQpO1xuICB9XG4gIGlmIChub2RlW0NSRUFURURfQ0FMTEJBQ0tdICYmIG5vdEZyb21Jbm5lckhUTUxIZWxwZXIpIHtcbiAgICBub2RlLmNyZWF0ZWQgPSB0cnVlO1xuICAgIG5vZGVbQ1JFQVRFRF9DQUxMQkFDS10oKTtcbiAgICBub2RlLmNyZWF0ZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdXJnZSgpIHtcbiAgZm9yICh2YXJcbiAgICBub2RlLFxuICAgIGkgPSAwLFxuICAgIGxlbmd0aCA9IHRhcmdldHMubGVuZ3RoO1xuICAgIGkgPCBsZW5ndGg7IGkrK1xuICApIHtcbiAgICBub2RlID0gdGFyZ2V0c1tpXTtcbiAgICBpZiAoIWRvY3VtZW50RWxlbWVudC5jb250YWlucyhub2RlKSkge1xuICAgICAgbGVuZ3RoLS07XG4gICAgICB0YXJnZXRzLnNwbGljZShpLS0sIDEpO1xuICAgICAgdmVyaWZ5QW5kU2V0dXBBbmRBY3Rpb24obm9kZSwgREVUQUNIRUQpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0aHJvd1R5cGVFcnJvcih0eXBlKSB7XG4gIHRocm93IG5ldyBFcnJvcignQSAnICsgdHlwZSArICcgdHlwZSBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQnKTtcbn1cblxuZnVuY3Rpb24gdmVyaWZ5QW5kU2V0dXBBbmRBY3Rpb24obm9kZSwgYWN0aW9uKSB7XG4gIHZhclxuICAgIGZuLFxuICAgIGkgPSBnZXRUeXBlSW5kZXgobm9kZSlcbiAgO1xuICBpZiAoLTEgPCBpKSB7XG4gICAgcGF0Y2hJZk5vdEFscmVhZHkobm9kZSwgcHJvdG9zW2ldKTtcbiAgICBpID0gMDtcbiAgICBpZiAoYWN0aW9uID09PSBBVFRBQ0hFRCAmJiAhbm9kZVtBVFRBQ0hFRF0pIHtcbiAgICAgIG5vZGVbREVUQUNIRURdID0gZmFsc2U7XG4gICAgICBub2RlW0FUVEFDSEVEXSA9IHRydWU7XG4gICAgICBpID0gMTtcbiAgICAgIGlmIChJRTggJiYgaW5kZXhPZi5jYWxsKHRhcmdldHMsIG5vZGUpIDwgMCkge1xuICAgICAgICB0YXJnZXRzLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhY3Rpb24gPT09IERFVEFDSEVEICYmICFub2RlW0RFVEFDSEVEXSkge1xuICAgICAgbm9kZVtBVFRBQ0hFRF0gPSBmYWxzZTtcbiAgICAgIG5vZGVbREVUQUNIRURdID0gdHJ1ZTtcbiAgICAgIGkgPSAxO1xuICAgIH1cbiAgICBpZiAoaSAmJiAoZm4gPSBub2RlW2FjdGlvbiArIENBTExCQUNLXSkpIGZuLmNhbGwobm9kZSk7XG4gIH1cbn1cblxuXG5cbi8vIFYxIGluIGRhIEhvdXNlIVxuZnVuY3Rpb24gQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5KCkge31cblxuQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEN1c3RvbUVsZW1lbnRSZWdpc3RyeSxcbiAgLy8gYSB3b3JrYXJvdW5kIGZvciB0aGUgc3R1YmJvcm4gV2ViS2l0XG4gIGRlZmluZTogdXNhYmxlQ3VzdG9tRWxlbWVudHMgP1xuICAgIGZ1bmN0aW9uIChuYW1lLCBDbGFzcywgb3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgQ0VSRGVmaW5lKG5hbWUsIENsYXNzLCBvcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZShuYW1lLCBDbGFzcyk7XG4gICAgICAgIG5hbWUgPSBuYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0cnVjdG9yc1tuYW1lXSA9IHtcbiAgICAgICAgICBjb25zdHJ1Y3RvcjogQ2xhc3MsXG4gICAgICAgICAgY3JlYXRlOiBbbmFtZV1cbiAgICAgICAgfTtcbiAgICAgICAgbm9kZU5hbWVzLnNldChDbGFzcywgbmFtZSk7XG4gICAgICB9XG4gICAgfSA6XG4gICAgQ0VSRGVmaW5lLFxuICBnZXQ6IHVzYWJsZUN1c3RvbUVsZW1lbnRzID9cbiAgICBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIGN1c3RvbUVsZW1lbnRzLmdldChuYW1lKSB8fCBnZXQobmFtZSk7XG4gICAgfSA6XG4gICAgZ2V0LFxuICB3aGVuRGVmaW5lZDogdXNhYmxlQ3VzdG9tRWxlbWVudHMgP1xuICAgIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgY3VzdG9tRWxlbWVudHMud2hlbkRlZmluZWQobmFtZSksXG4gICAgICAgIHdoZW5EZWZpbmVkKG5hbWUpXG4gICAgICBdKTtcbiAgICB9IDpcbiAgICB3aGVuRGVmaW5lZFxufTtcblxuZnVuY3Rpb24gQ0VSRGVmaW5lKG5hbWUsIENsYXNzLCBvcHRpb25zKSB7XG4gIHZhclxuICAgIGlzID0gb3B0aW9ucyAmJiBvcHRpb25zW0VYVEVORFNdIHx8ICcnLFxuICAgIENQcm90byA9IENsYXNzLnByb3RvdHlwZSxcbiAgICBwcm90byA9IGNyZWF0ZShDUHJvdG8pLFxuICAgIGF0dHJpYnV0ZXMgPSBDbGFzcy5vYnNlcnZlZEF0dHJpYnV0ZXMgfHwgZW1wdHksXG4gICAgZGVmaW5pdGlvbiA9IHtwcm90b3R5cGU6IHByb3RvfVxuICA7XG4gIC8vIFRPRE86IGlzIHRoaXMgbmVlZGVkIGF0IGFsbCBzaW5jZSBpdCdzIGluaGVyaXRlZD9cbiAgLy8gZGVmaW5lUHJvcGVydHkocHJvdG8sICdjb25zdHJ1Y3RvcicsIHt2YWx1ZTogQ2xhc3N9KTtcbiAgc2FmZVByb3BlcnR5KHByb3RvLCBDUkVBVEVEX0NBTExCQUNLLCB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoanVzdENyZWF0ZWQpIGp1c3RDcmVhdGVkID0gZmFsc2U7XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzW0RSRUNFVjFdKSB7XG4gICAgICAgICAgdGhpc1tEUkVDRVYxXSA9IHRydWU7XG4gICAgICAgICAgbmV3IENsYXNzKHRoaXMpO1xuICAgICAgICAgIGlmIChDUHJvdG9bQ1JFQVRFRF9DQUxMQkFDS10pXG4gICAgICAgICAgICBDUHJvdG9bQ1JFQVRFRF9DQUxMQkFDS10uY2FsbCh0aGlzKTtcbiAgICAgICAgICB2YXIgaW5mbyA9IGNvbnN0cnVjdG9yc1tub2RlTmFtZXMuZ2V0KENsYXNzKV07XG4gICAgICAgICAgaWYgKCF1c2FibGVDdXN0b21FbGVtZW50cyB8fCBpbmZvLmNyZWF0ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBub3RpZnlBdHRyaWJ1dGVzKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHNhZmVQcm9wZXJ0eShwcm90bywgQVRUUklCVVRFX0NIQU5HRURfQ0FMTEJBQ0ssIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIGlmICgtMSA8IGluZGV4T2YuY2FsbChhdHRyaWJ1dGVzLCBuYW1lKSlcbiAgICAgICAgQ1Byb3RvW0FUVFJJQlVURV9DSEFOR0VEX0NBTExCQUNLXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfSk7XG4gIGlmIChDUHJvdG9bQ09OTkVDVEVEX0NBTExCQUNLXSkge1xuICAgIHNhZmVQcm9wZXJ0eShwcm90bywgQVRUQUNIRURfQ0FMTEJBQ0ssIHtcbiAgICAgIHZhbHVlOiBDUHJvdG9bQ09OTkVDVEVEX0NBTExCQUNLXVxuICAgIH0pO1xuICB9XG4gIGlmIChDUHJvdG9bRElTQ09OTkVDVEVEX0NBTExCQUNLXSkge1xuICAgIHNhZmVQcm9wZXJ0eShwcm90bywgREVUQUNIRURfQ0FMTEJBQ0ssIHtcbiAgICAgIHZhbHVlOiBDUHJvdG9bRElTQ09OTkVDVEVEX0NBTExCQUNLXVxuICAgIH0pO1xuICB9XG4gIGlmIChpcykgZGVmaW5pdGlvbltFWFRFTkRTXSA9IGlzO1xuICBkb2N1bWVudFtSRUdJU1RFUl9FTEVNRU5UXShuYW1lLCBkZWZpbml0aW9uKTtcbiAgbmFtZSA9IG5hbWUudG9VcHBlckNhc2UoKTtcbiAgY29uc3RydWN0b3JzW25hbWVdID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDbGFzcyxcbiAgICBjcmVhdGU6IGlzID8gW2lzLCBzZWNvbmRBcmd1bWVudChuYW1lKV0gOiBbbmFtZV1cbiAgfTtcbiAgbm9kZU5hbWVzLnNldChDbGFzcywgbmFtZSk7XG4gIHdoZW5EZWZpbmVkKG5hbWUpO1xuICB3YWl0aW5nTGlzdFtuYW1lXS5yKCk7XG59XG5cbmZ1bmN0aW9uIGdldChuYW1lKSB7XG4gIHZhciBpbmZvID0gY29uc3RydWN0b3JzW25hbWUudG9VcHBlckNhc2UoKV07XG4gIHJldHVybiBpbmZvICYmIGluZm8uY29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIGdldElzKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJyA/XG4gICAgICBvcHRpb25zIDogKG9wdGlvbnMgJiYgb3B0aW9ucy5pcyB8fCAnJyk7XG59XG5cbmZ1bmN0aW9uIG5vdGlmeUF0dHJpYnV0ZXMoc2VsZikge1xuICB2YXJcbiAgICBjYWxsYmFjayA9IHNlbGZbQVRUUklCVVRFX0NIQU5HRURfQ0FMTEJBQ0tdLFxuICAgIGF0dHJpYnV0ZXMgPSBjYWxsYmFjayA/IHNlbGYuYXR0cmlidXRlcyA6IGVtcHR5LFxuICAgIGkgPSBhdHRyaWJ1dGVzLmxlbmd0aCxcbiAgICBhdHRyaWJ1dGVcbiAgO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgYXR0cmlidXRlID0gIGF0dHJpYnV0ZXNbaV07IC8vIHx8IGF0dHJpYnV0ZXMuaXRlbShpKTtcbiAgICBjYWxsYmFjay5jYWxsKFxuICAgICAgc2VsZixcbiAgICAgIGF0dHJpYnV0ZS5uYW1lIHx8IGF0dHJpYnV0ZS5ub2RlTmFtZSxcbiAgICAgIG51bGwsXG4gICAgICBhdHRyaWJ1dGUudmFsdWUgfHwgYXR0cmlidXRlLm5vZGVWYWx1ZVxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2hlbkRlZmluZWQobmFtZSkge1xuICBuYW1lID0gbmFtZS50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIShuYW1lIGluIHdhaXRpbmdMaXN0KSkge1xuICAgIHdhaXRpbmdMaXN0W25hbWVdID0ge307XG4gICAgd2FpdGluZ0xpc3RbbmFtZV0ucCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICB3YWl0aW5nTGlzdFtuYW1lXS5yID0gcmVzb2x2ZTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gd2FpdGluZ0xpc3RbbmFtZV0ucDtcbn1cblxuZnVuY3Rpb24gcG9seWZpbGxWMSgpIHtcbiAgaWYgKGN1c3RvbUVsZW1lbnRzKSBkZWxldGUgd2luZG93LmN1c3RvbUVsZW1lbnRzO1xuICBkZWZpbmVQcm9wZXJ0eSh3aW5kb3csICdjdXN0b21FbGVtZW50cycsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgdmFsdWU6IG5ldyBDdXN0b21FbGVtZW50UmVnaXN0cnkoKVxuICB9KTtcbiAgZGVmaW5lUHJvcGVydHkod2luZG93LCAnQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5Jywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5XG4gIH0pO1xuICBmb3IgKHZhclxuICAgIHBhdGNoQ2xhc3MgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIENsYXNzID0gd2luZG93W25hbWVdO1xuICAgICAgaWYgKENsYXNzKSB7XG4gICAgICAgIHdpbmRvd1tuYW1lXSA9IGZ1bmN0aW9uIEN1c3RvbUVsZW1lbnRzVjEoc2VsZikge1xuICAgICAgICAgIHZhciBpbmZvLCBpc05hdGl2ZTtcbiAgICAgICAgICBpZiAoIXNlbGYpIHNlbGYgPSB0aGlzO1xuICAgICAgICAgIGlmICghc2VsZltEUkVDRVYxXSkge1xuICAgICAgICAgICAganVzdENyZWF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaW5mbyA9IGNvbnN0cnVjdG9yc1tub2RlTmFtZXMuZ2V0KHNlbGYuY29uc3RydWN0b3IpXTtcbiAgICAgICAgICAgIGlzTmF0aXZlID0gdXNhYmxlQ3VzdG9tRWxlbWVudHMgJiYgaW5mby5jcmVhdGUubGVuZ3RoID09PSAxO1xuICAgICAgICAgICAgc2VsZiA9IGlzTmF0aXZlID9cbiAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoQ2xhc3MsIGVtcHR5LCBpbmZvLmNvbnN0cnVjdG9yKSA6XG4gICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQuYXBwbHkoZG9jdW1lbnQsIGluZm8uY3JlYXRlKTtcbiAgICAgICAgICAgIHNlbGZbRFJFQ0VWMV0gPSB0cnVlO1xuICAgICAgICAgICAganVzdENyZWF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICghaXNOYXRpdmUpIG5vdGlmeUF0dHJpYnV0ZXMoc2VsZik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICB9O1xuICAgICAgICB3aW5kb3dbbmFtZV0ucHJvdG90eXBlID0gQ2xhc3MucHJvdG90eXBlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIENsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHdpbmRvd1tuYW1lXTtcbiAgICAgICAgfSBjYXRjaChXZWJLaXQpIHtcbiAgICAgICAgICBmaXhHZXRDbGFzcyA9IHRydWU7XG4gICAgICAgICAgZGVmaW5lUHJvcGVydHkoQ2xhc3MsIERSRUNFVjEsIHt2YWx1ZTogd2luZG93W25hbWVdfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIENsYXNzZXMgPSBodG1sQ2xhc3MuZ2V0KC9eSFRNTC8pLFxuICAgIGkgPSBDbGFzc2VzLmxlbmd0aDtcbiAgICBpLS07XG4gICAgcGF0Y2hDbGFzcyhDbGFzc2VzW2ldKVxuICApIHt9XG4gIChkb2N1bWVudC5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKG5hbWUsIG9wdGlvbnMpIHtcbiAgICB2YXIgaXMgPSBnZXRJcyhvcHRpb25zKTtcbiAgICByZXR1cm4gaXMgP1xuICAgICAgcGF0Y2hlZENyZWF0ZUVsZW1lbnQuY2FsbCh0aGlzLCBuYW1lLCBzZWNvbmRBcmd1bWVudChpcykpIDpcbiAgICAgIHBhdGNoZWRDcmVhdGVFbGVtZW50LmNhbGwodGhpcywgbmFtZSk7XG4gIH0pO1xufVxuXG5pZiAoIWN1c3RvbUVsZW1lbnRzKSBwb2x5ZmlsbFYxKCk7XG50cnkge1xuICAoZnVuY3Rpb24gKERSRSwgb3B0aW9ucywgbmFtZSkge1xuICAgIG9wdGlvbnNbRVhURU5EU10gPSAnYSc7XG4gICAgRFJFLnByb3RvdHlwZSA9IEhUTUxBbmNob3JFbGVtZW50LnByb3RvdHlwZTtcbiAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUobmFtZSwgRFJFLCBvcHRpb25zKTtcbiAgICBpZiAoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKS5nZXRBdHRyaWJ1dGUoJ2lzJykgIT09IG5hbWUpIHtcbiAgICAgIHRocm93IG9wdGlvbnM7XG4gICAgfVxuICB9KFxuICAgIGZ1bmN0aW9uIERSRSgpIHtcbiAgICAgIHJldHVybiBSZWZsZWN0LmNvbnN0cnVjdChIVE1MQW5jaG9yRWxlbWVudCwgW10sIERSRSk7XG4gICAgfSxcbiAgICB7fSxcbiAgICAnZG9jdW1lbnQtcmVnaXN0ZXItZWxlbWVudC1hJ1xuICApKTtcbn0gY2F0Y2gob19PKSB7XG4gIHBvbHlmaWxsVjEoKTtcbn1cblxudHJ5IHtcbiAgY3JlYXRlRWxlbWVudC5jYWxsKGRvY3VtZW50LCAnYScsICdhJyk7XG59IGNhdGNoKEZpcmVGb3gpIHtcbiAgc2Vjb25kQXJndW1lbnQgPSBmdW5jdGlvbiAoaXMpIHtcbiAgICByZXR1cm4ge2lzOiBpc307XG4gIH07XG59XG5cbn0od2luZG93LCBkb2N1bWVudCwgT2JqZWN0LCAncmVnaXN0ZXJFbGVtZW50JykpOyIsIjsoZnVuY3Rpb24gKCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0LyoqXG5cdCAqIEBwcmVzZXJ2ZSBGYXN0Q2xpY2s6IHBvbHlmaWxsIHRvIHJlbW92ZSBjbGljayBkZWxheXMgb24gYnJvd3NlcnMgd2l0aCB0b3VjaCBVSXMuXG5cdCAqXG5cdCAqIEBjb2RpbmdzdGFuZGFyZCBmdGxhYnMtanN2MlxuXHQgKiBAY29weXJpZ2h0IFRoZSBGaW5hbmNpYWwgVGltZXMgTGltaXRlZCBbQWxsIFJpZ2h0cyBSZXNlcnZlZF1cblx0ICogQGxpY2Vuc2UgTUlUIExpY2Vuc2UgKHNlZSBMSUNFTlNFLnR4dClcblx0ICovXG5cblx0Lypqc2xpbnQgYnJvd3Nlcjp0cnVlLCBub2RlOnRydWUqL1xuXHQvKmdsb2JhbCBkZWZpbmUsIEV2ZW50LCBOb2RlKi9cblxuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZSBmYXN0LWNsaWNraW5nIGxpc3RlbmVycyBvbiB0aGUgc3BlY2lmaWVkIGxheWVyLlxuXHQgKlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtFbGVtZW50fSBsYXllciBUaGUgbGF5ZXIgdG8gbGlzdGVuIG9uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRzXG5cdCAqL1xuXHRmdW5jdGlvbiBGYXN0Q2xpY2sobGF5ZXIsIG9wdGlvbnMpIHtcblx0XHR2YXIgb2xkT25DbGljaztcblxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogV2hldGhlciBhIGNsaWNrIGlzIGN1cnJlbnRseSBiZWluZyB0cmFja2VkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgYm9vbGVhblxuXHRcdCAqL1xuXHRcdHRoaXMudHJhY2tpbmdDbGljayA9IGZhbHNlO1xuXG5cblx0XHQvKipcblx0XHQgKiBUaW1lc3RhbXAgZm9yIHdoZW4gY2xpY2sgdHJhY2tpbmcgc3RhcnRlZC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIG51bWJlclxuXHRcdCAqL1xuXHRcdHRoaXMudHJhY2tpbmdDbGlja1N0YXJ0ID0gMDtcblxuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGVsZW1lbnQgYmVpbmcgdHJhY2tlZCBmb3IgYSBjbGljay5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIEV2ZW50VGFyZ2V0XG5cdFx0ICovXG5cdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblxuXG5cdFx0LyoqXG5cdFx0ICogWC1jb29yZGluYXRlIG9mIHRvdWNoIHN0YXJ0IGV2ZW50LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgbnVtYmVyXG5cdFx0ICovXG5cdFx0dGhpcy50b3VjaFN0YXJ0WCA9IDA7XG5cblxuXHRcdC8qKlxuXHRcdCAqIFktY29vcmRpbmF0ZSBvZiB0b3VjaCBzdGFydCBldmVudC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIG51bWJlclxuXHRcdCAqL1xuXHRcdHRoaXMudG91Y2hTdGFydFkgPSAwO1xuXG5cblx0XHQvKipcblx0XHQgKiBJRCBvZiB0aGUgbGFzdCB0b3VjaCwgcmV0cmlldmVkIGZyb20gVG91Y2guaWRlbnRpZmllci5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIG51bWJlclxuXHRcdCAqL1xuXHRcdHRoaXMubGFzdFRvdWNoSWRlbnRpZmllciA9IDA7XG5cblxuXHRcdC8qKlxuXHRcdCAqIFRvdWNobW92ZSBib3VuZGFyeSwgYmV5b25kIHdoaWNoIGEgY2xpY2sgd2lsbCBiZSBjYW5jZWxsZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBudW1iZXJcblx0XHQgKi9cblx0XHR0aGlzLnRvdWNoQm91bmRhcnkgPSBvcHRpb25zLnRvdWNoQm91bmRhcnkgfHwgMTA7XG5cblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBGYXN0Q2xpY2sgbGF5ZXIuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBFbGVtZW50XG5cdFx0ICovXG5cdFx0dGhpcy5sYXllciA9IGxheWVyO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG1pbmltdW0gdGltZSBiZXR3ZWVuIHRhcCh0b3VjaHN0YXJ0IGFuZCB0b3VjaGVuZCkgZXZlbnRzXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBudW1iZXJcblx0XHQgKi9cblx0XHR0aGlzLnRhcERlbGF5ID0gb3B0aW9ucy50YXBEZWxheSB8fCAyMDA7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbWF4aW11bSB0aW1lIGZvciBhIHRhcFxuXHRcdCAqXG5cdFx0ICogQHR5cGUgbnVtYmVyXG5cdFx0ICovXG5cdFx0dGhpcy50YXBUaW1lb3V0ID0gb3B0aW9ucy50YXBUaW1lb3V0IHx8IDcwMDtcblxuXHRcdGlmIChGYXN0Q2xpY2subm90TmVlZGVkKGxheWVyKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFNvbWUgb2xkIHZlcnNpb25zIG9mIEFuZHJvaWQgZG9uJ3QgaGF2ZSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuXHRcdGZ1bmN0aW9uIGJpbmQobWV0aG9kLCBjb250ZXh0KSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7IHJldHVybiBtZXRob2QuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTsgfTtcblx0XHR9XG5cblxuXHRcdHZhciBtZXRob2RzID0gWydvbk1vdXNlJywgJ29uQ2xpY2snLCAnb25Ub3VjaFN0YXJ0JywgJ29uVG91Y2hNb3ZlJywgJ29uVG91Y2hFbmQnLCAnb25Ub3VjaENhbmNlbCddO1xuXHRcdHZhciBjb250ZXh0ID0gdGhpcztcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IG1ldGhvZHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRjb250ZXh0W21ldGhvZHNbaV1dID0gYmluZChjb250ZXh0W21ldGhvZHNbaV1dLCBjb250ZXh0KTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdXAgZXZlbnQgaGFuZGxlcnMgYXMgcmVxdWlyZWRcblx0XHRpZiAoZGV2aWNlSXNBbmRyb2lkKSB7XG5cdFx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCB0aGlzLm9uTW91c2UsIHRydWUpO1xuXHRcdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlLCB0cnVlKTtcblx0XHRcdGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2UsIHRydWUpO1xuXHRcdH1cblxuXHRcdGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkNsaWNrLCB0cnVlKTtcblx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vblRvdWNoU3RhcnQsIGZhbHNlKTtcblx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uVG91Y2hNb3ZlLCBmYWxzZSk7XG5cdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLm9uVG91Y2hFbmQsIGZhbHNlKTtcblx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMub25Ub3VjaENhbmNlbCwgZmFsc2UpO1xuXG5cdFx0Ly8gSGFjayBpcyByZXF1aXJlZCBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IEV2ZW50I3N0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiAoZS5nLiBBbmRyb2lkIDIpXG5cdFx0Ly8gd2hpY2ggaXMgaG93IEZhc3RDbGljayBub3JtYWxseSBzdG9wcyBjbGljayBldmVudHMgYnViYmxpbmcgdG8gY2FsbGJhY2tzIHJlZ2lzdGVyZWQgb24gdGhlIEZhc3RDbGlja1xuXHRcdC8vIGxheWVyIHdoZW4gdGhleSBhcmUgY2FuY2VsbGVkLlxuXHRcdGlmICghRXZlbnQucHJvdG90eXBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbikge1xuXHRcdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrLCBjYXB0dXJlKSB7XG5cdFx0XHRcdHZhciBybXYgPSBOb2RlLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyO1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ2NsaWNrJykge1xuXHRcdFx0XHRcdHJtdi5jYWxsKGxheWVyLCB0eXBlLCBjYWxsYmFjay5oaWphY2tlZCB8fCBjYWxsYmFjaywgY2FwdHVyZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cm12LmNhbGwobGF5ZXIsIHR5cGUsIGNhbGxiYWNrLCBjYXB0dXJlKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrLCBjYXB0dXJlKSB7XG5cdFx0XHRcdHZhciBhZHYgPSBOb2RlLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyO1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ2NsaWNrJykge1xuXHRcdFx0XHRcdGFkdi5jYWxsKGxheWVyLCB0eXBlLCBjYWxsYmFjay5oaWphY2tlZCB8fCAoY2FsbGJhY2suaGlqYWNrZWQgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRcdFx0aWYgKCFldmVudC5wcm9wYWdhdGlvblN0b3BwZWQpIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2soZXZlbnQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pLCBjYXB0dXJlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhZHYuY2FsbChsYXllciwgdHlwZSwgY2FsbGJhY2ssIGNhcHR1cmUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIElmIGEgaGFuZGxlciBpcyBhbHJlYWR5IGRlY2xhcmVkIGluIHRoZSBlbGVtZW50J3Mgb25jbGljayBhdHRyaWJ1dGUsIGl0IHdpbGwgYmUgZmlyZWQgYmVmb3JlXG5cdFx0Ly8gRmFzdENsaWNrJ3Mgb25DbGljayBoYW5kbGVyLiBGaXggdGhpcyBieSBwdWxsaW5nIG91dCB0aGUgdXNlci1kZWZpbmVkIGhhbmRsZXIgZnVuY3Rpb24gYW5kXG5cdFx0Ly8gYWRkaW5nIGl0IGFzIGxpc3RlbmVyLlxuXHRcdGlmICh0eXBlb2YgbGF5ZXIub25jbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuXG5cdFx0XHQvLyBBbmRyb2lkIGJyb3dzZXIgb24gYXQgbGVhc3QgMy4yIHJlcXVpcmVzIGEgbmV3IHJlZmVyZW5jZSB0byB0aGUgZnVuY3Rpb24gaW4gbGF5ZXIub25jbGlja1xuXHRcdFx0Ly8gLSB0aGUgb2xkIG9uZSB3b24ndCB3b3JrIGlmIHBhc3NlZCB0byBhZGRFdmVudExpc3RlbmVyIGRpcmVjdGx5LlxuXHRcdFx0b2xkT25DbGljayA9IGxheWVyLm9uY2xpY2s7XG5cdFx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdG9sZE9uQ2xpY2soZXZlbnQpO1xuXHRcdFx0fSwgZmFsc2UpO1xuXHRcdFx0bGF5ZXIub25jbGljayA9IG51bGw7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCogV2luZG93cyBQaG9uZSA4LjEgZmFrZXMgdXNlciBhZ2VudCBzdHJpbmcgdG8gbG9vayBsaWtlIEFuZHJvaWQgYW5kIGlQaG9uZS5cblx0KlxuXHQqIEB0eXBlIGJvb2xlYW5cblx0Ki9cblx0dmFyIGRldmljZUlzV2luZG93c1Bob25lID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiV2luZG93cyBQaG9uZVwiKSA+PSAwO1xuXG5cdC8qKlxuXHQgKiBBbmRyb2lkIHJlcXVpcmVzIGV4Y2VwdGlvbnMuXG5cdCAqXG5cdCAqIEB0eXBlIGJvb2xlYW5cblx0ICovXG5cdHZhciBkZXZpY2VJc0FuZHJvaWQgPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0FuZHJvaWQnKSA+IDAgJiYgIWRldmljZUlzV2luZG93c1Bob25lO1xuXG5cblx0LyoqXG5cdCAqIGlPUyByZXF1aXJlcyBleGNlcHRpb25zLlxuXHQgKlxuXHQgKiBAdHlwZSBib29sZWFuXG5cdCAqL1xuXHR2YXIgZGV2aWNlSXNJT1MgPSAvaVAoYWR8aG9uZXxvZCkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIWRldmljZUlzV2luZG93c1Bob25lO1xuXG5cblx0LyoqXG5cdCAqIGlPUyA0IHJlcXVpcmVzIGFuIGV4Y2VwdGlvbiBmb3Igc2VsZWN0IGVsZW1lbnRzLlxuXHQgKlxuXHQgKiBAdHlwZSBib29sZWFuXG5cdCAqL1xuXHR2YXIgZGV2aWNlSXNJT1M0ID0gZGV2aWNlSXNJT1MgJiYgKC9PUyA0X1xcZChfXFxkKT8vKS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG5cblx0LyoqXG5cdCAqIGlPUyA2LjAtNy4qIHJlcXVpcmVzIHRoZSB0YXJnZXQgZWxlbWVudCB0byBiZSBtYW51YWxseSBkZXJpdmVkXG5cdCAqXG5cdCAqIEB0eXBlIGJvb2xlYW5cblx0ICovXG5cdHZhciBkZXZpY2VJc0lPU1dpdGhCYWRUYXJnZXQgPSBkZXZpY2VJc0lPUyAmJiAoL09TIFs2LTddX1xcZC8pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cblx0LyoqXG5cdCAqIEJsYWNrQmVycnkgcmVxdWlyZXMgZXhjZXB0aW9ucy5cblx0ICpcblx0ICogQHR5cGUgYm9vbGVhblxuXHQgKi9cblx0dmFyIGRldmljZUlzQmxhY2tCZXJyeTEwID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdCQjEwJykgPiAwO1xuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgd2hldGhlciBhIGdpdmVuIGVsZW1lbnQgcmVxdWlyZXMgYSBuYXRpdmUgY2xpY2suXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnRUYXJnZXR8RWxlbWVudH0gdGFyZ2V0IFRhcmdldCBET00gZWxlbWVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBlbGVtZW50IG5lZWRzIGEgbmF0aXZlIGNsaWNrXG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm5lZWRzQ2xpY2sgPSBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHRzd2l0Y2ggKHRhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG5cblx0XHQvLyBEb24ndCBzZW5kIGEgc3ludGhldGljIGNsaWNrIHRvIGRpc2FibGVkIGlucHV0cyAoaXNzdWUgIzYyKVxuXHRcdGNhc2UgJ2J1dHRvbic6XG5cdFx0Y2FzZSAnc2VsZWN0Jzpcblx0XHRjYXNlICd0ZXh0YXJlYSc6XG5cdFx0XHRpZiAodGFyZ2V0LmRpc2FibGVkKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdpbnB1dCc6XG5cblx0XHRcdC8vIEZpbGUgaW5wdXRzIG5lZWQgcmVhbCBjbGlja3Mgb24gaU9TIDYgZHVlIHRvIGEgYnJvd3NlciBidWcgKGlzc3VlICM2OClcblx0XHRcdGlmICgoZGV2aWNlSXNJT1MgJiYgdGFyZ2V0LnR5cGUgPT09ICdmaWxlJykgfHwgdGFyZ2V0LmRpc2FibGVkKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdsYWJlbCc6XG5cdFx0Y2FzZSAnaWZyYW1lJzogLy8gaU9TOCBob21lc2NyZWVuIGFwcHMgY2FuIHByZXZlbnQgZXZlbnRzIGJ1YmJsaW5nIGludG8gZnJhbWVzXG5cdFx0Y2FzZSAndmlkZW8nOlxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICgvXFxibmVlZHNjbGlja1xcYi8pLnRlc3QodGFyZ2V0LmNsYXNzTmFtZSk7XG5cdH07XG5cblxuXHQvKipcblx0ICogRGV0ZXJtaW5lIHdoZXRoZXIgYSBnaXZlbiBlbGVtZW50IHJlcXVpcmVzIGEgY2FsbCB0byBmb2N1cyB0byBzaW11bGF0ZSBjbGljayBpbnRvIGVsZW1lbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnRUYXJnZXR8RWxlbWVudH0gdGFyZ2V0IFRhcmdldCBET00gZWxlbWVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBlbGVtZW50IHJlcXVpcmVzIGEgY2FsbCB0byBmb2N1cyB0byBzaW11bGF0ZSBuYXRpdmUgY2xpY2suXG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm5lZWRzRm9jdXMgPSBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHRzd2l0Y2ggKHRhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG5cdFx0Y2FzZSAndGV4dGFyZWEnOlxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0Y2FzZSAnc2VsZWN0Jzpcblx0XHRcdHJldHVybiAhZGV2aWNlSXNBbmRyb2lkO1xuXHRcdGNhc2UgJ2lucHV0Jzpcblx0XHRcdHN3aXRjaCAodGFyZ2V0LnR5cGUpIHtcblx0XHRcdGNhc2UgJ2J1dHRvbic6XG5cdFx0XHRjYXNlICdjaGVja2JveCc6XG5cdFx0XHRjYXNlICdmaWxlJzpcblx0XHRcdGNhc2UgJ2ltYWdlJzpcblx0XHRcdGNhc2UgJ3JhZGlvJzpcblx0XHRcdGNhc2UgJ3N1Ym1pdCc6XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTm8gcG9pbnQgaW4gYXR0ZW1wdGluZyB0byBmb2N1cyBkaXNhYmxlZCBpbnB1dHNcblx0XHRcdHJldHVybiAhdGFyZ2V0LmRpc2FibGVkICYmICF0YXJnZXQucmVhZE9ubHk7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHJldHVybiAoL1xcYm5lZWRzZm9jdXNcXGIvKS50ZXN0KHRhcmdldC5jbGFzc05hbWUpO1xuXHRcdH1cblx0fTtcblxuXG5cdC8qKlxuXHQgKiBTZW5kIGEgY2xpY2sgZXZlbnQgdG8gdGhlIHNwZWNpZmllZCBlbGVtZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fEVsZW1lbnR9IHRhcmdldEVsZW1lbnRcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUuc2VuZENsaWNrID0gZnVuY3Rpb24odGFyZ2V0RWxlbWVudCwgZXZlbnQpIHtcblx0XHR2YXIgY2xpY2tFdmVudCwgdG91Y2g7XG5cblx0XHQvLyBPbiBzb21lIEFuZHJvaWQgZGV2aWNlcyBhY3RpdmVFbGVtZW50IG5lZWRzIHRvIGJlIGJsdXJyZWQgb3RoZXJ3aXNlIHRoZSBzeW50aGV0aWMgY2xpY2sgd2lsbCBoYXZlIG5vIGVmZmVjdCAoIzI0KVxuXHRcdGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IHRhcmdldEVsZW1lbnQpIHtcblx0XHRcdGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuXHRcdH1cblxuXHRcdHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG5cblx0XHQvLyBTeW50aGVzaXplIGEgY2xpY2sgZXZlbnQsIHdpdGggYW4gZXh0cmEgYXR0cmlidXRlIHNvIGl0IGNhbiBiZSB0cmFja2VkXG5cdFx0Y2xpY2tFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpO1xuXHRcdGNsaWNrRXZlbnQuaW5pdE1vdXNlRXZlbnQodGhpcy5kZXRlcm1pbmVFdmVudFR5cGUodGFyZ2V0RWxlbWVudCksIHRydWUsIHRydWUsIHdpbmRvdywgMSwgdG91Y2guc2NyZWVuWCwgdG91Y2guc2NyZWVuWSwgdG91Y2guY2xpZW50WCwgdG91Y2guY2xpZW50WSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuXHRcdGNsaWNrRXZlbnQuZm9yd2FyZGVkVG91Y2hFdmVudCA9IHRydWU7XG5cdFx0dGFyZ2V0RWxlbWVudC5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQpO1xuXHR9O1xuXG5cdEZhc3RDbGljay5wcm90b3R5cGUuZGV0ZXJtaW5lRXZlbnRUeXBlID0gZnVuY3Rpb24odGFyZ2V0RWxlbWVudCkge1xuXG5cdFx0Ly9Jc3N1ZSAjMTU5OiBBbmRyb2lkIENocm9tZSBTZWxlY3QgQm94IGRvZXMgbm90IG9wZW4gd2l0aCBhIHN5bnRoZXRpYyBjbGljayBldmVudFxuXHRcdGlmIChkZXZpY2VJc0FuZHJvaWQgJiYgdGFyZ2V0RWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzZWxlY3QnKSB7XG5cdFx0XHRyZXR1cm4gJ21vdXNlZG93bic7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICdjbGljayc7XG5cdH07XG5cblxuXHQvKipcblx0ICogQHBhcmFtIHtFdmVudFRhcmdldHxFbGVtZW50fSB0YXJnZXRFbGVtZW50XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24odGFyZ2V0RWxlbWVudCkge1xuXHRcdHZhciBsZW5ndGg7XG5cblx0XHQvLyBJc3N1ZSAjMTYwOiBvbiBpT1MgNywgc29tZSBpbnB1dCBlbGVtZW50cyAoZS5nLiBkYXRlIGRhdGV0aW1lIG1vbnRoKSB0aHJvdyBhIHZhZ3VlIFR5cGVFcnJvciBvbiBzZXRTZWxlY3Rpb25SYW5nZS4gVGhlc2UgZWxlbWVudHMgZG9uJ3QgaGF2ZSBhbiBpbnRlZ2VyIHZhbHVlIGZvciB0aGUgc2VsZWN0aW9uU3RhcnQgYW5kIHNlbGVjdGlvbkVuZCBwcm9wZXJ0aWVzLCBidXQgdW5mb3J0dW5hdGVseSB0aGF0IGNhbid0IGJlIHVzZWQgZm9yIGRldGVjdGlvbiBiZWNhdXNlIGFjY2Vzc2luZyB0aGUgcHJvcGVydGllcyBhbHNvIHRocm93cyBhIFR5cGVFcnJvci4gSnVzdCBjaGVjayB0aGUgdHlwZSBpbnN0ZWFkLiBGaWxlZCBhcyBBcHBsZSBidWcgIzE1MTIyNzI0LlxuXHRcdGlmIChkZXZpY2VJc0lPUyAmJiB0YXJnZXRFbGVtZW50LnNldFNlbGVjdGlvblJhbmdlICYmIHRhcmdldEVsZW1lbnQudHlwZS5pbmRleE9mKCdkYXRlJykgIT09IDAgJiYgdGFyZ2V0RWxlbWVudC50eXBlICE9PSAndGltZScgJiYgdGFyZ2V0RWxlbWVudC50eXBlICE9PSAnbW9udGgnKSB7XG5cdFx0XHRsZW5ndGggPSB0YXJnZXRFbGVtZW50LnZhbHVlLmxlbmd0aDtcblx0XHRcdHRhcmdldEVsZW1lbnQuc2V0U2VsZWN0aW9uUmFuZ2UobGVuZ3RoLCBsZW5ndGgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXRFbGVtZW50LmZvY3VzKCk7XG5cdFx0fVxuXHR9O1xuXG5cblx0LyoqXG5cdCAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHRhcmdldCBlbGVtZW50IGlzIGEgY2hpbGQgb2YgYSBzY3JvbGxhYmxlIGxheWVyIGFuZCBpZiBzbywgc2V0IGEgZmxhZyBvbiBpdC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudFRhcmdldHxFbGVtZW50fSB0YXJnZXRFbGVtZW50XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLnVwZGF0ZVNjcm9sbFBhcmVudCA9IGZ1bmN0aW9uKHRhcmdldEVsZW1lbnQpIHtcblx0XHR2YXIgc2Nyb2xsUGFyZW50LCBwYXJlbnRFbGVtZW50O1xuXG5cdFx0c2Nyb2xsUGFyZW50ID0gdGFyZ2V0RWxlbWVudC5mYXN0Q2xpY2tTY3JvbGxQYXJlbnQ7XG5cblx0XHQvLyBBdHRlbXB0IHRvIGRpc2NvdmVyIHdoZXRoZXIgdGhlIHRhcmdldCBlbGVtZW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gYSBzY3JvbGxhYmxlIGxheWVyLiBSZS1jaGVjayBpZiB0aGVcblx0XHQvLyB0YXJnZXQgZWxlbWVudCB3YXMgbW92ZWQgdG8gYW5vdGhlciBwYXJlbnQuXG5cdFx0aWYgKCFzY3JvbGxQYXJlbnQgfHwgIXNjcm9sbFBhcmVudC5jb250YWlucyh0YXJnZXRFbGVtZW50KSkge1xuXHRcdFx0cGFyZW50RWxlbWVudCA9IHRhcmdldEVsZW1lbnQ7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdGlmIChwYXJlbnRFbGVtZW50LnNjcm9sbEhlaWdodCA+IHBhcmVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0KSB7XG5cdFx0XHRcdFx0c2Nyb2xsUGFyZW50ID0gcGFyZW50RWxlbWVudDtcblx0XHRcdFx0XHR0YXJnZXRFbGVtZW50LmZhc3RDbGlja1Njcm9sbFBhcmVudCA9IHBhcmVudEVsZW1lbnQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRwYXJlbnRFbGVtZW50ID0gcGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50O1xuXHRcdFx0fSB3aGlsZSAocGFyZW50RWxlbWVudCk7XG5cdFx0fVxuXG5cdFx0Ly8gQWx3YXlzIHVwZGF0ZSB0aGUgc2Nyb2xsIHRvcCB0cmFja2VyIGlmIHBvc3NpYmxlLlxuXHRcdGlmIChzY3JvbGxQYXJlbnQpIHtcblx0XHRcdHNjcm9sbFBhcmVudC5mYXN0Q2xpY2tMYXN0U2Nyb2xsVG9wID0gc2Nyb2xsUGFyZW50LnNjcm9sbFRvcDtcblx0XHR9XG5cdH07XG5cblxuXHQvKipcblx0ICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0RWxlbWVudFxuXHQgKiBAcmV0dXJucyB7RWxlbWVudHxFdmVudFRhcmdldH1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUuZ2V0VGFyZ2V0RWxlbWVudEZyb21FdmVudFRhcmdldCA9IGZ1bmN0aW9uKGV2ZW50VGFyZ2V0KSB7XG5cblx0XHQvLyBPbiBzb21lIG9sZGVyIGJyb3dzZXJzIChub3RhYmx5IFNhZmFyaSBvbiBpT1MgNC4xIC0gc2VlIGlzc3VlICM1NikgdGhlIGV2ZW50IHRhcmdldCBtYXkgYmUgYSB0ZXh0IG5vZGUuXG5cdFx0aWYgKGV2ZW50VGFyZ2V0Lm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuXHRcdFx0cmV0dXJuIGV2ZW50VGFyZ2V0LnBhcmVudE5vZGU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50VGFyZ2V0O1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIE9uIHRvdWNoIHN0YXJ0LCByZWNvcmQgdGhlIHBvc2l0aW9uIGFuZCBzY3JvbGwgb2Zmc2V0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUub25Ub3VjaFN0YXJ0ID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgdGFyZ2V0RWxlbWVudCwgdG91Y2gsIHNlbGVjdGlvbjtcblxuXHRcdC8vIElnbm9yZSBtdWx0aXBsZSB0b3VjaGVzLCBvdGhlcndpc2UgcGluY2gtdG8tem9vbSBpcyBwcmV2ZW50ZWQgaWYgYm90aCBmaW5nZXJzIGFyZSBvbiB0aGUgRmFzdENsaWNrIGVsZW1lbnQgKGlzc3VlICMxMTEpLlxuXHRcdGlmIChldmVudC50YXJnZXRUb3VjaGVzLmxlbmd0aCA+IDEpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHRhcmdldEVsZW1lbnQgPSB0aGlzLmdldFRhcmdldEVsZW1lbnRGcm9tRXZlbnRUYXJnZXQoZXZlbnQudGFyZ2V0KTtcblx0XHR0b3VjaCA9IGV2ZW50LnRhcmdldFRvdWNoZXNbMF07XG5cblx0XHRpZiAoZGV2aWNlSXNJT1MpIHtcblxuXHRcdFx0Ly8gT25seSB0cnVzdGVkIGV2ZW50cyB3aWxsIGRlc2VsZWN0IHRleHQgb24gaU9TIChpc3N1ZSAjNDkpXG5cdFx0XHRzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5cdFx0XHRpZiAoc2VsZWN0aW9uLnJhbmdlQ291bnQgJiYgIXNlbGVjdGlvbi5pc0NvbGxhcHNlZCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFkZXZpY2VJc0lPUzQpIHtcblxuXHRcdFx0XHQvLyBXZWlyZCB0aGluZ3MgaGFwcGVuIG9uIGlPUyB3aGVuIGFuIGFsZXJ0IG9yIGNvbmZpcm0gZGlhbG9nIGlzIG9wZW5lZCBmcm9tIGEgY2xpY2sgZXZlbnQgY2FsbGJhY2sgKGlzc3VlICMyMyk6XG5cdFx0XHRcdC8vIHdoZW4gdGhlIHVzZXIgbmV4dCB0YXBzIGFueXdoZXJlIGVsc2Ugb24gdGhlIHBhZ2UsIG5ldyB0b3VjaHN0YXJ0IGFuZCB0b3VjaGVuZCBldmVudHMgYXJlIGRpc3BhdGNoZWRcblx0XHRcdFx0Ly8gd2l0aCB0aGUgc2FtZSBpZGVudGlmaWVyIGFzIHRoZSB0b3VjaCBldmVudCB0aGF0IHByZXZpb3VzbHkgdHJpZ2dlcmVkIHRoZSBjbGljayB0aGF0IHRyaWdnZXJlZCB0aGUgYWxlcnQuXG5cdFx0XHRcdC8vIFNhZGx5LCB0aGVyZSBpcyBhbiBpc3N1ZSBvbiBpT1MgNCB0aGF0IGNhdXNlcyBzb21lIG5vcm1hbCB0b3VjaCBldmVudHMgdG8gaGF2ZSB0aGUgc2FtZSBpZGVudGlmaWVyIGFzIGFuXG5cdFx0XHRcdC8vIGltbWVkaWF0ZWx5IHByZWNlZGluZyB0b3VjaCBldmVudCAoaXNzdWUgIzUyKSwgc28gdGhpcyBmaXggaXMgdW5hdmFpbGFibGUgb24gdGhhdCBwbGF0Zm9ybS5cblx0XHRcdFx0Ly8gSXNzdWUgMTIwOiB0b3VjaC5pZGVudGlmaWVyIGlzIDAgd2hlbiBDaHJvbWUgZGV2IHRvb2xzICdFbXVsYXRlIHRvdWNoIGV2ZW50cycgaXMgc2V0IHdpdGggYW4gaU9TIGRldmljZSBVQSBzdHJpbmcsXG5cdFx0XHRcdC8vIHdoaWNoIGNhdXNlcyBhbGwgdG91Y2ggZXZlbnRzIHRvIGJlIGlnbm9yZWQuIEFzIHRoaXMgYmxvY2sgb25seSBhcHBsaWVzIHRvIGlPUywgYW5kIGlPUyBpZGVudGlmaWVycyBhcmUgYWx3YXlzIGxvbmcsXG5cdFx0XHRcdC8vIHJhbmRvbSBpbnRlZ2VycywgaXQncyBzYWZlIHRvIHRvIGNvbnRpbnVlIGlmIHRoZSBpZGVudGlmaWVyIGlzIDAgaGVyZS5cblx0XHRcdFx0aWYgKHRvdWNoLmlkZW50aWZpZXIgJiYgdG91Y2guaWRlbnRpZmllciA9PT0gdGhpcy5sYXN0VG91Y2hJZGVudGlmaWVyKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLmxhc3RUb3VjaElkZW50aWZpZXIgPSB0b3VjaC5pZGVudGlmaWVyO1xuXG5cdFx0XHRcdC8vIElmIHRoZSB0YXJnZXQgZWxlbWVudCBpcyBhIGNoaWxkIG9mIGEgc2Nyb2xsYWJsZSBsYXllciAodXNpbmcgLXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6IHRvdWNoKSBhbmQ6XG5cdFx0XHRcdC8vIDEpIHRoZSB1c2VyIGRvZXMgYSBmbGluZyBzY3JvbGwgb24gdGhlIHNjcm9sbGFibGUgbGF5ZXJcblx0XHRcdFx0Ly8gMikgdGhlIHVzZXIgc3RvcHMgdGhlIGZsaW5nIHNjcm9sbCB3aXRoIGFub3RoZXIgdGFwXG5cdFx0XHRcdC8vIHRoZW4gdGhlIGV2ZW50LnRhcmdldCBvZiB0aGUgbGFzdCAndG91Y2hlbmQnIGV2ZW50IHdpbGwgYmUgdGhlIGVsZW1lbnQgdGhhdCB3YXMgdW5kZXIgdGhlIHVzZXIncyBmaW5nZXJcblx0XHRcdFx0Ly8gd2hlbiB0aGUgZmxpbmcgc2Nyb2xsIHdhcyBzdGFydGVkLCBjYXVzaW5nIEZhc3RDbGljayB0byBzZW5kIGEgY2xpY2sgZXZlbnQgdG8gdGhhdCBsYXllciAtIHVubGVzcyBhIGNoZWNrXG5cdFx0XHRcdC8vIGlzIG1hZGUgdG8gZW5zdXJlIHRoYXQgYSBwYXJlbnQgbGF5ZXIgd2FzIG5vdCBzY3JvbGxlZCBiZWZvcmUgc2VuZGluZyBhIHN5bnRoZXRpYyBjbGljayAoaXNzdWUgIzQyKS5cblx0XHRcdFx0dGhpcy51cGRhdGVTY3JvbGxQYXJlbnQodGFyZ2V0RWxlbWVudCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy50cmFja2luZ0NsaWNrID0gdHJ1ZTtcblx0XHR0aGlzLnRyYWNraW5nQ2xpY2tTdGFydCA9IGV2ZW50LnRpbWVTdGFtcDtcblx0XHR0aGlzLnRhcmdldEVsZW1lbnQgPSB0YXJnZXRFbGVtZW50O1xuXG5cdFx0dGhpcy50b3VjaFN0YXJ0WCA9IHRvdWNoLnBhZ2VYO1xuXHRcdHRoaXMudG91Y2hTdGFydFkgPSB0b3VjaC5wYWdlWTtcblxuXHRcdC8vIFByZXZlbnQgcGhhbnRvbSBjbGlja3Mgb24gZmFzdCBkb3VibGUtdGFwIChpc3N1ZSAjMzYpXG5cdFx0aWYgKChldmVudC50aW1lU3RhbXAgLSB0aGlzLmxhc3RDbGlja1RpbWUpIDwgdGhpcy50YXBEZWxheSAmJiAoZXZlbnQudGltZVN0YW1wIC0gdGhpcy5sYXN0Q2xpY2tUaW1lKSA+IC0xKSB7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIEJhc2VkIG9uIGEgdG91Y2htb3ZlIGV2ZW50IG9iamVjdCwgY2hlY2sgd2hldGhlciB0aGUgdG91Y2ggaGFzIG1vdmVkIHBhc3QgYSBib3VuZGFyeSBzaW5jZSBpdCBzdGFydGVkLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUudG91Y2hIYXNNb3ZlZCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0sIGJvdW5kYXJ5ID0gdGhpcy50b3VjaEJvdW5kYXJ5O1xuXG5cdFx0aWYgKE1hdGguYWJzKHRvdWNoLnBhZ2VYIC0gdGhpcy50b3VjaFN0YXJ0WCkgPiBib3VuZGFyeSB8fCBNYXRoLmFicyh0b3VjaC5wYWdlWSAtIHRoaXMudG91Y2hTdGFydFkpID4gYm91bmRhcnkpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgdGhlIGxhc3QgcG9zaXRpb24uXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5vblRvdWNoTW92ZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0aWYgKCF0aGlzLnRyYWNraW5nQ2xpY2spIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZSB0b3VjaCBoYXMgbW92ZWQsIGNhbmNlbCB0aGUgY2xpY2sgdHJhY2tpbmdcblx0XHRpZiAodGhpcy50YXJnZXRFbGVtZW50ICE9PSB0aGlzLmdldFRhcmdldEVsZW1lbnRGcm9tRXZlbnRUYXJnZXQoZXZlbnQudGFyZ2V0KSB8fCB0aGlzLnRvdWNoSGFzTW92ZWQoZXZlbnQpKSB7XG5cdFx0XHR0aGlzLnRyYWNraW5nQ2xpY2sgPSBmYWxzZTtcblx0XHRcdHRoaXMudGFyZ2V0RWxlbWVudCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblxuXHQvKipcblx0ICogQXR0ZW1wdCB0byBmaW5kIHRoZSBsYWJlbGxlZCBjb250cm9sIGZvciB0aGUgZ2l2ZW4gbGFiZWwgZWxlbWVudC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudFRhcmdldHxIVE1MTGFiZWxFbGVtZW50fSBsYWJlbEVsZW1lbnRcblx0ICogQHJldHVybnMge0VsZW1lbnR8bnVsbH1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUuZmluZENvbnRyb2wgPSBmdW5jdGlvbihsYWJlbEVsZW1lbnQpIHtcblxuXHRcdC8vIEZhc3QgcGF0aCBmb3IgbmV3ZXIgYnJvd3NlcnMgc3VwcG9ydGluZyB0aGUgSFRNTDUgY29udHJvbCBhdHRyaWJ1dGVcblx0XHRpZiAobGFiZWxFbGVtZW50LmNvbnRyb2wgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIGxhYmVsRWxlbWVudC5jb250cm9sO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBicm93c2VycyB1bmRlciB0ZXN0IHRoYXQgc3VwcG9ydCB0b3VjaCBldmVudHMgYWxzbyBzdXBwb3J0IHRoZSBIVE1MNSBodG1sRm9yIGF0dHJpYnV0ZVxuXHRcdGlmIChsYWJlbEVsZW1lbnQuaHRtbEZvcikge1xuXHRcdFx0cmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGxhYmVsRWxlbWVudC5odG1sRm9yKTtcblx0XHR9XG5cblx0XHQvLyBJZiBubyBmb3IgYXR0cmlidXRlIGV4aXN0cywgYXR0ZW1wdCB0byByZXRyaWV2ZSB0aGUgZmlyc3QgbGFiZWxsYWJsZSBkZXNjZW5kYW50IGVsZW1lbnRcblx0XHQvLyB0aGUgbGlzdCBvZiB3aGljaCBpcyBkZWZpbmVkIGhlcmU6IGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2Zvcm1zLmh0bWwjY2F0ZWdvcnktbGFiZWxcblx0XHRyZXR1cm4gbGFiZWxFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2J1dHRvbiwgaW5wdXQ6bm90KFt0eXBlPWhpZGRlbl0pLCBrZXlnZW4sIG1ldGVyLCBvdXRwdXQsIHByb2dyZXNzLCBzZWxlY3QsIHRleHRhcmVhJyk7XG5cdH07XG5cblxuXHQvKipcblx0ICogT24gdG91Y2ggZW5kLCBkZXRlcm1pbmUgd2hldGhlciB0byBzZW5kIGEgY2xpY2sgZXZlbnQgYXQgb25jZS5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uVG91Y2hFbmQgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciBmb3JFbGVtZW50LCB0cmFja2luZ0NsaWNrU3RhcnQsIHRhcmdldFRhZ05hbWUsIHNjcm9sbFBhcmVudCwgdG91Y2gsIHRhcmdldEVsZW1lbnQgPSB0aGlzLnRhcmdldEVsZW1lbnQ7XG5cblx0XHRpZiAoIXRoaXMudHJhY2tpbmdDbGljaykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gUHJldmVudCBwaGFudG9tIGNsaWNrcyBvbiBmYXN0IGRvdWJsZS10YXAgKGlzc3VlICMzNilcblx0XHRpZiAoKGV2ZW50LnRpbWVTdGFtcCAtIHRoaXMubGFzdENsaWNrVGltZSkgPCB0aGlzLnRhcERlbGF5ICYmIChldmVudC50aW1lU3RhbXAgLSB0aGlzLmxhc3RDbGlja1RpbWUpID4gLTEpIHtcblx0XHRcdHRoaXMuY2FuY2VsTmV4dENsaWNrID0gdHJ1ZTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICgoZXZlbnQudGltZVN0YW1wIC0gdGhpcy50cmFja2luZ0NsaWNrU3RhcnQpID4gdGhpcy50YXBUaW1lb3V0KSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBSZXNldCB0byBwcmV2ZW50IHdyb25nIGNsaWNrIGNhbmNlbCBvbiBpbnB1dCAoaXNzdWUgIzE1NikuXG5cdFx0dGhpcy5jYW5jZWxOZXh0Q2xpY2sgPSBmYWxzZTtcblxuXHRcdHRoaXMubGFzdENsaWNrVGltZSA9IGV2ZW50LnRpbWVTdGFtcDtcblxuXHRcdHRyYWNraW5nQ2xpY2tTdGFydCA9IHRoaXMudHJhY2tpbmdDbGlja1N0YXJ0O1xuXHRcdHRoaXMudHJhY2tpbmdDbGljayA9IGZhbHNlO1xuXHRcdHRoaXMudHJhY2tpbmdDbGlja1N0YXJ0ID0gMDtcblxuXHRcdC8vIE9uIHNvbWUgaU9TIGRldmljZXMsIHRoZSB0YXJnZXRFbGVtZW50IHN1cHBsaWVkIHdpdGggdGhlIGV2ZW50IGlzIGludmFsaWQgaWYgdGhlIGxheWVyXG5cdFx0Ly8gaXMgcGVyZm9ybWluZyBhIHRyYW5zaXRpb24gb3Igc2Nyb2xsLCBhbmQgaGFzIHRvIGJlIHJlLWRldGVjdGVkIG1hbnVhbGx5LiBOb3RlIHRoYXRcblx0XHQvLyBmb3IgdGhpcyB0byBmdW5jdGlvbiBjb3JyZWN0bHksIGl0IG11c3QgYmUgY2FsbGVkICphZnRlciogdGhlIGV2ZW50IHRhcmdldCBpcyBjaGVja2VkIVxuXHRcdC8vIFNlZSBpc3N1ZSAjNTc7IGFsc28gZmlsZWQgYXMgcmRhcjovLzEzMDQ4NTg5IC5cblx0XHRpZiAoZGV2aWNlSXNJT1NXaXRoQmFkVGFyZ2V0KSB7XG5cdFx0XHR0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuXG5cdFx0XHQvLyBJbiBjZXJ0YWluIGNhc2VzIGFyZ3VtZW50cyBvZiBlbGVtZW50RnJvbVBvaW50IGNhbiBiZSBuZWdhdGl2ZSwgc28gcHJldmVudCBzZXR0aW5nIHRhcmdldEVsZW1lbnQgdG8gbnVsbFxuXHRcdFx0dGFyZ2V0RWxlbWVudCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQodG91Y2gucGFnZVggLSB3aW5kb3cucGFnZVhPZmZzZXQsIHRvdWNoLnBhZ2VZIC0gd2luZG93LnBhZ2VZT2Zmc2V0KSB8fCB0YXJnZXRFbGVtZW50O1xuXHRcdFx0dGFyZ2V0RWxlbWVudC5mYXN0Q2xpY2tTY3JvbGxQYXJlbnQgPSB0aGlzLnRhcmdldEVsZW1lbnQuZmFzdENsaWNrU2Nyb2xsUGFyZW50O1xuXHRcdH1cblxuXHRcdHRhcmdldFRhZ05hbWUgPSB0YXJnZXRFbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRpZiAodGFyZ2V0VGFnTmFtZSA9PT0gJ2xhYmVsJykge1xuXHRcdFx0Zm9yRWxlbWVudCA9IHRoaXMuZmluZENvbnRyb2wodGFyZ2V0RWxlbWVudCk7XG5cdFx0XHRpZiAoZm9yRWxlbWVudCkge1xuXHRcdFx0XHR0aGlzLmZvY3VzKHRhcmdldEVsZW1lbnQpO1xuXHRcdFx0XHRpZiAoZGV2aWNlSXNBbmRyb2lkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGFyZ2V0RWxlbWVudCA9IGZvckVsZW1lbnQ7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0aGlzLm5lZWRzRm9jdXModGFyZ2V0RWxlbWVudCkpIHtcblxuXHRcdFx0Ly8gQ2FzZSAxOiBJZiB0aGUgdG91Y2ggc3RhcnRlZCBhIHdoaWxlIGFnbyAoYmVzdCBndWVzcyBpcyAxMDBtcyBiYXNlZCBvbiB0ZXN0cyBmb3IgaXNzdWUgIzM2KSB0aGVuIGZvY3VzIHdpbGwgYmUgdHJpZ2dlcmVkIGFueXdheS4gUmV0dXJuIGVhcmx5IGFuZCB1bnNldCB0aGUgdGFyZ2V0IGVsZW1lbnQgcmVmZXJlbmNlIHNvIHRoYXQgdGhlIHN1YnNlcXVlbnQgY2xpY2sgd2lsbCBiZSBhbGxvd2VkIHRocm91Z2guXG5cdFx0XHQvLyBDYXNlIDI6IFdpdGhvdXQgdGhpcyBleGNlcHRpb24gZm9yIGlucHV0IGVsZW1lbnRzIHRhcHBlZCB3aGVuIHRoZSBkb2N1bWVudCBpcyBjb250YWluZWQgaW4gYW4gaWZyYW1lLCB0aGVuIGFueSBpbnB1dHRlZCB0ZXh0IHdvbid0IGJlIHZpc2libGUgZXZlbiB0aG91Z2ggdGhlIHZhbHVlIGF0dHJpYnV0ZSBpcyB1cGRhdGVkIGFzIHRoZSB1c2VyIHR5cGVzIChpc3N1ZSAjMzcpLlxuXHRcdFx0aWYgKChldmVudC50aW1lU3RhbXAgLSB0cmFja2luZ0NsaWNrU3RhcnQpID4gMTAwIHx8IChkZXZpY2VJc0lPUyAmJiB3aW5kb3cudG9wICE9PSB3aW5kb3cgJiYgdGFyZ2V0VGFnTmFtZSA9PT0gJ2lucHV0JykpIHtcblx0XHRcdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmZvY3VzKHRhcmdldEVsZW1lbnQpO1xuXHRcdFx0dGhpcy5zZW5kQ2xpY2sodGFyZ2V0RWxlbWVudCwgZXZlbnQpO1xuXG5cdFx0XHQvLyBTZWxlY3QgZWxlbWVudHMgbmVlZCB0aGUgZXZlbnQgdG8gZ28gdGhyb3VnaCBvbiBpT1MgNCwgb3RoZXJ3aXNlIHRoZSBzZWxlY3RvciBtZW51IHdvbid0IG9wZW4uXG5cdFx0XHQvLyBBbHNvIHRoaXMgYnJlYWtzIG9wZW5pbmcgc2VsZWN0cyB3aGVuIFZvaWNlT3ZlciBpcyBhY3RpdmUgb24gaU9TNiwgaU9TNyAoYW5kIHBvc3NpYmx5IG90aGVycylcblx0XHRcdGlmICghZGV2aWNlSXNJT1MgfHwgdGFyZ2V0VGFnTmFtZSAhPT0gJ3NlbGVjdCcpIHtcblx0XHRcdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmIChkZXZpY2VJc0lPUyAmJiAhZGV2aWNlSXNJT1M0KSB7XG5cblx0XHRcdC8vIERvbid0IHNlbmQgYSBzeW50aGV0aWMgY2xpY2sgZXZlbnQgaWYgdGhlIHRhcmdldCBlbGVtZW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gYSBwYXJlbnQgbGF5ZXIgdGhhdCB3YXMgc2Nyb2xsZWRcblx0XHRcdC8vIGFuZCB0aGlzIHRhcCBpcyBiZWluZyB1c2VkIHRvIHN0b3AgdGhlIHNjcm9sbGluZyAodXN1YWxseSBpbml0aWF0ZWQgYnkgYSBmbGluZyAtIGlzc3VlICM0MikuXG5cdFx0XHRzY3JvbGxQYXJlbnQgPSB0YXJnZXRFbGVtZW50LmZhc3RDbGlja1Njcm9sbFBhcmVudDtcblx0XHRcdGlmIChzY3JvbGxQYXJlbnQgJiYgc2Nyb2xsUGFyZW50LmZhc3RDbGlja0xhc3RTY3JvbGxUb3AgIT09IHNjcm9sbFBhcmVudC5zY3JvbGxUb3ApIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJldmVudCB0aGUgYWN0dWFsIGNsaWNrIGZyb20gZ29pbmcgdGhvdWdoIC0gdW5sZXNzIHRoZSB0YXJnZXQgbm9kZSBpcyBtYXJrZWQgYXMgcmVxdWlyaW5nXG5cdFx0Ly8gcmVhbCBjbGlja3Mgb3IgaWYgaXQgaXMgaW4gdGhlIHdoaXRlbGlzdCBpbiB3aGljaCBjYXNlIG9ubHkgbm9uLXByb2dyYW1tYXRpYyBjbGlja3MgYXJlIHBlcm1pdHRlZC5cblx0XHRpZiAoIXRoaXMubmVlZHNDbGljayh0YXJnZXRFbGVtZW50KSkge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdHRoaXMuc2VuZENsaWNrKHRhcmdldEVsZW1lbnQsIGV2ZW50KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblxuXHQvKipcblx0ICogT24gdG91Y2ggY2FuY2VsLCBzdG9wIHRyYWNraW5nIHRoZSBjbGljay5cblx0ICpcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uVG91Y2hDYW5jZWwgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnRyYWNraW5nQ2xpY2sgPSBmYWxzZTtcblx0XHR0aGlzLnRhcmdldEVsZW1lbnQgPSBudWxsO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIERldGVybWluZSBtb3VzZSBldmVudHMgd2hpY2ggc2hvdWxkIGJlIHBlcm1pdHRlZC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uTW91c2UgPSBmdW5jdGlvbihldmVudCkge1xuXG5cdFx0Ly8gSWYgYSB0YXJnZXQgZWxlbWVudCB3YXMgbmV2ZXIgc2V0IChiZWNhdXNlIGEgdG91Y2ggZXZlbnQgd2FzIG5ldmVyIGZpcmVkKSBhbGxvdyB0aGUgZXZlbnRcblx0XHRpZiAoIXRoaXMudGFyZ2V0RWxlbWVudCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKGV2ZW50LmZvcndhcmRlZFRvdWNoRXZlbnQpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIFByb2dyYW1tYXRpY2FsbHkgZ2VuZXJhdGVkIGV2ZW50cyB0YXJnZXRpbmcgYSBzcGVjaWZpYyBlbGVtZW50IHNob3VsZCBiZSBwZXJtaXR0ZWRcblx0XHRpZiAoIWV2ZW50LmNhbmNlbGFibGUpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIERlcml2ZSBhbmQgY2hlY2sgdGhlIHRhcmdldCBlbGVtZW50IHRvIHNlZSB3aGV0aGVyIHRoZSBtb3VzZSBldmVudCBuZWVkcyB0byBiZSBwZXJtaXR0ZWQ7XG5cdFx0Ly8gdW5sZXNzIGV4cGxpY2l0bHkgZW5hYmxlZCwgcHJldmVudCBub24tdG91Y2ggY2xpY2sgZXZlbnRzIGZyb20gdHJpZ2dlcmluZyBhY3Rpb25zLFxuXHRcdC8vIHRvIHByZXZlbnQgZ2hvc3QvZG91YmxlY2xpY2tzLlxuXHRcdGlmICghdGhpcy5uZWVkc0NsaWNrKHRoaXMudGFyZ2V0RWxlbWVudCkgfHwgdGhpcy5jYW5jZWxOZXh0Q2xpY2spIHtcblxuXHRcdFx0Ly8gUHJldmVudCBhbnkgdXNlci1hZGRlZCBsaXN0ZW5lcnMgZGVjbGFyZWQgb24gRmFzdENsaWNrIGVsZW1lbnQgZnJvbSBiZWluZyBmaXJlZC5cblx0XHRcdGlmIChldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24pIHtcblx0XHRcdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIFBhcnQgb2YgdGhlIGhhY2sgZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBFdmVudCNzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gKGUuZy4gQW5kcm9pZCAyKVxuXHRcdFx0XHRldmVudC5wcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYW5jZWwgdGhlIGV2ZW50XG5cdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGUgbW91c2UgZXZlbnQgaXMgcGVybWl0dGVkLCByZXR1cm4gdHJ1ZSBmb3IgdGhlIGFjdGlvbiB0byBnbyB0aHJvdWdoLlxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIE9uIGFjdHVhbCBjbGlja3MsIGRldGVybWluZSB3aGV0aGVyIHRoaXMgaXMgYSB0b3VjaC1nZW5lcmF0ZWQgY2xpY2ssIGEgY2xpY2sgYWN0aW9uIG9jY3VycmluZ1xuXHQgKiBuYXR1cmFsbHkgYWZ0ZXIgYSBkZWxheSBhZnRlciBhIHRvdWNoICh3aGljaCBuZWVkcyB0byBiZSBjYW5jZWxsZWQgdG8gYXZvaWQgZHVwbGljYXRpb24pLCBvclxuXHQgKiBhbiBhY3R1YWwgY2xpY2sgd2hpY2ggc2hvdWxkIGJlIHBlcm1pdHRlZC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciBwZXJtaXR0ZWQ7XG5cblx0XHQvLyBJdCdzIHBvc3NpYmxlIGZvciBhbm90aGVyIEZhc3RDbGljay1saWtlIGxpYnJhcnkgZGVsaXZlcmVkIHdpdGggdGhpcmQtcGFydHkgY29kZSB0byBmaXJlIGEgY2xpY2sgZXZlbnQgYmVmb3JlIEZhc3RDbGljayBkb2VzIChpc3N1ZSAjNDQpLiBJbiB0aGF0IGNhc2UsIHNldCB0aGUgY2xpY2stdHJhY2tpbmcgZmxhZyBiYWNrIHRvIGZhbHNlIGFuZCByZXR1cm4gZWFybHkuIFRoaXMgd2lsbCBjYXVzZSBvblRvdWNoRW5kIHRvIHJldHVybiBlYXJseS5cblx0XHRpZiAodGhpcy50cmFja2luZ0NsaWNrKSB7XG5cdFx0XHR0aGlzLnRhcmdldEVsZW1lbnQgPSBudWxsO1xuXHRcdFx0dGhpcy50cmFja2luZ0NsaWNrID0gZmFsc2U7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBWZXJ5IG9kZCBiZWhhdmlvciBvbiBpT1MgKGlzc3VlICMxOCk6IGlmIGEgc3VibWl0IGVsZW1lbnQgaXMgcHJlc2VudCBpbnNpZGUgYSBmb3JtIGFuZCB0aGUgdXNlciBoaXRzIGVudGVyIGluIHRoZSBpT1Mgc2ltdWxhdG9yIG9yIGNsaWNrcyB0aGUgR28gYnV0dG9uIG9uIHRoZSBwb3AtdXAgT1Mga2V5Ym9hcmQgdGhlIGEga2luZCBvZiAnZmFrZScgY2xpY2sgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQgd2l0aCB0aGUgc3VibWl0LXR5cGUgaW5wdXQgZWxlbWVudCBhcyB0aGUgdGFyZ2V0LlxuXHRcdGlmIChldmVudC50YXJnZXQudHlwZSA9PT0gJ3N1Ym1pdCcgJiYgZXZlbnQuZGV0YWlsID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRwZXJtaXR0ZWQgPSB0aGlzLm9uTW91c2UoZXZlbnQpO1xuXG5cdFx0Ly8gT25seSB1bnNldCB0YXJnZXRFbGVtZW50IGlmIHRoZSBjbGljayBpcyBub3QgcGVybWl0dGVkLiBUaGlzIHdpbGwgZW5zdXJlIHRoYXQgdGhlIGNoZWNrIGZvciAhdGFyZ2V0RWxlbWVudCBpbiBvbk1vdXNlIGZhaWxzIGFuZCB0aGUgYnJvd3NlcidzIGNsaWNrIGRvZXNuJ3QgZ28gdGhyb3VnaC5cblx0XHRpZiAoIXBlcm1pdHRlZCkge1xuXHRcdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblx0XHR9XG5cblx0XHQvLyBJZiBjbGlja3MgYXJlIHBlcm1pdHRlZCwgcmV0dXJuIHRydWUgZm9yIHRoZSBhY3Rpb24gdG8gZ28gdGhyb3VnaC5cblx0XHRyZXR1cm4gcGVybWl0dGVkO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhbGwgRmFzdENsaWNrJ3MgZXZlbnQgbGlzdGVuZXJzLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsYXllciA9IHRoaXMubGF5ZXI7XG5cblx0XHRpZiAoZGV2aWNlSXNBbmRyb2lkKSB7XG5cdFx0XHRsYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCB0aGlzLm9uTW91c2UsIHRydWUpO1xuXHRcdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlLCB0cnVlKTtcblx0XHRcdGxheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2UsIHRydWUpO1xuXHRcdH1cblxuXHRcdGxheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkNsaWNrLCB0cnVlKTtcblx0XHRsYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vblRvdWNoU3RhcnQsIGZhbHNlKTtcblx0XHRsYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uVG91Y2hNb3ZlLCBmYWxzZSk7XG5cdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLm9uVG91Y2hFbmQsIGZhbHNlKTtcblx0XHRsYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMub25Ub3VjaENhbmNlbCwgZmFsc2UpO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIENoZWNrIHdoZXRoZXIgRmFzdENsaWNrIGlzIG5lZWRlZC5cblx0ICpcblx0ICogQHBhcmFtIHtFbGVtZW50fSBsYXllciBUaGUgbGF5ZXIgdG8gbGlzdGVuIG9uXG5cdCAqL1xuXHRGYXN0Q2xpY2subm90TmVlZGVkID0gZnVuY3Rpb24obGF5ZXIpIHtcblx0XHR2YXIgbWV0YVZpZXdwb3J0O1xuXHRcdHZhciBjaHJvbWVWZXJzaW9uO1xuXHRcdHZhciBibGFja2JlcnJ5VmVyc2lvbjtcblx0XHR2YXIgZmlyZWZveFZlcnNpb247XG5cblx0XHQvLyBEZXZpY2VzIHRoYXQgZG9uJ3Qgc3VwcG9ydCB0b3VjaCBkb24ndCBuZWVkIEZhc3RDbGlja1xuXHRcdGlmICh0eXBlb2Ygd2luZG93Lm9udG91Y2hzdGFydCA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIENocm9tZSB2ZXJzaW9uIC0gemVybyBmb3Igb3RoZXIgYnJvd3NlcnNcblx0XHRjaHJvbWVWZXJzaW9uID0gKygvQ2hyb21lXFwvKFswLTldKykvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgWywwXSlbMV07XG5cblx0XHRpZiAoY2hyb21lVmVyc2lvbikge1xuXG5cdFx0XHRpZiAoZGV2aWNlSXNBbmRyb2lkKSB7XG5cdFx0XHRcdG1ldGFWaWV3cG9ydCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbbmFtZT12aWV3cG9ydF0nKTtcblxuXHRcdFx0XHRpZiAobWV0YVZpZXdwb3J0KSB7XG5cdFx0XHRcdFx0Ly8gQ2hyb21lIG9uIEFuZHJvaWQgd2l0aCB1c2VyLXNjYWxhYmxlPVwibm9cIiBkb2Vzbid0IG5lZWQgRmFzdENsaWNrIChpc3N1ZSAjODkpXG5cdFx0XHRcdFx0aWYgKG1ldGFWaWV3cG9ydC5jb250ZW50LmluZGV4T2YoJ3VzZXItc2NhbGFibGU9bm8nKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBDaHJvbWUgMzIgYW5kIGFib3ZlIHdpdGggd2lkdGg9ZGV2aWNlLXdpZHRoIG9yIGxlc3MgZG9uJ3QgbmVlZCBGYXN0Q2xpY2tcblx0XHRcdFx0XHRpZiAoY2hyb21lVmVyc2lvbiA+IDMxICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxXaWR0aCA8PSB3aW5kb3cub3V0ZXJXaWR0aCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIENocm9tZSBkZXNrdG9wIGRvZXNuJ3QgbmVlZCBGYXN0Q2xpY2sgKGlzc3VlICMxNSlcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChkZXZpY2VJc0JsYWNrQmVycnkxMCkge1xuXHRcdFx0YmxhY2tiZXJyeVZlcnNpb24gPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9WZXJzaW9uXFwvKFswLTldKilcXC4oWzAtOV0qKS8pO1xuXG5cdFx0XHQvLyBCbGFja0JlcnJ5IDEwLjMrIGRvZXMgbm90IHJlcXVpcmUgRmFzdGNsaWNrIGxpYnJhcnkuXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vZnRsYWJzL2Zhc3RjbGljay9pc3N1ZXMvMjUxXG5cdFx0XHRpZiAoYmxhY2tiZXJyeVZlcnNpb25bMV0gPj0gMTAgJiYgYmxhY2tiZXJyeVZlcnNpb25bMl0gPj0gMykge1xuXHRcdFx0XHRtZXRhVmlld3BvcnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9dmlld3BvcnRdJyk7XG5cblx0XHRcdFx0aWYgKG1ldGFWaWV3cG9ydCkge1xuXHRcdFx0XHRcdC8vIHVzZXItc2NhbGFibGU9bm8gZWxpbWluYXRlcyBjbGljayBkZWxheS5cblx0XHRcdFx0XHRpZiAobWV0YVZpZXdwb3J0LmNvbnRlbnQuaW5kZXhPZigndXNlci1zY2FsYWJsZT1ubycpICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIHdpZHRoPWRldmljZS13aWR0aCAob3IgbGVzcyB0aGFuIGRldmljZS13aWR0aCkgZWxpbWluYXRlcyBjbGljayBkZWxheS5cblx0XHRcdFx0XHRpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFdpZHRoIDw9IHdpbmRvdy5vdXRlcldpZHRoKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBJRTEwIHdpdGggLW1zLXRvdWNoLWFjdGlvbjogbm9uZSBvciBtYW5pcHVsYXRpb24sIHdoaWNoIGRpc2FibGVzIGRvdWJsZS10YXAtdG8tem9vbSAoaXNzdWUgIzk3KVxuXHRcdGlmIChsYXllci5zdHlsZS5tc1RvdWNoQWN0aW9uID09PSAnbm9uZScgfHwgbGF5ZXIuc3R5bGUudG91Y2hBY3Rpb24gPT09ICdtYW5pcHVsYXRpb24nKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBGaXJlZm94IHZlcnNpb24gLSB6ZXJvIGZvciBvdGhlciBicm93c2Vyc1xuXHRcdGZpcmVmb3hWZXJzaW9uID0gKygvRmlyZWZveFxcLyhbMC05XSspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpIHx8IFssMF0pWzFdO1xuXG5cdFx0aWYgKGZpcmVmb3hWZXJzaW9uID49IDI3KSB7XG5cdFx0XHQvLyBGaXJlZm94IDI3KyBkb2VzIG5vdCBoYXZlIHRhcCBkZWxheSBpZiB0aGUgY29udGVudCBpcyBub3Qgem9vbWFibGUgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD05MjI4OTZcblxuXHRcdFx0bWV0YVZpZXdwb3J0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPXZpZXdwb3J0XScpO1xuXHRcdFx0aWYgKG1ldGFWaWV3cG9ydCAmJiAobWV0YVZpZXdwb3J0LmNvbnRlbnQuaW5kZXhPZigndXNlci1zY2FsYWJsZT1ubycpICE9PSAtMSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGggPD0gd2luZG93Lm91dGVyV2lkdGgpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIElFMTE6IHByZWZpeGVkIC1tcy10b3VjaC1hY3Rpb24gaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCBhbmQgaXQncyByZWNvbW1lbmRlZCB0byB1c2Ugbm9uLXByZWZpeGVkIHZlcnNpb25cblx0XHQvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvd2luZG93cy9hcHBzL0hoNzY3MzEzLmFzcHhcblx0XHRpZiAobGF5ZXIuc3R5bGUudG91Y2hBY3Rpb24gPT09ICdub25lJyB8fCBsYXllci5zdHlsZS50b3VjaEFjdGlvbiA9PT0gJ21hbmlwdWxhdGlvbicpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBGYWN0b3J5IG1ldGhvZCBmb3IgY3JlYXRpbmcgYSBGYXN0Q2xpY2sgb2JqZWN0XG5cdCAqXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gbGF5ZXIgVGhlIGxheWVyIHRvIGxpc3RlbiBvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0c1xuXHQgKi9cblx0RmFzdENsaWNrLmF0dGFjaCA9IGZ1bmN0aW9uKGxheWVyLCBvcHRpb25zKSB7XG5cdFx0cmV0dXJuIG5ldyBGYXN0Q2xpY2sobGF5ZXIsIG9wdGlvbnMpO1xuXHR9O1xuXG4gIHdpbmRvdy5GYXN0Q2xpY2sgPSBGYXN0Q2xpY2s7XG59KCkpO1xuIiwiLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9XZWJSZWZsZWN0aW9uL2RvY3VtZW50LXJlZ2lzdGVyLWVsZW1lbnQvaXNzdWVzLzIxI2lzc3VlY29tbWVudC0xMDIwMjAzMTFcbnZhciBpbm5lckhUTUwgPSAoZnVuY3Rpb24gKGRvY3VtZW50KSB7XG5cbiAgdmFyXG4gICAgRVhURU5EUyA9ICdleHRlbmRzJyxcbiAgICByZWdpc3RlciA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCxcbiAgICBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICBkcmUgPSAnZG9jdW1lbnQtcmVnaXN0ZXItZWxlbWVudCcsXG4gICAgaW5uZXJIVE1MID0gcmVnaXN0ZXIuaW5uZXJIVE1MLFxuICAgIGluaXRpYWxpemUsXG4gICAgcmVnaXN0ZXJlZFxuICA7XG5cbiAgLy8gYXZvaWQgZHVwbGljYXRlZCB3cmFwcGVyc1xuICBpZiAoaW5uZXJIVE1MKSByZXR1cm4gaW5uZXJIVE1MO1xuXG4gIHRyeSB7XG5cbiAgICAvLyBmZWF0dXJlIGRldGVjdCB0aGUgcHJvYmxlbVxuICAgIHJlZ2lzdGVyLmNhbGwoXG4gICAgICBkb2N1bWVudCxcbiAgICAgIGRyZSxcbiAgICAgIHtwcm90b3R5cGU6IE9iamVjdC5jcmVhdGUoXG4gICAgICAgIEhUTUxFbGVtZW50LnByb3RvdHlwZSxcbiAgICAgICAge2NyZWF0ZWRDYWxsYmFjazoge3ZhbHVlOiBPYmplY3R9fVxuICAgICAgKX1cbiAgICApO1xuXG4gICAgZGl2LmlubmVySFRNTCA9ICc8JyArIGRyZSArICc+PC8nICsgZHJlICsgJz4nO1xuXG4gICAgLy8gaWYgbmF0aXZlbHkgc3VwcG9ydGVkLCBub3RoaW5nIHRvIGRvXG4gICAgaWYgKCdjcmVhdGVkQ2FsbGJhY2snIGluIGRpdi5xdWVyeVNlbGVjdG9yKGRyZSkpIHtcbiAgICAgIC8vIHJldHVybiBqdXN0IGFuIGlubmVySFRNTCB3cmFwXG4gICAgICByZXR1cm4gKHJlZ2lzdGVyLmlubmVySFRNTCA9IGZ1bmN0aW9uIChlbCwgaHRtbCkge1xuICAgICAgICBlbC5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgfSBjYXRjaChtZWgpIHt9XG5cbiAgLy8gaW4gb3RoZXIgY2FzZXNcbiAgcmVnaXN0ZXJlZCA9IFtdO1xuICBpbml0aWFsaXplID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKFxuICAgICAgJ2NyZWF0ZWRDYWxsYmFjaycgaW4gZWwgICAgICAgICB8fFxuICAgICAgJ2F0dGFjaGVkQ2FsbGJhY2snIGluIGVsICAgICAgICB8fFxuICAgICAgJ2RldGFjaGVkQ2FsbGJhY2snIGluIGVsICAgICAgICB8fFxuICAgICAgJ2F0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaycgaW4gZWxcbiAgICApIHJldHVybjtcbiAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50LmlubmVySFRNTEhlbHBlciA9IHRydWU7XG4gICAgZm9yICh2YXJcbiAgICAgIHBhcmVudE5vZGUgPSBlbC5wYXJlbnROb2RlLFxuICAgICAgdHlwZSA9IGVsLmdldEF0dHJpYnV0ZSgnaXMnKSxcbiAgICAgIG5hbWUgPSBlbC5ub2RlTmFtZSxcbiAgICAgIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50LmFwcGx5KFxuICAgICAgICBkb2N1bWVudCxcbiAgICAgICAgdHlwZSA/IFtuYW1lLCB0eXBlXSA6IFtuYW1lXVxuICAgICAgKSxcbiAgICAgIGF0dHJpYnV0ZXMgPSBlbC5hdHRyaWJ1dGVzLFxuICAgICAgaSA9IDAsXG4gICAgICBsZW5ndGggPSBhdHRyaWJ1dGVzLmxlbmd0aCxcbiAgICAgIGF0dHIsIGZjO1xuICAgICAgaSA8IGxlbmd0aDsgaSsrXG4gICAgKSB7XG4gICAgICBhdHRyID0gYXR0cmlidXRlc1tpXTtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHIubmFtZSwgYXR0ci52YWx1ZSk7XG4gICAgfVxuICAgIGlmIChub2RlLmNyZWF0ZWRDYWxsYmFjaykge1xuICAgICAgbm9kZS5jcmVhdGVkID0gdHJ1ZTtcbiAgICAgIG5vZGUuY3JlYXRlZENhbGxiYWNrKCk7XG4gICAgICBub2RlLmNyZWF0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgd2hpbGUgKChmYyA9IGVsLmZpcnN0Q2hpbGQpKSBub2RlLmFwcGVuZENoaWxkKGZjKTtcbiAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50LmlubmVySFRNTEhlbHBlciA9IGZhbHNlO1xuICAgIGlmIChwYXJlbnROb2RlKSBwYXJlbnROb2RlLnJlcGxhY2VDaGlsZChub2RlLCBlbCk7XG4gIH07XG4gIC8vIGF1Z21lbnQgdGhlIGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCBtZXRob2RcbiAgcmV0dXJuICgoZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50ID0gZnVuY3Rpb24gcmVnaXN0ZXJFbGVtZW50KHR5cGUsIG9wdGlvbnMpIHtcbiAgICB2YXIgbmFtZSA9IChvcHRpb25zW0VYVEVORFNdID9cbiAgICAgIChvcHRpb25zW0VYVEVORFNdICsgJ1tpcz1cIicgKyB0eXBlICsgJ1wiXScpIDogdHlwZVxuICAgICkudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAocmVnaXN0ZXJlZC5pbmRleE9mKG5hbWUpIDwgMCkgcmVnaXN0ZXJlZC5wdXNoKG5hbWUpO1xuICAgIHJldHVybiByZWdpc3Rlci5hcHBseShkb2N1bWVudCwgYXJndW1lbnRzKTtcbiAgfSkuaW5uZXJIVE1MID0gZnVuY3Rpb24gKGVsLCBodG1sKSB7XG4gICAgZWwuaW5uZXJIVE1MID0gaHRtbDtcbiAgICBmb3IgKHZhclxuICAgICAgbm9kZXMgPSBlbC5xdWVyeVNlbGVjdG9yQWxsKHJlZ2lzdGVyZWQuam9pbignLCcpKSxcbiAgICAgIGkgPSBub2Rlcy5sZW5ndGg7IGktLTsgaW5pdGlhbGl6ZShub2Rlc1tpXSlcbiAgICApIHt9XG4gICAgcmV0dXJuIGVsO1xuICB9KTtcbn0oZG9jdW1lbnQpKTsiLCIvKipcbiAqIE1pY3JvRXZlbnQgLSB0byBtYWtlIGFueSBqcyBvYmplY3QgYW4gZXZlbnQgZW1pdHRlciAoc2VydmVyIG9yIGJyb3dzZXIpXG4gKiBcbiAqIC0gcHVyZSBqYXZhc2NyaXB0IC0gc2VydmVyIGNvbXBhdGlibGUsIGJyb3dzZXIgY29tcGF0aWJsZVxuICogLSBkb250IHJlbHkgb24gdGhlIGJyb3dzZXIgZG9tc1xuICogLSBzdXBlciBzaW1wbGUgLSB5b3UgZ2V0IGl0IGltbWVkaWF0ZWx5LCBubyBteXN0ZXJ5LCBubyBtYWdpYyBpbnZvbHZlZFxuICpcbiAqIC0gY3JlYXRlIGEgTWljcm9FdmVudERlYnVnIHdpdGggZ29vZGllcyB0byBkZWJ1Z1xuICogICAtIG1ha2UgaXQgc2FmZXIgdG8gdXNlXG4qL1xuXG4vKiogTk9URTogVGhpcyBsaWJyYXJ5IGlzIGN1c3RvbWl6ZWQgZm9yIE9uc2VuIFVJLiAqL1xuXG52YXIgTWljcm9FdmVudCAgPSBmdW5jdGlvbigpe307XG5NaWNyb0V2ZW50LnByb3RvdHlwZSAgPSB7XG4gIG9uICA6IGZ1bmN0aW9uKGV2ZW50LCBmY3Qpe1xuICAgIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgICB0aGlzLl9ldmVudHNbZXZlbnRdID0gdGhpcy5fZXZlbnRzW2V2ZW50XSB8fCBbXTtcbiAgICB0aGlzLl9ldmVudHNbZXZlbnRdLnB1c2goZmN0KTtcbiAgfSxcbiAgb25jZSA6IGZ1bmN0aW9uKGV2ZW50LCBmY3Qpe1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgd3JhcHBlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5vZmYoZXZlbnQsIHdyYXBwZXIpO1xuICAgICAgcmV0dXJuIGZjdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgdGhpcy5vbihldmVudCwgd3JhcHBlcik7XG4gIH0sXG4gIG9mZiAgOiBmdW5jdGlvbihldmVudCwgZmN0KXtcbiAgICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gICAgaWYoIGV2ZW50IGluIHRoaXMuX2V2ZW50cyA9PT0gZmFsc2UgICkgIHJldHVybjtcbiAgICB0aGlzLl9ldmVudHNbZXZlbnRdLnNwbGljZSh0aGlzLl9ldmVudHNbZXZlbnRdLmluZGV4T2YoZmN0KSwgMSk7XG4gIH0sXG4gIGVtaXQgOiBmdW5jdGlvbihldmVudCAvKiAsIGFyZ3MuLi4gKi8pe1xuICAgIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgICBpZiggZXZlbnQgaW4gdGhpcy5fZXZlbnRzID09PSBmYWxzZSAgKSAgcmV0dXJuO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9ldmVudHNbZXZlbnRdLmxlbmd0aDsgaSsrKXtcbiAgICAgIHRoaXMuX2V2ZW50c1tldmVudF1baV0uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIG1peGluIHdpbGwgZGVsZWdhdGUgYWxsIE1pY3JvRXZlbnQuanMgZnVuY3Rpb24gaW4gdGhlIGRlc3RpbmF0aW9uIG9iamVjdFxuICpcbiAqIC0gcmVxdWlyZSgnTWljcm9FdmVudCcpLm1peGluKEZvb2Jhcikgd2lsbCBtYWtlIEZvb2JhciBhYmxlIHRvIHVzZSBNaWNyb0V2ZW50XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRoZSBvYmplY3Qgd2hpY2ggd2lsbCBzdXBwb3J0IE1pY3JvRXZlbnRcbiovXG5NaWNyb0V2ZW50Lm1peGluICA9IGZ1bmN0aW9uKGRlc3RPYmplY3Qpe1xuICB2YXIgcHJvcHMgPSBbJ29uJywgJ29uY2UnLCAnb2ZmJywgJ2VtaXQnXTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSArKyl7XG4gICAgaWYoIHR5cGVvZiBkZXN0T2JqZWN0ID09PSAnZnVuY3Rpb24nICl7XG4gICAgICBkZXN0T2JqZWN0LnByb3RvdHlwZVtwcm9wc1tpXV0gID0gTWljcm9FdmVudC5wcm90b3R5cGVbcHJvcHNbaV1dO1xuICAgIH1lbHNle1xuICAgICAgZGVzdE9iamVjdFtwcm9wc1tpXV0gPSBNaWNyb0V2ZW50LnByb3RvdHlwZVtwcm9wc1tpXV07XG4gICAgfVxuICB9XG59XG5cbi8vIGV4cG9ydCBpbiBjb21tb24ganNcbmlmKCB0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmICgnZXhwb3J0cycgaW4gbW9kdWxlKSl7XG4gIG1vZHVsZS5leHBvcnRzICA9IE1pY3JvRXZlbnQ7XG59XG5cbndpbmRvdy5NaWNyb0V2ZW50ID0gTWljcm9FdmVudDtcbiIsIihmdW5jdGlvbiAocm9vdCkge1xuXG4gIC8vIFN0b3JlIHNldFRpbWVvdXQgcmVmZXJlbmNlIHNvIHByb21pc2UtcG9seWZpbGwgd2lsbCBiZSB1bmFmZmVjdGVkIGJ5XG4gIC8vIG90aGVyIGNvZGUgbW9kaWZ5aW5nIHNldFRpbWVvdXQgKGxpa2Ugc2lub24udXNlRmFrZVRpbWVycygpKVxuICB2YXIgc2V0VGltZW91dEZ1bmMgPSBzZXRUaW1lb3V0O1xuXG4gIGZ1bmN0aW9uIG5vb3AoKSB7fVxuICBcbiAgLy8gUG9seWZpbGwgZm9yIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kXG4gIGZ1bmN0aW9uIGJpbmQoZm4sIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgZm4uYXBwbHkodGhpc0FyZywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gUHJvbWlzZShmbikge1xuICAgIGlmICh0eXBlb2YgdGhpcyAhPT0gJ29iamVjdCcpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb21pc2VzIG11c3QgYmUgY29uc3RydWN0ZWQgdmlhIG5ldycpO1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vdCBhIGZ1bmN0aW9uJyk7XG4gICAgdGhpcy5fc3RhdGUgPSAwO1xuICAgIHRoaXMuX2hhbmRsZWQgPSBmYWxzZTtcbiAgICB0aGlzLl92YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kZWZlcnJlZHMgPSBbXTtcblxuICAgIGRvUmVzb2x2ZShmbiwgdGhpcyk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGUoc2VsZiwgZGVmZXJyZWQpIHtcbiAgICB3aGlsZSAoc2VsZi5fc3RhdGUgPT09IDMpIHtcbiAgICAgIHNlbGYgPSBzZWxmLl92YWx1ZTtcbiAgICB9XG4gICAgaWYgKHNlbGYuX3N0YXRlID09PSAwKSB7XG4gICAgICBzZWxmLl9kZWZlcnJlZHMucHVzaChkZWZlcnJlZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNlbGYuX2hhbmRsZWQgPSB0cnVlO1xuICAgIFByb21pc2UuX2ltbWVkaWF0ZUZuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjYiA9IHNlbGYuX3N0YXRlID09PSAxID8gZGVmZXJyZWQub25GdWxmaWxsZWQgOiBkZWZlcnJlZC5vblJlamVjdGVkO1xuICAgICAgaWYgKGNiID09PSBudWxsKSB7XG4gICAgICAgIChzZWxmLl9zdGF0ZSA9PT0gMSA/IHJlc29sdmUgOiByZWplY3QpKGRlZmVycmVkLnByb21pc2UsIHNlbGYuX3ZhbHVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHJldDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldCA9IGNiKHNlbGYuX3ZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGRlZmVycmVkLnByb21pc2UsIGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXNvbHZlKGRlZmVycmVkLnByb21pc2UsIHJldCk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlKHNlbGYsIG5ld1ZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFByb21pc2UgUmVzb2x1dGlvbiBQcm9jZWR1cmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9wcm9taXNlcy1hcGx1cy9wcm9taXNlcy1zcGVjI3RoZS1wcm9taXNlLXJlc29sdXRpb24tcHJvY2VkdXJlXG4gICAgICBpZiAobmV3VmFsdWUgPT09IHNlbGYpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0EgcHJvbWlzZSBjYW5ub3QgYmUgcmVzb2x2ZWQgd2l0aCBpdHNlbGYuJyk7XG4gICAgICBpZiAobmV3VmFsdWUgJiYgKHR5cGVvZiBuZXdWYWx1ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG5ld1ZhbHVlID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICB2YXIgdGhlbiA9IG5ld1ZhbHVlLnRoZW47XG4gICAgICAgIGlmIChuZXdWYWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICBzZWxmLl9zdGF0ZSA9IDM7XG4gICAgICAgICAgc2VsZi5fdmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICBmaW5hbGUoc2VsZik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZG9SZXNvbHZlKGJpbmQodGhlbiwgbmV3VmFsdWUpLCBzZWxmKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNlbGYuX3N0YXRlID0gMTtcbiAgICAgIHNlbGYuX3ZhbHVlID0gbmV3VmFsdWU7XG4gICAgICBmaW5hbGUoc2VsZik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmVqZWN0KHNlbGYsIGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlamVjdChzZWxmLCBuZXdWYWx1ZSkge1xuICAgIHNlbGYuX3N0YXRlID0gMjtcbiAgICBzZWxmLl92YWx1ZSA9IG5ld1ZhbHVlO1xuICAgIGZpbmFsZShzZWxmKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmFsZShzZWxmKSB7XG4gICAgaWYgKHNlbGYuX3N0YXRlID09PSAyICYmIHNlbGYuX2RlZmVycmVkcy5sZW5ndGggPT09IDApIHtcbiAgICAgIFByb21pc2UuX2ltbWVkaWF0ZUZuKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXNlbGYuX2hhbmRsZWQpIHtcbiAgICAgICAgICBQcm9taXNlLl91bmhhbmRsZWRSZWplY3Rpb25GbihzZWxmLl92YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzZWxmLl9kZWZlcnJlZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGhhbmRsZShzZWxmLCBzZWxmLl9kZWZlcnJlZHNbaV0pO1xuICAgIH1cbiAgICBzZWxmLl9kZWZlcnJlZHMgPSBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gSGFuZGxlcihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgcHJvbWlzZSkge1xuICAgIHRoaXMub25GdWxmaWxsZWQgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IG51bGw7XG4gICAgdGhpcy5vblJlamVjdGVkID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT09ICdmdW5jdGlvbicgPyBvblJlamVjdGVkIDogbnVsbDtcbiAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRha2UgYSBwb3RlbnRpYWxseSBtaXNiZWhhdmluZyByZXNvbHZlciBmdW5jdGlvbiBhbmQgbWFrZSBzdXJlXG4gICAqIG9uRnVsZmlsbGVkIGFuZCBvblJlamVjdGVkIGFyZSBvbmx5IGNhbGxlZCBvbmNlLlxuICAgKlxuICAgKiBNYWtlcyBubyBndWFyYW50ZWVzIGFib3V0IGFzeW5jaHJvbnkuXG4gICAqL1xuICBmdW5jdGlvbiBkb1Jlc29sdmUoZm4sIHNlbGYpIHtcbiAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBmbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIHJlc29sdmUoc2VsZiwgdmFsdWUpO1xuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgcmVqZWN0KHNlbGYsIHJlYXNvbik7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgcmVqZWN0KHNlbGYsIGV4KTtcbiAgICB9XG4gIH1cblxuICBQcm9taXNlLnByb3RvdHlwZVsnY2F0Y2gnXSA9IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGVkKTtcbiAgfTtcblxuICBQcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgdmFyIHByb20gPSBuZXcgKHRoaXMuY29uc3RydWN0b3IpKG5vb3ApO1xuXG4gICAgaGFuZGxlKHRoaXMsIG5ldyBIYW5kbGVyKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBwcm9tKSk7XG4gICAgcmV0dXJuIHByb207XG4gIH07XG5cbiAgUHJvbWlzZS5hbGwgPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnIpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHJlc29sdmUoW10pO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IGFyZ3MubGVuZ3RoO1xuXG4gICAgICBmdW5jdGlvbiByZXMoaSwgdmFsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAgIHZhciB0aGVuID0gdmFsLnRoZW47XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgdGhlbi5jYWxsKHZhbCwgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgIHJlcyhpLCB2YWwpO1xuICAgICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGFyZ3NbaV0gPSB2YWw7XG4gICAgICAgICAgaWYgKC0tcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgICAgICByZXNvbHZlKGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICByZWplY3QoZXgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXMoaSwgYXJnc1tpXSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgUHJvbWlzZS5yZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IFByb21pc2UpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgIH0pO1xuICB9O1xuXG4gIFByb21pc2UucmVqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHJlamVjdCh2YWx1ZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgUHJvbWlzZS5yYWNlID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdmFsdWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhbHVlc1tpXS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gVXNlIHBvbHlmaWxsIGZvciBzZXRJbW1lZGlhdGUgZm9yIHBlcmZvcm1hbmNlIGdhaW5zXG4gIFByb21pc2UuX2ltbWVkaWF0ZUZuID0gKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicgJiYgZnVuY3Rpb24gKGZuKSB7IHNldEltbWVkaWF0ZShmbik7IH0pIHx8XG4gICAgZnVuY3Rpb24gKGZuKSB7XG4gICAgICBzZXRUaW1lb3V0RnVuYyhmbiwgMCk7XG4gICAgfTtcblxuICBQcm9taXNlLl91bmhhbmRsZWRSZWplY3Rpb25GbiA9IGZ1bmN0aW9uIF91bmhhbmRsZWRSZWplY3Rpb25GbihlcnIpIHtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUpIHtcbiAgICAgIGNvbnNvbGUud2FybignUG9zc2libGUgVW5oYW5kbGVkIFByb21pc2UgUmVqZWN0aW9uOicsIGVycik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBpbW1lZGlhdGUgZnVuY3Rpb24gdG8gZXhlY3V0ZSBjYWxsYmFja3NcbiAgICogQHBhcmFtIGZuIHtmdW5jdGlvbn0gRnVuY3Rpb24gdG8gZXhlY3V0ZVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgUHJvbWlzZS5fc2V0SW1tZWRpYXRlRm4gPSBmdW5jdGlvbiBfc2V0SW1tZWRpYXRlRm4oZm4pIHtcbiAgICBQcm9taXNlLl9pbW1lZGlhdGVGbiA9IGZuO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGFuZ2UgdGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gdW5oYW5kbGVkIHJlamVjdGlvblxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBleGVjdXRlIG9uIHVuaGFuZGxlZCByZWplY3Rpb25cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIFByb21pc2UuX3NldFVuaGFuZGxlZFJlamVjdGlvbkZuID0gZnVuY3Rpb24gX3NldFVuaGFuZGxlZFJlamVjdGlvbkZuKGZuKSB7XG4gICAgUHJvbWlzZS5fdW5oYW5kbGVkUmVqZWN0aW9uRm4gPSBmbjtcbiAgfTtcblxuICBpZiAoIXdpbmRvdy5Qcm9taXNlKSB7XG4gICAgd2luZG93LlByb21pc2UgPSBQcm9taXNlO1xuICB9XG59KSh0aGlzKTtcbiIsIi8qXG5Db3B5cmlnaHQgKGMpIDIwMTIgQmFybmVzYW5kbm9ibGUuY29tLCBsbGMsIERvbmF2b24gV2VzdCwgYW5kIERvbWVuaWMgRGVuaWNvbGFcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXG5hIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcblwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xud2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG5wZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbnRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbmluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG5NRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRVxuTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTlxuT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG5XSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHNldEltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIGFkZEZyb21TZXRJbW1lZGlhdGVBcmd1bWVudHMoYXJncykge1xuICAgICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gcGFydGlhbGx5QXBwbGllZC5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyB0aGUgc2FtZSBhcmd1bWVudHMgYXMgc2V0SW1tZWRpYXRlLCBidXRcbiAgICAvLyByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCByZXF1aXJlcyBubyBhcmd1bWVudHMuXG4gICAgZnVuY3Rpb24gcGFydGlhbGx5QXBwbGllZChoYW5kbGVyKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgKG5ldyBGdW5jdGlvbihcIlwiICsgaGFuZGxlcikpKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxuICAgICAgICAgICAgc2V0VGltZW91dChwYXJ0aWFsbHlBcHBsaWVkKHJ1bklmUHJlc2VudCwgaGFuZGxlKSwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0YXNrKCk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGFkZEZyb21TZXRJbW1lZGlhdGVBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2socGFydGlhbGx5QXBwbGllZChydW5JZlByZXNlbnQsIGhhbmRsZSkpO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGFkZEZyb21TZXRJbW1lZGlhdGVBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICBzZXRJbW1lZGlhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBhZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHBhcnRpYWxseUFwcGxpZWQocnVuSWZQcmVzZW50LCBoYW5kbGUpLCAwKTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufShmdW5jdGlvbigpIHtyZXR1cm4gdGhpczt9KCkpKTtcbiIsIihmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBWaWV3cG9ydCgpIHtcblxuICAgICAgICB0aGlzLlBSRV9JT1M3X1ZJRVdQT1JUID0gXCJpbml0aWFsLXNjYWxlPTEsIG1heGltdW0tc2NhbGU9MSwgdXNlci1zY2FsYWJsZT1ub1wiO1xuICAgICAgICB0aGlzLklPUzdfVklFV1BPUlQgPSBcImluaXRpYWwtc2NhbGU9MSwgbWF4aW11bS1zY2FsZT0xLCB1c2VyLXNjYWxhYmxlPW5vXCI7XG4gICAgICAgIHRoaXMuREVGQVVMVF9WSUVXUE9SVCA9IFwiaW5pdGlhbC1zY2FsZT0xLCBtYXhpbXVtLXNjYWxlPTEsIHVzZXItc2NhbGFibGU9bm9cIjtcblxuICAgICAgICB0aGlzLmVuc3VyZVZpZXdwb3J0RWxlbWVudCgpO1xuICAgICAgICB0aGlzLnBsYXRmb3JtID0ge307XG4gICAgICAgIHRoaXMucGxhdGZvcm0ubmFtZSA9IHRoaXMuZ2V0UGxhdGZvcm1OYW1lKCk7XG4gICAgICAgIHRoaXMucGxhdGZvcm0udmVyc2lvbiA9IHRoaXMuZ2V0UGxhdGZvcm1WZXJzaW9uKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFZpZXdwb3J0LnByb3RvdHlwZS5lbnN1cmVWaWV3cG9ydEVsZW1lbnQgPSBmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLnZpZXdwb3J0RWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbbmFtZT12aWV3cG9ydF0nKTtcbiAgICAgICAgaWYoIXRoaXMudmlld3BvcnRFbGVtZW50KXtcbiAgICAgICAgICAgIHRoaXMudmlld3BvcnRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbWV0YScpO1xuICAgICAgICAgICAgdGhpcy52aWV3cG9ydEVsZW1lbnQubmFtZSA9IFwidmlld3BvcnRcIjtcbiAgICAgICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQodGhpcy52aWV3cG9ydEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIFZpZXdwb3J0LnByb3RvdHlwZS5zZXR1cCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMudmlld3BvcnRFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy52aWV3cG9ydEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLW5vLWFkanVzdCcpID09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMudmlld3BvcnRFbGVtZW50LmdldEF0dHJpYnV0ZSgnY29udGVudCcpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wbGF0Zm9ybS5uYW1lID09ICdpb3MnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGxhdGZvcm0udmVyc2lvbiA+PSA3ICYmIGlzV2ViVmlldygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld3BvcnRFbGVtZW50LnNldEF0dHJpYnV0ZSgnY29udGVudCcsIHRoaXMuSU9TN19WSUVXUE9SVCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3cG9ydEVsZW1lbnQuc2V0QXR0cmlidXRlKCdjb250ZW50JywgdGhpcy5QUkVfSU9TN19WSUVXUE9SVCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdwb3J0RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnLCB0aGlzLkRFRkFVTFRfVklFV1BPUlQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaXNXZWJWaWV3KCkge1xuICAgICAgICAgICAgcmV0dXJuICEhKHdpbmRvdy5jb3Jkb3ZhIHx8IHdpbmRvdy5waG9uZWdhcCB8fCB3aW5kb3cuUGhvbmVHYXApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFZpZXdwb3J0LnByb3RvdHlwZS5nZXRQbGF0Zm9ybU5hbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0FuZHJvaWQvaSkpIHtcbiAgICAgICAgICAgIHJldHVybiBcImFuZHJvaWRcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9pUGhvbmV8aVBhZHxpUG9kL2kpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJpb3NcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVua25vd25cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuXG4gICAgVmlld3BvcnQucHJvdG90eXBlLmdldFBsYXRmb3JtVmVyc2lvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdPUyAnKTtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5OdW1iZXIod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuc3Vic3RyKHN0YXJ0ICsgMywgMykucmVwbGFjZSgnXycsICcuJykpO1xuICAgIH07XG5cbiAgICB3aW5kb3cuVmlld3BvcnQgPSBWaWV3cG9ydDtcbn0pKCk7XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBPcGVuIFRlY2hub2xvZ2llcywgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAuICBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbi8vIEphdmFTY3JpcHQgRHluYW1pYyBDb250ZW50IHNoaW0gZm9yIFdpbmRvd3MgU3RvcmUgYXBwc1xuKGZ1bmN0aW9uICgpIHtcblxuICAgIGlmICh3aW5kb3cuTVNBcHAgJiYgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24pIHtcblxuICAgICAgICAvLyBTb21lIG5vZGVzIHdpbGwgaGF2ZSBhbiBcImF0dHJpYnV0ZXNcIiBwcm9wZXJ0eSB3aGljaCBzaGFkb3dzIHRoZSBOb2RlLnByb3RvdHlwZS5hdHRyaWJ1dGVzIHByb3BlcnR5XG4gICAgICAgIC8vICBhbmQgbWVhbnMgd2UgZG9uJ3QgYWN0dWFsbHkgc2VlIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBOb2RlIChpbnRlcmVzdGluZ2x5IHRoZSBWUyBkZWJ1ZyBjb25zb2xlXG4gICAgICAgIC8vICBhcHBlYXJzIHRvIHN1ZmZlciBmcm9tIHRoZSBzYW1lIGlzc3VlKS5cbiAgICAgICAgLy9cbiAgICAgICAgdmFyIEVsZW1lbnRfc2V0QXR0cmlidXRlID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihFbGVtZW50LnByb3RvdHlwZSwgXCJzZXRBdHRyaWJ1dGVcIikudmFsdWU7XG4gICAgICAgIHZhciBFbGVtZW50X3JlbW92ZUF0dHJpYnV0ZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoRWxlbWVudC5wcm90b3R5cGUsIFwicmVtb3ZlQXR0cmlidXRlXCIpLnZhbHVlO1xuICAgICAgICB2YXIgSFRNTEVsZW1lbnRfaW5zZXJ0QWRqYWNlbnRIVE1MUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihIVE1MRWxlbWVudC5wcm90b3R5cGUsIFwiaW5zZXJ0QWRqYWNlbnRIVE1MXCIpO1xuICAgICAgICB2YXIgTm9kZV9nZXRfYXR0cmlidXRlcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTm9kZS5wcm90b3R5cGUsIFwiYXR0cmlidXRlc1wiKS5nZXQ7XG4gICAgICAgIHZhciBOb2RlX2dldF9jaGlsZE5vZGVzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihOb2RlLnByb3RvdHlwZSwgXCJjaGlsZE5vZGVzXCIpLmdldDtcbiAgICAgICAgdmFyIGRldGVjdGlvbkRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0QXR0cmlidXRlcyhlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gTm9kZV9nZXRfYXR0cmlidXRlcy5jYWxsKGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc2V0QXR0cmlidXRlKGVsZW1lbnQsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgRWxlbWVudF9zZXRBdHRyaWJ1dGUuY2FsbChlbGVtZW50LCBhdHRyaWJ1dGUsIHZhbHVlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZUF0dHJpYnV0ZShlbGVtZW50LCBhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIEVsZW1lbnRfcmVtb3ZlQXR0cmlidXRlLmNhbGwoZWxlbWVudCwgYXR0cmlidXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNoaWxkTm9kZXMoZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIE5vZGVfZ2V0X2NoaWxkTm9kZXMuY2FsbChlbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGVtcHR5KGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHdoaWxlIChlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVDaGlsZChlbGVtZW50Lmxhc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpbnNlcnRBZGphY2VudEhUTUwoZWxlbWVudCwgcG9zaXRpb24sIGh0bWwpIHtcbiAgICAgICAgICAgIEhUTUxFbGVtZW50X2luc2VydEFkamFjZW50SFRNTFByb3BlcnR5RGVzY3JpcHRvci52YWx1ZS5jYWxsKGVsZW1lbnQsIHBvc2l0aW9uLCBodG1sKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGluVW5zYWZlTW9kZSgpIHtcbiAgICAgICAgICAgIHZhciBpc1Vuc2FmZSA9IHRydWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGRldGVjdGlvbkRpdi5pbm5lckhUTUwgPSBcIjx0ZXN0Lz5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIGlzVW5zYWZlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpc1Vuc2FmZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNsZWFuc2UoaHRtbCwgdGFyZ2V0RWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIGNsZWFuZXIgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoXCJjbGVhbmVyXCIpO1xuICAgICAgICAgICAgZW1wdHkoY2xlYW5lci5kb2N1bWVudEVsZW1lbnQpO1xuICAgICAgICAgICAgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGluc2VydEFkamFjZW50SFRNTChjbGVhbmVyLmRvY3VtZW50RWxlbWVudCwgXCJhZnRlcmJlZ2luXCIsIGh0bWwpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBzY3JpcHRzID0gY2xlYW5lci5kb2N1bWVudEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoc2NyaXB0cywgZnVuY3Rpb24gKHNjcmlwdCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoc2NyaXB0LnR5cGUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHQudHlwZSA9IFwidGV4dC9pbmVydFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0L2phdmFzY3JpcHRcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRleHQvZWNtYXNjcmlwdFwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGV4dC94LWphdmFzY3JpcHRcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRleHQvanNjcmlwdFwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGV4dC9saXZlc2NyaXB0XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0L2phdmFzY3JpcHQxLjFcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRleHQvamF2YXNjcmlwdDEuMlwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGV4dC9qYXZhc2NyaXB0MS4zXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHQudHlwZSA9IFwidGV4dC9pbmVydC1cIiArIHNjcmlwdC50eXBlLnNsaWNlKFwidGV4dC9cIi5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhcHBsaWNhdGlvbi94LWphdmFzY3JpcHRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcmlwdC50eXBlID0gXCJhcHBsaWNhdGlvbi9pbmVydC1cIiArIHNjcmlwdC50eXBlLnNsaWNlKFwiYXBwbGljYXRpb24vXCIubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gY2xlYW5zZUF0dHJpYnV0ZXMoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gZ2V0QXR0cmlidXRlcyhlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlcyAmJiBhdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoZSBhdHRyaWJ1dGVzIGNvbGxlY3Rpb24gaXMgbGl2ZSBpdCBpcyBzaW1wbGVyIHRvIHF1ZXVlIHVwIHRoZSByZW5hbWVzXG4gICAgICAgICAgICAgICAgICAgIHZhciBldmVudHM7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhdHRyaWJ1dGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gYXR0cmlidXRlLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG5hbWVbMF0gPT09IFwib1wiIHx8IG5hbWVbMF0gPT09IFwiT1wiKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChuYW1lWzFdID09PSBcIm5cIiB8fCBuYW1lWzFdID09PSBcIk5cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudHMgPSBldmVudHMgfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzLnB1c2goeyBuYW1lOiBhdHRyaWJ1dGUubmFtZSwgdmFsdWU6IGF0dHJpYnV0ZS52YWx1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZXZlbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IGV2ZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVBdHRyaWJ1dGUoZWxlbWVudCwgYXR0cmlidXRlLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEF0dHJpYnV0ZShlbGVtZW50LCBcIngtXCIgKyBhdHRyaWJ1dGUubmFtZSwgYXR0cmlidXRlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBjaGlsZE5vZGVzKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjbGVhbnNlQXR0cmlidXRlcyhjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xlYW5zZUF0dHJpYnV0ZXMoY2xlYW5lci5kb2N1bWVudEVsZW1lbnQpO1xuXG4gICAgICAgICAgICB2YXIgY2xlYW5lZE5vZGVzID0gW107XG5cbiAgICAgICAgICAgIGlmICh0YXJnZXRFbGVtZW50LnRhZ05hbWUgPT09ICdIVE1MJykge1xuICAgICAgICAgICAgICAgIGNsZWFuZWROb2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRvY3VtZW50LmFkb3B0Tm9kZShjbGVhbmVyLmRvY3VtZW50RWxlbWVudCkuY2hpbGROb2Rlcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjbGVhbmVyLmhlYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW5lZE5vZGVzID0gY2xlYW5lZE5vZGVzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5hZG9wdE5vZGUoY2xlYW5lci5oZWFkKS5jaGlsZE5vZGVzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjbGVhbmVyLmJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW5lZE5vZGVzID0gY2xlYW5lZE5vZGVzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5hZG9wdE5vZGUoY2xlYW5lci5ib2R5KS5jaGlsZE5vZGVzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY2xlYW5lZE5vZGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY2xlYW5zZVByb3BlcnR5U2V0dGVyKHByb3BlcnR5LCBzZXR0ZXIpIHtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEhUTUxFbGVtZW50LnByb3RvdHlwZSwgcHJvcGVydHkpO1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsU2V0dGVyID0gcHJvcGVydHlEZXNjcmlwdG9yLnNldDtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIVE1MRWxlbWVudC5wcm90b3R5cGUsIHByb3BlcnR5LCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBwcm9wZXJ0eURlc2NyaXB0b3IuZ2V0LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHdpbmRvdy5XaW5KUyAmJiB3aW5kb3cuV2luSlMuX2V4ZWNVbnNhZmUgJiYgaW5VbnNhZmVNb2RlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsU2V0dGVyLmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVzID0gY2xlYW5zZSh2YWx1ZSwgdGhhdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGVyKHByb3BlcnR5RGVzY3JpcHRvciwgdGhhdCwgbm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHByb3BlcnR5RGVzY3JpcHRvci5lbnVtZXJhYmxlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogcHJvcGVydHlEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFuc2VQcm9wZXJ0eVNldHRlcihcImlubmVySFRNTFwiLCBmdW5jdGlvbiAocHJvcGVydHlEZXNjcmlwdG9yLCB0YXJnZXQsIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICBlbXB0eSh0YXJnZXQpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKGVsZW1lbnRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNsZWFuc2VQcm9wZXJ0eVNldHRlcihcIm91dGVySFRNTFwiLCBmdW5jdGlvbiAocHJvcGVydHlEZXNjcmlwdG9yLCB0YXJnZXQsIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KFwiYWZ0ZXJlbmRcIiwgZWxlbWVudHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGFyZ2V0KTtcbiAgICAgICAgfSk7XG5cbiAgICB9XG5cbn0oKSk7IiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB1bndyYXAgPSBzdHJpbmcgPT4gc3RyaW5nLnNsaWNlKDEsIC0xKTtcbmNvbnN0IGlzT2JqZWN0U3RyaW5nID0gc3RyaW5nID0+IHN0cmluZy5zdGFydHNXaXRoKCd7JykgJiYgc3RyaW5nLmVuZHNXaXRoKCd9Jyk7XG5jb25zdCBpc0FycmF5U3RyaW5nID0gc3RyaW5nID0+IHN0cmluZy5zdGFydHNXaXRoKCdbJykgJiYgc3RyaW5nLmVuZHNXaXRoKCddJyk7XG5jb25zdCBpc1F1b3RlZFN0cmluZyA9IHN0cmluZyA9PiAoc3RyaW5nLnN0YXJ0c1dpdGgoJ1xcJycpICYmIHN0cmluZy5lbmRzV2l0aCgnXFwnJykpIHx8IChzdHJpbmcuc3RhcnRzV2l0aCgnXCInKSAmJiBzdHJpbmcuZW5kc1dpdGgoJ1wiJykpO1xuXG5jb25zdCBlcnJvciA9ICh0b2tlbiwgc3RyaW5nLCBvcmlnaW5hbFN0cmluZykgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgdG9rZW4gXFwnJyArIHRva2VuICsgJ1xcJyBhdCBwb3NpdGlvbiAnICsgKG9yaWdpbmFsU3RyaW5nLmxlbmd0aCAtIHN0cmluZy5sZW5ndGggLSAxKSArICcgaW4gc3RyaW5nOiBcXCcnICsgb3JpZ2luYWxTdHJpbmcgKyAnXFwnJyk7XG59O1xuXG5jb25zdCBwcm9jZXNzVG9rZW4gPSAodG9rZW4sIHN0cmluZywgb3JpZ2luYWxTdHJpbmcpID0+IHtcbiAgaWYgKHRva2VuID09PSAndHJ1ZScgfHwgdG9rZW4gPT09ICdmYWxzZScpIHtcbiAgICByZXR1cm4gdG9rZW4gPT09ICd0cnVlJztcbiAgfSBlbHNlIGlmIChpc1F1b3RlZFN0cmluZyh0b2tlbikpIHtcbiAgICByZXR1cm4gdW53cmFwKHRva2VuKTtcbiAgfSBlbHNlIGlmICghaXNOYU4odG9rZW4pKSB7XG4gICAgcmV0dXJuICsodG9rZW4pO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0U3RyaW5nKHRva2VuKSkge1xuICAgIHJldHVybiBwYXJzZU9iamVjdCh1bndyYXAodG9rZW4pKTtcbiAgfSBlbHNlIGlmIChpc0FycmF5U3RyaW5nKHRva2VuKSkge1xuICAgIHJldHVybiBwYXJzZUFycmF5KHVud3JhcCh0b2tlbikpO1xuICB9IGVsc2Uge1xuICAgIGVycm9yKHRva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKTtcbiAgfVxufTtcblxuY29uc3QgbmV4dFRva2VuID0gKHN0cmluZykgPT4ge1xuICBzdHJpbmcgPSBzdHJpbmcudHJpbUxlZnQoKTtcbiAgbGV0IGxpbWl0ID0gc3RyaW5nLmxlbmd0aDtcblxuICBpZiAoc3RyaW5nWzBdID09PSAnOicgfHwgc3RyaW5nWzBdID09PSAnLCcpIHtcblxuICAgIGxpbWl0ID0gMTtcblxuICB9IGVsc2UgaWYgKHN0cmluZ1swXSA9PT0gJ3snIHx8IHN0cmluZ1swXSA9PT0gJ1snKSB7XG5cbiAgICBjb25zdCBjID0gc3RyaW5nLmNoYXJDb2RlQXQoMCk7XG4gICAgbGV0IG5lc3RlZE9iamVjdCA9IDE7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChzdHJpbmcuY2hhckNvZGVBdChpKSA9PT0gYykge1xuICAgICAgICBuZXN0ZWRPYmplY3QrKztcbiAgICAgIH0gZWxzZSBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoaSkgPT09IGMgKyAyKSB7XG4gICAgICAgIG5lc3RlZE9iamVjdC0tO1xuICAgICAgICBpZiAobmVzdGVkT2JqZWN0ID09PSAwKSB7XG4gICAgICAgICAgbGltaXQgPSBpICsgMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICB9IGVsc2UgaWYgKHN0cmluZ1swXSA9PT0gJ1xcJycgfHwgc3RyaW5nWzBdID09PSAnXFxcIicpIHtcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoc3RyaW5nW2ldID09PSBzdHJpbmdbMF0pIHtcbiAgICAgICAgbGltaXQgPSBpICsgMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gIH0gZWxzZSB7XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKFsnICcsICcsJywgJzonXS5pbmRleE9mKHN0cmluZ1tpXSkgIT09IC0xKSB7XG4gICAgICAgIGxpbWl0ID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gc3RyaW5nLnNsaWNlKDAsIGxpbWl0KTtcbn07XG5cbmNvbnN0IHBhcnNlT2JqZWN0ID0gKHN0cmluZykgPT4ge1xuICBjb25zdCBpc1ZhbGlkS2V5ID0ga2V5ID0+IC9eW0EtWl9cXCRdW0EtWjAtOV9cXCRdKiQvaS50ZXN0KGtleSk7XG5cbiAgc3RyaW5nID0gc3RyaW5nLnRyaW0oKTtcbiAgY29uc3Qgb3JpZ2luYWxTdHJpbmcgPSBzdHJpbmc7XG4gIGNvbnN0IG9iamVjdCA9IHt9O1xuICBsZXQgcmVhZGluZ0tleSA9IHRydWUsIGtleSwgcHJldmlvdXNUb2tlbiwgdG9rZW47XG5cbiAgd2hpbGUoc3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICBwcmV2aW91c1Rva2VuID0gdG9rZW47XG4gICAgdG9rZW4gPSBuZXh0VG9rZW4oc3RyaW5nKTtcbiAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2UodG9rZW4ubGVuZ3RoLCBzdHJpbmcubGVuZ3RoKS50cmltTGVmdCgpO1xuXG4gICAgaWYgKCh0b2tlbiA9PT0gJzonICYmICghcmVhZGluZ0tleSB8fCAhcHJldmlvdXNUb2tlbiB8fCBwcmV2aW91c1Rva2VuID09PSAnLCcpKVxuICAgICAgIHx8ICh0b2tlbiA9PT0gJywnICYmIHJlYWRpbmdLZXkpXG4gICAgICAgfHwgKHRva2VuICE9PSAnOicgJiYgdG9rZW4gIT09ICcsJyAmJiAocHJldmlvdXNUb2tlbiAmJiBwcmV2aW91c1Rva2VuICE9PSAnLCcgJiYgcHJldmlvdXNUb2tlbiAhPT0gJzonKSkpIHtcbiAgICAgIGVycm9yKHRva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKTtcbiAgICB9IGVsc2UgaWYgKHRva2VuID09PSAnOicgJiYgcmVhZGluZ0tleSAmJiBwcmV2aW91c1Rva2VuKSB7XG4gICAgICBpZiAoaXNWYWxpZEtleShwcmV2aW91c1Rva2VuKSkge1xuICAgICAgICBrZXkgPSBwcmV2aW91c1Rva2VuO1xuICAgICAgICByZWFkaW5nS2V5ID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQga2V5IHRva2VuIFxcJycgKyBwcmV2aW91c1Rva2VuICsgJ1xcJyBhdCBwb3NpdGlvbiAwIGluIHN0cmluZzogXFwnJyArIG9yaWdpbmFsU3RyaW5nICsgJ1xcJycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodG9rZW4gPT09ICcsJyAmJiAhcmVhZGluZ0tleSAmJiBwcmV2aW91c1Rva2VuKSB7XG4gICAgICBvYmplY3Rba2V5XSA9IHByb2Nlc3NUb2tlbihwcmV2aW91c1Rva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKTtcbiAgICAgIHJlYWRpbmdLZXkgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0b2tlbikge1xuICAgIG9iamVjdFtrZXldID0gcHJvY2Vzc1Rva2VuKHRva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKTtcbiAgfVxuXG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG5jb25zdCBwYXJzZUFycmF5ID0gKHN0cmluZykgPT4ge1xuICBzdHJpbmcgPSBzdHJpbmcudHJpbSgpO1xuICBjb25zdCBvcmlnaW5hbFN0cmluZyA9IHN0cmluZztcbiAgY29uc3QgYXJyYXkgPSBbXTtcbiAgbGV0IHByZXZpb3VzVG9rZW4sIHRva2VuO1xuXG4gIHdoaWxlKHN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgcHJldmlvdXNUb2tlbiA9IHRva2VuO1xuICAgIHRva2VuID0gbmV4dFRva2VuKHN0cmluZyk7XG4gICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKHRva2VuLmxlbmd0aCwgc3RyaW5nLmxlbmd0aCkudHJpbUxlZnQoKTtcblxuICAgIGlmICh0b2tlbiA9PT0gJywnICYmICghcHJldmlvdXNUb2tlbiB8fCBwcmV2aW91c1Rva2VuID09PSAnLCcpKSB7XG4gICAgICBlcnJvcih0b2tlbiwgc3RyaW5nLCBvcmlnaW5hbFN0cmluZyk7XG4gICAgfSBlbHNlIGlmICh0b2tlbiA9PT0gJywnKSB7XG4gICAgICBhcnJheS5wdXNoKHByb2Nlc3NUb2tlbihwcmV2aW91c1Rva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRva2VuKSB7XG4gICAgaWYgKHRva2VuICE9PSAnLCcpIHtcbiAgICAgIGFycmF5LnB1c2gocHJvY2Vzc1Rva2VuKHRva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yKHRva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXJyYXk7XG59O1xuXG5jb25zdCBwYXJzZSA9IChzdHJpbmcpID0+IHtcbiAgc3RyaW5nID0gc3RyaW5nLnRyaW0oKTtcblxuICBpZiAoaXNPYmplY3RTdHJpbmcoc3RyaW5nKSkge1xuICAgIHJldHVybiBwYXJzZU9iamVjdCh1bndyYXAoc3RyaW5nKSk7XG4gIH0gZWxzZSBpZiAoaXNBcnJheVN0cmluZyhzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHBhcnNlQXJyYXkodW53cmFwKHN0cmluZykpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignUHJvdmlkZWQgc3RyaW5nIG11c3QgYmUgb2JqZWN0IG9yIGFycmF5IGxpa2U6ICcgKyBzdHJpbmcpO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBwYXJzZTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBhbmltYXRpb25PcHRpb25zUGFyc2UgZnJvbSAnLi9hbmltYXRpb24tb3B0aW9ucy1wYXJzZXInO1xuXG5jb25zdCB1dGlsID0ge307XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmcvRnVuY3Rpb259IHF1ZXJ5IGRvdCBjbGFzcyBuYW1lIG9yIG5vZGUgbmFtZSBvciBtYXRjaGVyIGZ1bmN0aW9uLlxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbnV0aWwucHJlcGFyZVF1ZXJ5ID0gKHF1ZXJ5KSA9PiB7XG4gIHJldHVybiBxdWVyeSBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gcXVlcnkgOiAoZWxlbWVudCkgPT4gdXRpbC5tYXRjaChlbGVtZW50LCBxdWVyeSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmcvRnVuY3Rpb259IHF1ZXJ5IGRvdCBjbGFzcyBuYW1lIG9yIG5vZGUgbmFtZS5cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnV0aWwubWF0Y2ggPSAoZWxlbWVudCwgcXVlcnkpID0+IHtcbiAgaWYgKHF1ZXJ5WzBdID09PSAnLicpIHtcbiAgICByZXR1cm4gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMocXVlcnkuc2xpY2UoMSkpO1xuICB9XG4gIHJldHVybiBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IHF1ZXJ5O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nL0Z1bmN0aW9ufSBxdWVyeSBkb3QgY2xhc3MgbmFtZSBvciBub2RlIG5hbWUgb3IgbWF0Y2hlciBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50L251bGx9XG4gKi9cbnV0aWwuZmluZENoaWxkID0gKGVsZW1lbnQsIHF1ZXJ5KSA9PiB7XG4gIGNvbnN0IG1hdGNoID0gdXRpbC5wcmVwYXJlUXVlcnkocXVlcnkpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBlbGVtZW50LmNoaWxkcmVuW2ldO1xuICAgIGlmIChtYXRjaChub2RlKSkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nL0Z1bmN0aW9ufSBxdWVyeSBkb3QgY2xhc3MgbmFtZSBvciBub2RlIG5hbWUgb3IgbWF0Y2hlciBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50L251bGx9XG4gKi9cbnV0aWwuZmluZFBhcmVudCA9IChlbGVtZW50LCBxdWVyeSkgPT4ge1xuICBjb25zdCBtYXRjaCA9IHV0aWwucHJlcGFyZVF1ZXJ5KHF1ZXJ5KTtcblxuICBsZXQgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICBmb3IgKDs7KSB7XG4gICAgaWYgKCFwYXJlbnQgfHwgcGFyZW50ID09PSBkb2N1bWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChtYXRjaChwYXJlbnQpKSB7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbnV0aWwuaXNBdHRhY2hlZCA9IChlbGVtZW50KSA9PiB7XG4gIHdoaWxlIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgIT09IGVsZW1lbnQpIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG51dGlsLmhhc0FueUNvbXBvbmVudEFzUGFyZW50ID0gKGVsZW1lbnQpID0+IHtcbiAgd2hpbGUgKGVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICE9PSBlbGVtZW50KSB7XG4gICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkubWF0Y2goLyhvbnMtbmF2aWdhdG9yfG9ucy10YWJiYXJ8b25zLXNsaWRpbmctbWVudXxvbnMtc3BsaXQtdmlldykvKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gYWN0aW9uIHRvIHByb3BhZ2F0ZVxuICovXG51dGlsLnByb3BhZ2F0ZUFjdGlvbiA9IChlbGVtZW50LCBhY3Rpb24pID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1tpXTtcbiAgICBpZiAoY2hpbGRbYWN0aW9uXSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICBjaGlsZFthY3Rpb25dKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHV0aWwucHJvcGFnYXRlQWN0aW9uKGNoaWxkLCBhY3Rpb24pO1xuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvciAtIHRhZyBhbmQgY2xhc3Mgb25seVxuICogQHBhcmFtIHtPYmplY3R9IHN0eWxlXG4gKiBAcGFyYW0ge0VsZW1lbnR9XG4gKi9cbnV0aWwuY3JlYXRlID0gKHNlbGVjdG9yID0gJycsIHN0eWxlID0ge30pID0+IHtcbiAgY29uc3QgY2xhc3NMaXN0ID0gc2VsZWN0b3Iuc3BsaXQoJy4nKTtcbiAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoY2xhc3NMaXN0LnNoaWZ0KCkgfHwgJ2RpdicpO1xuXG4gIGlmIChjbGFzc0xpc3QubGVuZ3RoKSB7XG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSBjbGFzc0xpc3Quam9pbignICcpO1xuICB9XG5cbiAgdXRpbC5leHRlbmQoZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuXG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gaHRtbFxuICogQHJldHVybiB7RWxlbWVudH1cbiAqL1xudXRpbC5jcmVhdGVFbGVtZW50ID0gKGh0bWwpID0+IHtcbiAgY29uc3Qgd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBpbm5lckhUTUwod3JhcHBlciwgaHRtbCk7XG5cbiAgaWYgKHdyYXBwZXIuY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignXCJodG1sXCIgbXVzdCBiZSBvbmUgd3JhcHBlciBlbGVtZW50LicpO1xuICB9XG5cbiAgcmV0dXJuIHdyYXBwZXIuY2hpbGRyZW5bMF07XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBodG1sXG4gKiBAcmV0dXJuIHtIVE1MRnJhZ21lbnR9XG4gKi9cbnV0aWwuY3JlYXRlRnJhZ21lbnQgPSAoaHRtbCkgPT4ge1xuICBjb25zdCB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGlubmVySFRNTCh3cmFwcGVyLCBodG1sKTtcbiAgY29uc3QgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgd2hpbGUgKHdyYXBwZXIuZmlyc3RDaGlsZCkge1xuICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKHdyYXBwZXIuZmlyc3RDaGlsZCk7XG4gIH1cblxuICByZXR1cm4gZnJhZ21lbnQ7XG59O1xuXG4vKlxuICogQHBhcmFtIHtPYmplY3R9IGRzdCBEZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gc3JjIFNvdXJjZSBvYmplY3QocykuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZWZlcmVuY2UgdG8gYGRzdGAuXG4gKi9cbnV0aWwuZXh0ZW5kID0gKGRzdCwgLi4uYXJncykgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJnc1tpXSkge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGFyZ3NbaV0pO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBrZXlzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbal07XG4gICAgICAgIGRzdFtrZXldID0gYXJnc1tpXVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkc3Q7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBhcnJheUxpa2VcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG51dGlsLmFycmF5RnJvbSA9IChhcnJheUxpa2UpID0+IHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShhcnJheUxpa2UpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30ganNvblN0cmluZ1xuICogQHBhcmFtIHtPYmplY3R9IFtmYWlsU2FmZV1cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xudXRpbC5wYXJzZUpTT05PYmplY3RTYWZlbHkgPSAoanNvblN0cmluZywgZmFpbFNhZmUgPSB7fSkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2UoJycgKyBqc29uU3RyaW5nKTtcbiAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcgJiYgcmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSBjYXRjaChlKSB7XG4gICAgcmV0dXJuIGZhaWxTYWZlO1xuICB9XG4gIHJldHVybiBmYWlsU2FmZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggLSBwYXRoIHN1Y2ggYXMgJ215QXBwLmNvbnRyb2xsZXJzLmRhdGEubG9hZERhdGEnXG4gKiBAcmV0dXJuIHtBbnl9IC0gd2hhdGV2ZXIgaXMgbG9jYXRlZCBhdCB0aGF0IHBhdGhcbiAqL1xudXRpbC5maW5kRnJvbVBhdGggPSAocGF0aCkgPT4ge1xuICBwYXRoID0gcGF0aC5zcGxpdCgnLicpO1xuICB2YXIgZWwgPSB3aW5kb3csIGtleTtcbiAgd2hpbGUgKGtleSA9IHBhdGguc2hpZnQoKSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbmQtYXNzaWduXG4gICAgZWwgPSBlbFtrZXldO1xuICB9XG4gIHJldHVybiBlbDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gW2RldGFpbF1cbiAqIEByZXR1cm4ge0N1c3RvbUV2ZW50fVxuICovXG51dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQgPSAodGFyZ2V0LCBldmVudE5hbWUsIGRldGFpbCA9IHt9KSA9PiB7XG5cbiAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCB7XG4gICAgYnViYmxlczogdHJ1ZSxcbiAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgIGRldGFpbDogZGV0YWlsXG4gIH0pO1xuXG4gIE9iamVjdC5rZXlzKGRldGFpbCkuZm9yRWFjaChrZXkgPT4ge1xuICAgIGV2ZW50W2tleV0gPSBkZXRhaWxba2V5XTtcbiAgfSk7XG5cbiAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXG4gIHJldHVybiBldmVudDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBtb2RpZmllck5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnV0aWwuaGFzTW9kaWZpZXIgPSAodGFyZ2V0LCBtb2RpZmllck5hbWUpID0+IHtcbiAgaWYgKCF0YXJnZXQuaGFzQXR0cmlidXRlKCdtb2RpZmllcicpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0YXJnZXQuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpLnNwbGl0KC9cXHMrLykuc29tZShlID0+IGUgPT09IG1vZGlmaWVyTmFtZSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gbW9kaWZpZXJOYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIGl0IHdhcyBhZGRlZCBvciBub3QuXG4gKi9cbnV0aWwuYWRkTW9kaWZpZXIgPSAodGFyZ2V0LCBtb2RpZmllck5hbWUpID0+IHtcbiAgaWYgKHV0aWwuaGFzTW9kaWZpZXIodGFyZ2V0LCBtb2RpZmllck5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbW9kaWZpZXJOYW1lID0gbW9kaWZpZXJOYW1lLnRyaW0oKTtcbiAgY29uc3QgbW9kaWZpZXJBdHRyaWJ1dGUgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpIHx8ICcnO1xuICB0YXJnZXQuc2V0QXR0cmlidXRlKCdtb2RpZmllcicsIChtb2RpZmllckF0dHJpYnV0ZSArICcgJyArIG1vZGlmaWVyTmFtZSkudHJpbSgpKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gbW9kaWZpZXJOYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIGl0IHdhcyBmb3VuZCBvciBub3QuXG4gKi9cbnV0aWwucmVtb3ZlTW9kaWZpZXIgPSAodGFyZ2V0LCBtb2RpZmllck5hbWUpID0+IHtcbiAgaWYgKCF0YXJnZXQuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgbW9kaWZpZXJzID0gdGFyZ2V0LmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKS5zcGxpdCgvXFxzKy8pO1xuXG4gIGNvbnN0IG5ld01vZGlmaWVycyA9IG1vZGlmaWVycy5maWx0ZXIoaXRlbSA9PiBpdGVtICYmIGl0ZW0gIT09IG1vZGlmaWVyTmFtZSk7XG4gIHRhcmdldC5zZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJywgbmV3TW9kaWZpZXJzLmpvaW4oJyAnKSk7XG5cbiAgcmV0dXJuIG1vZGlmaWVycy5sZW5ndGggIT09IG5ld01vZGlmaWVycy5sZW5ndGg7XG59O1xuXG51dGlsLnVwZGF0ZVBhcmVudFBvc2l0aW9uID0gKGVsKSA9PiB7XG4gIGlmICghZWwuX3BhcmVudFVwZGF0ZWQgJiYgZWwucGFyZW50RWxlbWVudCkge1xuICAgIGlmICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbC5wYXJlbnRFbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKCdwb3NpdGlvbicpID09PSAnc3RhdGljJykge1xuICAgICAgZWwucGFyZW50RWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgfVxuICAgIGVsLl9wYXJlbnRVcGRhdGVkID0gdHJ1ZTtcbiAgfVxufTtcblxudXRpbC50b2dnbGVBdHRyaWJ1dGUgPSAoZWxlbWVudCwgbmFtZSwgZW5hYmxlKSA9PiB7XG4gIGlmIChlbmFibGUpIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCAnJyk7XG4gIH0gZWxzZSB7XG4gICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIH1cbn07XG5cbnV0aWwuYmluZExpc3RlbmVycyA9IChlbGVtZW50LCBsaXN0ZW5lck5hbWVzKSA9PiB7XG4gIGxpc3RlbmVyTmFtZXMuZm9yRWFjaChuYW1lID0+IHtcbiAgICBjb25zdCBib3VuZE5hbWUgPSBuYW1lLnJlcGxhY2UoL15fW2Etel0vLCAnX2JvdW5kJyArIG5hbWVbMV0udG9VcHBlckNhc2UoKSk7XG4gICAgZWxlbWVudFtib3VuZE5hbWVdID0gZWxlbWVudFtib3VuZE5hbWVdIHx8IGVsZW1lbnRbbmFtZV0uYmluZChlbGVtZW50KTtcbiAgfSk7XG59O1xuXG51dGlsLmVhY2ggPSAob2JqLCBmKSA9PiBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goa2V5ID0+IGYoa2V5LCBvYmpba2V5XSkpO1xuXG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqL1xudXRpbC51cGRhdGVSaXBwbGUgPSAodGFyZ2V0KSA9PiB7XG4gIGNvbnN0IHJpcHBsZUVsZW1lbnQgPSB1dGlsLmZpbmRDaGlsZCh0YXJnZXQsICdvbnMtcmlwcGxlJyk7XG5cbiAgaWYgKHRhcmdldC5oYXNBdHRyaWJ1dGUoJ3JpcHBsZScpKSB7XG4gICAgaWYgKCFyaXBwbGVFbGVtZW50KSB7XG4gICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29ucy1yaXBwbGUnKSwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChyaXBwbGVFbGVtZW50KSB7XG4gICAgcmlwcGxlRWxlbWVudC5yZW1vdmUoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ31cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xudXRpbC5hbmltYXRpb25PcHRpb25zUGFyc2UgPSBhbmltYXRpb25PcHRpb25zUGFyc2U7XG5cbi8qKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICovXG51dGlsLmlzSW50ZWdlciA9ICh2YWx1ZSkgPT4ge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJlxuICAgIGlzRmluaXRlKHZhbHVlKSAmJlxuICAgIE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHV0aWw7XG4iLCIvKlxuICogR2VzdHVyZSBkZXRlY3RvciBsaWJyYXJ5IHRoYXQgZm9ya2VkIGZyb20gZ2l0aHViLmNvbS9FaWdodE1lZGlhL2hhbW1lci5qcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudCwgVXRpbHMsIERldGVjdGlvbiwgUG9pbnRlckV2ZW50O1xuXG4vKipcbiAqIEBvYmplY3Qgb25zLkdlc3R1cmVEZXRlY3RvclxuICogQGNhdGVnb3J5IGdlc3R1cmVcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dVXRpbGl0eSBjbGFzcyBmb3IgZ2VzdHVyZSBkZXRlY3Rpb24uWy9lbl1cbiAqICAgW2phXeOCuOOCp+OCueODgeODo+OCkuaknOefpeOBmeOCi+OBn+OCgeOBruODpuODvOODhuOCo+ODquODhuOCo+OCr+ODqeOCueOBp+OBmeOAglsvamFdXG4gKi9cblxuLyoqXG4gKiBAbWV0aG9kIGNvbnN0cnVjdG9yXG4gKiBAc2lnbmF0dXJlIGNvbnN0cnVjdG9yKGVsZW1lbnRbLCBvcHRpb25zXSlcbiAqIEBkZXNjcmlwdGlvblxuICogIFtlbl1DcmVhdGUgYSBuZXcgR2VzdHVyZURldGVjdG9yIGluc3RhbmNlLlsvZW5dXG4gKiAgW2phXUdlc3R1cmVEZXRlY3RvcuOBruOCpOODs+OCueOCv+ODs+OCueOCkueUn+aIkOOBl+OBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqICAgW2VuXU5hbWUgb2YgdGhlIGV2ZW50LlsvZW5dXG4gKiAgIFtqYV3jgrjjgqfjgrnjg4Hjg6PjgpLmpJznn6XjgZnjgotET03opoHntKDjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogICBbZW5dT3B0aW9ucyBvYmplY3QuWy9lbl1cbiAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAcmV0dXJuIHtvbnMuR2VzdHVyZURldGVjdG9yLkluc3RhbmNlfVxuICovXG52YXIgR2VzdHVyZURldGVjdG9yID0gZnVuY3Rpb24gR2VzdHVyZURldGVjdG9yKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBHZXN0dXJlRGV0ZWN0b3IuSW5zdGFuY2UoZWxlbWVudCwgb3B0aW9ucyB8fCB7fSk7XG59O1xuXG5cbi8qKlxuICogZGVmYXVsdCBzZXR0aW5ncy5cbiAqIG1vcmUgc2V0dGluZ3MgYXJlIGRlZmluZWQgcGVyIGdlc3R1cmUgYXQgYC9nZXN0dXJlc2AuIEVhY2ggZ2VzdHVyZSBjYW4gYmUgZGlzYWJsZWQvZW5hYmxlZFxuICogYnkgc2V0dGluZyBpdCdzIG5hbWUgKGxpa2UgYHN3aXBlYCkgdG8gZmFsc2UuXG4gKiBZb3UgY2FuIHNldCB0aGUgZGVmYXVsdHMgZm9yIGFsbCBpbnN0YW5jZXMgYnkgY2hhbmdpbmcgdGhpcyBvYmplY3QgYmVmb3JlIGNyZWF0aW5nIGFuIGluc3RhbmNlLlxuICogQGV4YW1wbGVcbiAqIGBgYGBcbiAqICBHZXN0dXJlRGV0ZWN0b3IuZGVmYXVsdHMuZHJhZyA9IGZhbHNlO1xuICogIEdlc3R1cmVEZXRlY3Rvci5kZWZhdWx0cy5iZWhhdmlvci50b3VjaEFjdGlvbiA9ICdwYW4teSc7XG4gKiAgZGVsZXRlIEdlc3R1cmVEZXRlY3Rvci5kZWZhdWx0cy5iZWhhdmlvci51c2VyU2VsZWN0O1xuICogYGBgYFxuICogQHByb3BlcnR5IGRlZmF1bHRzXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5HZXN0dXJlRGV0ZWN0b3IuZGVmYXVsdHMgPSB7XG4gIGJlaGF2aW9yOiB7XG4gICAgLy8gdXNlclNlbGVjdDogJ25vbmUnLCAvLyBBbHNvIGRpc2FibGVzIHNlbGVjdGlvbiBpbiBgaW5wdXRgIGNoaWxkcmVuXG4gICAgdG91Y2hBY3Rpb246ICdwYW4teScsXG4gICAgdG91Y2hDYWxsb3V0OiAnbm9uZScsXG4gICAgY29udGVudFpvb21pbmc6ICdub25lJyxcbiAgICB1c2VyRHJhZzogJ25vbmUnLFxuICAgIHRhcEhpZ2hsaWdodENvbG9yOiAncmdiYSgwLDAsMCwwKSdcbiAgfVxufTtcblxuLyoqXG4gKiBHZXN0dXJlRGV0ZWN0b3IgZG9jdW1lbnQgd2hlcmUgdGhlIGJhc2UgZXZlbnRzIGFyZSBhZGRlZCBhdFxuICogQHByb3BlcnR5IERPQ1VNRU5UXG4gKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gKiBAZGVmYXVsdCB3aW5kb3cuZG9jdW1lbnRcbiAqL1xuR2VzdHVyZURldGVjdG9yLkRPQ1VNRU5UID0gZG9jdW1lbnQ7XG5cbi8qKlxuICogZGV0ZWN0IHN1cHBvcnQgZm9yIHBvaW50ZXIgZXZlbnRzXG4gKiBAcHJvcGVydHkgSEFTX1BPSU5URVJFVkVOVFNcbiAqIEB0eXBlIHtCb29sZWFufVxuICovXG5HZXN0dXJlRGV0ZWN0b3IuSEFTX1BPSU5URVJFVkVOVFMgPSBuYXZpZ2F0b3IucG9pbnRlckVuYWJsZWQgfHwgbmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQ7XG5cbi8qKlxuICogZGV0ZWN0IHN1cHBvcnQgZm9yIHRvdWNoIGV2ZW50c1xuICogQHByb3BlcnR5IEhBU19UT1VDSEVWRU5UU1xuICogQHR5cGUge0Jvb2xlYW59XG4gKi9cbkdlc3R1cmVEZXRlY3Rvci5IQVNfVE9VQ0hFVkVOVFMgPSAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KTtcblxuLyoqXG4gKiBkZXRlY3QgbW9iaWxlIGJyb3dzZXJzXG4gKiBAcHJvcGVydHkgSVNfTU9CSUxFXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqL1xuR2VzdHVyZURldGVjdG9yLklTX01PQklMRSA9IC9tb2JpbGV8dGFibGV0fGlwKGFkfGhvbmV8b2QpfGFuZHJvaWR8c2lsay9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxuICogZGV0ZWN0IGlmIHdlIHdhbnQgdG8gc3VwcG9ydCBtb3VzZWV2ZW50cyBhdCBhbGxcbiAqIEBwcm9wZXJ0eSBOT19NT1VTRUVWRU5UU1xuICogQHR5cGUge0Jvb2xlYW59XG4gKi9cbkdlc3R1cmVEZXRlY3Rvci5OT19NT1VTRUVWRU5UUyA9IChHZXN0dXJlRGV0ZWN0b3IuSEFTX1RPVUNIRVZFTlRTICYmIEdlc3R1cmVEZXRlY3Rvci5JU19NT0JJTEUpIHx8IEdlc3R1cmVEZXRlY3Rvci5IQVNfUE9JTlRFUkVWRU5UUztcblxuLyoqXG4gKiBpbnRlcnZhbCBpbiB3aGljaCBHZXN0dXJlRGV0ZWN0b3IgcmVjYWxjdWxhdGVzIGN1cnJlbnQgdmVsb2NpdHkvZGlyZWN0aW9uL2FuZ2xlIGluIG1zXG4gKiBAcHJvcGVydHkgQ0FMQ1VMQVRFX0lOVEVSVkFMXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQGRlZmF1bHQgMjVcbiAqL1xuR2VzdHVyZURldGVjdG9yLkNBTENVTEFURV9JTlRFUlZBTCA9IDI1O1xuXG4vKipcbiAqIGV2ZW50dHlwZXMgcGVyIHRvdWNoZXZlbnQgKHN0YXJ0LCBtb3ZlLCBlbmQpIGFyZSBmaWxsZWQgYnkgYEV2ZW50LmRldGVybWluZUV2ZW50VHlwZXNgIG9uIGBzZXR1cGBcbiAqIHRoZSBvYmplY3QgY29udGFpbnMgdGhlIERPTSBldmVudCBuYW1lcyBwZXIgdHlwZSAoYEVWRU5UX1NUQVJUYCwgYEVWRU5UX01PVkVgLCBgRVZFTlRfRU5EYClcbiAqIEBwcm9wZXJ0eSBFVkVOVF9UWVBFU1xuICogQHByaXZhdGVcbiAqIEB3cml0ZU9uY2VcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciBFVkVOVF9UWVBFUyA9IHt9O1xuXG4vKipcbiAqIGRpcmVjdGlvbiBzdHJpbmdzLCBmb3Igc2FmZSBjb21wYXJpc29uc1xuICogQHByb3BlcnR5IERJUkVDVElPTl9ET1dOfExFRlR8VVB8UklHSFRcbiAqIEBmaW5hbFxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0ICdkb3duJyAnbGVmdCcgJ3VwJyAncmlnaHQnXG4gKi9cbnZhciBESVJFQ1RJT05fRE9XTiA9IEdlc3R1cmVEZXRlY3Rvci5ESVJFQ1RJT05fRE9XTiA9ICdkb3duJztcbnZhciBESVJFQ1RJT05fTEVGVCA9IEdlc3R1cmVEZXRlY3Rvci5ESVJFQ1RJT05fTEVGVCA9ICdsZWZ0JztcbnZhciBESVJFQ1RJT05fVVAgPSBHZXN0dXJlRGV0ZWN0b3IuRElSRUNUSU9OX1VQID0gJ3VwJztcbnZhciBESVJFQ1RJT05fUklHSFQgPSBHZXN0dXJlRGV0ZWN0b3IuRElSRUNUSU9OX1JJR0hUID0gJ3JpZ2h0JztcblxuLyoqXG4gKiBwb2ludGVydHlwZSBzdHJpbmdzLCBmb3Igc2FmZSBjb21wYXJpc29uc1xuICogQHByb3BlcnR5IFBPSU5URVJfTU9VU0V8VE9VQ0h8UEVOXG4gKiBAZmluYWxcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVmYXVsdCAnbW91c2UnICd0b3VjaCcgJ3BlbidcbiAqL1xudmFyIFBPSU5URVJfTU9VU0UgPSBHZXN0dXJlRGV0ZWN0b3IuUE9JTlRFUl9NT1VTRSA9ICdtb3VzZSc7XG52YXIgUE9JTlRFUl9UT1VDSCA9IEdlc3R1cmVEZXRlY3Rvci5QT0lOVEVSX1RPVUNIID0gJ3RvdWNoJztcbnZhciBQT0lOVEVSX1BFTiA9IEdlc3R1cmVEZXRlY3Rvci5QT0lOVEVSX1BFTiA9ICdwZW4nO1xuXG4vKipcbiAqIGV2ZW50dHlwZXNcbiAqIEBwcm9wZXJ0eSBFVkVOVF9TVEFSVHxNT1ZFfEVORHxSRUxFQVNFfFRPVUNIXG4gKiBAZmluYWxcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVmYXVsdCAnc3RhcnQnICdjaGFuZ2UnICdtb3ZlJyAnZW5kJyAncmVsZWFzZScgJ3RvdWNoJ1xuICovXG52YXIgRVZFTlRfU1RBUlQgPSBHZXN0dXJlRGV0ZWN0b3IuRVZFTlRfU1RBUlQgPSAnc3RhcnQnO1xudmFyIEVWRU5UX01PVkUgPSBHZXN0dXJlRGV0ZWN0b3IuRVZFTlRfTU9WRSA9ICdtb3ZlJztcbnZhciBFVkVOVF9FTkQgPSBHZXN0dXJlRGV0ZWN0b3IuRVZFTlRfRU5EID0gJ2VuZCc7XG52YXIgRVZFTlRfUkVMRUFTRSA9IEdlc3R1cmVEZXRlY3Rvci5FVkVOVF9SRUxFQVNFID0gJ3JlbGVhc2UnO1xudmFyIEVWRU5UX1RPVUNIID0gR2VzdHVyZURldGVjdG9yLkVWRU5UX1RPVUNIID0gJ3RvdWNoJztcblxuLyoqXG4gKiBpZiB0aGUgd2luZG93IGV2ZW50cyBhcmUgc2V0Li4uXG4gKiBAcHJvcGVydHkgUkVBRFlcbiAqIEB3cml0ZU9uY2VcbiAqIEB0eXBlIHtCb29sZWFufVxuICogQGRlZmF1bHQgZmFsc2VcbiAqL1xuR2VzdHVyZURldGVjdG9yLlJFQURZID0gZmFsc2U7XG5cbi8qKlxuICogcGx1Z2lucyBuYW1lc3BhY2VcbiAqIEBwcm9wZXJ0eSBwbHVnaW5zXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5HZXN0dXJlRGV0ZWN0b3IucGx1Z2lucyA9IEdlc3R1cmVEZXRlY3Rvci5wbHVnaW5zIHx8IHt9O1xuXG4vKipcbiAqIGdlc3R1cmVzIG5hbWVzcGFjZVxuICogc2VlIGAvZ2VzdHVyZXNgIGZvciB0aGUgZGVmaW5pdGlvbnNcbiAqIEBwcm9wZXJ0eSBnZXN0dXJlc1xuICogQHR5cGUge09iamVjdH1cbiAqL1xuR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzID0gR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzIHx8IHt9O1xuXG4vKipcbiAqIHNldHVwIGV2ZW50cyB0byBkZXRlY3QgZ2VzdHVyZXMgb24gdGhlIGRvY3VtZW50XG4gKiB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIGNyZWF0aW5nIGFuIG5ldyBpbnN0YW5jZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0dXAoKSB7XG4gIGlmKEdlc3R1cmVEZXRlY3Rvci5SRUFEWSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGZpbmQgd2hhdCBldmVudHR5cGVzIHdlIGFkZCBsaXN0ZW5lcnMgdG9cbiAgRXZlbnQuZGV0ZXJtaW5lRXZlbnRUeXBlcygpO1xuXG4gIC8vIFJlZ2lzdGVyIGFsbCBnZXN0dXJlcyBpbnNpZGUgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzXG4gIFV0aWxzLmVhY2goR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzLCBmdW5jdGlvbihnZXN0dXJlKSB7XG4gICAgRGV0ZWN0aW9uLnJlZ2lzdGVyKGdlc3R1cmUpO1xuICB9KTtcblxuICAvLyBBZGQgdG91Y2ggZXZlbnRzIG9uIHRoZSBkb2N1bWVudFxuICBFdmVudC5vblRvdWNoKEdlc3R1cmVEZXRlY3Rvci5ET0NVTUVOVCwgRVZFTlRfTU9WRSwgRGV0ZWN0aW9uLmRldGVjdCk7XG4gIEV2ZW50Lm9uVG91Y2goR2VzdHVyZURldGVjdG9yLkRPQ1VNRU5ULCBFVkVOVF9FTkQsIERldGVjdGlvbi5kZXRlY3QpO1xuXG4gIC8vIEdlc3R1cmVEZXRlY3RvciBpcyByZWFkeS4uLiFcbiAgR2VzdHVyZURldGVjdG9yLlJFQURZID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBAbW9kdWxlIEdlc3R1cmVEZXRlY3RvclxuICpcbiAqIEBjbGFzcyBVdGlsc1xuICogQHN0YXRpY1xuICovXG5VdGlscyA9IEdlc3R1cmVEZXRlY3Rvci51dGlscyA9IHtcbiAgLyoqXG4gICAqIGV4dGVuZCBtZXRob2QsIGNvdWxkIGFsc28gYmUgdXNlZCBmb3IgY2xvbmluZyB3aGVuIGBkZXN0YCBpcyBhbiBlbXB0eSBvYmplY3QuXG4gICAqIGNoYW5nZXMgdGhlIGRlc3Qgb2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzcmNcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWVyZ2U9ZmFsc2VdICBkbyBhIG1lcmdlXG4gICAqIEByZXR1cm4ge09iamVjdH0gZGVzdFxuICAgKi9cbiAgZXh0ZW5kOiBmdW5jdGlvbiBleHRlbmQoZGVzdCwgc3JjLCBtZXJnZSkge1xuICAgIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICAgIGlmIChzcmMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZGVzdFtrZXldID09PSB1bmRlZmluZWQgfHwgIW1lcmdlKSkge1xuICAgICAgICBkZXN0W2tleV0gPSBzcmNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHNpbXBsZSBhZGRFdmVudExpc3RlbmVyIHdyYXBwZXJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBvbjogZnVuY3Rpb24gb24oZWxlbWVudCwgdHlwZSwgaGFuZGxlcikge1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHNpbXBsZSByZW1vdmVFdmVudExpc3RlbmVyIHdyYXBwZXJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBvZmY6IGZ1bmN0aW9uIG9mZihlbGVtZW50LCB0eXBlLCBoYW5kbGVyKSB7XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgfSxcblxuICAvKipcbiAgICogZm9yRWFjaCBvdmVyIGFycmF5cyBhbmQgb2JqZWN0c1xuICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdG9yXG4gICAqIEBwYXJhbSB7YW55fSBpdGVyYXRvci5pdGVtXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpdGVyYXRvci5pbmRleFxuICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gaXRlcmF0b3Iub2JqIHRoZSBzb3VyY2Ugb2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IHZhbHVlIHRvIHVzZSBhcyBgdGhpc2AgaW4gdGhlIGl0ZXJhdG9yXG4gICAqL1xuICBlYWNoOiBmdW5jdGlvbiBlYWNoKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICB2YXIgaSwgbGVuO1xuXG4gICAgLy8gbmF0aXZlIGZvckVhY2ggb24gYXJyYXlzXG4gICAgaWYoJ2ZvckVhY2gnIGluIG9iaikge1xuICAgICAgb2JqLmZvckVhY2goaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgICAgLy8gYXJyYXlzXG4gICAgfSBlbHNlIGlmKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgZm9yKGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYoaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBvYmplY3RzXG4gICAgfSBlbHNlIHtcbiAgICAgIGZvcihpIGluIG9iaikge1xuICAgICAgICBpZihvYmouaGFzT3duUHJvcGVydHkoaSkgJiZcbiAgICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIGZpbmQgaWYgYSBzdHJpbmcgY29udGFpbnMgdGhlIHN0cmluZyB1c2luZyBpbmRleE9mXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzcmNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gZm91bmRcbiAgICovXG4gIGluU3RyOiBmdW5jdGlvbiBpblN0cihzcmMsIGZpbmQpIHtcbiAgICByZXR1cm4gc3JjLmluZGV4T2YoZmluZCkgPiAtMTtcbiAgfSxcblxuICAvKipcbiAgICogZmluZCBpZiBhIGFycmF5IGNvbnRhaW5zIHRoZSBvYmplY3QgdXNpbmcgaW5kZXhPZiBvciBhIHNpbXBsZSBwb2x5ZmlsbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3JjXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmaW5kXG4gICAqIEByZXR1cm4ge0Jvb2xlYW58TnVtYmVyfSBmYWxzZSB3aGVuIG5vdCBmb3VuZCwgb3IgdGhlIGluZGV4XG4gICAqL1xuICBpbkFycmF5OiBmdW5jdGlvbiBpbkFycmF5KHNyYywgZmluZCkge1xuICAgIGlmKHNyYy5pbmRleE9mKSB7XG4gICAgICB2YXIgaW5kZXggPSBzcmMuaW5kZXhPZihmaW5kKTtcbiAgICAgIHJldHVybiAoaW5kZXggPT09IC0xKSA/IGZhbHNlIDogaW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvcih2YXIgaSA9IDAsIGxlbiA9IHNyYy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZihzcmNbaV0gPT09IGZpbmQpIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogY29udmVydCBhbiBhcnJheS1saWtlIG9iamVjdCAoYGFyZ3VtZW50c2AsIGB0b3VjaGxpc3RgKSB0byBhbiBhcnJheVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgdG9BcnJheTogZnVuY3Rpb24gdG9BcnJheShvYmopIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob2JqLCAwKTtcbiAgfSxcblxuICAvKipcbiAgICogZmluZCBpZiBhIG5vZGUgaXMgaW4gdGhlIGdpdmVuIHBhcmVudFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBmb3VuZFxuICAgKi9cbiAgaGFzUGFyZW50OiBmdW5jdGlvbiBoYXNQYXJlbnQobm9kZSwgcGFyZW50KSB7XG4gICAgd2hpbGUobm9kZSkge1xuICAgICAgaWYobm9kZSA9PSBwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGdldCB0aGUgY2VudGVyIG9mIGFsbCB0aGUgdG91Y2hlc1xuICAgKiBAcGFyYW0ge0FycmF5fSB0b3VjaGVzXG4gICAqIEByZXR1cm4ge09iamVjdH0gY2VudGVyIGNvbnRhaW5zIGBwYWdlWGAsIGBwYWdlWWAsIGBjbGllbnRYYCBhbmQgYGNsaWVudFlgIHByb3BlcnRpZXNcbiAgICovXG4gIGdldENlbnRlcjogZnVuY3Rpb24gZ2V0Q2VudGVyKHRvdWNoZXMpIHtcbiAgICB2YXIgcGFnZVggPSBbXSxcbiAgICAgICAgcGFnZVkgPSBbXSxcbiAgICAgICAgY2xpZW50WCA9IFtdLFxuICAgICAgICBjbGllbnRZID0gW10sXG4gICAgICAgIG1pbiA9IE1hdGgubWluLFxuICAgICAgICBtYXggPSBNYXRoLm1heDtcblxuICAgIC8vIG5vIG5lZWQgdG8gbG9vcCB3aGVuIG9ubHkgb25lIHRvdWNoXG4gICAgaWYodG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhZ2VYOiB0b3VjaGVzWzBdLnBhZ2VYLFxuICAgICAgICBwYWdlWTogdG91Y2hlc1swXS5wYWdlWSxcbiAgICAgICAgY2xpZW50WDogdG91Y2hlc1swXS5jbGllbnRYLFxuICAgICAgICBjbGllbnRZOiB0b3VjaGVzWzBdLmNsaWVudFlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgVXRpbHMuZWFjaCh0b3VjaGVzLCBmdW5jdGlvbih0b3VjaCkge1xuICAgICAgcGFnZVgucHVzaCh0b3VjaC5wYWdlWCk7XG4gICAgICBwYWdlWS5wdXNoKHRvdWNoLnBhZ2VZKTtcbiAgICAgIGNsaWVudFgucHVzaCh0b3VjaC5jbGllbnRYKTtcbiAgICAgIGNsaWVudFkucHVzaCh0b3VjaC5jbGllbnRZKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICBwYWdlWDogKG1pbi5hcHBseShNYXRoLCBwYWdlWCkgKyBtYXguYXBwbHkoTWF0aCwgcGFnZVgpKSAvIDIsXG4gICAgICBwYWdlWTogKG1pbi5hcHBseShNYXRoLCBwYWdlWSkgKyBtYXguYXBwbHkoTWF0aCwgcGFnZVkpKSAvIDIsXG4gICAgICBjbGllbnRYOiAobWluLmFwcGx5KE1hdGgsIGNsaWVudFgpICsgbWF4LmFwcGx5KE1hdGgsIGNsaWVudFgpKSAvIDIsXG4gICAgICBjbGllbnRZOiAobWluLmFwcGx5KE1hdGgsIGNsaWVudFkpICsgbWF4LmFwcGx5KE1hdGgsIGNsaWVudFkpKSAvIDJcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBjYWxjdWxhdGUgdGhlIHZlbG9jaXR5IGJldHdlZW4gdHdvIHBvaW50cy4gdW5pdCBpcyBpbiBweCBwZXIgbXMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVRpbWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhWFxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFZXG4gICAqIEByZXR1cm4ge09iamVjdH0gdmVsb2NpdHkgYHhgIGFuZCBgeWBcbiAgICovXG4gIGdldFZlbG9jaXR5OiBmdW5jdGlvbiBnZXRWZWxvY2l0eShkZWx0YVRpbWUsIGRlbHRhWCwgZGVsdGFZKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IE1hdGguYWJzKGRlbHRhWCAvIGRlbHRhVGltZSkgfHwgMCxcbiAgICAgIHk6IE1hdGguYWJzKGRlbHRhWSAvIGRlbHRhVGltZSkgfHwgMFxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB0aGUgYW5nbGUgYmV0d2VlbiB0d28gY29vcmRpbmF0ZXNcbiAgICogQHBhcmFtIHtUb3VjaH0gdG91Y2gxXG4gICAqIEBwYXJhbSB7VG91Y2h9IHRvdWNoMlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGFuZ2xlXG4gICAqL1xuICBnZXRBbmdsZTogZnVuY3Rpb24gZ2V0QW5nbGUodG91Y2gxLCB0b3VjaDIpIHtcbiAgICB2YXIgeCA9IHRvdWNoMi5jbGllbnRYIC0gdG91Y2gxLmNsaWVudFgsXG4gICAgICAgIHkgPSB0b3VjaDIuY2xpZW50WSAtIHRvdWNoMS5jbGllbnRZO1xuXG4gICAgcmV0dXJuIE1hdGguYXRhbjIoeSwgeCkgKiAxODAgLyBNYXRoLlBJO1xuICB9LFxuXG4gIC8qKlxuICAgKiBkbyBhIHNtYWxsIGNvbXBhcmlzb24gdG8gZ2V0IHRoZSBkaXJlY3Rpb24gYmV0d2VlbiB0d28gdG91Y2hlcy5cbiAgICogQHBhcmFtIHtUb3VjaH0gdG91Y2gxXG4gICAqIEBwYXJhbSB7VG91Y2h9IHRvdWNoMlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGRpcmVjdGlvbiBtYXRjaGVzIGBESVJFQ1RJT05fTEVGVHxSSUdIVHxVUHxET1dOYFxuICAgKi9cbiAgZ2V0RGlyZWN0aW9uOiBmdW5jdGlvbiBnZXREaXJlY3Rpb24odG91Y2gxLCB0b3VjaDIpIHtcbiAgICB2YXIgeCA9IE1hdGguYWJzKHRvdWNoMS5jbGllbnRYIC0gdG91Y2gyLmNsaWVudFgpLFxuICAgICAgICB5ID0gTWF0aC5hYnModG91Y2gxLmNsaWVudFkgLSB0b3VjaDIuY2xpZW50WSk7XG5cbiAgICBpZih4ID49IHkpIHtcbiAgICAgIHJldHVybiB0b3VjaDEuY2xpZW50WCAtIHRvdWNoMi5jbGllbnRYID4gMCA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xuICAgIH1cbiAgICByZXR1cm4gdG91Y2gxLmNsaWVudFkgLSB0b3VjaDIuY2xpZW50WSA+IDAgPyBESVJFQ1RJT05fVVAgOiBESVJFQ1RJT05fRE9XTjtcbiAgfSxcblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byB0b3VjaGVzXG4gICAqIEBwYXJhbSB7VG91Y2h9dG91Y2gxXG4gICAqIEBwYXJhbSB7VG91Y2h9IHRvdWNoMlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGRpc3RhbmNlXG4gICAqL1xuICBnZXREaXN0YW5jZTogZnVuY3Rpb24gZ2V0RGlzdGFuY2UodG91Y2gxLCB0b3VjaDIpIHtcbiAgICB2YXIgeCA9IHRvdWNoMi5jbGllbnRYIC0gdG91Y2gxLmNsaWVudFgsXG4gICAgICAgIHkgPSB0b3VjaDIuY2xpZW50WSAtIHRvdWNoMS5jbGllbnRZO1xuXG4gICAgcmV0dXJuIE1hdGguc3FydCgoeCAqIHgpICsgKHkgKiB5KSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB0aGUgc2NhbGUgZmFjdG9yIGJldHdlZW4gdHdvIHRvdWNoTGlzdHNcbiAgICogbm8gc2NhbGUgaXMgMSwgYW5kIGdvZXMgZG93biB0byAwIHdoZW4gcGluY2hlZCB0b2dldGhlciwgYW5kIGJpZ2dlciB3aGVuIHBpbmNoZWQgb3V0XG4gICAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0IGFycmF5IG9mIHRvdWNoZXNcbiAgICogQHBhcmFtIHtBcnJheX0gZW5kIGFycmF5IG9mIHRvdWNoZXNcbiAgICogQHJldHVybiB7TnVtYmVyfSBzY2FsZVxuICAgKi9cbiAgZ2V0U2NhbGU6IGZ1bmN0aW9uIGdldFNjYWxlKHN0YXJ0LCBlbmQpIHtcbiAgICAvLyBuZWVkIHR3byBmaW5nZXJzLi4uXG4gICAgaWYoc3RhcnQubGVuZ3RoID49IDIgJiYgZW5kLmxlbmd0aCA+PSAyKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXREaXN0YW5jZShlbmRbMF0sIGVuZFsxXSkgLyB0aGlzLmdldERpc3RhbmNlKHN0YXJ0WzBdLCBzdGFydFsxXSk7XG4gICAgfVxuICAgIHJldHVybiAxO1xuICB9LFxuXG4gIC8qKlxuICAgKiBjYWxjdWxhdGUgdGhlIHJvdGF0aW9uIGRlZ3JlZXMgYmV0d2VlbiB0d28gdG91Y2hMaXN0c1xuICAgKiBAcGFyYW0ge0FycmF5fSBzdGFydCBhcnJheSBvZiB0b3VjaGVzXG4gICAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiB0b3VjaGVzXG4gICAqIEByZXR1cm4ge051bWJlcn0gcm90YXRpb25cbiAgICovXG4gIGdldFJvdGF0aW9uOiBmdW5jdGlvbiBnZXRSb3RhdGlvbihzdGFydCwgZW5kKSB7XG4gICAgLy8gbmVlZCB0d28gZmluZ2Vyc1xuICAgIGlmKHN0YXJ0Lmxlbmd0aCA+PSAyICYmIGVuZC5sZW5ndGggPj0gMikge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0QW5nbGUoZW5kWzFdLCBlbmRbMF0pIC0gdGhpcy5nZXRBbmdsZShzdGFydFsxXSwgc3RhcnRbMF0pO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSxcblxuICAvKipcbiAgICogZmluZCBvdXQgaWYgdGhlIGRpcmVjdGlvbiBpcyB2ZXJ0aWNhbCAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRpcmVjdGlvbiBtYXRjaGVzIGBESVJFQ1RJT05fVVB8RE9XTmBcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gaXNfdmVydGljYWxcbiAgICovXG4gIGlzVmVydGljYWw6IGZ1bmN0aW9uIGlzVmVydGljYWwoZGlyZWN0aW9uKSB7XG4gICAgcmV0dXJuIGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fVVAgfHwgZGlyZWN0aW9uID09IERJUkVDVElPTl9ET1dOO1xuICB9LFxuXG4gIC8qKlxuICAgKiBzZXQgY3NzIHByb3BlcnRpZXMgd2l0aCB0aGVpciBwcmVmaXhlc1xuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt0b2dnbGU9dHJ1ZV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIHNldFByZWZpeGVkQ3NzOiBmdW5jdGlvbiBzZXRQcmVmaXhlZENzcyhlbGVtZW50LCBwcm9wLCB2YWx1ZSwgdG9nZ2xlKSB7XG4gICAgdmFyIHByZWZpeGVzID0gWycnLCAnV2Via2l0JywgJ01veicsICdPJywgJ21zJ107XG4gICAgcHJvcCA9IFV0aWxzLnRvQ2FtZWxDYXNlKHByb3ApO1xuXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcCA9IHByb3A7XG4gICAgICAvLyBwcmVmaXhlc1xuICAgICAgaWYocHJlZml4ZXNbaV0pIHtcbiAgICAgICAgcCA9IHByZWZpeGVzW2ldICsgcC5zbGljZSgwLCAxKS50b1VwcGVyQ2FzZSgpICsgcC5zbGljZSgxKTtcbiAgICAgIH1cblxuICAgICAgLy8gdGVzdCB0aGUgc3R5bGVcbiAgICAgIGlmKHAgaW4gZWxlbWVudC5zdHlsZSkge1xuICAgICAgICBlbGVtZW50LnN0eWxlW3BdID0gKHRvZ2dsZSA9PT0gbnVsbCB8fCB0b2dnbGUpICYmIHZhbHVlIHx8ICcnO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIHRvZ2dsZSBicm93c2VyIGRlZmF1bHQgYmVoYXZpb3IgYnkgc2V0dGluZyBjc3MgcHJvcGVydGllcy5cbiAgICogYHVzZXJTZWxlY3Q9J25vbmUnYCBhbHNvIHNldHMgYGVsZW1lbnQub25zZWxlY3RzdGFydGAgdG8gZmFsc2VcbiAgICogYHVzZXJEcmFnPSdub25lJ2AgYWxzbyBzZXRzIGBlbGVtZW50Lm9uZHJhZ3N0YXJ0YCB0byBmYWxzZVxuICAgKlxuICAgKiBAcGFyYW0ge0h0bWxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt0b2dnbGU9dHJ1ZV1cbiAgICovXG4gIHRvZ2dsZUJlaGF2aW9yOiBmdW5jdGlvbiB0b2dnbGVCZWhhdmlvcihlbGVtZW50LCBwcm9wcywgdG9nZ2xlKSB7XG4gICAgaWYoIXByb3BzIHx8ICFlbGVtZW50IHx8ICFlbGVtZW50LnN0eWxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gc2V0IHRoZSBjc3MgcHJvcGVydGllc1xuICAgIFV0aWxzLmVhY2gocHJvcHMsIGZ1bmN0aW9uKHZhbHVlLCBwcm9wKSB7XG4gICAgICBVdGlscy5zZXRQcmVmaXhlZENzcyhlbGVtZW50LCBwcm9wLCB2YWx1ZSwgdG9nZ2xlKTtcbiAgICB9KTtcblxuICAgIHZhciBmYWxzZUZuID0gdG9nZ2xlICYmIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvLyBhbHNvIHRoZSBkaXNhYmxlIG9uc2VsZWN0c3RhcnRcbiAgICBpZihwcm9wcy51c2VyU2VsZWN0ID09ICdub25lJykge1xuICAgICAgZWxlbWVudC5vbnNlbGVjdHN0YXJ0ID0gZmFsc2VGbjtcbiAgICB9XG4gICAgLy8gYW5kIGRpc2FibGUgb25kcmFnc3RhcnRcbiAgICBpZihwcm9wcy51c2VyRHJhZyA9PSAnbm9uZScpIHtcbiAgICAgIGVsZW1lbnQub25kcmFnc3RhcnQgPSBmYWxzZUZuO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogY29udmVydCBhIHN0cmluZyB3aXRoIHVuZGVyc2NvcmVzIHRvIGNhbWVsQ2FzZVxuICAgKiBzbyBwcmV2ZW50X2RlZmF1bHQgYmVjb21lcyBwcmV2ZW50RGVmYXVsdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICAqIEByZXR1cm4ge1N0cmluZ30gY2FtZWxDYXNlU3RyXG4gICAqL1xuICB0b0NhbWVsQ2FzZTogZnVuY3Rpb24gdG9DYW1lbENhc2Uoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bXy1dKFthLXpdKS9nLCBmdW5jdGlvbihzKSB7XG4gICAgICByZXR1cm4gc1sxXS50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xuICB9XG59O1xuXG5cbi8qKlxuICogQG1vZHVsZSBHZXN0dXJlRGV0ZWN0b3JcbiAqL1xuLyoqXG4gKiBAY2xhc3MgRXZlbnRcbiAqIEBzdGF0aWNcbiAqL1xuRXZlbnQgPSBHZXN0dXJlRGV0ZWN0b3IuZXZlbnQgPSB7XG4gIC8qKlxuICAgKiB3aGVuIHRvdWNoIGV2ZW50cyBoYXZlIGJlZW4gZmlyZWQsIHRoaXMgaXMgdHJ1ZVxuICAgKiB0aGlzIGlzIHVzZWQgdG8gc3RvcCBtb3VzZSBldmVudHNcbiAgICogQHByb3BlcnR5IHByZXZlbnRfbW91c2VldmVudHNcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBwcmV2ZW50TW91c2VFdmVudHM6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBpZiBFVkVOVF9TVEFSVCBoYXMgYmVlbiBmaXJlZFxuICAgKiBAcHJvcGVydHkgc3RhcnRlZFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIHN0YXJ0ZWQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiB3aGVuIHRoZSBtb3VzZSBpcyBob2xkIGRvd24sIHRoaXMgaXMgdHJ1ZVxuICAgKiBAcHJvcGVydHkgc2hvdWxkX2RldGVjdFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIHNob3VsZERldGVjdDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIHNpbXBsZSBldmVudCBiaW5kZXIgd2l0aCBhIGhvb2sgYW5kIHN1cHBvcnQgZm9yIG11bHRpcGxlIHR5cGVzXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaG9va11cbiAgICogQHBhcmFtIHtPYmplY3R9IGhvb2sudHlwZVxuICAgKi9cbiAgb246IGZ1bmN0aW9uIG9uKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIsIGhvb2spIHtcbiAgICB2YXIgdHlwZXMgPSB0eXBlLnNwbGl0KCcgJyk7XG4gICAgVXRpbHMuZWFjaCh0eXBlcywgZnVuY3Rpb24odHlwZSkge1xuICAgICAgVXRpbHMub24oZWxlbWVudCwgdHlwZSwgaGFuZGxlcik7XG4gICAgICBob29rICYmIGhvb2sodHlwZSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHNpbXBsZSBldmVudCB1bmJpbmRlciB3aXRoIGEgaG9vayBhbmQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgdHlwZXNcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtob29rXVxuICAgKiBAcGFyYW0ge09iamVjdH0gaG9vay50eXBlXG4gICAqL1xuICBvZmY6IGZ1bmN0aW9uIG9mZihlbGVtZW50LCB0eXBlLCBoYW5kbGVyLCBob29rKSB7XG4gICAgdmFyIHR5cGVzID0gdHlwZS5zcGxpdCgnICcpO1xuICAgIFV0aWxzLmVhY2godHlwZXMsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIFV0aWxzLm9mZihlbGVtZW50LCB0eXBlLCBoYW5kbGVyKTtcbiAgICAgIGhvb2sgJiYgaG9vayh0eXBlKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogdGhlIGNvcmUgdG91Y2ggZXZlbnQgaGFuZGxlci5cbiAgICogdGhpcyBmaW5kcyBvdXQgaWYgd2Ugc2hvdWxkIHRvIGRldGVjdCBnZXN0dXJlc1xuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGUgbWF0Y2hlcyBgRVZFTlRfU1RBUlR8TU9WRXxFTkRgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICogQHJldHVybiBvblRvdWNoSGFuZGxlciB7RnVuY3Rpb259IHRoZSBjb3JlIGV2ZW50IGhhbmRsZXJcbiAgICovXG4gIG9uVG91Y2g6IGZ1bmN0aW9uIG9uVG91Y2goZWxlbWVudCwgZXZlbnRUeXBlLCBoYW5kbGVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIG9uVG91Y2hIYW5kbGVyID0gZnVuY3Rpb24gb25Ub3VjaEhhbmRsZXIoZXYpIHtcbiAgICAgIHZhciBzcmNUeXBlID0gZXYudHlwZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgIGlzUG9pbnRlciA9IEdlc3R1cmVEZXRlY3Rvci5IQVNfUE9JTlRFUkVWRU5UUyxcbiAgICAgICAgICBpc01vdXNlID0gVXRpbHMuaW5TdHIoc3JjVHlwZSwgJ21vdXNlJyksXG4gICAgICAgICAgdHJpZ2dlclR5cGU7XG5cbiAgICAgIC8vIGlmIHdlIGFyZSBpbiBhIG1vdXNlZXZlbnQsIGJ1dCB0aGVyZSBoYXMgYmVlbiBhIHRvdWNoZXZlbnQgdHJpZ2dlcmVkIGluIHRoaXMgc2Vzc2lvblxuICAgICAgLy8gd2Ugd2FudCB0byBkbyBub3RoaW5nLiBzaW1wbHkgYnJlYWsgb3V0IG9mIHRoZSBldmVudC5cbiAgICAgIGlmKGlzTW91c2UgJiYgc2VsZi5wcmV2ZW50TW91c2VFdmVudHMpIHtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIC8vIG1vdXNlYnV0dG9uIG11c3QgYmUgZG93blxuICAgICAgfSBlbHNlIGlmKGlzTW91c2UgJiYgZXZlbnRUeXBlID09IEVWRU5UX1NUQVJUICYmIGV2LmJ1dHRvbiA9PT0gMCkge1xuICAgICAgICBzZWxmLnByZXZlbnRNb3VzZUV2ZW50cyA9IGZhbHNlO1xuICAgICAgICBzZWxmLnNob3VsZERldGVjdCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYoaXNQb2ludGVyICYmIGV2ZW50VHlwZSA9PSBFVkVOVF9TVEFSVCkge1xuICAgICAgICBzZWxmLnNob3VsZERldGVjdCA9IChldi5idXR0b25zID09PSAxIHx8IFBvaW50ZXJFdmVudC5tYXRjaFR5cGUoUE9JTlRFUl9UT1VDSCwgZXYpKTtcbiAgICAgICAgLy8ganVzdCBhIHZhbGlkIHN0YXJ0IGV2ZW50LCBidXQgbm8gbW91c2VcbiAgICAgIH0gZWxzZSBpZighaXNNb3VzZSAmJiBldmVudFR5cGUgPT0gRVZFTlRfU1RBUlQpIHtcbiAgICAgICAgc2VsZi5wcmV2ZW50TW91c2VFdmVudHMgPSB0cnVlO1xuICAgICAgICBzZWxmLnNob3VsZERldGVjdCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHVwZGF0ZSB0aGUgcG9pbnRlciBldmVudCBiZWZvcmUgZW50ZXJpbmcgdGhlIGRldGVjdGlvblxuICAgICAgaWYoaXNQb2ludGVyICYmIGV2ZW50VHlwZSAhPSBFVkVOVF9FTkQpIHtcbiAgICAgICAgUG9pbnRlckV2ZW50LnVwZGF0ZVBvaW50ZXIoZXZlbnRUeXBlLCBldik7XG4gICAgICB9XG5cbiAgICAgIC8vIHdlIGFyZSBpbiBhIHRvdWNoL2Rvd24gc3RhdGUsIHNvIGFsbG93ZWQgZGV0ZWN0aW9uIG9mIGdlc3R1cmVzXG4gICAgICBpZihzZWxmLnNob3VsZERldGVjdCkge1xuICAgICAgICB0cmlnZ2VyVHlwZSA9IHNlbGYuZG9EZXRlY3QuY2FsbChzZWxmLCBldiwgZXZlbnRUeXBlLCBlbGVtZW50LCBoYW5kbGVyKTtcbiAgICAgIH1cblxuICAgICAgLy8gLi4uYW5kIHdlIGFyZSBkb25lIHdpdGggdGhlIGRldGVjdGlvblxuICAgICAgLy8gc28gcmVzZXQgZXZlcnl0aGluZyB0byBzdGFydCBlYWNoIGRldGVjdGlvbiB0b3RhbGx5IGZyZXNoXG4gICAgICBpZih0cmlnZ2VyVHlwZSA9PSBFVkVOVF9FTkQpIHtcbiAgICAgICAgc2VsZi5wcmV2ZW50TW91c2VFdmVudHMgPSBmYWxzZTtcbiAgICAgICAgc2VsZi5zaG91bGREZXRlY3QgPSBmYWxzZTtcbiAgICAgICAgUG9pbnRlckV2ZW50LnJlc2V0KCk7XG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgcG9pbnRlcmV2ZW50IG9iamVjdCBhZnRlciB0aGUgZGV0ZWN0aW9uXG4gICAgICB9XG5cbiAgICAgIGlmKGlzUG9pbnRlciAmJiBldmVudFR5cGUgPT0gRVZFTlRfRU5EKSB7XG4gICAgICAgIFBvaW50ZXJFdmVudC51cGRhdGVQb2ludGVyKGV2ZW50VHlwZSwgZXYpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLm9uKGVsZW1lbnQsIEVWRU5UX1RZUEVTW2V2ZW50VHlwZV0sIG9uVG91Y2hIYW5kbGVyKTtcbiAgICByZXR1cm4gb25Ub3VjaEhhbmRsZXI7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHRoZSBjb3JlIGRldGVjdGlvbiBtZXRob2RcbiAgICogdGhpcyBmaW5kcyBvdXQgd2hhdCBHZXN0dXJlRGV0ZWN0b3ItdG91Y2gtZXZlbnRzIHRvIHRyaWdnZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGUgbWF0Y2hlcyBgRVZFTlRfU1RBUlR8TU9WRXxFTkRgXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRyaWdnZXJUeXBlIG1hdGNoZXMgYEVWRU5UX1NUQVJUfE1PVkV8RU5EYFxuICAgKi9cbiAgZG9EZXRlY3Q6IGZ1bmN0aW9uIGRvRGV0ZWN0KGV2LCBldmVudFR5cGUsIGVsZW1lbnQsIGhhbmRsZXIpIHtcbiAgICB2YXIgdG91Y2hMaXN0ID0gdGhpcy5nZXRUb3VjaExpc3QoZXYsIGV2ZW50VHlwZSk7XG4gICAgdmFyIHRvdWNoTGlzdExlbmd0aCA9IHRvdWNoTGlzdC5sZW5ndGg7XG4gICAgdmFyIHRyaWdnZXJUeXBlID0gZXZlbnRUeXBlO1xuICAgIHZhciB0cmlnZ2VyQ2hhbmdlID0gdG91Y2hMaXN0LnRyaWdnZXI7IC8vIHVzZWQgYnkgZmFrZU11bHRpdG91Y2ggcGx1Z2luXG4gICAgdmFyIGNoYW5nZWRMZW5ndGggPSB0b3VjaExpc3RMZW5ndGg7XG5cbiAgICAvLyBhdCBlYWNoIHRvdWNoc3RhcnQtbGlrZSBldmVudCB3ZSB3YW50IGFsc28gd2FudCB0byB0cmlnZ2VyIGEgVE9VQ0ggZXZlbnQuLi5cbiAgICBpZihldmVudFR5cGUgPT0gRVZFTlRfU1RBUlQpIHtcbiAgICAgIHRyaWdnZXJDaGFuZ2UgPSBFVkVOVF9UT1VDSDtcbiAgICAgIC8vIC4uLnRoZSBzYW1lIGZvciBhIHRvdWNoZW5kLWxpa2UgZXZlbnRcbiAgICB9IGVsc2UgaWYoZXZlbnRUeXBlID09IEVWRU5UX0VORCkge1xuICAgICAgdHJpZ2dlckNoYW5nZSA9IEVWRU5UX1JFTEVBU0U7XG5cbiAgICAgIC8vIGtlZXAgdHJhY2sgb2YgaG93IG1hbnkgdG91Y2hlcyBoYXZlIGJlZW4gcmVtb3ZlZFxuICAgICAgY2hhbmdlZExlbmd0aCA9IHRvdWNoTGlzdC5sZW5ndGggLSAoKGV2LmNoYW5nZWRUb3VjaGVzKSA/IGV2LmNoYW5nZWRUb3VjaGVzLmxlbmd0aCA6IDEpO1xuICAgIH1cblxuICAgIC8vIGFmdGVyIHRoZXJlIGFyZSBzdGlsbCB0b3VjaGVzIG9uIHRoZSBzY3JlZW4sXG4gICAgLy8gd2UganVzdCB3YW50IHRvIHRyaWdnZXIgYSBNT1ZFIGV2ZW50LiBzbyBjaGFuZ2UgdGhlIFNUQVJUIG9yIEVORCB0byBhIE1PVkVcbiAgICAvLyBidXQgb25seSBhZnRlciBkZXRlY3Rpb24gaGFzIGJlZW4gc3RhcnRlZCwgdGhlIGZpcnN0IHRpbWUgd2UgYWN0dWFsbHkgd2FudCBhIFNUQVJUXG4gICAgaWYoY2hhbmdlZExlbmd0aCA+IDAgJiYgdGhpcy5zdGFydGVkKSB7XG4gICAgICB0cmlnZ2VyVHlwZSA9IEVWRU5UX01PVkU7XG4gICAgfVxuXG4gICAgLy8gZGV0ZWN0aW9uIGhhcyBiZWVuIHN0YXJ0ZWQsIHdlIGtlZXAgdHJhY2sgb2YgdGhpcywgc2VlIGFib3ZlXG4gICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcblxuICAgIC8vIGdlbmVyYXRlIHNvbWUgZXZlbnQgZGF0YSwgc29tZSBiYXNpYyBpbmZvcm1hdGlvblxuICAgIHZhciBldkRhdGEgPSB0aGlzLmNvbGxlY3RFdmVudERhdGEoZWxlbWVudCwgdHJpZ2dlclR5cGUsIHRvdWNoTGlzdCwgZXYpO1xuXG4gICAgLy8gdHJpZ2dlciB0aGUgdHJpZ2dlclR5cGUgZXZlbnQgYmVmb3JlIHRoZSBjaGFuZ2UgKFRPVUNILCBSRUxFQVNFKSBldmVudHNcbiAgICAvLyBidXQgdGhlIEVORCBldmVudCBzaG91bGQgYmUgYXQgbGFzdFxuICAgIGlmKGV2ZW50VHlwZSAhPSBFVkVOVF9FTkQpIHtcbiAgICAgIGhhbmRsZXIuY2FsbChEZXRlY3Rpb24sIGV2RGF0YSk7XG4gICAgfVxuXG4gICAgLy8gdHJpZ2dlciBhIGNoYW5nZSAoVE9VQ0gsIFJFTEVBU0UpIGV2ZW50LCB0aGlzIG1lYW5zIHRoZSBsZW5ndGggb2YgdGhlIHRvdWNoZXMgY2hhbmdlZFxuICAgIGlmKHRyaWdnZXJDaGFuZ2UpIHtcbiAgICAgIGV2RGF0YS5jaGFuZ2VkTGVuZ3RoID0gY2hhbmdlZExlbmd0aDtcbiAgICAgIGV2RGF0YS5ldmVudFR5cGUgPSB0cmlnZ2VyQ2hhbmdlO1xuXG4gICAgICBoYW5kbGVyLmNhbGwoRGV0ZWN0aW9uLCBldkRhdGEpO1xuXG4gICAgICBldkRhdGEuZXZlbnRUeXBlID0gdHJpZ2dlclR5cGU7XG4gICAgICBkZWxldGUgZXZEYXRhLmNoYW5nZWRMZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gdHJpZ2dlciB0aGUgRU5EIGV2ZW50XG4gICAgaWYodHJpZ2dlclR5cGUgPT0gRVZFTlRfRU5EKSB7XG4gICAgICBoYW5kbGVyLmNhbGwoRGV0ZWN0aW9uLCBldkRhdGEpO1xuXG4gICAgICAvLyAuLi5hbmQgd2UgYXJlIGRvbmUgd2l0aCB0aGUgZGV0ZWN0aW9uXG4gICAgICAvLyBzbyByZXNldCBldmVyeXRoaW5nIHRvIHN0YXJ0IGVhY2ggZGV0ZWN0aW9uIHRvdGFsbHkgZnJlc2hcbiAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cmlnZ2VyVHlwZTtcbiAgfSxcblxuICAvKipcbiAgICogd2UgaGF2ZSBkaWZmZXJlbnQgZXZlbnRzIGZvciBlYWNoIGRldmljZS9icm93c2VyXG4gICAqIGRldGVybWluZSB3aGF0IHdlIG5lZWQgYW5kIHNldCB0aGVtIGluIHRoZSBFVkVOVF9UWVBFUyBjb25zdGFudFxuICAgKiB0aGUgYG9uVG91Y2hgIG1ldGhvZCBpcyBiaW5kIHRvIHRoZXNlIHByb3BlcnRpZXMuXG4gICAqIEByZXR1cm4ge09iamVjdH0gZXZlbnRzXG4gICAqL1xuICBkZXRlcm1pbmVFdmVudFR5cGVzOiBmdW5jdGlvbiBkZXRlcm1pbmVFdmVudFR5cGVzKCkge1xuICAgIHZhciB0eXBlcztcbiAgICBpZihHZXN0dXJlRGV0ZWN0b3IuSEFTX1BPSU5URVJFVkVOVFMpIHtcbiAgICAgIGlmKHdpbmRvdy5Qb2ludGVyRXZlbnQpIHtcbiAgICAgICAgdHlwZXMgPSBbXG4gICAgICAgICAgJ3BvaW50ZXJkb3duJyxcbiAgICAgICAgICAncG9pbnRlcm1vdmUnLFxuICAgICAgICAgICdwb2ludGVydXAgcG9pbnRlcmNhbmNlbCBsb3N0cG9pbnRlcmNhcHR1cmUnXG4gICAgICAgIF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlcyA9IFtcbiAgICAgICAgICAnTVNQb2ludGVyRG93bicsXG4gICAgICAgICAgJ01TUG9pbnRlck1vdmUnLFxuICAgICAgICAgICdNU1BvaW50ZXJVcCBNU1BvaW50ZXJDYW5jZWwgTVNMb3N0UG9pbnRlckNhcHR1cmUnXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmKEdlc3R1cmVEZXRlY3Rvci5OT19NT1VTRUVWRU5UUykge1xuICAgICAgdHlwZXMgPSBbXG4gICAgICAgICd0b3VjaHN0YXJ0JyxcbiAgICAgICAgJ3RvdWNobW92ZScsXG4gICAgICAgICd0b3VjaGVuZCB0b3VjaGNhbmNlbCdcbiAgICAgIF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGVzID0gW1xuICAgICAgICAndG91Y2hzdGFydCBtb3VzZWRvd24nLFxuICAgICAgICAndG91Y2htb3ZlIG1vdXNlbW92ZScsXG4gICAgICAgICd0b3VjaGVuZCB0b3VjaGNhbmNlbCBtb3VzZXVwJ1xuICAgICAgXTtcbiAgICB9XG5cbiAgICBFVkVOVF9UWVBFU1tFVkVOVF9TVEFSVF0gPSB0eXBlc1swXTtcbiAgICBFVkVOVF9UWVBFU1tFVkVOVF9NT1ZFXSA9IHR5cGVzWzFdO1xuICAgIEVWRU5UX1RZUEVTW0VWRU5UX0VORF0gPSB0eXBlc1syXTtcbiAgICByZXR1cm4gRVZFTlRfVFlQRVM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNyZWF0ZSB0b3VjaExpc3QgZGVwZW5kaW5nIG9uIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZVxuICAgKiBAcmV0dXJuIHtBcnJheX0gdG91Y2hlc1xuICAgKi9cbiAgZ2V0VG91Y2hMaXN0OiBmdW5jdGlvbiBnZXRUb3VjaExpc3QoZXYsIGV2ZW50VHlwZSkge1xuICAgIC8vIGdldCB0aGUgZmFrZSBwb2ludGVyRXZlbnQgdG91Y2hsaXN0XG4gICAgaWYoR2VzdHVyZURldGVjdG9yLkhBU19QT0lOVEVSRVZFTlRTKSB7XG4gICAgICByZXR1cm4gUG9pbnRlckV2ZW50LmdldFRvdWNoTGlzdCgpO1xuICAgIH1cblxuICAgIC8vIGdldCB0aGUgdG91Y2hsaXN0XG4gICAgaWYoZXYudG91Y2hlcykge1xuICAgICAgaWYoZXZlbnRUeXBlID09IEVWRU5UX01PVkUpIHtcbiAgICAgICAgcmV0dXJuIGV2LnRvdWNoZXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBpZGVudGlmaWVycyA9IFtdO1xuICAgICAgdmFyIGNvbmNhdCA9IFtdLmNvbmNhdChVdGlscy50b0FycmF5KGV2LnRvdWNoZXMpLCBVdGlscy50b0FycmF5KGV2LmNoYW5nZWRUb3VjaGVzKSk7XG4gICAgICB2YXIgdG91Y2hMaXN0ID0gW107XG5cbiAgICAgIFV0aWxzLmVhY2goY29uY2F0LCBmdW5jdGlvbih0b3VjaCkge1xuICAgICAgICBpZihVdGlscy5pbkFycmF5KGlkZW50aWZpZXJzLCB0b3VjaC5pZGVudGlmaWVyKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0b3VjaExpc3QucHVzaCh0b3VjaCk7XG4gICAgICAgIH1cbiAgICAgICAgaWRlbnRpZmllcnMucHVzaCh0b3VjaC5pZGVudGlmaWVyKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdG91Y2hMaXN0O1xuICAgIH1cblxuICAgIC8vIG1ha2UgZmFrZSB0b3VjaExpc3QgZnJvbSBtb3VzZSBwb3NpdGlvblxuICAgIGV2LmlkZW50aWZpZXIgPSAxO1xuICAgIHJldHVybiBbZXZdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBjb2xsZWN0IGJhc2ljIGV2ZW50IGRhdGFcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlIG1hdGNoZXMgYEVWRU5UX1NUQVJUfE1PVkV8RU5EYFxuICAgKiBAcGFyYW0ge0FycmF5fSB0b3VjaGVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGV2XG4gICAqL1xuICBjb2xsZWN0RXZlbnREYXRhOiBmdW5jdGlvbiBjb2xsZWN0RXZlbnREYXRhKGVsZW1lbnQsIGV2ZW50VHlwZSwgdG91Y2hlcywgZXYpIHtcbiAgICAvLyBmaW5kIG91dCBwb2ludGVyVHlwZVxuICAgIHZhciBwb2ludGVyVHlwZSA9IFBPSU5URVJfVE9VQ0g7XG4gICAgaWYoVXRpbHMuaW5TdHIoZXYudHlwZSwgJ21vdXNlJykgfHwgUG9pbnRlckV2ZW50Lm1hdGNoVHlwZShQT0lOVEVSX01PVVNFLCBldikpIHtcbiAgICAgIHBvaW50ZXJUeXBlID0gUE9JTlRFUl9NT1VTRTtcbiAgICB9IGVsc2UgaWYoUG9pbnRlckV2ZW50Lm1hdGNoVHlwZShQT0lOVEVSX1BFTiwgZXYpKSB7XG4gICAgICBwb2ludGVyVHlwZSA9IFBPSU5URVJfUEVOO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjZW50ZXI6IFV0aWxzLmdldENlbnRlcih0b3VjaGVzKSxcbiAgICAgIHRpbWVTdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgIHRhcmdldDogZXYudGFyZ2V0LFxuICAgICAgdG91Y2hlczogdG91Y2hlcyxcbiAgICAgIGV2ZW50VHlwZTogZXZlbnRUeXBlLFxuICAgICAgcG9pbnRlclR5cGU6IHBvaW50ZXJUeXBlLFxuICAgICAgc3JjRXZlbnQ6IGV2LFxuXG4gICAgICAvKipcbiAgICAgICAqIHByZXZlbnQgdGhlIGJyb3dzZXIgZGVmYXVsdCBhY3Rpb25zXG4gICAgICAgKiBtb3N0bHkgdXNlZCB0byBkaXNhYmxlIHNjcm9sbGluZyBvZiB0aGUgYnJvd3NlclxuICAgICAgICovXG4gICAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzcmNFdmVudCA9IHRoaXMuc3JjRXZlbnQ7XG4gICAgICAgIHNyY0V2ZW50LnByZXZlbnRNYW5pcHVsYXRpb24gJiYgc3JjRXZlbnQucHJldmVudE1hbmlwdWxhdGlvbigpO1xuICAgICAgICBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCAmJiBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBzdG9wIGJ1YmJsaW5nIHRoZSBldmVudCB1cCB0byBpdHMgcGFyZW50c1xuICAgICAgICovXG4gICAgICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNyY0V2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBpbW1lZGlhdGVseSBzdG9wIGdlc3R1cmUgZGV0ZWN0aW9uXG4gICAgICAgKiBtaWdodCBiZSB1c2VmdWwgYWZ0ZXIgYSBzd2lwZSB3YXMgZGV0ZWN0ZWRcbiAgICAgICAqIEByZXR1cm4geyp9XG4gICAgICAgKi9cbiAgICAgIHN0b3BEZXRlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gRGV0ZWN0aW9uLnN0b3BEZXRlY3QoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuXG5cbi8qKlxuICogQG1vZHVsZSBHZXN0dXJlRGV0ZWN0b3JcbiAqXG4gKiBAY2xhc3MgUG9pbnRlckV2ZW50XG4gKiBAc3RhdGljXG4gKi9cblBvaW50ZXJFdmVudCA9IEdlc3R1cmVEZXRlY3Rvci5Qb2ludGVyRXZlbnQgPSB7XG4gIC8qKlxuICAgKiBob2xkcyBhbGwgcG9pbnRlcnMsIGJ5IGBpZGVudGlmaWVyYFxuICAgKiBAcHJvcGVydHkgcG9pbnRlcnNcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHBvaW50ZXJzOiB7fSxcblxuICAvKipcbiAgICogZ2V0IHRoZSBwb2ludGVycyBhcyBhbiBhcnJheVxuICAgKiBAcmV0dXJuIHtBcnJheX0gdG91Y2hsaXN0XG4gICAqL1xuICBnZXRUb3VjaExpc3Q6IGZ1bmN0aW9uIGdldFRvdWNoTGlzdCgpIHtcbiAgICB2YXIgdG91Y2hsaXN0ID0gW107XG4gICAgLy8gd2UgY2FuIHVzZSBmb3JFYWNoIHNpbmNlIHBvaW50ZXJFdmVudHMgb25seSBpcyBpbiBJRTEwXG4gICAgVXRpbHMuZWFjaCh0aGlzLnBvaW50ZXJzLCBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgICB0b3VjaGxpc3QucHVzaChwb2ludGVyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdG91Y2hsaXN0O1xuICB9LFxuXG4gIC8qKlxuICAgKiB1cGRhdGUgdGhlIHBvc2l0aW9uIG9mIGEgcG9pbnRlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlIG1hdGNoZXMgYEVWRU5UX1NUQVJUfE1PVkV8RU5EYFxuICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlckV2ZW50XG4gICAqL1xuICB1cGRhdGVQb2ludGVyOiBmdW5jdGlvbiB1cGRhdGVQb2ludGVyKGV2ZW50VHlwZSwgcG9pbnRlckV2ZW50KSB7XG4gICAgaWYoZXZlbnRUeXBlID09IEVWRU5UX0VORCB8fCAoZXZlbnRUeXBlICE9IEVWRU5UX0VORCAmJiBwb2ludGVyRXZlbnQuYnV0dG9ucyAhPT0gMSkpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnBvaW50ZXJzW3BvaW50ZXJFdmVudC5wb2ludGVySWRdO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludGVyRXZlbnQuaWRlbnRpZmllciA9IHBvaW50ZXJFdmVudC5wb2ludGVySWQ7XG4gICAgICB0aGlzLnBvaW50ZXJzW3BvaW50ZXJFdmVudC5wb2ludGVySWRdID0gcG9pbnRlckV2ZW50O1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogY2hlY2sgaWYgZXYgbWF0Y2hlcyBwb2ludGVydHlwZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcG9pbnRlclR5cGUgbWF0Y2hlcyBgUE9JTlRFUl9NT1VTRXxUT1VDSHxQRU5gXG4gICAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBldlxuICAgKi9cbiAgbWF0Y2hUeXBlOiBmdW5jdGlvbiBtYXRjaFR5cGUocG9pbnRlclR5cGUsIGV2KSB7XG4gICAgaWYoIWV2LnBvaW50ZXJUeXBlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHB0ID0gZXYucG9pbnRlclR5cGUsXG4gICAgICAgIHR5cGVzID0ge307XG5cbiAgICB0eXBlc1tQT0lOVEVSX01PVVNFXSA9IChwdCA9PT0gKGV2Lk1TUE9JTlRFUl9UWVBFX01PVVNFIHx8IFBPSU5URVJfTU9VU0UpKTtcbiAgICB0eXBlc1tQT0lOVEVSX1RPVUNIXSA9IChwdCA9PT0gKGV2Lk1TUE9JTlRFUl9UWVBFX1RPVUNIIHx8IFBPSU5URVJfVE9VQ0gpKTtcbiAgICB0eXBlc1tQT0lOVEVSX1BFTl0gPSAocHQgPT09IChldi5NU1BPSU5URVJfVFlQRV9QRU4gfHwgUE9JTlRFUl9QRU4pKTtcbiAgICByZXR1cm4gdHlwZXNbcG9pbnRlclR5cGVdO1xuICB9LFxuXG4gIC8qKlxuICAgKiByZXNldCB0aGUgc3RvcmVkIHBvaW50ZXJzXG4gICAqL1xuICByZXNldDogZnVuY3Rpb24gcmVzZXRMaXN0KCkge1xuICAgIHRoaXMucG9pbnRlcnMgPSB7fTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEBtb2R1bGUgR2VzdHVyZURldGVjdG9yXG4gKlxuICogQGNsYXNzIERldGVjdGlvblxuICogQHN0YXRpY1xuICovXG5EZXRlY3Rpb24gPSBHZXN0dXJlRGV0ZWN0b3IuZGV0ZWN0aW9uID0ge1xuICAvLyBjb250YWlucyBhbGwgcmVnaXN0ZXJlZCBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMgaW4gdGhlIGNvcnJlY3Qgb3JkZXJcbiAgZ2VzdHVyZXM6IFtdLFxuXG4gIC8vIGRhdGEgb2YgdGhlIGN1cnJlbnQgR2VzdHVyZURldGVjdG9yLmdlc3R1cmUgZGV0ZWN0aW9uIHNlc3Npb25cbiAgY3VycmVudDogbnVsbCxcblxuICAvLyB0aGUgcHJldmlvdXMgR2VzdHVyZURldGVjdG9yLmdlc3R1cmUgc2Vzc2lvbiBkYXRhXG4gIC8vIGlzIGEgZnVsbCBjbG9uZSBvZiB0aGUgcHJldmlvdXMgZ2VzdHVyZS5jdXJyZW50IG9iamVjdFxuICBwcmV2aW91czogbnVsbCxcblxuICAvLyB3aGVuIHRoaXMgYmVjb21lcyB0cnVlLCBubyBnZXN0dXJlcyBhcmUgZmlyZWRcbiAgc3RvcHBlZDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIHN0YXJ0IEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIGRldGVjdGlvblxuICAgKiBAcGFyYW0ge0dlc3R1cmVEZXRlY3Rvci5JbnN0YW5jZX0gaW5zdFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnREYXRhXG4gICAqL1xuICBzdGFydERldGVjdDogZnVuY3Rpb24gc3RhcnREZXRlY3QoaW5zdCwgZXZlbnREYXRhKSB7XG4gICAgLy8gYWxyZWFkeSBidXN5IHdpdGggYSBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZSBkZXRlY3Rpb24gb24gYW4gZWxlbWVudFxuICAgIGlmKHRoaXMuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc3RvcHBlZCA9IGZhbHNlO1xuXG4gICAgLy8gaG9sZHMgY3VycmVudCBzZXNzaW9uXG4gICAgdGhpcy5jdXJyZW50ID0ge1xuICAgICAgaW5zdDogaW5zdCwgLy8gcmVmZXJlbmNlIHRvIEdlc3R1cmVEZXRlY3Rvckluc3RhbmNlIHdlJ3JlIHdvcmtpbmcgZm9yXG4gICAgICBzdGFydEV2ZW50OiBVdGlscy5leHRlbmQoe30sIGV2ZW50RGF0YSksIC8vIHN0YXJ0IGV2ZW50RGF0YSBmb3IgZGlzdGFuY2VzLCB0aW1pbmcgZXRjXG4gICAgICBsYXN0RXZlbnQ6IGZhbHNlLCAvLyBsYXN0IGV2ZW50RGF0YVxuICAgICAgbGFzdENhbGNFdmVudDogZmFsc2UsIC8vIGxhc3QgZXZlbnREYXRhIGZvciBjYWxjdWxhdGlvbnMuXG4gICAgICBmdXR1cmVDYWxjRXZlbnQ6IGZhbHNlLCAvLyBsYXN0IGV2ZW50RGF0YSBmb3IgY2FsY3VsYXRpb25zLlxuICAgICAgbGFzdENhbGNEYXRhOiB7fSwgLy8gbGFzdCBsYXN0Q2FsY0RhdGFcbiAgICAgIG5hbWU6ICcnIC8vIGN1cnJlbnQgZ2VzdHVyZSB3ZSdyZSBpbi9kZXRlY3RlZCwgY2FuIGJlICd0YXAnLCAnaG9sZCcgZXRjXG4gICAgfTtcblxuICAgIHRoaXMuZGV0ZWN0KGV2ZW50RGF0YSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIGRldGVjdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnREYXRhXG4gICAqIEByZXR1cm4ge2FueX1cbiAgICovXG4gIGRldGVjdDogZnVuY3Rpb24gZGV0ZWN0KGV2ZW50RGF0YSkge1xuICAgIGlmKCF0aGlzLmN1cnJlbnQgfHwgdGhpcy5zdG9wcGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZXh0ZW5kIGV2ZW50IGRhdGEgd2l0aCBjYWxjdWxhdGlvbnMgYWJvdXQgc2NhbGUsIGRpc3RhbmNlIGV0Y1xuICAgIGV2ZW50RGF0YSA9IHRoaXMuZXh0ZW5kRXZlbnREYXRhKGV2ZW50RGF0YSk7XG5cbiAgICAvLyBHZXN0dXJlRGV0ZWN0b3IgaW5zdGFuY2UgYW5kIGluc3RhbmNlIG9wdGlvbnNcbiAgICB2YXIgaW5zdCA9IHRoaXMuY3VycmVudC5pbnN0LFxuICAgICAgICBpbnN0T3B0aW9ucyA9IGluc3Qub3B0aW9ucztcblxuICAgIC8vIGNhbGwgR2VzdHVyZURldGVjdG9yLmdlc3R1cmUgaGFuZGxlcnNcbiAgICBVdGlscy5lYWNoKHRoaXMuZ2VzdHVyZXMsIGZ1bmN0aW9uIHRyaWdnZXJHZXN0dXJlKGdlc3R1cmUpIHtcbiAgICAgIC8vIG9ubHkgd2hlbiB0aGUgaW5zdGFuY2Ugb3B0aW9ucyBoYXZlIGVuYWJsZWQgdGhpcyBnZXN0dXJlXG4gICAgICBpZighdGhpcy5zdG9wcGVkICYmIGluc3QuZW5hYmxlZCAmJiBpbnN0T3B0aW9uc1tnZXN0dXJlLm5hbWVdKSB7XG4gICAgICAgIGdlc3R1cmUuaGFuZGxlci5jYWxsKGdlc3R1cmUsIGV2ZW50RGF0YSwgaW5zdCk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG5cbiAgICAvLyBzdG9yZSBhcyBwcmV2aW91cyBldmVudCBldmVudFxuICAgIGlmKHRoaXMuY3VycmVudCkge1xuICAgICAgdGhpcy5jdXJyZW50Lmxhc3RFdmVudCA9IGV2ZW50RGF0YTtcbiAgICB9XG5cbiAgICBpZihldmVudERhdGEuZXZlbnRUeXBlID09IEVWRU5UX0VORCkge1xuICAgICAgdGhpcy5zdG9wRGV0ZWN0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV2ZW50RGF0YTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICB9LFxuXG4gIC8qKlxuICAgKiBjbGVhciB0aGUgR2VzdHVyZURldGVjdG9yLmdlc3R1cmUgdmFyc1xuICAgKiB0aGlzIGlzIGNhbGxlZCBvbiBlbmREZXRlY3QsIGJ1dCBjYW4gYWxzbyBiZSB1c2VkIHdoZW4gYSBmaW5hbCBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZSBoYXMgYmVlbiBkZXRlY3RlZFxuICAgKiB0byBzdG9wIG90aGVyIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcyBmcm9tIGJlaW5nIGZpcmVkXG4gICAqL1xuICBzdG9wRGV0ZWN0OiBmdW5jdGlvbiBzdG9wRGV0ZWN0KCkge1xuICAgIC8vIGNsb25lIGN1cnJlbnQgZGF0YSB0byB0aGUgc3RvcmUgYXMgdGhlIHByZXZpb3VzIGdlc3R1cmVcbiAgICAvLyB1c2VkIGZvciB0aGUgZG91YmxlIHRhcCBnZXN0dXJlLCBzaW5jZSB0aGlzIGlzIGFuIG90aGVyIGdlc3R1cmUgZGV0ZWN0IHNlc3Npb25cbiAgICB0aGlzLnByZXZpb3VzID0gVXRpbHMuZXh0ZW5kKHt9LCB0aGlzLmN1cnJlbnQpO1xuXG4gICAgLy8gcmVzZXQgdGhlIGN1cnJlbnRcbiAgICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuICAgIHRoaXMuc3RvcHBlZCA9IHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB2ZWxvY2l0eSwgYW5nbGUgYW5kIGRpcmVjdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICogQHBhcmFtIHtPYmplY3R9IGNlbnRlclxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFUaW1lXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhWVxuICAgKi9cbiAgZ2V0Q2FsY3VsYXRlZERhdGE6IGZ1bmN0aW9uIGdldENhbGN1bGF0ZWREYXRhKGV2LCBjZW50ZXIsIGRlbHRhVGltZSwgZGVsdGFYLCBkZWx0YVkpIHtcbiAgICB2YXIgY3VyID0gdGhpcy5jdXJyZW50LFxuICAgICAgICByZWNhbGMgPSBmYWxzZSxcbiAgICAgICAgY2FsY0V2ID0gY3VyLmxhc3RDYWxjRXZlbnQsXG4gICAgICAgIGNhbGNEYXRhID0gY3VyLmxhc3RDYWxjRGF0YTtcblxuICAgIGlmKGNhbGNFdiAmJiBldi50aW1lU3RhbXAgLSBjYWxjRXYudGltZVN0YW1wID4gR2VzdHVyZURldGVjdG9yLkNBTENVTEFURV9JTlRFUlZBTCkge1xuICAgICAgY2VudGVyID0gY2FsY0V2LmNlbnRlcjtcbiAgICAgIGRlbHRhVGltZSA9IGV2LnRpbWVTdGFtcCAtIGNhbGNFdi50aW1lU3RhbXA7XG4gICAgICBkZWx0YVggPSBldi5jZW50ZXIuY2xpZW50WCAtIGNhbGNFdi5jZW50ZXIuY2xpZW50WDtcbiAgICAgIGRlbHRhWSA9IGV2LmNlbnRlci5jbGllbnRZIC0gY2FsY0V2LmNlbnRlci5jbGllbnRZO1xuICAgICAgcmVjYWxjID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZihldi5ldmVudFR5cGUgPT0gRVZFTlRfVE9VQ0ggfHwgZXYuZXZlbnRUeXBlID09IEVWRU5UX1JFTEVBU0UpIHtcbiAgICAgIGN1ci5mdXR1cmVDYWxjRXZlbnQgPSBldjtcbiAgICB9XG5cbiAgICBpZighY3VyLmxhc3RDYWxjRXZlbnQgfHwgcmVjYWxjKSB7XG4gICAgICBjYWxjRGF0YS52ZWxvY2l0eSA9IFV0aWxzLmdldFZlbG9jaXR5KGRlbHRhVGltZSwgZGVsdGFYLCBkZWx0YVkpO1xuICAgICAgY2FsY0RhdGEuYW5nbGUgPSBVdGlscy5nZXRBbmdsZShjZW50ZXIsIGV2LmNlbnRlcik7XG4gICAgICBjYWxjRGF0YS5kaXJlY3Rpb24gPSBVdGlscy5nZXREaXJlY3Rpb24oY2VudGVyLCBldi5jZW50ZXIpO1xuXG4gICAgICBjdXIubGFzdENhbGNFdmVudCA9IGN1ci5mdXR1cmVDYWxjRXZlbnQgfHwgZXY7XG4gICAgICBjdXIuZnV0dXJlQ2FsY0V2ZW50ID0gZXY7XG4gICAgfVxuXG4gICAgZXYudmVsb2NpdHlYID0gY2FsY0RhdGEudmVsb2NpdHkueDtcbiAgICBldi52ZWxvY2l0eVkgPSBjYWxjRGF0YS52ZWxvY2l0eS55O1xuICAgIGV2LmludGVyaW1BbmdsZSA9IGNhbGNEYXRhLmFuZ2xlO1xuICAgIGV2LmludGVyaW1EaXJlY3Rpb24gPSBjYWxjRGF0YS5kaXJlY3Rpb247XG4gIH0sXG5cbiAgLyoqXG4gICAqIGV4dGVuZCBldmVudERhdGEgZm9yIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlc1xuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICogQHJldHVybiB7T2JqZWN0fSBldlxuICAgKi9cbiAgZXh0ZW5kRXZlbnREYXRhOiBmdW5jdGlvbiBleHRlbmRFdmVudERhdGEoZXYpIHtcbiAgICB2YXIgY3VyID0gdGhpcy5jdXJyZW50LFxuICAgICAgICBzdGFydEV2ID0gY3VyLnN0YXJ0RXZlbnQsXG4gICAgICAgIGxhc3RFdiA9IGN1ci5sYXN0RXZlbnQgfHwgc3RhcnRFdjtcblxuICAgIC8vIHVwZGF0ZSB0aGUgc3RhcnQgdG91Y2hsaXN0IHRvIGNhbGN1bGF0ZSB0aGUgc2NhbGUvcm90YXRpb25cbiAgICBpZihldi5ldmVudFR5cGUgPT0gRVZFTlRfVE9VQ0ggfHwgZXYuZXZlbnRUeXBlID09IEVWRU5UX1JFTEVBU0UpIHtcbiAgICAgIHN0YXJ0RXYudG91Y2hlcyA9IFtdO1xuICAgICAgVXRpbHMuZWFjaChldi50b3VjaGVzLCBmdW5jdGlvbih0b3VjaCkge1xuICAgICAgICBzdGFydEV2LnRvdWNoZXMucHVzaCh7XG4gICAgICAgICAgY2xpZW50WDogdG91Y2guY2xpZW50WCxcbiAgICAgICAgICBjbGllbnRZOiB0b3VjaC5jbGllbnRZXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGRlbHRhVGltZSA9IGV2LnRpbWVTdGFtcCAtIHN0YXJ0RXYudGltZVN0YW1wLFxuICAgICAgICBkZWx0YVggPSBldi5jZW50ZXIuY2xpZW50WCAtIHN0YXJ0RXYuY2VudGVyLmNsaWVudFgsXG4gICAgICAgIGRlbHRhWSA9IGV2LmNlbnRlci5jbGllbnRZIC0gc3RhcnRFdi5jZW50ZXIuY2xpZW50WTtcblxuICAgIHRoaXMuZ2V0Q2FsY3VsYXRlZERhdGEoZXYsIGxhc3RFdi5jZW50ZXIsIGRlbHRhVGltZSwgZGVsdGFYLCBkZWx0YVkpO1xuXG4gICAgVXRpbHMuZXh0ZW5kKGV2LCB7XG4gICAgICBzdGFydEV2ZW50OiBzdGFydEV2LFxuXG4gICAgICBkZWx0YVRpbWU6IGRlbHRhVGltZSxcbiAgICAgIGRlbHRhWDogZGVsdGFYLFxuICAgICAgZGVsdGFZOiBkZWx0YVksXG5cbiAgICAgIGRpc3RhbmNlOiBVdGlscy5nZXREaXN0YW5jZShzdGFydEV2LmNlbnRlciwgZXYuY2VudGVyKSxcbiAgICAgIGFuZ2xlOiBVdGlscy5nZXRBbmdsZShzdGFydEV2LmNlbnRlciwgZXYuY2VudGVyKSxcbiAgICAgIGRpcmVjdGlvbjogVXRpbHMuZ2V0RGlyZWN0aW9uKHN0YXJ0RXYuY2VudGVyLCBldi5jZW50ZXIpLFxuICAgICAgc2NhbGU6IFV0aWxzLmdldFNjYWxlKHN0YXJ0RXYudG91Y2hlcywgZXYudG91Y2hlcyksXG4gICAgICByb3RhdGlvbjogVXRpbHMuZ2V0Um90YXRpb24oc3RhcnRFdi50b3VjaGVzLCBldi50b3VjaGVzKVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGV2O1xuICB9LFxuXG4gIC8qKlxuICAgKiByZWdpc3RlciBuZXcgZ2VzdHVyZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZ2VzdHVyZSBvYmplY3QsIHNlZSBgZ2VzdHVyZXMvYCBmb3IgZG9jdW1lbnRhdGlvblxuICAgKiBAcmV0dXJuIHtBcnJheX0gZ2VzdHVyZXNcbiAgICovXG4gIHJlZ2lzdGVyOiBmdW5jdGlvbiByZWdpc3RlcihnZXN0dXJlKSB7XG4gICAgLy8gYWRkIGFuIGVuYWJsZSBnZXN0dXJlIG9wdGlvbnMgaWYgdGhlcmUgaXMgbm8gZ2l2ZW5cbiAgICB2YXIgb3B0aW9ucyA9IGdlc3R1cmUuZGVmYXVsdHMgfHwge307XG4gICAgaWYob3B0aW9uc1tnZXN0dXJlLm5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnNbZ2VzdHVyZS5uYW1lXSA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gZXh0ZW5kIEdlc3R1cmVEZXRlY3RvciBkZWZhdWx0IG9wdGlvbnMgd2l0aCB0aGUgR2VzdHVyZURldGVjdG9yLmdlc3R1cmUgb3B0aW9uc1xuICAgIFV0aWxzLmV4dGVuZChHZXN0dXJlRGV0ZWN0b3IuZGVmYXVsdHMsIG9wdGlvbnMsIHRydWUpO1xuXG4gICAgLy8gc2V0IGl0cyBpbmRleFxuICAgIGdlc3R1cmUuaW5kZXggPSBnZXN0dXJlLmluZGV4IHx8IDEwMDA7XG5cbiAgICAvLyBhZGQgR2VzdHVyZURldGVjdG9yLmdlc3R1cmUgdG8gdGhlIGxpc3RcbiAgICB0aGlzLmdlc3R1cmVzLnB1c2goZ2VzdHVyZSk7XG5cbiAgICAvLyBzb3J0IHRoZSBsaXN0IGJ5IGluZGV4XG4gICAgdGhpcy5nZXN0dXJlcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIGlmKGEuaW5kZXggPCBiLmluZGV4KSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGlmKGEuaW5kZXggPiBiLmluZGV4KSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5nZXN0dXJlcztcbiAgfVxufTtcblxuXG4vKipcbiAqIEBtb2R1bGUgR2VzdHVyZURldGVjdG9yXG4gKi9cblxuLyoqXG4gKiBjcmVhdGUgbmV3IEdlc3R1cmVEZXRlY3RvciBpbnN0YW5jZVxuICogYWxsIG1ldGhvZHMgc2hvdWxkIHJldHVybiB0aGUgaW5zdGFuY2UgaXRzZWxmLCBzbyBpdCBpcyBjaGFpbmFibGUuXG4gKlxuICogQGNsYXNzIEluc3RhbmNlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gb3B0aW9ucyBhcmUgbWVyZ2VkIHdpdGggYEdlc3R1cmVEZXRlY3Rvci5kZWZhdWx0c2BcbiAqIEByZXR1cm4ge0dlc3R1cmVEZXRlY3Rvci5JbnN0YW5jZX1cbiAqL1xuR2VzdHVyZURldGVjdG9yLkluc3RhbmNlID0gZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLy8gc2V0dXAgR2VzdHVyZURldGVjdG9ySlMgd2luZG93IGV2ZW50cyBhbmQgcmVnaXN0ZXIgYWxsIGdlc3R1cmVzXG4gIC8vIHRoaXMgYWxzbyBzZXRzIHVwIHRoZSBkZWZhdWx0IG9wdGlvbnNcbiAgc2V0dXAoKTtcblxuICAvKipcbiAgICogQHByb3BlcnR5IGVsZW1lbnRcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcblxuICAvKipcbiAgICogQHByb3BlcnR5IGVuYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHRoaXMuZW5hYmxlZCA9IHRydWU7XG5cbiAgLyoqXG4gICAqIG9wdGlvbnMsIG1lcmdlZCB3aXRoIHRoZSBkZWZhdWx0c1xuICAgKiBvcHRpb25zIHdpdGggYW4gXyBhcmUgY29udmVydGVkIHRvIGNhbWVsQ2FzZVxuICAgKiBAcHJvcGVydHkgb3B0aW9uc1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgVXRpbHMuZWFjaChvcHRpb25zLCBmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgIGRlbGV0ZSBvcHRpb25zW25hbWVdO1xuICAgIG9wdGlvbnNbVXRpbHMudG9DYW1lbENhc2UobmFtZSldID0gdmFsdWU7XG4gIH0pO1xuXG4gIHRoaXMub3B0aW9ucyA9IFV0aWxzLmV4dGVuZChVdGlscy5leHRlbmQoe30sIEdlc3R1cmVEZXRlY3Rvci5kZWZhdWx0cyksIG9wdGlvbnMgfHwge30pO1xuXG4gIC8vIGFkZCBzb21lIGNzcyB0byB0aGUgZWxlbWVudCB0byBwcmV2ZW50IHRoZSBicm93c2VyIGZyb20gZG9pbmcgaXRzIG5hdGl2ZSBiZWhhdmlvclxuICBpZih0aGlzLm9wdGlvbnMuYmVoYXZpb3IpIHtcbiAgICBVdGlscy50b2dnbGVCZWhhdmlvcih0aGlzLmVsZW1lbnQsIHRoaXMub3B0aW9ucy5iZWhhdmlvciwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogZXZlbnQgc3RhcnQgaGFuZGxlciBvbiB0aGUgZWxlbWVudCB0byBzdGFydCB0aGUgZGV0ZWN0aW9uXG4gICAqIEBwcm9wZXJ0eSBldmVudFN0YXJ0SGFuZGxlclxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgdGhpcy5ldmVudFN0YXJ0SGFuZGxlciA9IEV2ZW50Lm9uVG91Y2goZWxlbWVudCwgRVZFTlRfU1RBUlQsIGZ1bmN0aW9uKGV2KSB7XG4gICAgaWYoc2VsZi5lbmFibGVkICYmIGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9TVEFSVCkge1xuICAgICAgRGV0ZWN0aW9uLnN0YXJ0RGV0ZWN0KHNlbGYsIGV2KTtcbiAgICB9IGVsc2UgaWYoZXYuZXZlbnRUeXBlID09IEVWRU5UX1RPVUNIKSB7XG4gICAgICBEZXRlY3Rpb24uZGV0ZWN0KGV2KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBrZWVwIGEgbGlzdCBvZiB1c2VyIGV2ZW50IGhhbmRsZXJzIHdoaWNoIG5lZWRzIHRvIGJlIHJlbW92ZWQgd2hlbiBjYWxsaW5nICdkaXNwb3NlJ1xuICAgKiBAcHJvcGVydHkgZXZlbnRIYW5kbGVyc1xuICAgKiBAdHlwZSB7QXJyYXl9XG4gICAqL1xuICB0aGlzLmV2ZW50SGFuZGxlcnMgPSBbXTtcbn07XG5cbkdlc3R1cmVEZXRlY3Rvci5JbnN0YW5jZS5wcm90b3R5cGUgPSB7XG4gIC8qKlxuICAgKiBAbWV0aG9kIG9uXG4gICAqIEBzaWduYXR1cmUgb24oZ2VzdHVyZXMsIGhhbmRsZXIpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUFkZHMgYW4gZXZlbnQgaGFuZGxlciBmb3IgYSBnZXN0dXJlLiBBdmFpbGFibGUgZ2VzdHVyZXMgYXJlOiBkcmFnLCBkcmFnbGVmdCwgZHJhZ3JpZ2h0LCBkcmFndXAsIGRyYWdkb3duLCBob2xkLCByZWxlYXNlLCBzd2lwZSwgc3dpcGVsZWZ0LCBzd2lwZXJpZ2h0LCBzd2lwZXVwLCBzd2lwZWRvd24sIHRhcCwgZG91YmxldGFwLCB0b3VjaCwgdHJhbnNmb3JtLCBwaW5jaCwgcGluY2hpbiwgcGluY2hvdXQgYW5kIHJvdGF0ZS4gWy9lbl1cbiAgICogIFtqYV3jgrjjgqfjgrnjg4Hjg6Pjgavlr77jgZnjgovjgqTjg5njg7Pjg4jjg4/jg7Pjg4njg6njgpLov73liqDjgZfjgb7jgZnjgILmjIflrprjgafjgY3jgovjgrjjgqfjgrnjg4Hjg6PlkI3jga/jgIFkcmFnIGRyYWdsZWZ0IGRyYWdyaWdodCBkcmFndXAgZHJhZ2Rvd24gaG9sZCByZWxlYXNlIHN3aXBlIHN3aXBlbGVmdCBzd2lwZXJpZ2h0IHN3aXBldXAgc3dpcGVkb3duIHRhcCBkb3VibGV0YXAgdG91Y2ggdHJhbnNmb3JtIHBpbmNoIHBpbmNoaW4gcGluY2hvdXQgcm90YXRlIOOBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBnZXN0dXJlc1xuICAgKiAgIFtlbl1BIHNwYWNlIHNlcGFyYXRlZCBsaXN0IG9mIGdlc3R1cmVzLlsvZW5dXG4gICAqICAgW2phXeaknOefpeOBmeOCi+OCuOOCp+OCueODgeODo+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAguOCueODmuODvOOCueOBp+ikh+aVsOaMh+WumuOBmeOCi+OBk+OBqOOBjOOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICogICBbZW5dQW4gZXZlbnQgaGFuZGxpbmcgZnVuY3Rpb24uWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44OP44Oz44OJ44Op44Go44Gq44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIG9uOiBmdW5jdGlvbiBvbkV2ZW50KGdlc3R1cmVzLCBoYW5kbGVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIEV2ZW50Lm9uKHNlbGYuZWxlbWVudCwgZ2VzdHVyZXMsIGhhbmRsZXIsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHNlbGYuZXZlbnRIYW5kbGVycy5wdXNoKHsgZ2VzdHVyZTogdHlwZSwgaGFuZGxlcjogaGFuZGxlciB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfSxcblxuICAvKipcbiAgICogQG1ldGhvZCBvZmZcbiAgICogQHNpZ25hdHVyZSBvZmYoZ2VzdHVyZXMsIGhhbmRsZXIpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVJlbW92ZSBhbiBldmVudCBsaXN0ZW5lci5bL2VuXVxuICAgKiAgW2phXeOCpOODmeODs+ODiOODquOCueODiuODvOOCkuWJiumZpOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBnZXN0dXJlc1xuICAgKiAgIFtlbl1BIHNwYWNlIHNlcGFyYXRlZCBsaXN0IG9mIGdlc3R1cmVzLlsvZW5dXG4gICAqICAgW2phXeOCuOOCp+OCueODgeODo+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAguOCueODmuODvOOCueOBp+ikh+aVsOaMh+WumuOBmeOCi+OBk+OBqOOBjOOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICogICBbZW5dQW4gZXZlbnQgaGFuZGxpbmcgZnVuY3Rpb24uWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44OP44Oz44OJ44Op44Go44Gq44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIG9mZjogZnVuY3Rpb24gb2ZmRXZlbnQoZ2VzdHVyZXMsIGhhbmRsZXIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBFdmVudC5vZmYoc2VsZi5lbGVtZW50LCBnZXN0dXJlcywgaGFuZGxlciwgZnVuY3Rpb24odHlwZSkge1xuICAgICAgdmFyIGluZGV4ID0gVXRpbHMuaW5BcnJheSh7IGdlc3R1cmU6IHR5cGUsIGhhbmRsZXI6IGhhbmRsZXIgfSk7XG4gICAgICBpZihpbmRleCAhPT0gZmFsc2UpIHtcbiAgICAgICAgc2VsZi5ldmVudEhhbmRsZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHRyaWdnZXIgZ2VzdHVyZSBldmVudFxuICAgKiBAbWV0aG9kIHRyaWdnZXJcbiAgICogQHNpZ25hdHVyZSB0cmlnZ2VyKGdlc3R1cmUsIGV2ZW50RGF0YSlcbiAgICogQHBhcmFtIHtTdHJpbmd9IGdlc3R1cmVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtldmVudERhdGFdXG4gICAqL1xuICB0cmlnZ2VyOiBmdW5jdGlvbiB0cmlnZ2VyRXZlbnQoZ2VzdHVyZSwgZXZlbnREYXRhKSB7XG4gICAgLy8gb3B0aW9uYWxcbiAgICBpZighZXZlbnREYXRhKSB7XG4gICAgICBldmVudERhdGEgPSB7fTtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgRE9NIGV2ZW50XG4gICAgdmFyIGV2ZW50ID0gR2VzdHVyZURldGVjdG9yLkRPQ1VNRU5ULmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgIGV2ZW50LmluaXRFdmVudChnZXN0dXJlLCB0cnVlLCB0cnVlKTtcbiAgICBldmVudC5nZXN0dXJlID0gZXZlbnREYXRhO1xuXG4gICAgLy8gdHJpZ2dlciBvbiB0aGUgdGFyZ2V0IGlmIGl0IGlzIGluIHRoZSBpbnN0YW5jZSBlbGVtZW50LFxuICAgIC8vIHRoaXMgaXMgZm9yIGV2ZW50IGRlbGVnYXRpb24gdHJpY2tzXG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgaWYoVXRpbHMuaGFzUGFyZW50KGV2ZW50RGF0YS50YXJnZXQsIGVsZW1lbnQpKSB7XG4gICAgICBlbGVtZW50ID0gZXZlbnREYXRhLnRhcmdldDtcbiAgICB9XG5cbiAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGVuYWJsZVxuICAgKiBAc2lnbmF0dXJlIGVuYWJsZShzdGF0ZSlcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dRW5hYmxlIG9yIGRpc2FibGUgZ2VzdHVyZSBkZXRlY3Rpb24uWy9lbl1cbiAgICogIFtqYV3jgrjjgqfjgrnjg4Hjg6PmpJznn6XjgpLmnInlirnljJYv54Sh5Yq55YyW44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtCb29sZWFufSBzdGF0ZVxuICAgKiAgIFtlbl1TcGVjaWZ5IGlmIGl0IHNob3VsZCBiZSBlbmFibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3mnInlirnjgavjgZnjgovjgYvjganjgYbjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZW5hYmxlOiBmdW5jdGlvbiBlbmFibGUoc3RhdGUpIHtcbiAgICB0aGlzLmVuYWJsZWQgPSBzdGF0ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQG1ldGhvZCBkaXNwb3NlXG4gICAqIEBzaWduYXR1cmUgZGlzcG9zZSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVJlbW92ZSBhbmQgZGVzdHJveSBhbGwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoaXMgaW5zdGFuY2UuWy9lbl1cbiAgICogIFtqYV3jgZPjga7jgqTjg7Pjgrnjgr/jg7Pjgrnjgafjga7jgrjjgqfjgrnjg4Hjg6Pjga7mpJznn6XjgoTjgIHjgqTjg5njg7Pjg4jjg4/jg7Pjg4njg6njgpLlhajjgabop6PpmaTjgZfjgablu4Pmo4TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZGlzcG9zZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICB2YXIgaSwgZWg7XG5cbiAgICAvLyB1bmRvIGFsbCBjaGFuZ2VzIG1hZGUgYnkgc3RvcF9icm93c2VyX2JlaGF2aW9yXG4gICAgVXRpbHMudG9nZ2xlQmVoYXZpb3IodGhpcy5lbGVtZW50LCB0aGlzLm9wdGlvbnMuYmVoYXZpb3IsIGZhbHNlKTtcblxuICAgIC8vIHVuYmluZCBhbGwgY3VzdG9tIGV2ZW50IGhhbmRsZXJzXG4gICAgZm9yKGkgPSAtMTsgKGVoID0gdGhpcy5ldmVudEhhbmRsZXJzWysraV0pOykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbmQtYXNzaWduXG4gICAgICBVdGlscy5vZmYodGhpcy5lbGVtZW50LCBlaC5nZXN0dXJlLCBlaC5oYW5kbGVyKTtcbiAgICB9XG5cbiAgICB0aGlzLmV2ZW50SGFuZGxlcnMgPSBbXTtcblxuICAgIC8vIHVuYmluZCB0aGUgc3RhcnQgZXZlbnQgbGlzdGVuZXJcbiAgICBFdmVudC5vZmYodGhpcy5lbGVtZW50LCBFVkVOVF9UWVBFU1tFVkVOVF9TVEFSVF0sIHRoaXMuZXZlbnRTdGFydEhhbmRsZXIpO1xuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAbW9kdWxlIGdlc3R1cmVzXG4gKi9cbi8qKlxuICogTW92ZSB3aXRoIHggZmluZ2VycyAoZGVmYXVsdCAxKSBhcm91bmQgb24gdGhlIHBhZ2UuXG4gKiBQcmV2ZW50aW5nIHRoZSBkZWZhdWx0IGJyb3dzZXIgYmVoYXZpb3IgaXMgYSBnb29kIHdheSB0byBpbXByb3ZlIGZlZWwgYW5kIHdvcmtpbmcuXG4gKiBgYGBgXG4gKiAgR2VzdHVyZURldGVjdG9ydGltZS5vbihcImRyYWdcIiwgZnVuY3Rpb24oZXYpIHtcbiAqICAgIGNvbnNvbGUubG9nKGV2KTtcbiAqICAgIGV2Lmdlc3R1cmUucHJldmVudERlZmF1bHQoKTtcbiAqICB9KTtcbiAqIGBgYGBcbiAqXG4gKiBAY2xhc3MgRHJhZ1xuICogQHN0YXRpY1xuICovXG4vKipcbiAqIEBldmVudCBkcmFnXG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuLyoqXG4gKiBAZXZlbnQgZHJhZ3N0YXJ0XG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuLyoqXG4gKiBAZXZlbnQgZHJhZ2VuZFxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IGRyYXBsZWZ0XG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuLyoqXG4gKiBAZXZlbnQgZHJhZ3JpZ2h0XG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuLyoqXG4gKiBAZXZlbnQgZHJhZ3VwXG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuLyoqXG4gKiBAZXZlbnQgZHJhZ2Rvd25cbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqL1xuKGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIHRyaWdnZXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGRyYWdHZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgdmFyIGN1ciA9IERldGVjdGlvbi5jdXJyZW50O1xuXG4gICAgLy8gbWF4IHRvdWNoZXNcbiAgICBpZihpbnN0Lm9wdGlvbnMuZHJhZ01heFRvdWNoZXMgPiAwICYmXG4gICAgICBldi50b3VjaGVzLmxlbmd0aCA+IGluc3Qub3B0aW9ucy5kcmFnTWF4VG91Y2hlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN3aXRjaChldi5ldmVudFR5cGUpIHtcbiAgICBjYXNlIEVWRU5UX1NUQVJUOlxuICAgICAgdHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgRVZFTlRfTU9WRTpcbiAgICAgIC8vIHdoZW4gdGhlIGRpc3RhbmNlIHdlIG1vdmVkIGlzIHRvbyBzbWFsbCB3ZSBza2lwIHRoaXMgZ2VzdHVyZVxuICAgICAgLy8gb3Igd2UgY2FuIGJlIGFscmVhZHkgaW4gZHJhZ2dpbmdcbiAgICAgIGlmKGV2LmRpc3RhbmNlIDwgaW5zdC5vcHRpb25zLmRyYWdNaW5EaXN0YW5jZSAmJlxuICAgICAgICBjdXIubmFtZSAhPSBuYW1lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXJ0Q2VudGVyID0gY3VyLnN0YXJ0RXZlbnQuY2VudGVyO1xuXG4gICAgICAvLyB3ZSBhcmUgZHJhZ2dpbmchXG4gICAgICBpZihjdXIubmFtZSAhPSBuYW1lKSB7XG4gICAgICAgIGN1ci5uYW1lID0gbmFtZTtcbiAgICAgICAgaWYoaW5zdC5vcHRpb25zLmRyYWdEaXN0YW5jZUNvcnJlY3Rpb24gJiYgZXYuZGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIGRyYWcgaXMgdHJpZ2dlcmVkLCBzZXQgdGhlIGV2ZW50IGNlbnRlciB0byBkcmFnTWluRGlzdGFuY2UgcGl4ZWxzIGZyb20gdGhlIG9yaWdpbmFsIGV2ZW50IGNlbnRlci5cbiAgICAgICAgICAvLyBXaXRob3V0IHRoaXMgY29ycmVjdGlvbiwgdGhlIGRyYWdnZWQgZGlzdGFuY2Ugd291bGQganVtcHN0YXJ0IGF0IGRyYWdNaW5EaXN0YW5jZSBwaXhlbHMgaW5zdGVhZCBvZiBhdCAwLlxuICAgICAgICAgIC8vIEl0IG1pZ2h0IGJlIHVzZWZ1bCB0byBzYXZlIHRoZSBvcmlnaW5hbCBzdGFydCBwb2ludCBzb21ld2hlcmVcbiAgICAgICAgICB2YXIgZmFjdG9yID0gTWF0aC5hYnMoaW5zdC5vcHRpb25zLmRyYWdNaW5EaXN0YW5jZSAvIGV2LmRpc3RhbmNlKTtcbiAgICAgICAgICBzdGFydENlbnRlci5wYWdlWCArPSBldi5kZWx0YVggKiBmYWN0b3I7XG4gICAgICAgICAgc3RhcnRDZW50ZXIucGFnZVkgKz0gZXYuZGVsdGFZICogZmFjdG9yO1xuICAgICAgICAgIHN0YXJ0Q2VudGVyLmNsaWVudFggKz0gZXYuZGVsdGFYICogZmFjdG9yO1xuICAgICAgICAgIHN0YXJ0Q2VudGVyLmNsaWVudFkgKz0gZXYuZGVsdGFZICogZmFjdG9yO1xuXG4gICAgICAgICAgLy8gcmVjYWxjdWxhdGUgZXZlbnQgZGF0YSB1c2luZyBuZXcgc3RhcnQgcG9pbnRcbiAgICAgICAgICBldiA9IERldGVjdGlvbi5leHRlbmRFdmVudERhdGEoZXYpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGxvY2sgZHJhZyB0byBheGlzP1xuICAgICAgaWYoY3VyLmxhc3RFdmVudC5kcmFnTG9ja1RvQXhpcyB8fFxuICAgICAgICAoIGluc3Qub3B0aW9ucy5kcmFnTG9ja1RvQXhpcyAmJlxuICAgICAgICAgIGluc3Qub3B0aW9ucy5kcmFnTG9ja01pbkRpc3RhbmNlIDw9IGV2LmRpc3RhbmNlXG4gICAgICAgICkpIHtcbiAgICAgICAgICBldi5kcmFnTG9ja1RvQXhpcyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBrZWVwIGRpcmVjdGlvbiBvbiB0aGUgYXhpcyB0aGF0IHRoZSBkcmFnIGdlc3R1cmUgc3RhcnRlZCBvblxuICAgICAgICB2YXIgbGFzdERpcmVjdGlvbiA9IGN1ci5sYXN0RXZlbnQuZGlyZWN0aW9uO1xuICAgICAgICBpZihldi5kcmFnTG9ja1RvQXhpcyAmJiBsYXN0RGlyZWN0aW9uICE9PSBldi5kaXJlY3Rpb24pIHtcbiAgICAgICAgICBpZihVdGlscy5pc1ZlcnRpY2FsKGxhc3REaXJlY3Rpb24pKSB7XG4gICAgICAgICAgICBldi5kaXJlY3Rpb24gPSAoZXYuZGVsdGFZIDwgMCkgPyBESVJFQ1RJT05fVVAgOiBESVJFQ1RJT05fRE9XTjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXYuZGlyZWN0aW9uID0gKGV2LmRlbHRhWCA8IDApID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmlyc3QgdGltZSwgdHJpZ2dlciBkcmFnc3RhcnQgZXZlbnRcbiAgICAgICAgaWYoIXRyaWdnZXJlZCkge1xuICAgICAgICAgIGluc3QudHJpZ2dlcihuYW1lICsgJ3N0YXJ0JywgZXYpO1xuICAgICAgICAgIHRyaWdnZXJlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cmlnZ2VyIGV2ZW50c1xuICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSwgZXYpO1xuICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSArIGV2LmRpcmVjdGlvbiwgZXYpO1xuXG4gICAgICAgIHZhciBpc1ZlcnRpY2FsID0gVXRpbHMuaXNWZXJ0aWNhbChldi5kaXJlY3Rpb24pO1xuXG4gICAgICAgIC8vIGJsb2NrIHRoZSBicm93c2VyIGV2ZW50c1xuICAgICAgICBpZigoaW5zdC5vcHRpb25zLmRyYWdCbG9ja1ZlcnRpY2FsICYmIGlzVmVydGljYWwpIHx8XG4gICAgICAgICAgKGluc3Qub3B0aW9ucy5kcmFnQmxvY2tIb3Jpem9udGFsICYmICFpc1ZlcnRpY2FsKSkge1xuICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRVZFTlRfUkVMRUFTRTpcbiAgICAgICAgaWYodHJpZ2dlcmVkICYmIGV2LmNoYW5nZWRMZW5ndGggPD0gaW5zdC5vcHRpb25zLmRyYWdNYXhUb3VjaGVzKSB7XG4gICAgICAgICAgaW5zdC50cmlnZ2VyKG5hbWUgKyAnZW5kJywgZXYpO1xuICAgICAgICAgIHRyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEVWRU5UX0VORDpcbiAgICAgICAgdHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcy5EcmFnID0ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGluZGV4OiA1MCxcbiAgICAgIGhhbmRsZXI6IGRyYWdHZXN0dXJlLFxuICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1pbmltYWwgbW92ZW1lbnQgdGhhdCBoYXZlIHRvIGJlIG1hZGUgYmVmb3JlIHRoZSBkcmFnIGV2ZW50IGdldHMgdHJpZ2dlcmVkXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnTWluRGlzdGFuY2VcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMTBcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdNaW5EaXN0YW5jZTogMTAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBkcmFnRGlzdGFuY2VDb3JyZWN0aW9uIHRvIHRydWUgdG8gbWFrZSB0aGUgc3RhcnRpbmcgcG9pbnQgb2YgdGhlIGRyYWdcbiAgICAgICAgICogYmUgY2FsY3VsYXRlZCBmcm9tIHdoZXJlIHRoZSBkcmFnIHdhcyB0cmlnZ2VyZWQsIG5vdCBmcm9tIHdoZXJlIHRoZSB0b3VjaCBzdGFydGVkLlxuICAgICAgICAgKiBVc2VmdWwgdG8gYXZvaWQgYSBqZXJrLXN0YXJ0aW5nIGRyYWcsIHdoaWNoIGNhbiBtYWtlIGZpbmUtYWRqdXN0bWVudHNcbiAgICAgICAgICogdGhyb3VnaCBkcmFnZ2luZyBkaWZmaWN1bHQsIGFuZCBiZSB2aXN1YWxseSB1bmFwcGVhbGluZy5cbiAgICAgICAgICogQHByb3BlcnR5IGRyYWdEaXN0YW5jZUNvcnJlY3Rpb25cbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdEaXN0YW5jZUNvcnJlY3Rpb246IHRydWUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNldCAwIGZvciB1bmxpbWl0ZWQsIGJ1dCB0aGlzIGNhbiBjb25mbGljdCB3aXRoIHRyYW5zZm9ybVxuICAgICAgICAgKiBAcHJvcGVydHkgZHJhZ01heFRvdWNoZXNcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ01heFRvdWNoZXM6IDEsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHByZXZlbnQgZGVmYXVsdCBicm93c2VyIGJlaGF2aW9yIHdoZW4gZHJhZ2dpbmcgb2NjdXJzXG4gICAgICAgICAqIGJlIGNhcmVmdWwgd2l0aCBpdCwgaXQgbWFrZXMgdGhlIGVsZW1lbnQgYSBibG9ja2luZyBlbGVtZW50XG4gICAgICAgICAqIHdoZW4geW91IGFyZSB1c2luZyB0aGUgZHJhZyBnZXN0dXJlLCBpdCBpcyBhIGdvb2QgcHJhY3RpY2UgdG8gc2V0IHRoaXMgdHJ1ZVxuICAgICAgICAgKiBAcHJvcGVydHkgZHJhZ0Jsb2NrSG9yaXpvbnRhbFxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdCbG9ja0hvcml6b250YWw6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzYW1lIGFzIGBkcmFnQmxvY2tIb3Jpem9udGFsYCwgYnV0IGZvciB2ZXJ0aWNhbCBtb3ZlbWVudFxuICAgICAgICAgKiBAcHJvcGVydHkgZHJhZ0Jsb2NrVmVydGljYWxcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnQmxvY2tWZXJ0aWNhbDogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRyYWdMb2NrVG9BeGlzIGtlZXBzIHRoZSBkcmFnIGdlc3R1cmUgb24gdGhlIGF4aXMgdGhhdCBpdCBzdGFydGVkIG9uLFxuICAgICAgICAgKiBJdCBkaXNhbGxvd3MgdmVydGljYWwgZGlyZWN0aW9ucyBpZiB0aGUgaW5pdGlhbCBkaXJlY3Rpb24gd2FzIGhvcml6b250YWwsIGFuZCB2aWNlIHZlcnNhLlxuICAgICAgICAgKiBAcHJvcGVydHkgZHJhZ0xvY2tUb0F4aXNcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnTG9ja1RvQXhpczogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRyYWcgbG9jayBvbmx5IGtpY2tzIGluIHdoZW4gZGlzdGFuY2UgPiBkcmFnTG9ja01pbkRpc3RhbmNlXG4gICAgICAgICAqIFRoaXMgd2F5LCBsb2NraW5nIG9jY3VycyBvbmx5IHdoZW4gdGhlIGRpc3RhbmNlIGhhcyBiZWNvbWUgbGFyZ2UgZW5vdWdoIHRvIHJlbGlhYmx5IGRldGVybWluZSB0aGUgZGlyZWN0aW9uXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnTG9ja01pbkRpc3RhbmNlXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDI1XG4gICAgICAgICAqL1xuICAgICAgICBkcmFnTG9ja01pbkRpc3RhbmNlOiAyNVxuICAgICAgfVxuICAgIH07XG4gIH0pKCdkcmFnJyk7XG5cbiAgLyoqXG4gICAqIEBtb2R1bGUgZ2VzdHVyZXNcbiAgICovXG4gIC8qKlxuICAgKiB0cmlnZ2VyIGEgc2ltcGxlIGdlc3R1cmUgZXZlbnQsIHNvIHlvdSBjYW4gZG8gYW55dGhpbmcgaW4geW91ciBoYW5kbGVyLlxuICAgKiBvbmx5IHVzYWJsZSBpZiB5b3Uga25vdyB3aGF0IHlvdXIgZG9pbmcuLi5cbiAgICpcbiAgICogQGNsYXNzIEdlc3R1cmVcbiAgICogQHN0YXRpY1xuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCBnZXN0dXJlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzLkdlc3R1cmUgPSB7XG4gICAgbmFtZTogJ2dlc3R1cmUnLFxuICAgIGluZGV4OiAxMzM3LFxuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIHJlbGVhc2VHZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgICBpbnN0LnRyaWdnZXIodGhpcy5uYW1lLCBldik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAbW9kdWxlIGdlc3R1cmVzXG4gICAqL1xuICAvKipcbiAgICogVG91Y2ggc3RheXMgYXQgdGhlIHNhbWUgcGxhY2UgZm9yIHggdGltZVxuICAgKlxuICAgKiBAY2xhc3MgSG9sZFxuICAgKiBAc3RhdGljXG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IGhvbGRcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKi9cbiAgKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgdGltZXI7XG5cbiAgICBmdW5jdGlvbiBob2xkR2VzdHVyZShldiwgaW5zdCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBpbnN0Lm9wdGlvbnMsXG4gICAgICAgICAgY3VycmVudCA9IERldGVjdGlvbi5jdXJyZW50O1xuXG4gICAgICBzd2l0Y2goZXYuZXZlbnRUeXBlKSB7XG4gICAgICBjYXNlIEVWRU5UX1NUQVJUOlxuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuXG4gICAgICAgIC8vIHNldCB0aGUgZ2VzdHVyZSBzbyB3ZSBjYW4gY2hlY2sgaW4gdGhlIHRpbWVvdXQgaWYgaXQgc3RpbGwgaXNcbiAgICAgICAgY3VycmVudC5uYW1lID0gbmFtZTtcblxuICAgICAgICAvLyBzZXQgdGltZXIgYW5kIGlmIGFmdGVyIHRoZSB0aW1lb3V0IGl0IHN0aWxsIGlzIGhvbGQsXG4gICAgICAgIC8vIHdlIHRyaWdnZXIgdGhlIGhvbGQgZXZlbnRcbiAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmKGN1cnJlbnQgJiYgY3VycmVudC5uYW1lID09IG5hbWUpIHtcbiAgICAgICAgICAgIGluc3QudHJpZ2dlcihuYW1lLCBldik7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBvcHRpb25zLmhvbGRUaW1lb3V0KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRVZFTlRfTU9WRTpcbiAgICAgICAgaWYoZXYuZGlzdGFuY2UgPiBvcHRpb25zLmhvbGRUaHJlc2hvbGQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEVWRU5UX1JFTEVBU0U6XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcy5Ib2xkID0ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGluZGV4OiAxMCxcbiAgICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJvcGVydHkgaG9sZFRpbWVvdXRcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgNTAwXG4gICAgICAgICAqL1xuICAgICAgICBob2xkVGltZW91dDogNTAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtb3ZlbWVudCBhbGxvd2VkIHdoaWxlIGhvbGRpbmdcbiAgICAgICAgICogQHByb3BlcnR5IGhvbGRUaHJlc2hvbGRcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMlxuICAgICAgICAgKi9cbiAgICAgICAgaG9sZFRocmVzaG9sZDogMlxuICAgICAgfSxcbiAgICAgIGhhbmRsZXI6IGhvbGRHZXN0dXJlXG4gICAgfTtcbiAgfSkoJ2hvbGQnKTtcblxuICAvKipcbiAgICogQG1vZHVsZSBnZXN0dXJlc1xuICAgKi9cbiAgLyoqXG4gICAqIHdoZW4gYSB0b3VjaCBpcyBiZWluZyByZWxlYXNlZCBmcm9tIHRoZSBwYWdlXG4gICAqXG4gICAqIEBjbGFzcyBSZWxlYXNlXG4gICAqIEBzdGF0aWNcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgcmVsZWFzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcy5SZWxlYXNlID0ge1xuICAgIG5hbWU6ICdyZWxlYXNlJyxcbiAgICBpbmRleDogSW5maW5pdHksXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gcmVsZWFzZUdlc3R1cmUoZXYsIGluc3QpIHtcbiAgICAgIGlmKGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9SRUxFQVNFKSB7XG4gICAgICAgIGluc3QudHJpZ2dlcih0aGlzLm5hbWUsIGV2KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBtb2R1bGUgZ2VzdHVyZXNcbiAgICovXG4gIC8qKlxuICAgKiB0cmlnZ2VycyBzd2lwZSBldmVudHMgd2hlbiB0aGUgZW5kIHZlbG9jaXR5IGlzIGFib3ZlIHRoZSB0aHJlc2hvbGRcbiAgICogZm9yIGJlc3QgdXNhZ2UsIHNldCBgcHJldmVudERlZmF1bHRgIChvbiB0aGUgZHJhZyBnZXN0dXJlKSB0byBgdHJ1ZWBcbiAgICogYGBgYFxuICAgKiAgR2VzdHVyZURldGVjdG9ydGltZS5vbihcImRyYWdsZWZ0IHN3aXBlbGVmdFwiLCBmdW5jdGlvbihldikge1xuICAgKiAgICBjb25zb2xlLmxvZyhldik7XG4gICAqICAgIGV2Lmdlc3R1cmUucHJldmVudERlZmF1bHQoKTtcbiAgICogIH0pO1xuICAgKiBgYGBgXG4gICAqXG4gICAqIEBjbGFzcyBTd2lwZVxuICAgKiBAc3RhdGljXG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHN3aXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCBzd2lwZWxlZnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHN3aXBlcmlnaHRcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHN3aXBldXBcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHN3aXBlZG93blxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcy5Td2lwZSA9IHtcbiAgICBuYW1lOiAnc3dpcGUnLFxuICAgIGluZGV4OiA0MCxcbiAgICBkZWZhdWx0czoge1xuICAgICAgLyoqXG4gICAgICAgKiBAcHJvcGVydHkgc3dpcGVNaW5Ub3VjaGVzXG4gICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICovXG4gICAgICBzd2lwZU1pblRvdWNoZXM6IDEsXG5cbiAgICAgIC8qKlxuICAgICAgICogQHByb3BlcnR5IHN3aXBlTWF4VG91Y2hlc1xuICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAqL1xuICAgICAgc3dpcGVNYXhUb3VjaGVzOiAxLFxuXG4gICAgICAvKipcbiAgICAgICAqIGhvcml6b250YWwgc3dpcGUgdmVsb2NpdHlcbiAgICAgICAqIEBwcm9wZXJ0eSBzd2lwZVZlbG9jaXR5WFxuICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAqIEBkZWZhdWx0IDAuNlxuICAgICAgICovXG4gICAgICBzd2lwZVZlbG9jaXR5WDogMC42LFxuXG4gICAgICAvKipcbiAgICAgICAqIHZlcnRpY2FsIHN3aXBlIHZlbG9jaXR5XG4gICAgICAgKiBAcHJvcGVydHkgc3dpcGVWZWxvY2l0eVlcbiAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgKiBAZGVmYXVsdCAwLjZcbiAgICAgICAqL1xuICAgICAgc3dpcGVWZWxvY2l0eVk6IDAuNlxuICAgIH0sXG5cbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBzd2lwZUdlc3R1cmUoZXYsIGluc3QpIHtcbiAgICAgIGlmKGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9SRUxFQVNFKSB7XG4gICAgICAgIHZhciB0b3VjaGVzID0gZXYudG91Y2hlcy5sZW5ndGgsXG4gICAgICAgICAgICBvcHRpb25zID0gaW5zdC5vcHRpb25zO1xuXG4gICAgICAgIC8vIG1heCB0b3VjaGVzXG4gICAgICAgIGlmKHRvdWNoZXMgPCBvcHRpb25zLnN3aXBlTWluVG91Y2hlcyB8fFxuICAgICAgICAgIHRvdWNoZXMgPiBvcHRpb25zLnN3aXBlTWF4VG91Y2hlcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdoZW4gdGhlIGRpc3RhbmNlIHdlIG1vdmVkIGlzIHRvbyBzbWFsbCB3ZSBza2lwIHRoaXMgZ2VzdHVyZVxuICAgICAgICAvLyBvciB3ZSBjYW4gYmUgYWxyZWFkeSBpbiBkcmFnZ2luZ1xuICAgICAgICBpZihldi52ZWxvY2l0eVggPiBvcHRpb25zLnN3aXBlVmVsb2NpdHlYIHx8XG4gICAgICAgICAgZXYudmVsb2NpdHlZID4gb3B0aW9ucy5zd2lwZVZlbG9jaXR5WSkge1xuICAgICAgICAgIC8vIHRyaWdnZXIgc3dpcGUgZXZlbnRzXG4gICAgICAgICAgaW5zdC50cmlnZ2VyKHRoaXMubmFtZSwgZXYpO1xuICAgICAgICAgIGluc3QudHJpZ2dlcih0aGlzLm5hbWUgKyBldi5kaXJlY3Rpb24sIGV2KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQG1vZHVsZSBnZXN0dXJlc1xuICAgKi9cbiAgLyoqXG4gICAqIFNpbmdsZSB0YXAgYW5kIGEgZG91YmxlIHRhcCBvbiBhIHBsYWNlXG4gICAqXG4gICAqIEBjbGFzcyBUYXBcbiAgICogQHN0YXRpY1xuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCB0YXBcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IGRvdWJsZXRhcFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqL1xuICAoZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBoYXNNb3ZlZCA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gdGFwR2VzdHVyZShldiwgaW5zdCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBpbnN0Lm9wdGlvbnMsXG4gICAgICAgICAgY3VycmVudCA9IERldGVjdGlvbi5jdXJyZW50LFxuICAgICAgICAgIHByZXYgPSBEZXRlY3Rpb24ucHJldmlvdXMsXG4gICAgICAgICAgc2luY2VQcmV2LFxuICAgICAgICAgIGRpZERvdWJsZVRhcDtcblxuICAgICAgc3dpdGNoKGV2LmV2ZW50VHlwZSkge1xuICAgICAgY2FzZSBFVkVOVF9TVEFSVDpcbiAgICAgICAgaGFzTW92ZWQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRVZFTlRfTU9WRTpcbiAgICAgICAgaGFzTW92ZWQgPSBoYXNNb3ZlZCB8fCAoZXYuZGlzdGFuY2UgPiBvcHRpb25zLnRhcE1heERpc3RhbmNlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRVZFTlRfRU5EOlxuICAgICAgICBpZighVXRpbHMuaW5TdHIoZXYuc3JjRXZlbnQudHlwZSwgJ2NhbmNlbCcpICYmIGV2LmRlbHRhVGltZSA8IG9wdGlvbnMudGFwTWF4VGltZSAmJiAhaGFzTW92ZWQpIHtcbiAgICAgICAgICAvLyBwcmV2aW91cyBnZXN0dXJlLCBmb3IgdGhlIGRvdWJsZSB0YXAgc2luY2UgdGhlc2UgYXJlIHR3byBkaWZmZXJlbnQgZ2VzdHVyZSBkZXRlY3Rpb25zXG4gICAgICAgICAgc2luY2VQcmV2ID0gcHJldiAmJiBwcmV2Lmxhc3RFdmVudCAmJiBldi50aW1lU3RhbXAgLSBwcmV2Lmxhc3RFdmVudC50aW1lU3RhbXA7XG4gICAgICAgICAgZGlkRG91YmxlVGFwID0gZmFsc2U7XG5cbiAgICAgICAgICAvLyBjaGVjayBpZiBkb3VibGUgdGFwXG4gICAgICAgICAgaWYocHJldiAmJiBwcmV2Lm5hbWUgPT0gbmFtZSAmJlxuICAgICAgICAgICAgKHNpbmNlUHJldiAmJiBzaW5jZVByZXYgPCBvcHRpb25zLmRvdWJsZVRhcEludGVydmFsKSAmJlxuICAgICAgICAgICAgZXYuZGlzdGFuY2UgPCBvcHRpb25zLmRvdWJsZVRhcERpc3RhbmNlKSB7XG4gICAgICAgICAgICBpbnN0LnRyaWdnZXIoJ2RvdWJsZXRhcCcsIGV2KTtcbiAgICAgICAgICAgIGRpZERvdWJsZVRhcCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZG8gYSBzaW5nbGUgdGFwXG4gICAgICAgICAgaWYoIWRpZERvdWJsZVRhcCB8fCBvcHRpb25zLnRhcEFsd2F5cykge1xuICAgICAgICAgICAgY3VycmVudC5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIGluc3QudHJpZ2dlcihjdXJyZW50Lm5hbWUsIGV2KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzLlRhcCA9IHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBpbmRleDogMTAwLFxuICAgICAgaGFuZGxlcjogdGFwR2VzdHVyZSxcbiAgICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtYXggdGltZSBvZiBhIHRhcCwgdGhpcyBpcyBmb3IgdGhlIHNsb3cgdGFwcGVyc1xuICAgICAgICAgKiBAcHJvcGVydHkgdGFwTWF4VGltZVxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAyNTBcbiAgICAgICAgICovXG4gICAgICAgIHRhcE1heFRpbWU6IDI1MCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogbWF4IGRpc3RhbmNlIG9mIG1vdmVtZW50IG9mIGEgdGFwLCB0aGlzIGlzIGZvciB0aGUgc2xvdyB0YXBwZXJzXG4gICAgICAgICAqIEBwcm9wZXJ0eSB0YXBNYXhEaXN0YW5jZVxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAxMFxuICAgICAgICAgKi9cbiAgICAgICAgdGFwTWF4RGlzdGFuY2U6IDEwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhbHdheXMgdHJpZ2dlciB0aGUgYHRhcGAgZXZlbnQsIGV2ZW4gd2hpbGUgZG91YmxlLXRhcHBpbmdcbiAgICAgICAgICogQHByb3BlcnR5IHRhcEFsd2F5c1xuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGFwQWx3YXlzOiB0cnVlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtYXggZGlzdGFuY2UgYmV0d2VlbiB0d28gdGFwc1xuICAgICAgICAgKiBAcHJvcGVydHkgZG91YmxlVGFwRGlzdGFuY2VcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMjBcbiAgICAgICAgICovXG4gICAgICAgIGRvdWJsZVRhcERpc3RhbmNlOiAyMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogbWF4IHRpbWUgYmV0d2VlbiB0d28gdGFwc1xuICAgICAgICAgKiBAcHJvcGVydHkgZG91YmxlVGFwSW50ZXJ2YWxcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMzAwXG4gICAgICAgICAqL1xuICAgICAgICBkb3VibGVUYXBJbnRlcnZhbDogMzAwXG4gICAgICB9XG4gICAgfTtcbiAgfSkoJ3RhcCcpO1xuXG4gIC8qKlxuICAgKiBAbW9kdWxlIGdlc3R1cmVzXG4gICAqL1xuICAvKipcbiAgICogd2hlbiBhIHRvdWNoIGlzIGJlaW5nIHRvdWNoZWQgYXQgdGhlIHBhZ2VcbiAgICpcbiAgICogQGNsYXNzIFRvdWNoXG4gICAqIEBzdGF0aWNcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgdG91Y2hcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMuVG91Y2ggPSB7XG4gICAgbmFtZTogJ3RvdWNoJyxcbiAgICBpbmRleDogLUluZmluaXR5LFxuICAgIGRlZmF1bHRzOiB7XG4gICAgICAvKipcbiAgICAgICAqIGNhbGwgcHJldmVudERlZmF1bHQgYXQgdG91Y2hzdGFydCwgYW5kIG1ha2VzIHRoZSBlbGVtZW50IGJsb2NraW5nIGJ5IGRpc2FibGluZyB0aGUgc2Nyb2xsaW5nIG9mIHRoZSBwYWdlLFxuICAgICAgICogYnV0IGl0IGltcHJvdmVzIGdlc3R1cmVzIGxpa2UgdHJhbnNmb3JtaW5nIGFuZCBkcmFnZ2luZy5cbiAgICAgICAqIGJlIGNhcmVmdWwgd2l0aCB1c2luZyB0aGlzLCBpdCBjYW4gYmUgdmVyeSBhbm5veWluZyBmb3IgdXNlcnMgdG8gYmUgc3R1Y2sgb24gdGhlIHBhZ2VcbiAgICAgICAqIEBwcm9wZXJ0eSBwcmV2ZW50RGVmYXVsdFxuICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICovXG4gICAgICBwcmV2ZW50RGVmYXVsdDogZmFsc2UsXG5cbiAgICAgIC8qKlxuICAgICAgICogZGlzYWJsZSBtb3VzZSBldmVudHMsIHNvIG9ubHkgdG91Y2ggKG9yIHBlbiEpIGlucHV0IHRyaWdnZXJzIGV2ZW50c1xuICAgICAgICogQHByb3BlcnR5IHByZXZlbnRNb3VzZVxuICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICovXG4gICAgICBwcmV2ZW50TW91c2U6IGZhbHNlXG4gICAgfSxcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiB0b3VjaEdlc3R1cmUoZXYsIGluc3QpIHtcbiAgICAgIGlmKGluc3Qub3B0aW9ucy5wcmV2ZW50TW91c2UgJiYgZXYucG9pbnRlclR5cGUgPT0gUE9JTlRFUl9NT1VTRSkge1xuICAgICAgICBldi5zdG9wRGV0ZWN0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYoaW5zdC5vcHRpb25zLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmKGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9UT1VDSCkge1xuICAgICAgICBpbnN0LnRyaWdnZXIoJ3RvdWNoJywgZXYpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQG1vZHVsZSBnZXN0dXJlc1xuICAgKi9cbiAgLyoqXG4gICAqIFVzZXIgd2FudCB0byBzY2FsZSBvciByb3RhdGUgd2l0aCAyIGZpbmdlcnNcbiAgICogUHJldmVudGluZyB0aGUgZGVmYXVsdCBicm93c2VyIGJlaGF2aW9yIGlzIGEgZ29vZCB3YXkgdG8gaW1wcm92ZSBmZWVsIGFuZCB3b3JraW5nLiBUaGlzIGNhbiBiZSBkb25lIHdpdGggdGhlXG4gICAqIGBwcmV2ZW50RGVmYXVsdGAgb3B0aW9uLlxuICAgKlxuICAgKiBAY2xhc3MgVHJhbnNmb3JtXG4gICAqIEBzdGF0aWNcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCB0cmFuc2Zvcm1zdGFydFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgdHJhbnNmb3JtZW5kXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCBwaW5jaGluXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCBwaW5jaG91dFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgcm90YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICovXG4gIChmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIHRyaWdnZXJlZCA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtR2VzdHVyZShldiwgaW5zdCkge1xuICAgICAgc3dpdGNoKGV2LmV2ZW50VHlwZSkge1xuICAgICAgY2FzZSBFVkVOVF9TVEFSVDpcbiAgICAgICAgdHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEVWRU5UX01PVkU6XG4gICAgICAgIC8vIGF0IGxlYXN0IG11bHRpdG91Y2hcbiAgICAgICAgaWYoZXYudG91Y2hlcy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNjYWxlVGhyZXNob2xkID0gTWF0aC5hYnMoMSAtIGV2LnNjYWxlKTtcbiAgICAgICAgdmFyIHJvdGF0aW9uVGhyZXNob2xkID0gTWF0aC5hYnMoZXYucm90YXRpb24pO1xuXG4gICAgICAgIC8vIHdoZW4gdGhlIGRpc3RhbmNlIHdlIG1vdmVkIGlzIHRvbyBzbWFsbCB3ZSBza2lwIHRoaXMgZ2VzdHVyZVxuICAgICAgICAvLyBvciB3ZSBjYW4gYmUgYWxyZWFkeSBpbiBkcmFnZ2luZ1xuICAgICAgICBpZihzY2FsZVRocmVzaG9sZCA8IGluc3Qub3B0aW9ucy50cmFuc2Zvcm1NaW5TY2FsZSAmJlxuICAgICAgICAgIHJvdGF0aW9uVGhyZXNob2xkIDwgaW5zdC5vcHRpb25zLnRyYW5zZm9ybU1pblJvdGF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2UgYXJlIHRyYW5zZm9ybWluZyFcbiAgICAgICAgRGV0ZWN0aW9uLmN1cnJlbnQubmFtZSA9IG5hbWU7XG5cbiAgICAgICAgLy8gZmlyc3QgdGltZSwgdHJpZ2dlciBkcmFnc3RhcnQgZXZlbnRcbiAgICAgICAgaWYoIXRyaWdnZXJlZCkge1xuICAgICAgICAgIGluc3QudHJpZ2dlcihuYW1lICsgJ3N0YXJ0JywgZXYpO1xuICAgICAgICAgIHRyaWdnZXJlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSwgZXYpOyAvLyBiYXNpYyB0cmFuc2Zvcm0gZXZlbnRcblxuICAgICAgICAvLyB0cmlnZ2VyIHJvdGF0ZSBldmVudFxuICAgICAgICBpZihyb3RhdGlvblRocmVzaG9sZCA+IGluc3Qub3B0aW9ucy50cmFuc2Zvcm1NaW5Sb3RhdGlvbikge1xuICAgICAgICAgIGluc3QudHJpZ2dlcigncm90YXRlJywgZXYpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJpZ2dlciBwaW5jaCBldmVudFxuICAgICAgICBpZihzY2FsZVRocmVzaG9sZCA+IGluc3Qub3B0aW9ucy50cmFuc2Zvcm1NaW5TY2FsZSkge1xuICAgICAgICAgIGluc3QudHJpZ2dlcigncGluY2gnLCBldik7XG4gICAgICAgICAgaW5zdC50cmlnZ2VyKCdwaW5jaCcgKyAoZXYuc2NhbGUgPCAxID8gJ2luJyA6ICdvdXQnKSwgZXYpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEVWRU5UX1JFTEVBU0U6XG4gICAgICAgIGlmKHRyaWdnZXJlZCAmJiBldi5jaGFuZ2VkTGVuZ3RoIDwgMikge1xuICAgICAgICAgIGluc3QudHJpZ2dlcihuYW1lICsgJ2VuZCcsIGV2KTtcbiAgICAgICAgICB0cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMuVHJhbnNmb3JtID0ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGluZGV4OiA0NSxcbiAgICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtaW5pbWFsIHNjYWxlIGZhY3Rvciwgbm8gc2NhbGUgaXMgMSwgem9vbWluIGlzIHRvIDAgYW5kIHpvb21vdXQgdW50aWwgaGlnaGVyIHRoZW4gMVxuICAgICAgICAgKiBAcHJvcGVydHkgdHJhbnNmb3JtTWluU2NhbGVcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMC4wMVxuICAgICAgICAgKi9cbiAgICAgICAgdHJhbnNmb3JtTWluU2NhbGU6IDAuMDEsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgICAgICogQHByb3BlcnR5IHRyYW5zZm9ybU1pblJvdGF0aW9uXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAgICovXG4gICAgICAgIHRyYW5zZm9ybU1pblJvdGF0aW9uOiAxXG4gICAgICB9LFxuXG4gICAgICBoYW5kbGVyOiB0cmFuc2Zvcm1HZXN0dXJlXG4gICAgfTtcbiAgfSkoJ3RyYW5zZm9ybScpO1xuXG5leHBvcnQgZGVmYXVsdCBHZXN0dXJlRGV0ZWN0b3I7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG4vKipcbiAqIEBvYmplY3Qgb25zLnBsYXRmb3JtXG4gKiBAY2F0ZWdvcnkgdXRpbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1VdGlsaXR5IG1ldGhvZHMgdG8gZGV0ZWN0IGN1cnJlbnQgcGxhdGZvcm0uWy9lbl1cbiAqICAgW2phXeePvuWcqOWun+ihjOOBleOCjOOBpuOBhOOCi+ODl+ODqeODg+ODiOODleOCqeODvOODoOOCkuaknOefpeOBmeOCi+OBn+OCgeOBruODpuODvOODhuOCo+ODquODhuOCo+ODoeOCveODg+ODieOCkuWPjuOCgeOBn+OCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gKi9cbmNsYXNzIFBsYXRmb3JtIHtcblxuICAvKipcbiAgICogQWxsIGVsZW1lbnRzIHdpbGwgYmUgcmVuZGVyZWQgYXMgaWYgdGhlIGFwcCB3YXMgcnVubmluZyBvbiB0aGlzIHBsYXRmb3JtLlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fcmVuZGVyUGxhdGZvcm0gPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2VsZWN0XG4gICAqIEBzaWduYXR1cmUgc2VsZWN0KHBsYXRmb3JtKVxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHBsYXRmb3JtIE5hbWUgb2YgdGhlIHBsYXRmb3JtLlxuICAgKiAgIFtlbl1Qb3NzaWJsZSB2YWx1ZXMgYXJlOiBcIm9wZXJhXCIsIFwiZmlyZWZveFwiLCBcInNhZmFyaVwiLCBcImNocm9tZVwiLCBcImllXCIsIFwiYW5kcm9pZFwiLCBcImJsYWNrYmVycnlcIiwgXCJpb3NcIiBvciBcIndwXCIuWy9lbl1cbiAgICogICBbamFdXCJvcGVyYVwiLCBcImZpcmVmb3hcIiwgXCJzYWZhcmlcIiwgXCJjaHJvbWVcIiwgXCJpZVwiLCBcImFuZHJvaWRcIiwgXCJibGFja2JlcnJ5XCIsIFwiaW9zXCIsIFwid3BcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TZXRzIHRoZSBwbGF0Zm9ybSB1c2VkIHRvIHJlbmRlciB0aGUgZWxlbWVudHMuIFVzZWZ1bCBmb3IgdGVzdGluZy5bL2VuXVxuICAgKiAgIFtqYV3opoHntKDjgpLmj4/nlLvjgZnjgovjgZ/jgoHjgavliKnnlKjjgZnjgovjg5fjg6njg4Pjg4jjg5Xjgqnjg7zjg6DlkI3jgpLoqK3lrprjgZfjgb7jgZnjgILjg4bjgrnjg4jjgavkvr/liKnjgafjgZnjgIJbL2phXVxuICAgKi9cbiAgc2VsZWN0KHBsYXRmb3JtKSB7XG4gICAgaWYgKHR5cGVvZiBwbGF0Zm9ybSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX3JlbmRlclBsYXRmb3JtID0gcGxhdGZvcm0udHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNXZWJWaWV3XG4gICAqIEBzaWduYXR1cmUgaXNXZWJWaWV3KClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciBhcHAgaXMgcnVubmluZyBpbiBDb3Jkb3ZhLlsvZW5dXG4gICAqICAgW2phXUNvcmRvdmHlhoXjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNXZWJWaWV3KCkge1xuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZycgfHwgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PSAndW5pbml0aWFsaXplZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaXNXZWJWaWV3KCkgbWV0aG9kIGlzIGF2YWlsYWJsZSBhZnRlciBkb20gY29udGVudHMgbG9hZGVkLicpO1xuICAgIH1cblxuICAgIHJldHVybiAhISh3aW5kb3cuY29yZG92YSB8fCB3aW5kb3cucGhvbmVnYXAgfHwgd2luZG93LlBob25lR2FwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzSU9TXG4gICAqIEBzaWduYXR1cmUgaXNJT1MoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBPUyBpcyBpT1MuWy9lbl1cbiAgICogICBbamFdaU9T5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzSU9TKCkge1xuICAgIGlmICh0aGlzLl9yZW5kZXJQbGF0Zm9ybSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclBsYXRmb3JtID09PSAnaW9zJztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZXZpY2UgPT09ICdvYmplY3QnICYmICEvYnJvd3Nlci9pLnRlc3QoZGV2aWNlLnBsYXRmb3JtKSkge1xuICAgICAgcmV0dXJuIC9pT1MvaS50ZXN0KGRldmljZS5wbGF0Zm9ybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAvaVBob25lfGlQYWR8aVBvZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNBbmRyb2lkXG4gICAqIEBzaWduYXR1cmUgaXNBbmRyb2lkKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgT1MgaXMgQW5kcm9pZC5bL2VuXVxuICAgKiAgIFtqYV1BbmRyb2lk5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzQW5kcm9pZCgpIHtcbiAgICBpZiAodGhpcy5fcmVuZGVyUGxhdGZvcm0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJQbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRldmljZSA9PT0gJ29iamVjdCcgJiYgIS9icm93c2VyL2kudGVzdChkZXZpY2UucGxhdGZvcm0pKSB7XG4gICAgICByZXR1cm4gL0FuZHJvaWQvaS50ZXN0KGRldmljZS5wbGF0Zm9ybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAvQW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNBbmRyb2lkUGhvbmVcbiAgICogQHNpZ25hdHVyZSBpc0FuZHJvaWRQaG9uZSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGRldmljZSBpcyBBbmRyb2lkIHBob25lLlsvZW5dXG4gICAqICAgW2phXUFuZHJvaWTmkLrluK/kuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNBbmRyb2lkUGhvbmUoKSB7XG4gICAgcmV0dXJuIC9BbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAvTW9iaWxlL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzQW5kcm9pZFRhYmxldFxuICAgKiBAc2lnbmF0dXJlIGlzQW5kcm9pZFRhYmxldCgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGRldmljZSBpcyBBbmRyb2lkIHRhYmxldC5bL2VuXVxuICAgKiAgIFtqYV1BbmRyb2lk44K/44OW44Os44OD44OI5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzQW5kcm9pZFRhYmxldCgpIHtcbiAgICByZXR1cm4gL0FuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICEvTW9iaWxlL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNXUCgpIHtcbiAgICBpZiAodGhpcy5fcmVuZGVyUGxhdGZvcm0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJQbGF0Zm9ybSA9PT0gJ3dwJztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZXZpY2UgPT09ICdvYmplY3QnICYmICEvYnJvd3Nlci9pLnRlc3QoZGV2aWNlLnBsYXRmb3JtKSkge1xuICAgICAgcmV0dXJuIC9XaW4zMk5UfFdpbkNFL2kudGVzdChkZXZpY2UucGxhdGZvcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gL1dpbmRvd3MgUGhvbmV8SUVNb2JpbGV8V1BEZXNrdG9wL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvcyBpc0lQaG9uZVxuICAgKiBAc2lnbmF0dXJlIGlzSVBob25lKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgZGV2aWNlIGlzIGlQaG9uZS5bL2VuXVxuICAgKiAgIFtqYV1pUGhvbmXkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNJUGhvbmUoKSB7XG4gICAgcmV0dXJuIC9pUGhvbmUvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNJUGFkXG4gICAqIEBzaWduYXR1cmUgaXNJUGFkKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgZGV2aWNlIGlzIGlQYWQuWy9lbl1cbiAgICogICBbamFdaVBhZOS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0lQYWQoKSB7XG4gICAgcmV0dXJuIC9pUGFkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNJUG9kKCkge1xuICAgIHJldHVybiAvaVBvZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc0JsYWNrQmVycnlcbiAgICogQHNpZ25hdHVyZSBpc0JsYWNrQmVycnkoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBkZXZpY2UgaXMgQmxhY2tCZXJyeS5bL2VuXVxuICAgKiAgIFtqYV1CbGFja0JlcnJ55LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzQmxhY2tCZXJyeSgpIHtcbiAgICBpZiAodGhpcy5fcmVuZGVyUGxhdGZvcm0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJQbGF0Zm9ybSA9PT0gJ2JsYWNrYmVycnknO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRldmljZSA9PT0gJ29iamVjdCcgJiYgIS9icm93c2VyL2kudGVzdChkZXZpY2UucGxhdGZvcm0pKSB7XG4gICAgICByZXR1cm4gL0JsYWNrQmVycnkvaS50ZXN0KGRldmljZS5wbGF0Zm9ybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAvQmxhY2tCZXJyeXxSSU0gVGFibGV0IE9TfEJCMTAvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzT3BlcmFcbiAgICogQHNpZ25hdHVyZSBpc09wZXJhKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgYnJvd3NlciBpcyBPcGVyYS5bL2VuXVxuICAgKiAgIFtqYV1PcGVyYeS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc09wZXJhKCkge1xuICAgIGlmICh0aGlzLl9yZW5kZXJQbGF0Zm9ybSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclBsYXRmb3JtID09PSAnb3BlcmEnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKCEhd2luZG93Lm9wZXJhIHx8IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignIE9QUi8nKSA+PSAwKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc0ZpcmVmb3hcbiAgICogQHNpZ25hdHVyZSBpc0ZpcmVmb3goKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBicm93c2VyIGlzIEZpcmVmb3guWy9lbl1cbiAgICogICBbamFdRmlyZWZveOS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0ZpcmVmb3goKSB7XG4gICAgaWYgKHRoaXMuX3JlbmRlclBsYXRmb3JtKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVuZGVyUGxhdGZvcm0gPT09ICdmaXJlZm94JztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICh0eXBlb2YgSW5zdGFsbFRyaWdnZXIgIT09ICd1bmRlZmluZWQnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc1NhZmFyaVxuICAgKiBAc2lnbmF0dXJlIGlzU2FmYXJpKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgYnJvd3NlciBpcyBTYWZhcmkuWy9lbl1cbiAgICogICBbamFdU2FmYXJp5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzU2FmYXJpKCkge1xuICAgIGlmICh0aGlzLl9yZW5kZXJQbGF0Zm9ybSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclBsYXRmb3JtID09PSAnc2FmYXJpJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwod2luZG93LkhUTUxFbGVtZW50KS5pbmRleE9mKCdDb25zdHJ1Y3RvcicpID4gMCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNDaHJvbWVcbiAgICogQHNpZ25hdHVyZSBpc0Nocm9tZSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGJyb3dzZXIgaXMgQ2hyb21lLlsvZW5dXG4gICAqICAgW2phXUNocm9tZeS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0Nocm9tZSgpIHtcbiAgICBpZiAodGhpcy5fcmVuZGVyUGxhdGZvcm0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJQbGF0Zm9ybSA9PT0gJ2Nocm9tZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoISF3aW5kb3cuY2hyb21lICYmICEoISF3aW5kb3cub3BlcmEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCcgT1BSLycpID49IDApICYmICEobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCcgRWRnZS8nKSA+PSAwKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNJRVxuICAgKiBAc2lnbmF0dXJlIGlzSUUoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBicm93c2VyIGlzIEludGVybmV0IEV4cGxvcmVyLlsvZW5dXG4gICAqICAgW2phXUludGVybmV0IEV4cGxvcmVy5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzSUUoKSB7XG4gICAgaWYgKHRoaXMuX3JlbmRlclBsYXRmb3JtKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVuZGVyUGxhdGZvcm0gPT09ICdpZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZSB8fCAhIWRvY3VtZW50LmRvY3VtZW50TW9kZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc0VkZ2VcbiAgICogQHNpZ25hdHVyZSBpc0VkZ2UoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBicm93c2VyIGlzIEVkZ2UuWy9lbl1cbiAgICogICBbamFdRWRnZeS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0VkZ2UoKSB7XG4gICAgaWYgKHRoaXMuX3JlbmRlclBsYXRmb3JtKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVuZGVyUGxhdGZvcm0gPT09ICdlZGdlJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignIEVkZ2UvJykgPj0gMDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc0lPUzdhYm92ZVxuICAgKiBAc2lnbmF0dXJlIGlzSU9TN2Fib3ZlKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgaU9TIHZlcnNpb24gaXMgNyBvciBhYm92ZS5bL2VuXVxuICAgKiAgIFtqYV1pT1M35Lul5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzSU9TN2Fib3ZlKCkge1xuICAgIGlmICh0eXBlb2YgZGV2aWNlID09PSAnb2JqZWN0JyAmJiAhL2Jyb3dzZXIvaS50ZXN0KGRldmljZS5wbGF0Zm9ybSkpIHtcbiAgICAgIHJldHVybiAoL2lPUy9pLnRlc3QoZGV2aWNlLnBsYXRmb3JtKSAmJiAocGFyc2VJbnQoZGV2aWNlLnZlcnNpb24uc3BsaXQoJy4nKVswXSkgPj0gNykpO1xuICAgIH0gZWxzZSBpZigvaVBob25lfGlQYWR8aVBvZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgIGNvbnN0IHZlciA9IChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9cXGJbMC05XStfWzAtOV0rKD86X1swLTldKyk/XFxiLykgfHwgWycnXSlbMF0ucmVwbGFjZSgvXy9nLCAnLicpO1xuICAgICAgcmV0dXJuIChwYXJzZUludCh2ZXIuc3BsaXQoJy4nKVswXSkgPj0gNyk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBnZXRNb2JpbGVPUygpIHtcbiAgICBpZiAodGhpcy5pc0FuZHJvaWQoKSkge1xuICAgICAgcmV0dXJuICdhbmRyb2lkJztcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5pc0lPUygpKSB7XG4gICAgICByZXR1cm4gJ2lvcyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuaXNXUCgpKSB7XG4gICAgICByZXR1cm4gJ3dwJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gJ290aGVyJztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0SU9TRGV2aWNlKCkge1xuICAgIGlmICh0aGlzLmlzSVBob25lKCkpIHtcbiAgICAgIHJldHVybiAnaXBob25lJztcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5pc0lQYWQoKSkge1xuICAgICAgcmV0dXJuICdpcGFkJztcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5pc0lQb2QoKSkge1xuICAgICAgcmV0dXJuICdpcG9kJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gJ25hJztcbiAgICB9XG4gIH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBuZXcgUGxhdGZvcm0oKTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4vdXRpbCc7XG5cbi8qKlxuICogQG9iamVjdCBvbnMubm90aWZpY2F0aW9uXG4gKiBAY2F0ZWdvcnkgZGlhbG9nXG4gKiBAY29kZXBlbiBRd3d4eXBcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9kaWFsb2dcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgVXRpbGl0eSBtZXRob2RzIHRvIGNyZWF0ZSBkaWZmZXJlbnQga2luZHMgb2YgYWxlcnQgZGlhbG9ncy4gVGhlcmUgYXJlIHRocmVlIG1ldGhvZHMgYXZhaWxhYmxlOlxuICpcbiAqICAgICAqIGBvbnMubm90aWZpY2F0aW9uLmFsZXJ0KClgXG4gKiAgICAgKiBgb25zLm5vdGlmaWNhdGlvbi5jb25maXJtKClgXG4gKiAgICAgKiBgb25zLm5vdGlmaWNhdGlvbi5wcm9tcHQoKWBcbiAqXG4gKiAgICAgSXQgd2lsbCBhdXRvbWF0aWNhbGx5IGRpc3BsYXkgYSBNYXRlcmlhbCBEZXNpZ24gZGlhbG9nIG9uIEFuZHJvaWQgZGV2aWNlcy5cbiAqICAgWy9lbl1cbiAqICAgW2phXeOBhOOBj+OBpOOBi+OBrueorumhnuOBruOCouODqeODvOODiOODgOOCpOOCouODreOCsOOCkuS9nOaIkOOBmeOCi+OBn+OCgeOBruODpuODvOODhuOCo+ODquODhuOCo+ODoeOCveODg+ODieOCkuWPjuOCgeOBn+OCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gKiBAZXhhbXBsZVxuICogb25zLm5vdGlmaWNhdGlvbi5hbGVydCgnSGVsbG8sIHdvcmxkIScpO1xuICpcbiAqIG9ucy5ub3RpZmljYXRpb24uY29uZmlybSgnQXJlIHlvdSByZWFkeT8nKVxuICogICAudGhlbihcbiAqICAgICBmdW5jdGlvbihhbnN3ZXIpIHtcbiAqICAgICAgIGlmIChhbnN3ZXIgPT09IDEpIHtcbiAqICAgICAgICAgb25zLm5vdGlmaWNhdGlvbi5hbGVydCgnTGV0XFwncyBnbyEnKTtcbiAqICAgICAgIH1cbiAqICAgICB9XG4gKiAgICk7XG4gKlxuICogb25zLm5vdGlmaWNhdGlvbi5wcm9tcHQoJ0hvdyBvbGQgYXJlID8nKVxuICogICAudGhlbihcbiAqICAgICBmdW5jdGlvbihhZ2UpIHtcbiAqICAgICAgIG9ucy5ub3RpZmljYXRpb24uYWxlcnQoJ1lvdSBhcmUgJyArIGFnZSArICcgeWVhcnMgb2xkLicpO1xuICogICAgIH1cbiAqICAgKTtcbiAqL1xuY29uc3Qgbm90aWZpY2F0aW9uID0ge307XG5cbm5vdGlmaWNhdGlvbi5fY3JlYXRlQWxlcnREaWFsb2cgPSBmdW5jdGlvbih0aXRsZSwgbWVzc2FnZSxcbiAgYnV0dG9uTGFiZWxzLCBwcmltYXJ5QnV0dG9uSW5kZXgsIG1vZGlmaWVyLCBhbmltYXRpb24sIGlkLCBjYWxsYmFjayxcbiAgbWVzc2FnZUlzSFRNTCwgY2FuY2VsYWJsZSwgcHJvbXB0RGlhbG9nLCBhdXRvZm9jdXMsIHBsYWNlaG9sZGVyLFxuICBkZWZhdWx0VmFsdWUsIHN1Ym1pdE9uRW50ZXIsIGNvbXBpbGUpIHtcblxuICBjb21waWxlID0gY29tcGlsZSB8fCBmdW5jdGlvbihvYmplY3QpIHsgcmV0dXJuIG9iamVjdDsgfTtcblxuICBjb25zdCB0aXRsZUVsZW1lbnRIVE1MID0gdHlwZW9mIHRpdGxlID09PSAnc3RyaW5nJyA/ICc8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLXRpdGxlXCI+PC9kaXY+JyA6ICcnO1xuXG4gIGxldCBkaWFsb2dFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb25zLWFsZXJ0LWRpYWxvZycpO1xuXG4gIGlubmVySFRNTChkaWFsb2dFbGVtZW50LCBgXG4gICAgJHt0aXRsZUVsZW1lbnRIVE1MfVxuICAgIDxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2ctY29udGVudFwiPjwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2ctZm9vdGVyXCI+PC9kaXY+XG4gIGApO1xuXG4gIGlmIChpZCkge1xuICAgIGRpYWxvZ0VsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIGlkKTtcbiAgfVxuXG4gIGxldCB0aXRsZUVsZW1lbnQgPSBkaWFsb2dFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5hbGVydC1kaWFsb2ctdGl0bGUnKTtcbiAgbGV0IG1lc3NhZ2VFbGVtZW50ID0gZGlhbG9nRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuYWxlcnQtZGlhbG9nLWNvbnRlbnQnKTtcbiAgbGV0IGZvb3RlckVsZW1lbnQgPSBkaWFsb2dFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5hbGVydC1kaWFsb2ctZm9vdGVyJyk7XG4gIGxldCBpbnB1dEVsZW1lbnQ7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuXG4gIHJlc3VsdC5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHJlc3VsdC5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICByZXN1bHQucmVqZWN0ID0gcmVqZWN0O1xuICB9KTtcblxuICBtb2RpZmllciA9IG1vZGlmaWVyIHx8IGRpYWxvZ0VsZW1lbnQuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpO1xuXG4gIGlmICh0eXBlb2YgdGl0bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgdGl0bGVFbGVtZW50LnRleHRDb250ZW50ID0gdGl0bGU7XG4gIH1cblxuICB0aXRsZUVsZW1lbnQgPSBudWxsO1xuXG4gIGRpYWxvZ0VsZW1lbnQuc2V0QXR0cmlidXRlKCdhbmltYXRpb24nLCBhbmltYXRpb24pO1xuXG4gIGlmIChtZXNzYWdlSXNIVE1MKSB7XG4gICAgaW5uZXJIVE1MKG1lc3NhZ2VFbGVtZW50LCBtZXNzYWdlKTtcbiAgfSBlbHNlIHtcbiAgICBtZXNzYWdlRWxlbWVudC50ZXh0Q29udGVudCA9IG1lc3NhZ2U7XG4gIH1cblxuICBpZiAocHJvbXB0RGlhbG9nKSB7XG4gICAgaW5wdXRFbGVtZW50ID0gdXRpbC5jcmVhdGVFbGVtZW50KCc8aW5wdXQgY2xhc3M9XCJ0ZXh0LWlucHV0IHRleHQtaW5wdXQtLXVuZGVyYmFyXCIgdHlwZT1cInRleHRcIj48L2lucHV0PicpO1xuXG4gICAgaWYgKG1vZGlmaWVyKSB7XG4gICAgICBpbnB1dEVsZW1lbnQuY2xhc3NMaXN0LmFkZChgdGV4dC1pbnB1dC0tJHttb2RpZmllcn1gKTtcbiAgICB9XG5cbiAgICBpbnB1dEVsZW1lbnQuc2V0QXR0cmlidXRlKCdwbGFjZWhvbGRlcicsIHBsYWNlaG9sZGVyKTtcbiAgICBpbnB1dEVsZW1lbnQudmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgaW5wdXRFbGVtZW50LnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgIGlucHV0RWxlbWVudC5zdHlsZS5tYXJnaW5Ub3AgPSAnMTBweCc7XG5cbiAgICBtZXNzYWdlRWxlbWVudC5hcHBlbmRDaGlsZChpbnB1dEVsZW1lbnQpO1xuXG4gICAgaWYgKHN1Ym1pdE9uRW50ZXIpIHtcbiAgICAgIGlucHV0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSAxMykge1xuICAgICAgICAgIGRpYWxvZ0VsZW1lbnQuaGlkZSh7XG4gICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKGlucHV0RWxlbWVudC52YWx1ZSk7XG4gICAgICAgICAgICAgIHJlc3VsdC5yZXNvbHZlKGlucHV0RWxlbWVudC52YWx1ZSk7XG4gICAgICAgICAgICAgIGRpYWxvZ0VsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgICAgICAgIGRpYWxvZ0VsZW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LCBmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaWFsb2dFbGVtZW50KTtcblxuICBjb21waWxlKGRpYWxvZ0VsZW1lbnQpO1xuXG4gIGlmIChidXR0b25MYWJlbHMubGVuZ3RoIDw9IDIpIHtcbiAgICBmb290ZXJFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2FsZXJ0LWRpYWxvZy1mb290ZXItLW9uZScpO1xuICB9XG5cbiAgY29uc3QgY3JlYXRlQnV0dG9uID0gZnVuY3Rpb24oaSkge1xuICAgIGxldCBidXR0b25FbGVtZW50ID0gdXRpbC5jcmVhdGVFbGVtZW50KCc8YnV0dG9uIGNsYXNzPVwiYWxlcnQtZGlhbG9nLWJ1dHRvblwiPjwvYnV0dG9uPicpO1xuICAgIGJ1dHRvbkVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYnV0dG9uTGFiZWxzW2ldKSk7XG5cbiAgICBpZiAoaSA9PSBwcmltYXJ5QnV0dG9uSW5kZXgpIHtcbiAgICAgIGJ1dHRvbkVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnYWxlcnQtZGlhbG9nLWJ1dHRvbi0tcHJpbWFsJyk7XG4gICAgfVxuXG4gICAgaWYgKGJ1dHRvbkxhYmVscy5sZW5ndGggPD0gMikge1xuICAgICAgYnV0dG9uRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdhbGVydC1kaWFsb2ctYnV0dG9uLS1vbmUnKTtcbiAgICB9XG5cbiAgICBjb25zdCBvbkNsaWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICBidXR0b25FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25DbGljaywgZmFsc2UpO1xuXG4gICAgICBkaWFsb2dFbGVtZW50LmhpZGUoe1xuICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKHByb21wdERpYWxvZykge1xuICAgICAgICAgICAgY2FsbGJhY2soaW5wdXRFbGVtZW50LnZhbHVlKTtcbiAgICAgICAgICAgIHJlc3VsdC5yZXNvbHZlKGlucHV0RWxlbWVudC52YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGkpO1xuICAgICAgICAgICAgcmVzdWx0LnJlc29sdmUoaSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRpYWxvZ0VsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgICAgZGlhbG9nRWxlbWVudCA9IGlucHV0RWxlbWVudCA9IGJ1dHRvbkVsZW1lbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgYnV0dG9uRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIG9uQ2xpY2ssIGZhbHNlKTtcbiAgICBmb290ZXJFbGVtZW50LmFwcGVuZENoaWxkKGJ1dHRvbkVsZW1lbnQpO1xuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnV0dG9uTGFiZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgY3JlYXRlQnV0dG9uKGkpO1xuICB9XG5cbiAgaWYgKGNhbmNlbGFibGUpIHtcbiAgICBkaWFsb2dFbGVtZW50LmNhbmNlbGFibGUgPSB0cnVlO1xuICAgIGRpYWxvZ0VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZGlhbG9nLWNhbmNlbCcsIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHByb21wdERpYWxvZykge1xuICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgcmVzdWx0LnJlamVjdChudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKC0xKTtcbiAgICAgICAgcmVzdWx0LnJlamVjdCgtMSk7XG4gICAgICB9XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBkaWFsb2dFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICBkaWFsb2dFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgaW5wdXRFbGVtZW50ID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH0sIGZhbHNlKTtcbiAgfVxuXG4gIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgZGlhbG9nRWxlbWVudC5zaG93KHtcbiAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGlucHV0RWxlbWVudCAmJiBwcm9tcHREaWFsb2cgJiYgYXV0b2ZvY3VzKSB7XG4gICAgICAgICAgaW5wdXRFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgbWVzc2FnZUVsZW1lbnQgPSBmb290ZXJFbGVtZW50ID0gbnVsbDtcblxuICBpZiAobW9kaWZpZXIpIHtcbiAgICBkaWFsb2dFbGVtZW50LnNldEF0dHJpYnV0ZSgnbW9kaWZpZXInLCAnJyk7XG4gICAgZGlhbG9nRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJywgbW9kaWZpZXIpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdC5wcm9taXNlO1xufTtcblxubm90aWZpY2F0aW9uLl9hbGVydE9yaWdpbmFsID0gZnVuY3Rpb24obWVzc2FnZSwgb3B0aW9ucyA9IHt9KSB7XG4gIHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJyA/IChvcHRpb25zLm1lc3NhZ2UgPSBtZXNzYWdlKSA6IChvcHRpb25zID0gbWVzc2FnZSk7XG5cbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIGJ1dHRvbkxhYmVsOiAnT0snLFxuICAgIGFuaW1hdGlvbjogJ2RlZmF1bHQnLFxuICAgIHRpdGxlOiAnQWxlcnQnLFxuICAgIGNhbGxiYWNrOiBmdW5jdGlvbigpIHt9XG4gIH07XG5cbiAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG4gIGlmICghb3B0aW9ucy5tZXNzYWdlICYmICFvcHRpb25zLm1lc3NhZ2VIVE1MKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBbGVydCBkaWFsb2cgbXVzdCBjb250YWluIGEgbWVzc2FnZS4nKTtcbiAgfVxuXG4gIHJldHVybiBub3RpZmljYXRpb24uX2NyZWF0ZUFsZXJ0RGlhbG9nKFxuICAgIG9wdGlvbnMudGl0bGUsXG4gICAgb3B0aW9ucy5tZXNzYWdlIHx8IG9wdGlvbnMubWVzc2FnZUhUTUwsXG4gICAgW29wdGlvbnMuYnV0dG9uTGFiZWxdLFxuICAgIDAsXG4gICAgb3B0aW9ucy5tb2RpZmllcixcbiAgICBvcHRpb25zLmFuaW1hdGlvbixcbiAgICBvcHRpb25zLmlkLFxuICAgIG9wdGlvbnMuY2FsbGJhY2ssXG4gICAgIW9wdGlvbnMubWVzc2FnZSA/IHRydWUgOiBmYWxzZSxcbiAgICBmYWxzZSwgZmFsc2UsIGZhbHNlLCAnJywgJycsIGZhbHNlLFxuICAgIG9wdGlvbnMuY29tcGlsZVxuICApO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGFsZXJ0XG4gKiBAc2lnbmF0dXJlIGFsZXJ0KG1lc3NhZ2UgWywgb3B0aW9uc10gfCBvcHRpb25zKVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqICAgW2VuXVdpbGwgcmVzb2x2ZSB3aGVuIHRoZSBkaWFsb2cgaXMgY2xvc2VkLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAqICAgW2VuXUFsZXJ0IG1lc3NhZ2UuIFRoaXMgYXJndW1lbnQgaXMgb3B0aW9uYWwgYnV0IGlmIGl0J3Mgbm90IGRlZmluZWQgZWl0aGVyIGBvcHRpb25zLm1lc3NhZ2VgIG9yIGBvcHRpb25zLm1lc3NhZ2VIVE1MYCBtdXN0IGJlIGRlZmluZWQgaW5zdGVhZC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1lc3NhZ2VdXG4gKiAgIFtlbl1BbGVydCBtZXNzYWdlLlsvZW5dXG4gKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgavooajnpLrjgZnjgovmloflrZfliJfjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1lc3NhZ2VIVE1MXVxuICogICBbZW5dQWxlcnQgbWVzc2FnZSBpbiBIVE1MLlsvZW5dXG4gKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgavooajnpLrjgZnjgotIVE1M44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5idXR0b25MYWJlbF1cbiAqICAgW2VuXUxhYmVsIGZvciBjb25maXJtYXRpb24gYnV0dG9uLiBEZWZhdWx0IGlzIGBcIk9LXCJgLlsvZW5dXG4gKiAgIFtqYV3norroqo3jg5zjgr/jg7Pjga7jg6njg5njg6vjgpLmjIflrprjgZfjgb7jgZnjgIJcIk9LXCLjgYzjg4fjg5Xjgqnjg6vjg4jjgafjgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwibm9uZVwiYCwgYFwiZmFkZVwiYCBhbmQgYFwic2xpZGVcImAuWy9lbl1cbiAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOCkuihqOekuuOBmeOCi+mam+OBruOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwiLCBcImZhZGVcIiwgXCJzbGlkZVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5pZF1cbiAqICAgW2VuXVRoZSBgPG9ucy1hbGVydC1kaWFsb2c+YCBlbGVtZW50J3MgSUQuWy9lbl1cbiAqICAgW2phXW9ucy1hbGVydC1kaWFsb2fopoHntKDjga5JROOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGl0bGVdXG4gKiAgIFtlbl1EaWFsb2cgdGl0bGUuIERlZmF1bHQgaXMgYFwiQWxlcnRcImAuWy9lbl1cbiAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBruS4iumDqOOBq+ihqOekuuOBmeOCi+OCv+OCpOODiOODq+OCkuaMh+WumuOBl+OBvuOBmeOAglwiQWxlcnRcIuOBjOODh+ODleOCqeODq+ODiOOBp+OBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubW9kaWZpZXJdXG4gKiAgIFtlbl1Nb2RpZmllciBmb3IgdGhlIGRpYWxvZy5bL2VuXVxuICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44GubW9kaWZpZXLlsZ7mgKfjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gKiAgIFtlbl1GdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIGFmdGVyIGRpYWxvZyBoYXMgYmVlbiBjbG9zZWQuWy9lbl1cbiAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBjOmWieOBmOOCieOCjOOBn+aZguOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIERpc3BsYXkgYW4gYWxlcnQgZGlhbG9nIHRvIHNob3cgdGhlIHVzZXIgYSBtZXNzYWdlLlxuICpcbiAqICAgICBUaGUgY29udGVudCBvZiB0aGUgbWVzc2FnZSBjYW4gYmUgZWl0aGVyIHNpbXBsZSB0ZXh0IG9yIEhUTUwuXG4gKlxuICogICAgIEl0IGNhbiBiZSBjYWxsZWQgaW4gdGhlIGZvbGxvd2luZyB3YXlzOlxuICpcbiAqICAgICBgYGBcbiAqICAgICBvbnMubm90aWZpY2F0aW9uLmFsZXJ0KG1lc3NhZ2UsIG9wdGlvbnMpO1xuICogICAgIG9ucy5ub3RpZmljYXRpb24uYWxlcnQob3B0aW9ucyk7XG4gKiAgICAgYGBgXG4gKlxuICogICAgIE11c3Qgc3BlY2lmeSBlaXRoZXIgYG1lc3NhZ2VgIG9yIGBtZXNzYWdlSFRNTGAuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1cbiAqICAgICDjg6bjg7zjgrbjg7zjgbjjg6Hjg4Pjgrvjg7zjgrjjgpLopovjgZvjgovjgZ/jgoHjga7jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZfjgb7jgZnjgIJcbiAqICAgICDooajnpLrjgZnjgovjg6Hjg4Pjgrvjg7zjgrjjga/jgIHjg4bjgq3jgrnjg4jjgYvjgoLjgZfjgY/jga9IVE1M44KS5oyH5a6a44Gn44GN44G+44GZ44CCXG4gKiAgICAg44GT44Gu44Oh44K944OD44OJ44Gu5byV5pWw44Gr44Gv44CBb3B0aW9ucy5tZXNzYWdl44KC44GX44GP44Gvb3B0aW9ucy5tZXNzYWdlSFRNTOOBruOBqeOBoeOCieOBi+OCkuW/heOBmuaMh+WumuOBmeOCi+W/heimgeOBjOOBguOCiuOBvuOBmeOAglxuICogICBbL2phXVxuICovXG5ub3RpZmljYXRpb24uYWxlcnQgPSBub3RpZmljYXRpb24uX2FsZXJ0T3JpZ2luYWw7XG5cbm5vdGlmaWNhdGlvbi5fY29uZmlybU9yaWdpbmFsID0gZnVuY3Rpb24obWVzc2FnZSwgb3B0aW9ucyA9IHt9KSB7XG4gIHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJyA/IChvcHRpb25zLm1lc3NhZ2UgPSBtZXNzYWdlKSA6IChvcHRpb25zID0gbWVzc2FnZSk7XG5cbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIGJ1dHRvbkxhYmVsczogWydDYW5jZWwnLCAnT0snXSxcbiAgICBwcmltYXJ5QnV0dG9uSW5kZXg6IDEsXG4gICAgYW5pbWF0aW9uOiAnZGVmYXVsdCcsXG4gICAgdGl0bGU6ICdDb25maXJtJyxcbiAgICBjYWxsYmFjazogZnVuY3Rpb24oKSB7fSxcbiAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICB9O1xuXG4gIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gIGlmICghb3B0aW9ucy5tZXNzYWdlICYmICFvcHRpb25zLm1lc3NhZ2VIVE1MKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb25maXJtIGRpYWxvZyBtdXN0IGNvbnRhaW4gYSBtZXNzYWdlLicpO1xuICB9XG5cbiAgcmV0dXJuIG5vdGlmaWNhdGlvbi5fY3JlYXRlQWxlcnREaWFsb2coXG4gICAgb3B0aW9ucy50aXRsZSxcbiAgICBvcHRpb25zLm1lc3NhZ2UgfHwgb3B0aW9ucy5tZXNzYWdlSFRNTCxcbiAgICBvcHRpb25zLmJ1dHRvbkxhYmVscyxcbiAgICBvcHRpb25zLnByaW1hcnlCdXR0b25JbmRleCxcbiAgICBvcHRpb25zLm1vZGlmaWVyLFxuICAgIG9wdGlvbnMuYW5pbWF0aW9uLFxuICAgIG9wdGlvbnMuaWQsXG4gICAgb3B0aW9ucy5jYWxsYmFjayxcbiAgICAhb3B0aW9ucy5tZXNzYWdlID8gdHJ1ZSA6IGZhbHNlLFxuICAgIG9wdGlvbnMuY2FuY2VsYWJsZSxcbiAgICBmYWxzZSwgZmFsc2UsICcnLCAnJywgZmFsc2UsXG4gICAgb3B0aW9ucy5jb21waWxlXG4gICk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgY29uZmlybVxuICogQHNpZ25hdHVyZSBjb25maXJtKG1lc3NhZ2UgWywgb3B0aW9uc10gfCBvcHRpb25zKVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqICAgW2VuXVdpbGwgcmVzb2x2ZSB0byB0aGUgaW5kZXggb2YgdGhlIGJ1dHRvbiB0aGF0IHdhcyBwcmVzc2VkLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAqICAgW2VuXUFsZXJ0IG1lc3NhZ2UuIFRoaXMgYXJndW1lbnQgaXMgb3B0aW9uYWwgYnV0IGlmIGl0J3Mgbm90IGRlZmluZWQgZWl0aGVyIGBvcHRpb25zLm1lc3NhZ2VgIG9yIGBvcHRpb25zLm1lc3NhZ2VIVE1MYCBtdXN0IGJlIGRlZmluZWQgaW5zdGVhZC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWVzc2FnZV1cbiAqICAgW2VuXUNvbmZpcm1hdGlvbiBxdWVzdGlvbi5bL2VuXVxuICogICBbamFd56K66KqN44OA44Kk44Ki44Ot44Kw44Gr6KGo56S644GZ44KL44Oh44OD44K744O844K444KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tZXNzYWdlSFRNTF1cbiAqICAgW2VuXURpYWxvZyBjb250ZW50IGluIEhUTUwuWy9lbl1cbiAqICAgW2phXeeiuuiqjeODgOOCpOOCouODreOCsOOBq+ihqOekuuOBmeOCi0hUTUzjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMuYnV0dG9uTGFiZWxzXVxuICogICBbZW5dTGFiZWxzIGZvciB0aGUgYnV0dG9ucy4gRGVmYXVsdCBpcyBgW1wiQ2FuY2VsXCIsIFwiT0tcIl1gLlsvZW5dXG4gKiAgIFtqYV3jg5zjgr/jg7Pjga7jg6njg5njg6vjga7phY3liJfjgpLmjIflrprjgZfjgb7jgZnjgIJbXCJDYW5jZWxcIiwgXCJPS1wiXeOBjOODh+ODleOCqeODq+ODiOOBp+OBmeOAglsvamFdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucHJpbWFyeUJ1dHRvbkluZGV4XVxuICogICBbZW5dSW5kZXggb2YgcHJpbWFyeSBidXR0b24uIERlZmF1bHQgaXMgYDFgLlsvZW5dXG4gKiAgIFtqYV3jg5fjg6njgqTjg57jg6rjg5zjgr/jg7Pjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLmjIflrprjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga8gMSDjgafjgZnjgIJbL2phXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jYW5jZWxhYmxlXVxuICogICBbZW5dV2hldGhlciB0aGUgZGlhbG9nIGlzIGNhbmNlbGFibGUgb3Igbm90LiBEZWZhdWx0IGlzIGBmYWxzZWAuIElmIHRoZSBkaWFsb2cgaXMgY2FuY2VsYWJsZSBpdCBjYW4gYmUgY2xvc2VkIGJ5IGNsaWNraW5nIHRoZSBiYWNrZ3JvdW5kIG9yIHByZXNzaW5nIHRoZSBBbmRyb2lkIGJhY2sgYnV0dG9uLlsvZW5dXG4gKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzjgq3jg6Pjg7Pjgrvjg6vlj6/og73jgYvjganjgYbjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwibm9uZVwiYCwgYFwiZmFkZVwiYCBhbmQgYFwic2xpZGVcImAuWy9lbl1cbiAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwiLCBcImZhZGVcIiwgXCJzbGlkZVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5pZF1cbiAqICAgW2VuXVRoZSBgPG9ucy1hbGVydC1kaWFsb2c+YCBlbGVtZW50J3MgSUQuWy9lbl1cbiAqICAgW2phXW9ucy1hbGVydC1kaWFsb2fopoHntKDjga5JROOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGl0bGVdXG4gKiAgIFtlbl1EaWFsb2cgdGl0bGUuIERlZmF1bHQgaXMgYFwiQ29uZmlybVwiYC5bL2VuXVxuICogICBbamFd44OA44Kk44Ki44Ot44Kw44Gu44K/44Kk44OI44Or44KS5oyH5a6a44GX44G+44GZ44CCXCJDb25maXJtXCLjgYzjg4fjg5Xjgqnjg6vjg4jjgafjgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1vZGlmaWVyXVxuICogICBbZW5dTW9kaWZpZXIgZm9yIHRoZSBkaWFsb2cuWy9lbl1cbiAqICAgW2phXeODgOOCpOOCouODreOCsOOBrm1vZGlmaWVy5bGe5oCn44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICogICBbZW5dXG4gKiAgICAgRnVuY3Rpb24gdGhhdCBleGVjdXRlcyBhZnRlciB0aGUgZGlhbG9nIGhhcyBiZWVuIGNsb3NlZC5cbiAqICAgICBBcmd1bWVudCBmb3IgdGhlIGZ1bmN0aW9uIGlzIHRoZSBpbmRleCBvZiB0aGUgYnV0dG9uIHRoYXQgd2FzIHByZXNzZWQgb3IgYC0xYCBpZiB0aGUgZGlhbG9nIHdhcyBjYW5jZWxlZC5cbiAqICAgWy9lbl1cbiAqICAgW2phXVxuICogICAgIOODgOOCpOOCouODreOCsOOBjOmWieOBmOOCieOCjOOBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglxuICogICAgIOOBk+OBrumWouaVsOOBruW8leaVsOOBqOOBl+OBpuOAgeaKvOOBleOCjOOBn+ODnOOCv+ODs+OBruOCpOODs+ODh+ODg+OCr+OCueWApOOBjOa4oeOBleOCjOOBvuOBmeOAglxuICogICAgIOOCguOBl+ODgOOCpOOCouODreOCsOOBjOOCreODo+ODs+OCu+ODq+OBleOCjOOBn+WgtOWQiOOBq+OBry0x44GM5rih44GV44KM44G+44GZ44CCXG4gKiAgIFsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIERpc3BsYXkgYSBkaWFsb2cgdG8gYXNrIHRoZSB1c2VyIGZvciBjb25maXJtYXRpb24uXG4gKiAgICAgVGhlIGRlZmF1bHQgYnV0dG9uIGxhYmVscyBhcmUgYFwiQ2FuY2VsXCJgIGFuZCBgXCJPS1wiYCBidXQgdGhleSBjYW4gYmUgY3VzdG9taXplZC5cbiAqXG4gKiAgICAgSXQgY2FuIGJlIGNhbGxlZCBpbiB0aGUgZm9sbG93aW5nIHdheXM6XG4gKlxuICogICAgIGBgYFxuICogICAgIG9ucy5ub3RpZmljYXRpb24uY29uZmlybShtZXNzYWdlLCBvcHRpb25zKTtcbiAqICAgICBvbnMubm90aWZpY2F0aW9uLmNvbmZpcm0ob3B0aW9ucyk7XG4gKiAgICAgYGBgXG4gKlxuICogICAgIE11c3Qgc3BlY2lmeSBlaXRoZXIgYG1lc3NhZ2VgIG9yIGBtZXNzYWdlSFRNTGAuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1cbiAqICAgICDjg6bjg7zjgrbjgavnorroqo3jgpLkv4PjgZnjg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZfjgb7jgZnjgIJcbiAqICAgICDjg4fjgqrjg6vjgajjga7jg5zjgr/jg7Pjg6njg5njg6vjga/jgIFcIkNhbmNlbFwi44GoXCJPS1wi44Gn44GZ44GM44CB44GT44KM44Gv44GT44Gu44Oh44K944OD44OJ44Gu5byV5pWw44Gn44Kr44K544K/44Oe44Kk44K644Gn44GN44G+44GZ44CCXG4gKiAgICAg44GT44Gu44Oh44K944OD44OJ44Gu5byV5pWw44Gr44Gv44CBb3B0aW9ucy5tZXNzYWdl44KC44GX44GP44Gvb3B0aW9ucy5tZXNzYWdlSFRNTOOBruOBqeOBoeOCieOBi+OCkuW/heOBmuaMh+WumuOBmeOCi+W/heimgeOBjOOBguOCiuOBvuOBmeOAglxuICogICBbL2phXVxuICovXG5ub3RpZmljYXRpb24uY29uZmlybSA9IG5vdGlmaWNhdGlvbi5fY29uZmlybU9yaWdpbmFsO1xuXG5ub3RpZmljYXRpb24uX3Byb21wdE9yaWdpbmFsID0gZnVuY3Rpb24obWVzc2FnZSwgb3B0aW9ucyA9IHt9KSB7XG4gIHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJyA/IChvcHRpb25zLm1lc3NhZ2UgPSBtZXNzYWdlKSA6IChvcHRpb25zID0gbWVzc2FnZSk7XG5cbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIGJ1dHRvbkxhYmVsOiAnT0snLFxuICAgIGFuaW1hdGlvbjogJ2RlZmF1bHQnLFxuICAgIHRpdGxlOiAnQWxlcnQnLFxuICAgIGRlZmF1bHRWYWx1ZTogJycsXG4gICAgcGxhY2Vob2xkZXI6ICcnLFxuICAgIGNhbGxiYWNrOiBmdW5jdGlvbigpIHt9LFxuICAgIGNhbmNlbGFibGU6IGZhbHNlLFxuICAgIGF1dG9mb2N1czogdHJ1ZSxcbiAgICBzdWJtaXRPbkVudGVyOiB0cnVlXG4gIH07XG5cbiAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG4gIGlmICghb3B0aW9ucy5tZXNzYWdlICYmICFvcHRpb25zLm1lc3NhZ2VIVE1MKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQcm9tcHQgZGlhbG9nIG11c3QgY29udGFpbiBhIG1lc3NhZ2UuJyk7XG4gIH1cblxuICByZXR1cm4gbm90aWZpY2F0aW9uLl9jcmVhdGVBbGVydERpYWxvZyhcbiAgICBvcHRpb25zLnRpdGxlLFxuICAgIG9wdGlvbnMubWVzc2FnZSB8fCBvcHRpb25zLm1lc3NhZ2VIVE1MLFxuICAgIFtvcHRpb25zLmJ1dHRvbkxhYmVsXSxcbiAgICAwLFxuICAgIG9wdGlvbnMubW9kaWZpZXIsXG4gICAgb3B0aW9ucy5hbmltYXRpb24sXG4gICAgb3B0aW9ucy5pZCxcbiAgICBvcHRpb25zLmNhbGxiYWNrLFxuICAgICFvcHRpb25zLm1lc3NhZ2UgPyB0cnVlIDogZmFsc2UsXG4gICAgb3B0aW9ucy5jYW5jZWxhYmxlLFxuICAgIHRydWUsXG4gICAgb3B0aW9ucy5hdXRvZm9jdXMsXG4gICAgb3B0aW9ucy5wbGFjZWhvbGRlcixcbiAgICBvcHRpb25zLmRlZmF1bHRWYWx1ZSxcbiAgICBvcHRpb25zLnN1Ym1pdE9uRW50ZXIsXG4gICAgb3B0aW9ucy5jb21waWxlXG4gICk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgcHJvbXB0XG4gKiBAc2lnbmF0dXJlIHByb21wdChtZXNzYWdlIFssIG9wdGlvbnNdIHwgb3B0aW9ucylcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gKiAgIFtlbl1BbGVydCBtZXNzYWdlLiBUaGlzIGFyZ3VtZW50IGlzIG9wdGlvbmFsIGJ1dCBpZiBpdCdzIG5vdCBkZWZpbmVkIGVpdGhlciBgb3B0aW9ucy5tZXNzYWdlYCBvciBgb3B0aW9ucy5tZXNzYWdlSFRNTGAgbXVzdCBiZSBkZWZpbmVkIGluc3RlYWQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogICBbZW5dV2lsbCByZXNvbHZlIHRvIHRoZSBpbnB1dCB2YWx1ZSB3aGVuIHRoZSBkaWFsb2cgaXMgY2xvc2VkLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWVzc2FnZV1cbiAqICAgW2VuXVByb21wdCBxdWVzdGlvbi5bL2VuXVxuICogICBbamFd44OA44Kk44Ki44Ot44Kw44Gr6KGo56S644GZ44KL44Oh44OD44K744O844K444KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tZXNzYWdlSFRNTF1cbiAqICAgW2VuXURpYWxvZyBjb250ZW50IGluIEhUTUwuWy9lbl1cbiAqICAgW2phXeODgOOCpOOCouODreOCsOOBq+ihqOekuuOBmeOCi0hUTUzjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmJ1dHRvbkxhYmVsXVxuICogICBbZW5dTGFiZWwgZm9yIGNvbmZpcm1hdGlvbiBidXR0b24uIERlZmF1bHQgaXMgYFwiT0tcImAuWy9lbl1cbiAqICAgW2phXeeiuuiqjeODnOOCv+ODs+OBruODqeODmeODq+OCkuaMh+WumuOBl+OBvuOBmeOAglwiT0tcIuOBjOODh+ODleOCqeODq+ODiOOBp+OBmeOAglsvamFdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucHJpbWFyeUJ1dHRvbkluZGV4XVxuICogICBbZW5dSW5kZXggb2YgcHJpbWFyeSBidXR0b24uIERlZmF1bHQgaXMgYDFgLlsvZW5dXG4gKiAgIFtqYV3jg5fjg6njgqTjg57jg6rjg5zjgr/jg7Pjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLmjIflrprjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga8gMSDjgafjgZnjgIJbL2phXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jYW5jZWxhYmxlXVxuICogICBbZW5dV2hldGhlciB0aGUgZGlhbG9nIGlzIGNhbmNlbGFibGUgb3Igbm90LiBEZWZhdWx0IGlzIGZhbHNlLiBXaGVuIHRoZSBkaWFsb2cgaXMgY2FuY2VsYWJsZSBpdCB3aWxsIGJlIGNsb3NlZCBpZiB0aGUgdXNlciB0YXBzIHRoZSBiYWNrZ3JvdW5kIG9yIHByZXNzZXMgdGhlIEFuZHJvaWQgYmFjayBidXR0b24uWy9lbl1cbiAqICAgW2phXeODgOOCpOOCouODreOCsOOBjOOCreODo+ODs+OCu+ODq+WPr+iDveOBi+OBqeOBhuOBi+OCkuaMh+WumuOBl+OBvuOBmeOAguODh+ODleOCqeODq+ODiOOBryBmYWxzZSDjgafjgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwibm9uZVwiYCwgYFwiZmFkZVwiYCBhbmQgYFwic2xpZGVcImAuWy9lbl1cbiAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwiLCBcImZhZGVcIiwgXCJzbGlkZVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5pZF1cbiAqICAgW2VuXVRoZSBgPG9ucy1hbGVydC1kaWFsb2c+YCBlbGVtZW50J3MgSUQuWy9lbl1cbiAqICAgW2phXW9ucy1hbGVydC1kaWFsb2fopoHntKDjga5JROOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGl0bGVdXG4gKiAgIFtlbl1EaWFsb2cgdGl0bGUuIERlZmF1bHQgaXMgYFwiQWxlcnRcImAuWy9lbl1cbiAqICAgW2phXeODgOOCpOOCouODreOCsOOBruOCv+OCpOODiOODq+OCkuaMh+WumuOBl+OBvuOBmeOAguODh+ODleOCqeODq+ODiOOBryBcIkFsZXJ0XCIg44Gn44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wbGFjZWhvbGRlcl1cbiAqICAgW2VuXVBsYWNlaG9sZGVyIGZvciB0aGUgdGV4dCBpbnB1dC5bL2VuXVxuICogICBbamFd44OG44Kt44K544OI5qyE44Gu44OX44Os44O844K544Ob44Or44OA44Gr6KGo56S644GZ44KL44OG44Kt44K544OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5kZWZhdWx0VmFsdWVdXG4gKiAgIFtlbl1EZWZhdWx0IHZhbHVlIGZvciB0aGUgdGV4dCBpbnB1dC5bL2VuXVxuICogICBbamFd44OG44Kt44K544OI5qyE44Gu44OH44OV44Kp44Or44OI44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYXV0b2ZvY3VzXVxuICogICBbZW5dQXV0b2ZvY3VzIHRoZSBpbnB1dCBlbGVtZW50LiBEZWZhdWx0IGlzIGB0cnVlYC5bL2VuXVxuICogICBbamFdaW5wdXTopoHntKDjgavoh6rli5XnmoTjgavjg5Xjgqnjg7zjgqvjgrnjgZnjgovjgYvjganjgYbjgYvjgpLmjIflrprjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga90cnVl44Gn44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tb2RpZmllcl1cbiAqICAgW2VuXU1vZGlmaWVyIGZvciB0aGUgZGlhbG9nLlsvZW5dXG4gKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjga5tb2RpZmllcuWxnuaAp+OBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAqICAgW2VuXVxuICogICAgIEZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgYWZ0ZXIgdGhlIGRpYWxvZyBoYXMgYmVlbiBjbG9zZWQuXG4gKiAgICAgQXJndW1lbnQgZm9yIHRoZSBmdW5jdGlvbiBpcyB0aGUgdmFsdWUgb2YgdGhlIGlucHV0IGZpZWxkIG9yIGBudWxsYCBpZiB0aGUgZGlhbG9nIHdhcyBjYW5jZWxlZC5cbiAqICAgWy9lbl1cbiAqICAgW2phXVxuICogICAgIOODgOOCpOOCouODreOCsOOBjOmWieOBmOOCieOCjOOBn+W+jOOBq+Wun+ihjOOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglxuICogICAgIOmWouaVsOOBruW8leaVsOOBqOOBl+OBpuOAgeOCpOODs+ODl+ODg+ODiOimgee0oOOBruS4reOBruWApOOBjOa4oeOBleOCjOOBvuOBmeOAguODgOOCpOOCouODreOCsOOBjOOCreODo+ODs+OCu+ODq+OBleOCjOOBn+WgtOWQiOOBq+OBr+OAgW51bGzjgYzmuKHjgZXjgozjgb7jgZnjgIJcbiAqICAgWy9qYV1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc3VibWl0T25FbnRlcl1cbiAqICAgW2VuXVN1Ym1pdCBhdXRvbWF0aWNhbGx5IHdoZW4gZW50ZXIgaXMgcHJlc3NlZC4gRGVmYXVsdCBpcyBgdHJ1ZWAuWy9lbl1cbiAqICAgW2phXUVudGVy44GM5oq844GV44KM44Gf6Zqb44Gr44Gd44GuZm9ybeOCknN1Ym1pdOOBmeOCi+OBi+OBqeOBhuOBi+OCkuaMh+WumuOBl+OBvuOBmeOAguODh+ODleOCqeODq+ODiOOBr3RydWXjgafjgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBEaXNwbGF5IGEgZGlhbG9nIHdpdGggYSBwcm9tcHQgdG8gYXNrIHRoZSB1c2VyIGEgcXVlc3Rpb24uXG4gKlxuICogICAgIEl0IGNhbiBiZSBjYWxsZWQgaW4gdGhlIGZvbGxvd2luZyB3YXlzOlxuICpcbiAqICAgICBgYGBcbiAqICAgICBvbnMubm90aWZpY2F0aW9uLnByb21wdChtZXNzYWdlLCBvcHRpb25zKTtcbiAqICAgICBvbnMubm90aWZpY2F0aW9uLnByb21wdChvcHRpb25zKTtcbiAqICAgICBgYGBcbiAqXG4gKiAgICAgTXVzdCBzcGVjaWZ5IGVpdGhlciBgbWVzc2FnZWAgb3IgYG1lc3NhZ2VIVE1MYC5cbiAqICAgWy9lbl1cbiAqICAgW2phXVxuICogICAgIOODpuODvOOCtuODvOOBq+WFpeWKm+OCkuS/g+OBmeODgOOCpOOCouODreOCsOOCkuihqOekuuOBl+OBvuOBmeOAglxuICogICAgIOOBk+OBruODoeOCveODg+ODieOBruW8leaVsOOBq+OBr+OAgW9wdGlvbnMubWVzc2FnZeOCguOBl+OBj+OBr29wdGlvbnMubWVzc2FnZUhUTUzjga7jganjgaHjgonjgYvjgpLlv4XjgZrmjIflrprjgZnjgovlv4XopoHjgYzjgYLjgorjgb7jgZnjgIJcbiAqICAgWy9qYV1cbiAqL1xubm90aWZpY2F0aW9uLnByb21wdCA9IG5vdGlmaWNhdGlvbi5fcHJvbXB0T3JpZ2luYWw7XG5cbmV4cG9ydCBkZWZhdWx0IG5vdGlmaWNhdGlvbjtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuL3BsYXRmb3JtJztcblxuY29uc3QgcGFnZUF0dHJpYnV0ZUV4cHJlc3Npb24gPSB7XG4gIF92YXJpYWJsZXM6IHt9LFxuXG4gIC8qKlxuICAgKiBEZWZpbmUgYSB2YXJpYWJsZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgdmFyaWFibGVcbiAgICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHZhbHVlIFZhbHVlIG9mIHRoZSB2YXJpYWJsZS4gQ2FuIGJlIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb24uIFRoZSBmdW5jdGlvbiBtdXN0IHJldHVybiBhIHN0cmluZy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBvdmVyd3JpdGUgSWYgdGhpcyB2YWx1ZSBpcyBmYWxzZSwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24gd2hlbiB0cnlpbmcgdG8gZGVmaW5lIGEgdmFyaWFibGUgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQuXG4gICAqL1xuICBkZWZpbmVWYXJpYWJsZTogZnVuY3Rpb24obmFtZSwgdmFsdWUsIG92ZXJ3cml0ZT1mYWxzZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVmFyaWFibGUgbmFtZSBtdXN0IGJlIGEgc3RyaW5nLicpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYXJpYWJsZSB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuX3ZhcmlhYmxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiAhb3ZlcndyaXRlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtuYW1lfVwiIGlzIGFscmVhZHkgZGVmaW5lZC5gKTtcbiAgICB9XG4gICAgdGhpcy5fdmFyaWFibGVzW25hbWVdID0gdmFsdWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBhIHZhcmlhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSB2YXJpYWJsZS5cbiAgICogQHJldHVybiB7U3RyaW5nfEZ1bmN0aW9ufG51bGx9XG4gICAqL1xuICBnZXRWYXJpYWJsZTogZnVuY3Rpb24obmFtZSkge1xuICAgIGlmICghdGhpcy5fdmFyaWFibGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fdmFyaWFibGVzW25hbWVdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSB2YXJpYWJsZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgdmFyYWlibGUuXG4gICAqL1xuICByZW1vdmVWYXJpYWJsZTogZnVuY3Rpb24obmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLl92YXJpYWJsZXNbbmFtZV07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBhbGwgdmFyaWFibGVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXRBbGxWYXJpYWJsZXM6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl92YXJpYWJsZXM7XG4gIH0sXG4gIF9wYXJzZVBhcnQ6IGZ1bmN0aW9uKHBhcnQpIHtcbiAgICBsZXQgYyxcbiAgICAgIGluSW50ZXJwb2xhdGlvbiA9IGZhbHNlLFxuICAgICAgY3VycmVudEluZGV4ID0gMDtcblxuICAgIGNvbnN0IHRva2VucyA9IFtdO1xuXG4gICAgaWYgKHBhcnQubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBwYXJzZSBlbXB0eSBzdHJpbmcuJyk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjID0gcGFydC5jaGFyQXQoaSk7XG5cbiAgICAgIGlmIChjID09PSAnJCcgJiYgcGFydC5jaGFyQXQoaSArIDEpID09PSAneycpIHtcbiAgICAgICAgaWYgKGluSW50ZXJwb2xhdGlvbikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTmVzdGVkIGludGVycG9sYXRpb24gbm90IHN1cHBvcnRlZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRva2VuID0gcGFydC5zdWJzdHJpbmcoY3VycmVudEluZGV4LCBpKTtcbiAgICAgICAgaWYgKHRva2VuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0b2tlbnMucHVzaChwYXJ0LnN1YnN0cmluZyhjdXJyZW50SW5kZXgsIGkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRJbmRleCA9IGk7XG4gICAgICAgIGluSW50ZXJwb2xhdGlvbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChjID09PSAnfScpIHtcbiAgICAgICAgaWYgKCFpbkludGVycG9sYXRpb24pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ30gbXVzdCBiZSBwcmVjZWVkZWQgYnkgJHsnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRva2VuID0gcGFydC5zdWJzdHJpbmcoY3VycmVudEluZGV4LCBpICsgMSk7XG4gICAgICAgIGlmICh0b2tlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2gocGFydC5zdWJzdHJpbmcoY3VycmVudEluZGV4LCBpICsgMSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudEluZGV4ID0gaSArIDE7XG4gICAgICAgIGluSW50ZXJwb2xhdGlvbiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpbkludGVycG9sYXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW50ZXJtaW5hdGVkIGludGVycG9sYXRpb24uJyk7XG4gICAgfVxuXG4gICAgdG9rZW5zLnB1c2gocGFydC5zdWJzdHJpbmcoY3VycmVudEluZGV4LCBwYXJ0Lmxlbmd0aCkpO1xuXG4gICAgcmV0dXJuIHRva2VucztcbiAgfSxcbiAgX3JlcGxhY2VUb2tlbjogZnVuY3Rpb24odG9rZW4pIHtcbiAgICBjb25zdCByZSA9IC9eXFwkeyguKj8pfSQvLFxuICAgICAgbWF0Y2ggPSB0b2tlbi5tYXRjaChyZSk7XG5cbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBtYXRjaFsxXS50cmltKCk7XG4gICAgICBjb25zdCB2YXJpYWJsZSA9IHRoaXMuZ2V0VmFyaWFibGUobmFtZSk7XG5cbiAgICAgIGlmICh2YXJpYWJsZSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZhcmlhYmxlIFwiJHtuYW1lfVwiIGRvZXMgbm90IGV4aXN0LmApO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZW9mIHZhcmlhYmxlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFyaWFibGU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgcnYgPSB2YXJpYWJsZSgpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgcnYgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHJldHVybiBhIHN0cmluZy4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBydjtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuICB9LFxuICBfcmVwbGFjZVRva2VuczogZnVuY3Rpb24odG9rZW5zKSB7XG4gICAgcmV0dXJuIHRva2Vucy5tYXAodGhpcy5fcmVwbGFjZVRva2VuLmJpbmQodGhpcykpO1xuICB9LFxuICBfcGFyc2VFeHByZXNzaW9uOiBmdW5jdGlvbihleHByZXNzaW9uKSB7XG4gICAgcmV0dXJuIGV4cHJlc3Npb24uc3BsaXQoJywnKVxuICAgICAgLm1hcChcbiAgICAgICAgZnVuY3Rpb24ocGFydCkge1xuICAgICAgICAgIHJldHVybiBwYXJ0LnRyaW0oKTtcbiAgICAgICAgfVxuICAgICAgKVxuICAgICAgLm1hcCh0aGlzLl9wYXJzZVBhcnQuYmluZCh0aGlzKSlcbiAgICAgIC5tYXAodGhpcy5fcmVwbGFjZVRva2Vucy5iaW5kKHRoaXMpKVxuICAgICAgLm1hcCgocGFydCkgPT4gcGFydC5qb2luKCcnKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV2YWx1YXRlIGFuIGV4cHJlc3Npb24uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBleHByZXNzaW9uIEFuIHBhZ2UgYXR0cmlidXRlIGV4cHJlc3Npb24uXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgZXZhbHVhdGU6IGZ1bmN0aW9uKGV4cHJlc3Npb24pIHtcbiAgICBpZiAoIWV4cHJlc3Npb24pIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcGFyc2VFeHByZXNzaW9uKGV4cHJlc3Npb24pO1xuICB9XG59O1xuXG4vLyBEZWZpbmUgZGVmYXVsdCB2YXJpYWJsZXMuXG5wYWdlQXR0cmlidXRlRXhwcmVzc2lvbi5kZWZpbmVWYXJpYWJsZSgnbW9iaWxlT1MnLCBwbGF0Zm9ybS5nZXRNb2JpbGVPUygpKTtcbnBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uLmRlZmluZVZhcmlhYmxlKCdpT1NEZXZpY2UnLCBwbGF0Zm9ybS5nZXRJT1NEZXZpY2UoKSk7XG5wYWdlQXR0cmlidXRlRXhwcmVzc2lvbi5kZWZpbmVWYXJpYWJsZSgncnVudGltZScsICgpID0+IHtcbiAgcmV0dXJuIHBsYXRmb3JtLmlzV2ViVmlldygpID8gJ2NvcmRvdmEnIDogJ2Jyb3dzZXInO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uL3BsYXRmb3JtJztcbmltcG9ydCBwYWdlQXR0cmlidXRlRXhwcmVzc2lvbiBmcm9tICcuLi9wYWdlLWF0dHJpYnV0ZS1leHByZXNzaW9uJztcblxuY29uc3QgaW50ZXJuYWwgPSB7fTtcblxuaW50ZXJuYWwuY29uZmlnID0ge1xuICBhdXRvU3RhdHVzQmFyRmlsbDogdHJ1ZSxcbiAgYW5pbWF0aW9uc0Rpc2FibGVkOiBmYWxzZVxufTtcblxuaW50ZXJuYWwubnVsbEVsZW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbi8qKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuaW50ZXJuYWwuaXNFbmFibGVkQXV0b1N0YXR1c0JhckZpbGwgPSAoKSA9PiB7XG4gIHJldHVybiAhIWludGVybmFsLmNvbmZpZy5hdXRvU3RhdHVzQmFyRmlsbDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IGh0bWxcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuaW50ZXJuYWwubm9ybWFsaXplUGFnZUhUTUwgPSBodG1sID0+IHtcbiAgaHRtbCA9ICgnJyArIGh0bWwpLnRyaW0oKTtcblxuICBpZiAoIWh0bWwubWF0Y2goL148b25zLXBhZ2UvKSkge1xuICAgIGh0bWwgPSAnPG9ucy1wYWdlIF9tdXRlZD4nICsgaHRtbCArICc8L29ucy1wYWdlPic7XG4gIH1cblxuICByZXR1cm4gaHRtbDtcbn07XG5cbmludGVybmFsLndhaXRET01Db250ZW50TG9hZGVkID0gY2FsbGJhY2sgPT4ge1xuICBpZiAod2luZG93LmRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJyB8fCB3aW5kb3cuZG9jdW1lbnQucmVhZHlTdGF0ZSA9PSAndW5pbml0aWFsaXplZCcpIHtcbiAgICB3aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGNhbGxiYWNrKTtcbiAgfSBlbHNlIHtcbiAgICBzZXRJbW1lZGlhdGUoY2FsbGJhY2spO1xuICB9XG59O1xuXG5pbnRlcm5hbC5hdXRvU3RhdHVzQmFyRmlsbCA9IGFjdGlvbiA9PiB7XG4gIGNvbnN0IG9uUmVhZHkgPSAoKSA9PiB7XG4gICAgaWYgKGludGVybmFsLnNob3VsZEZpbGxTdGF0dXNCYXIoKSkge1xuICAgICAgYWN0aW9uKCk7XG4gICAgfVxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RldmljZXJlYWR5Jywgb25SZWFkeSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIG9uUmVhZHkpO1xuICB9O1xuXG4gIGlmICh0eXBlb2YgZGV2aWNlID09PSAnb2JqZWN0Jykge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZXJlYWR5Jywgb25SZWFkeSk7XG4gIH0gZWxzZSBpZiAoWydjb21wbGV0ZScsICdpbnRlcmFjdGl2ZSddLmluZGV4T2YoZG9jdW1lbnQucmVhZHlTdGF0ZSkgPT09IC0xKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgb25SZWFkeSgpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9uUmVhZHkoKTtcbiAgfVxufTtcblxuaW50ZXJuYWwuc2hvdWxkRmlsbFN0YXR1c0JhciA9ICgpID0+IGludGVybmFsLmlzRW5hYmxlZEF1dG9TdGF0dXNCYXJGaWxsKCkgJiYgcGxhdGZvcm0uaXNXZWJWaWV3KCkgJiYgcGxhdGZvcm0uaXNJT1M3YWJvdmUoKTtcblxuaW50ZXJuYWwudGVtcGxhdGVTdG9yZSA9IHtcbiAgX3N0b3JhZ2U6IHt9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAqIEByZXR1cm4ge1N0cmluZy9udWxsfSB0ZW1wbGF0ZVxuICAgKi9cbiAgZ2V0KGtleSkge1xuICAgIHJldHVybiBpbnRlcm5hbC50ZW1wbGF0ZVN0b3JlLl9zdG9yYWdlW2tleV0gfHwgbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGVtcGxhdGVcbiAgICovXG4gIHNldChrZXksIHRlbXBsYXRlKSB7XG4gICAgaW50ZXJuYWwudGVtcGxhdGVTdG9yZS5fc3RvcmFnZVtrZXldID0gdGVtcGxhdGU7XG4gIH1cbn07XG5cbndpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdfdGVtcGxhdGVsb2FkZWQnLCBmdW5jdGlvbihlKSB7XG4gIGlmIChlLnRhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb25zLXRlbXBsYXRlJykge1xuICAgIGludGVybmFsLnRlbXBsYXRlU3RvcmUuc2V0KGUudGVtcGxhdGVJZCwgZS50ZW1wbGF0ZSk7XG4gIH1cbn0sIGZhbHNlKTtcblxud2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbigpIHtcbiAgcmVnaXN0ZXIoJ3NjcmlwdFt0eXBlPVwidGV4dC9vbnMtdGVtcGxhdGVcIl0nKTtcbiAgcmVnaXN0ZXIoJ3NjcmlwdFt0eXBlPVwidGV4dC90ZW1wbGF0ZVwiXScpO1xuICByZWdpc3Rlcignc2NyaXB0W3R5cGU9XCJ0ZXh0L25nLXRlbXBsYXRlXCJdJyk7XG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXIocXVlcnkpIHtcbiAgICBjb25zdCB0ZW1wbGF0ZXMgPSB3aW5kb3cuZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChxdWVyeSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZW1wbGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGludGVybmFsLnRlbXBsYXRlU3RvcmUuc2V0KHRlbXBsYXRlc1tpXS5nZXRBdHRyaWJ1dGUoJ2lkJyksIHRlbXBsYXRlc1tpXS50ZXh0Q29udGVudCk7XG4gICAgfVxuICB9XG59LCBmYWxzZSk7XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKi9cbmludGVybmFsLmdldFRlbXBsYXRlSFRNTEFzeW5jID0gZnVuY3Rpb24ocGFnZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICBjb25zdCBjYWNoZSA9IGludGVybmFsLnRlbXBsYXRlU3RvcmUuZ2V0KHBhZ2UpO1xuXG4gICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgY29uc3QgaHRtbCA9IHR5cGVvZiBjYWNoZSA9PT0gJ3N0cmluZycgPyBjYWNoZSA6IGNhY2hlWzFdO1xuICAgICAgICByZXNvbHZlKGh0bWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHhoci5vcGVuKCdHRVQnLCBwYWdlLCB0cnVlKTtcbiAgICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgY29uc3QgaHRtbCA9IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgaWYgKHhoci5zdGF0dXMgPj0gNDAwICYmIHhoci5zdGF0dXMgPCA2MDApIHtcbiAgICAgICAgICAgIHJlamVjdChodG1sKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKGh0bWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBwYWdlIGlzIG5vdCBmb3VuZDogJHtwYWdlfWApO1xuICAgICAgICB9O1xuICAgICAgICB4aHIuc2VuZChudWxsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICovXG5pbnRlcm5hbC5nZXRQYWdlSFRNTEFzeW5jID0gZnVuY3Rpb24ocGFnZSkge1xuICBjb25zdCBwYWdlcyA9IHBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uLmV2YWx1YXRlKHBhZ2UpO1xuXG4gIGNvbnN0IGdldFBhZ2UgPSAocGFnZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgcGFnZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnTXVzdCBzcGVjaWZ5IGEgcGFnZS4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZXJuYWwuZ2V0VGVtcGxhdGVIVE1MQXN5bmMocGFnZSlcbiAgICAgIC50aGVuKFxuICAgICAgICBmdW5jdGlvbihodG1sKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVybmFsLm5vcm1hbGl6ZVBhZ2VIVE1MKGh0bWwpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIGlmIChwYWdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGdldFBhZ2UocGFnZXMuc2hpZnQoKSk7XG4gICAgICAgIH1cbiAgICAgIClcbiAgICAgIC50aGVuKGh0bWwgPT4gaW50ZXJuYWwubm9ybWFsaXplUGFnZUhUTUwoaHRtbCkpO1xuICB9O1xuXG4gIHJldHVybiBnZXRQYWdlKHBhZ2VzLnNoaWZ0KCkpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgaW50ZXJuYWw7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi91dGlsJztcbmltcG9ydCBpbnRlcm5hbCBmcm9tICcuLi9pbnRlcm5hbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFuaW1hdG9yRmFjdG9yeSB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmFuaW1hdG9ycyBUaGUgZGljdGlvbmFyeSBmb3IgYW5pbWF0b3IgY2xhc3Nlc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRzLmJhc2VDbGFzcyBUaGUgYmFzZSBjbGFzcyBvZiBhbmltYXRvcnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRzLmJhc2VDbGFzc05hbWVdIFRoZSBuYW1lIG9mIHRoZSBiYXNlIGNsYXNzIG9mIGFuaW1hdG9yc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdHMuZGVmYXVsdEFuaW1hdGlvbl0gVGhlIGRlZmF1bHQgYW5pbWF0aW9uIG5hbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzLmRlZmF1bHRBbmltYXRpb25PcHRpb25zXSBUaGUgZGVmYXVsdCBhbmltYXRpb24gb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHRoaXMuX2FuaW1hdG9ycyA9IG9wdHMuYW5pbWF0b3JzO1xuICAgIHRoaXMuX2Jhc2VDbGFzcyA9IG9wdHMuYmFzZUNsYXNzO1xuICAgIHRoaXMuX2Jhc2VDbGFzc05hbWUgPSBvcHRzLmJhc2VDbGFzc05hbWUgfHwgb3B0cy5iYXNlQ2xhc3MubmFtZTtcbiAgICB0aGlzLl9hbmltYXRpb24gPSBvcHRzLmRlZmF1bHRBbmltYXRpb24gfHwgJ2RlZmF1bHQnO1xuICAgIHRoaXMuX2FuaW1hdGlvbk9wdGlvbnMgPSBvcHRzLmRlZmF1bHRBbmltYXRpb25PcHRpb25zIHx8IHt9O1xuXG4gICAgaWYgKCF0aGlzLl9hbmltYXRvcnNbdGhpcy5fYW5pbWF0aW9uXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzdWNoIGFuaW1hdGlvbjogJyArIHRoaXMuX2FuaW1hdGlvbik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBqc29uU3RyaW5nXG4gICAqIEByZXR1cm4ge09iamVjdC9udWxsfVxuICAgKi9cbiAgc3RhdGljIHBhcnNlQW5pbWF0aW9uT3B0aW9uc1N0cmluZyhqc29uU3RyaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YganNvblN0cmluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdXRpbC5hbmltYXRpb25PcHRpb25zUGFyc2UoanNvblN0cmluZyk7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0JyAmJiByZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1wiYW5pbWF0aW9uLW9wdGlvbnNcIiBhdHRyaWJ1dGUgbXVzdCBiZSBhIEpTT04gb2JqZWN0IHN0cmluZzogJyArIGpzb25TdHJpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcignXCJhbmltYXRpb24tb3B0aW9uc1wiIGF0dHJpYnV0ZSBtdXN0IGJlIGEgSlNPTiBvYmplY3Qgc3RyaW5nOiAnICsganNvblN0cmluZyk7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqL1xuICBzZXRBbmltYXRpb25PcHRpb25zKG9wdGlvbnMpIHtcbiAgICB0aGlzLl9hbmltYXRpb25PcHRpb25zID0gb3B0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXSBUaGUgYW5pbWF0aW9uIG5hbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdIFRoZSBhbmltYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdEFuaW1hdG9yIFRoZSBkZWZhdWx0IGFuaW1hdG9yIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge09iamVjdH0gQW4gYW5pbWF0b3IgaW5zdGFuY2VcbiAgICovXG4gIG5ld0FuaW1hdG9yKG9wdGlvbnMgPSB7fSwgZGVmYXVsdEFuaW1hdG9yKSB7XG5cbiAgICBsZXQgYW5pbWF0b3IgPSBudWxsO1xuXG4gICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uIGluc3RhbmNlb2YgdGhpcy5fYmFzZUNsYXNzKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5hbmltYXRpb247XG4gICAgfVxuXG4gICAgbGV0IEFuaW1hdG9yID0gbnVsbDtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5hbmltYXRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICBBbmltYXRvciA9IHRoaXMuX2FuaW1hdG9yc1tvcHRpb25zLmFuaW1hdGlvbl07XG4gICAgfVxuXG4gICAgaWYgKCFBbmltYXRvciAmJiBkZWZhdWx0QW5pbWF0b3IpIHtcbiAgICAgIGFuaW1hdG9yID0gZGVmYXVsdEFuaW1hdG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICBBbmltYXRvciA9IEFuaW1hdG9yIHx8IHRoaXMuX2FuaW1hdG9yc1t0aGlzLl9hbmltYXRpb25dO1xuXG4gICAgICBjb25zdCBhbmltYXRpb25PcHRzID0gdXRpbC5leHRlbmQoXG4gICAgICAgIHt9LFxuICAgICAgICB0aGlzLl9hbmltYXRpb25PcHRpb25zLFxuICAgICAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgfHwge30sXG4gICAgICAgIGludGVybmFsLmNvbmZpZy5hbmltYXRpb25zRGlzYWJsZWQgPyB7ZHVyYXRpb246IDAsIGRlbGF5OiAwfSA6IHt9XG4gICAgICApO1xuXG4gICAgICBhbmltYXRvciA9IG5ldyBBbmltYXRvcihhbmltYXRpb25PcHRzKTtcblxuICAgICAgaWYgKHR5cGVvZiBhbmltYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBhbmltYXRvciA9IG5ldyBhbmltYXRvcihhbmltYXRpb25PcHRzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEoYW5pbWF0b3IgaW5zdGFuY2VvZiB0aGlzLl9iYXNlQ2xhc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiYW5pbWF0b3JcIiBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgJyArIHRoaXMuX2Jhc2VDbGFzc05hbWUgKyAnLicpO1xuICAgIH1cblxuICAgIHJldHVybiBhbmltYXRvcjtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9kaWZpZXJVdGlsIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBsYXN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjdXJyZW50XG4gICAqL1xuICBzdGF0aWMgZGlmZihsYXN0LCBjdXJyZW50KSB7XG4gICAgbGFzdCA9IG1ha2VEaWN0KCgnJyArIGxhc3QpLnRyaW0oKSk7XG4gICAgY3VycmVudCA9IG1ha2VEaWN0KCgnJyArIGN1cnJlbnQpLnRyaW0oKSk7XG5cbiAgICBjb25zdCByZW1vdmVkID0gT2JqZWN0LmtleXMobGFzdCkucmVkdWNlKChyZXN1bHQsIHRva2VuKSA9PiB7XG4gICAgICBpZiAoIWN1cnJlbnRbdG9rZW5dKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRva2VuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgYWRkZWQgPSBPYmplY3Qua2V5cyhjdXJyZW50KS5yZWR1Y2UoKHJlc3VsdCwgdG9rZW4pID0+IHtcbiAgICAgIGlmICghbGFzdFt0b2tlbl0pIHtcbiAgICAgICAgcmVzdWx0LnB1c2godG9rZW4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4ge2FkZGVkLCByZW1vdmVkfTtcblxuICAgIGZ1bmN0aW9uIG1ha2VEaWN0KG1vZGlmaWVyKSB7XG4gICAgICBjb25zdCBkaWN0ID0ge307XG4gICAgICBNb2RpZmllclV0aWwuc3BsaXQobW9kaWZpZXIpLmZvckVhY2godG9rZW4gPT4gZGljdFt0b2tlbl0gPSB0b2tlbik7XG4gICAgICByZXR1cm4gZGljdDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpZmZcbiAgICogQHBhcmFtIHtPYmplY3R9IGNsYXNzTGlzdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGVtcGxhdGVcbiAgICovXG4gIHN0YXRpYyBhcHBseURpZmZUb0NsYXNzTGlzdChkaWZmLCBjbGFzc0xpc3QsIHRlbXBsYXRlKSB7XG4gICAgZGlmZi5hZGRlZFxuICAgICAgLm1hcChtb2RpZmllciA9PiB0ZW1wbGF0ZS5yZXBsYWNlKC9cXCovZywgbW9kaWZpZXIpKVxuICAgICAgLmZvckVhY2goa2xhc3MgPT4gY2xhc3NMaXN0LmFkZChrbGFzcykpO1xuXG4gICAgZGlmZi5yZW1vdmVkXG4gICAgICAubWFwKG1vZGlmaWVyID0+IHRlbXBsYXRlLnJlcGxhY2UoL1xcKi9nLCBtb2RpZmllcikpXG4gICAgICAuZm9yRWFjaChrbGFzcyA9PiBjbGFzc0xpc3QucmVtb3ZlKGtsYXNzKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpZmZcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gc2NoZW1lXG4gICAqL1xuICBzdGF0aWMgYXBwbHlEaWZmVG9FbGVtZW50KGRpZmYsIGVsZW1lbnQsIHNjaGVtZSkge1xuICAgIGNvbnN0IG1hdGNoZXMgPSAoZSwgcykgPT4gKGUubWF0Y2hlcyB8fCBlLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBlLm1vek1hdGNoZXNTZWxlY3RvciB8fCBlLm1zTWF0Y2hlc1NlbGVjdG9yKS5jYWxsKGUsIHMpO1xuICAgIGZvciAoY29uc3Qgc2VsZWN0b3IgaW4gc2NoZW1lKSB7XG4gICAgICBpZiAoc2NoZW1lLmhhc093blByb3BlcnR5KHNlbGVjdG9yKSkge1xuICAgICAgICBjb25zdCB0YXJnZXRFbGVtZW50cyA9ICFzZWxlY3RvciB8fCBtYXRjaGVzKGVsZW1lbnQsIHNlbGVjdG9yKSA/IFtlbGVtZW50XSA6IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFyZ2V0RWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBNb2RpZmllclV0aWwuYXBwbHlEaWZmVG9DbGFzc0xpc3QoZGlmZiwgdGFyZ2V0RWxlbWVudHNbaV0uY2xhc3NMaXN0LCBzY2hlbWVbc2VsZWN0b3JdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbGFzdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gY3VycmVudFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzY2hlbWVcbiAgICovXG4gIHN0YXRpYyBvbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCBlbGVtZW50LCBzY2hlbWUpIHtcbiAgICByZXR1cm4gTW9kaWZpZXJVdGlsLmFwcGx5RGlmZlRvRWxlbWVudChNb2RpZmllclV0aWwuZGlmZihsYXN0LCBjdXJyZW50KSwgZWxlbWVudCwgc2NoZW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzY2hlbWVcbiAgICovXG4gIHN0YXRpYyBpbml0TW9kaWZpZXIoZWxlbWVudCwgc2NoZW1lKSB7XG4gICAgY29uc3QgbW9kaWZpZXIgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKTtcbiAgICBpZiAodHlwZW9mIG1vZGlmaWVyICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIE1vZGlmaWVyVXRpbC5hcHBseURpZmZUb0VsZW1lbnQoe1xuICAgICAgcmVtb3ZlZDogW10sXG4gICAgICBhZGRlZDogTW9kaWZpZXJVdGlsLnNwbGl0KG1vZGlmaWVyKVxuICAgIH0sIGVsZW1lbnQsIHNjaGVtZSk7XG4gIH1cblxuICBzdGF0aWMgc3BsaXQobW9kaWZpZXIpIHtcbiAgICBpZiAodHlwZW9mIG1vZGlmaWVyICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHJldHVybiBtb2RpZmllci50cmltKCkuc3BsaXQoLyArLykuZmlsdGVyKHRva2VuID0+IHRva2VuICE9PSAnJyk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uL3BsYXRmb3JtJztcblxuZXhwb3J0IGNsYXNzIExhenlSZXBlYXREZWxlZ2F0ZSB7XG5cbiAgY29uc3RydWN0b3IodXNlckRlbGVnYXRlLCB0ZW1wbGF0ZUVsZW1lbnQgPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiB1c2VyRGVsZWdhdGUgIT09ICdvYmplY3QnIHx8IHVzZXJEZWxlZ2F0ZSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgRXJyb3IoJ1wiZGVsZWdhdGVcIiBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgfVxuICAgIHRoaXMuX3VzZXJEZWxlZ2F0ZSA9IHVzZXJEZWxlZ2F0ZTtcblxuICAgIGlmICghKHRlbXBsYXRlRWxlbWVudCBpbnN0YW5jZW9mIEVsZW1lbnQpICYmIHRlbXBsYXRlRWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgdGhyb3cgRXJyb3IoJ1widGVtcGxhdGVFbGVtZW50XCIgcGFyYW1ldGVyIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgRWxlbWVudCBvciBudWxsLicpO1xuICAgIH1cbiAgICB0aGlzLl90ZW1wbGF0ZUVsZW1lbnQgPSB0ZW1wbGF0ZUVsZW1lbnQ7XG4gIH1cblxuICBnZXQgaXRlbUhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlckRlbGVnYXRlLml0ZW1IZWlnaHQ7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGhhc1JlbmRlckZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl91c2VyRGVsZWdhdGUuX3JlbmRlciBpbnN0YW5jZW9mIEZ1bmN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBfcmVuZGVyKGl0ZW1zLCBoZWlnaHQpIHtcbiAgICB0aGlzLl91c2VyRGVsZWdhdGUuX3JlbmRlcihpdGVtcywgaGVpZ2h0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtFbGVtZW50fSBwYXJlbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZSBBIGZ1bmN0aW9uIHRoYXQgdGFrZSBpdGVtIG9iamVjdCBhcyBwYXJhbWV0ZXIuXG4gICAqL1xuICBsb2FkSXRlbUVsZW1lbnQoaW5kZXgsIHBhcmVudCwgZG9uZSkge1xuICAgIGlmICh0aGlzLl91c2VyRGVsZWdhdGUubG9hZEl0ZW1FbGVtZW50IGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIHRoaXMuX3VzZXJEZWxlZ2F0ZS5sb2FkSXRlbUVsZW1lbnQoaW5kZXgsIHBhcmVudCwgZWxlbWVudCA9PiBkb25lKHtlbGVtZW50fSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fdXNlckRlbGVnYXRlLmNyZWF0ZUl0ZW1Db250ZW50KGluZGV4LCB0aGlzLl90ZW1wbGF0ZUVsZW1lbnQpO1xuICAgICAgaWYgKCEoZWxlbWVudCBpbnN0YW5jZW9mIEVsZW1lbnQpKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdjcmVhdGVJdGVtQ29udGVudCgpIG11c3QgcmV0dXJuIGFuIGluc3RhbmNlIG9mIEVsZW1lbnQuJyk7XG4gICAgICB9XG4gICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICBkb25lKHtlbGVtZW50fSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIGNvdW50SXRlbXMoKSB7XG4gICAgY29uc3QgY291bnQgPSB0aGlzLl91c2VyRGVsZWdhdGUuY291bnRJdGVtcygpO1xuICAgIGlmICh0eXBlb2YgY291bnQgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBFcnJvcignY291bnRJdGVtcygpIG11c3QgcmV0dXJuIGEgbnVtYmVyLicpO1xuICAgIH1cbiAgICByZXR1cm4gY291bnQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gaXRlbS5lbGVtZW50XG4gICAqL1xuICB1cGRhdGVJdGVtKGluZGV4LCBpdGVtKSB7XG4gICAgaWYgKHRoaXMuX3VzZXJEZWxlZ2F0ZS51cGRhdGVJdGVtQ29udGVudCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICB0aGlzLl91c2VyRGVsZWdhdGUudXBkYXRlSXRlbUNvbnRlbnQoaW5kZXgsIGl0ZW0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBjYWxjdWxhdGVJdGVtSGVpZ2h0KGluZGV4KSB7XG4gICAgaWYgKHRoaXMuX3VzZXJEZWxlZ2F0ZS5jYWxjdWxhdGVJdGVtSGVpZ2h0IGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuX3VzZXJEZWxlZ2F0ZS5jYWxjdWxhdGVJdGVtSGVpZ2h0KGluZGV4KTtcblxuICAgICAgaWYgKHR5cGVvZiBoZWlnaHQgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdjYWxjdWxhdGVJdGVtSGVpZ2h0KCkgbXVzdCByZXR1cm4gYSBudW1iZXIuJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoZWlnaHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG4gICAqL1xuICBkZXN0cm95SXRlbShpbmRleCwgaXRlbSkge1xuICAgIGlmICh0aGlzLl91c2VyRGVsZWdhdGUuZGVzdHJveUl0ZW0gaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgdGhpcy5fdXNlckRlbGVnYXRlLmRlc3Ryb3lJdGVtKGluZGV4LCBpdGVtKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuX3VzZXJEZWxlZ2F0ZS5kZXN0cm95IGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIHRoaXMuX3VzZXJEZWxlZ2F0ZS5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgdGhpcy5fdXNlckRlbGVnYXRlID0gdGhpcy5fdGVtcGxhdGVFbGVtZW50ID0gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgY2xhc3MgcHJvdmlkZSBjb3JlIGZ1bmN0aW9ucyBmb3Igb25zLWxhenktcmVwZWF0LlxuICovXG5leHBvcnQgY2xhc3MgTGF6eVJlcGVhdFByb3ZpZGVyIHtcblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSB3cmFwcGVyRWxlbWVudFxuICAgKiBAcGFyYW0ge0xhenlSZXBlYXREZWxlZ2F0ZX0gZGVsZWdhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKHdyYXBwZXJFbGVtZW50LCBkZWxlZ2F0ZSkge1xuICAgIGlmICghKGRlbGVnYXRlIGluc3RhbmNlb2YgTGF6eVJlcGVhdERlbGVnYXRlKSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ1wiZGVsZWdhdGVcIiBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBMYXp5UmVwZWF0RGVsZWdhdGUuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fd3JhcHBlckVsZW1lbnQgPSB3cmFwcGVyRWxlbWVudDtcbiAgICB0aGlzLl9kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuXG4gICAgaWYgKHdyYXBwZXJFbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29ucy1saXN0Jykge1xuICAgICAgd3JhcHBlckVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnbGF6eS1saXN0Jyk7XG4gICAgfVxuXG4gICAgdGhpcy5fcGFnZUNvbnRlbnQgPSB1dGlsLmZpbmRQYXJlbnQod3JhcHBlckVsZW1lbnQsICcucGFnZV9fY29udGVudCcpO1xuXG4gICAgaWYgKCF0aGlzLl9wYWdlQ29udGVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvbnMtbGF6eS1yZXBlYXQgbXVzdCBiZSBhIGRlc2NlbmRhbnQgb2YgYW4gPG9ucy1wYWdlPiBvciBhbiBlbGVtZW50LicpO1xuICAgIH1cblxuICAgIHRoaXMuX3RvcFBvc2l0aW9ucyA9IFtdO1xuICAgIHRoaXMuX3JlbmRlcmVkSXRlbXMgPSB7fTtcblxuICAgIGlmICghdGhpcy5fZGVsZWdhdGUuaXRlbUhlaWdodCAmJiAhdGhpcy5fZGVsZWdhdGUuY2FsY3VsYXRlSXRlbUhlaWdodCgwKSkge1xuICAgICAgdGhpcy5fdW5rbm93bkl0ZW1IZWlnaHQgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xuICAgIHRoaXMuX29uQ2hhbmdlKCk7XG4gIH1cblxuICBfY2hlY2tJdGVtSGVpZ2h0KGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fZGVsZWdhdGUubG9hZEl0ZW1FbGVtZW50KDAsIHRoaXMuX3dyYXBwZXJFbGVtZW50LCBpdGVtID0+IHtcbiAgICAgIGlmICghdGhpcy5fdW5rbm93bkl0ZW1IZWlnaHQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgc3RhdGUnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZG9uZSA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQucmVtb3ZlQ2hpbGQoaXRlbS5lbGVtZW50KTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3Vua25vd25JdGVtSGVpZ2h0O1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5faXRlbUhlaWdodCA9IGl0ZW0uZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgIGlmICh0aGlzLl9pdGVtSGVpZ2h0ID4gMCkge1xuICAgICAgICBkb25lKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gcmV0cnkgdG8gbWVhc3VyZSBvZmZzZXQgaGVpZ2h0XG4gICAgICAvLyBkaXJ0eSBmaXggZm9yIGFuZ3VsYXIyIGRpcmVjdGl2ZVxuICAgICAgY29uc3QgbGFzdFZpc2liaWxpdHkgPSB0aGlzLl93cmFwcGVyRWxlbWVudC5zdHlsZS52aXNpYmlsaXR5O1xuICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgaXRlbS5lbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcblxuICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgdGhpcy5faXRlbUhlaWdodCA9IGl0ZW0uZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIGlmICh0aGlzLl9pdGVtSGVpZ2h0ID09IDApIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBzdGF0ZTogdGhpcy5faXRlbUhlaWdodCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB6ZXJvLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSBsYXN0VmlzaWJpbGl0eTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBnZXQgc3RhdGljSXRlbUhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGUuaXRlbUhlaWdodCB8fCB0aGlzLl9pdGVtSGVpZ2h0O1xuICB9XG5cbiAgX2NvdW50SXRlbXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLmNvdW50SXRlbXMoKTtcbiAgfVxuXG4gIF9nZXRJdGVtSGVpZ2h0KGkpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0aWNJdGVtSGVpZ2h0IHx8IHRoaXMuX2RlbGVnYXRlLmNhbGN1bGF0ZUl0ZW1IZWlnaHQoaSk7XG4gIH1cblxuICBfb25DaGFuZ2UoKSB7XG4gICAgdGhpcy5fcmVuZGVyKCk7XG4gIH1cblxuICByZWZyZXNoKCkge1xuICAgIHRoaXMuX3JlbW92ZUFsbEVsZW1lbnRzKCk7XG4gICAgdGhpcy5fb25DaGFuZ2UoKTtcbiAgfVxuXG4gIF9yZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuX3Vua25vd25JdGVtSGVpZ2h0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2hlY2tJdGVtSGVpZ2h0KHRoaXMuX3JlbmRlci5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2dldEl0ZW1zSW5WaWV3KCk7XG5cbiAgICBpZiAodGhpcy5fZGVsZWdhdGUuaGFzUmVuZGVyRnVuY3Rpb24gJiYgdGhpcy5fZGVsZWdhdGUuaGFzUmVuZGVyRnVuY3Rpb24oKSkge1xuICAgICAgdGhpcy5fZGVsZWdhdGUuX3JlbmRlcihpdGVtcywgdGhpcy5fbGlzdEhlaWdodCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBrZWVwID0ge307XG5cbiAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgdGhpcy5fcmVuZGVyRWxlbWVudChpdGVtKTtcbiAgICAgIGtlZXBbaXRlbS5pbmRleF0gPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgT2JqZWN0LmtleXModGhpcy5fcmVuZGVyZWRJdGVtcykuZm9yRWFjaChrZXkgPT4ga2VlcFtrZXldIHx8IHRoaXMuX3JlbW92ZUVsZW1lbnQoa2V5KSk7XG5cbiAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5zdHlsZS5oZWlnaHQgPSB0aGlzLl9saXN0SGVpZ2h0ICsgJ3B4JztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuICAgKiBAcGFyYW0ge051bWJlcn0gaXRlbS5pbmRleFxuICAgKiBAcGFyYW0ge051bWJlcn0gaXRlbS50b3BcbiAgICovXG4gIF9yZW5kZXJFbGVtZW50KHtpbmRleCwgdG9wfSkge1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9yZW5kZXJlZEl0ZW1zW2luZGV4XTtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgdGhpcy5fZGVsZWdhdGUudXBkYXRlSXRlbShpbmRleCwgaXRlbSk7IC8vIHVwZGF0ZSBpZiBpdCBleGlzdHNcbiAgICAgIGl0ZW0uZWxlbWVudC5zdHlsZS50b3AgPSB0b3AgKyAncHgnO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2RlbGVnYXRlLmxvYWRJdGVtRWxlbWVudChpbmRleCwgdGhpcy5fd3JhcHBlckVsZW1lbnQsIGl0ZW0gPT4ge1xuICAgICAgdXRpbC5leHRlbmQoaXRlbS5lbGVtZW50LnN0eWxlLCB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICB0b3A6IHRvcCArICdweCcsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHJpZ2h0OiAwXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fcmVuZGVyZWRJdGVtc1tpbmRleF0gPSBpdGVtO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKi9cbiAgX3JlbW92ZUVsZW1lbnQoaW5kZXgpIHtcbiAgICBjb25zdCBpdGVtID0gdGhpcy5fcmVuZGVyZWRJdGVtc1tpbmRleF07XG5cbiAgICB0aGlzLl9kZWxlZ2F0ZS5kZXN0cm95SXRlbShpbmRleCwgaXRlbSk7XG5cbiAgICBpZiAoaXRlbS5lbGVtZW50LnBhcmVudEVsZW1lbnQpIHtcbiAgICAgIGl0ZW0uZWxlbWVudC5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGl0ZW0uZWxlbWVudCk7XG4gICAgfVxuXG4gICAgZGVsZXRlIHRoaXMuX3JlbmRlcmVkSXRlbXNbaW5kZXhdO1xuICB9XG5cbiAgX3JlbW92ZUFsbEVsZW1lbnRzKCkge1xuICAgIE9iamVjdC5rZXlzKHRoaXMuX3JlbmRlcmVkSXRlbXMpLmZvckVhY2goa2V5ID0+IHRoaXMuX3JlbW92ZUVsZW1lbnQoa2V5KSk7XG4gIH1cblxuICBfY2FsY3VsYXRlU3RhcnRJbmRleChjdXJyZW50KSB7XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBsZXQgZW5kID0gdGhpcy5faXRlbUNvdW50IC0gMTtcblxuICAgIGlmICh0aGlzLnN0YXRpY0l0ZW1IZWlnaHQpIHtcbiAgICAgIHJldHVybiBwYXJzZUludCgtY3VycmVudCAvIHRoaXMuc3RhdGljSXRlbUhlaWdodCk7XG4gICAgfVxuXG4gICAgLy8gQmluYXJ5IHNlYXJjaCBmb3IgaW5kZXggYXQgdG9wIG9mIHNjcmVlbiBzbyB3ZSBjYW4gc3BlZWQgdXAgcmVuZGVyaW5nLlxuICAgIGZvciAoOzspIHtcbiAgICAgIGNvbnN0IG1pZGRsZSA9IE1hdGguZmxvb3IoKHN0YXJ0ICsgZW5kKSAvIDIpO1xuICAgICAgY29uc3QgdmFsdWUgPSBjdXJyZW50ICsgdGhpcy5fdG9wUG9zaXRpb25zW21pZGRsZV07XG5cbiAgICAgIGlmIChlbmQgPCBzdGFydCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPD0gMCAmJiB2YWx1ZSArIHRoaXMuX2dldEl0ZW1IZWlnaHQobWlkZGxlKSA+IDApIHtcbiAgICAgICAgcmV0dXJuIG1pZGRsZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID49IDApIHtcbiAgICAgICAgZW5kID0gbWlkZGxlIC0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0ID0gbWlkZGxlICsgMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfcmVjYWxjdWxhdGVUb3BQb3NpdGlvbnMoKSB7XG4gICAgY29uc3QgbCA9IE1hdGgubWluKHRoaXMuX3RvcFBvc2l0aW9ucy5sZW5ndGgsIHRoaXMuX2l0ZW1Db3VudCk7XG4gICAgdGhpcy5fdG9wUG9zaXRpb25zWzBdID0gMDtcbiAgICBmb3IgKGxldCBpID0gMSwgbDsgaSA8IGw7IGkrKykge1xuICAgICAgdGhpcy5fdG9wUG9zaXRpb25zW2ldID0gdGhpcy5fdG9wUG9zaXRpb25zW2kgLSAxXSArIHRoaXMuX2dldEl0ZW1IZWlnaHQoaSk7XG4gICAgfVxuICB9XG5cbiAgX2dldEl0ZW1zSW5WaWV3KCkge1xuICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX3dyYXBwZXJFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbiAgICBjb25zdCBsaW1pdCA9IDQgKiB3aW5kb3cuaW5uZXJIZWlnaHQgLSBvZmZzZXQ7XG4gICAgY29uc3QgY291bnQgPSB0aGlzLl9jb3VudEl0ZW1zKCk7XG5cbiAgICBpZiAoY291bnQgIT09IHRoaXMuX2l0ZW1Db3VudCl7XG4gICAgICB0aGlzLl9pdGVtQ291bnQgPSBjb3VudDtcbiAgICAgIHRoaXMuX3JlY2FsY3VsYXRlVG9wUG9zaXRpb25zKCk7XG4gICAgfVxuXG4gICAgbGV0IGkgPSBNYXRoLm1heCgwLCB0aGlzLl9jYWxjdWxhdGVTdGFydEluZGV4KG9mZnNldCkgLSAzMCk7XG5cbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGZvciAodmFyIHRvcCA9IHRoaXMuX3RvcFBvc2l0aW9uc1tpXTsgaSA8IGNvdW50ICYmIHRvcCA8IGxpbWl0OyBpKyspIHtcbiAgICAgIGlmIChpID49IHRoaXMuX3RvcFBvc2l0aW9ucy5sZW5ndGgpIHsgLy8gcGVyZiBvcHRpbWl6YXRpb25cbiAgICAgICAgdGhpcy5fdG9wUG9zaXRpb25zLmxlbmd0aCArPSAxMDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3RvcFBvc2l0aW9uc1tpXSA9IHRvcDtcbiAgICAgIGl0ZW1zLnB1c2goe3RvcCwgaW5kZXg6IGl9KTtcbiAgICAgIHRvcCArPSB0aGlzLl9nZXRJdGVtSGVpZ2h0KGkpO1xuICAgIH1cbiAgICB0aGlzLl9saXN0SGVpZ2h0ID0gdG9wO1xuXG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG5cbiAgX2RlYm91bmNlKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICAgIGxldCB0aW1lb3V0O1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGNhbGxOb3cgPSBpbW1lZGlhdGUgJiYgIXRpbWVvdXQ7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICBpZiAoY2FsbE5vdykge1xuICAgICAgICBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LCB3YWl0KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgX2RvdWJsZUZpcmVPblRvdWNoZW5kKCkge1xuICAgIHRoaXMuX3JlbmRlcigpO1xuICAgIHRoaXMuX2RlYm91bmNlKHRoaXMuX3JlbmRlci5iaW5kKHRoaXMpLCAxMDApO1xuICB9XG5cbiAgX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHV0aWwuYmluZExpc3RlbmVycyh0aGlzLCBbJ19vbkNoYW5nZScsICdfZG91YmxlRmlyZU9uVG91Y2hlbmQnXSk7XG5cbiAgICBpZiAocGxhdGZvcm0uaXNJT1MoKSkge1xuICAgICAgdGhpcy5fYm91bmRPbkNoYW5nZSA9IHRoaXMuX2RlYm91bmNlKHRoaXMuX2JvdW5kT25DaGFuZ2UsIDMwKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wYWdlQ29udGVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCB0cnVlKTtcblxuICAgIGlmIChwbGF0Zm9ybS5pc0lPUygpKSB7XG4gICAgICB0aGlzLl9wYWdlQ29udGVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCB0cnVlKTtcbiAgICAgIHRoaXMuX3BhZ2VDb250ZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fYm91bmREb3VibGVGaXJlT25Ub3VjaGVuZCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgd2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX2JvdW5kT25DaGFuZ2UsIHRydWUpO1xuICB9XG5cbiAgX3JlbW92ZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuX3BhZ2VDb250ZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX2JvdW5kT25DaGFuZ2UsIHRydWUpO1xuXG4gICAgaWYgKHBsYXRmb3JtLmlzSU9TKCkpIHtcbiAgICAgIHRoaXMuX3BhZ2VDb250ZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX2JvdW5kT25DaGFuZ2UsIHRydWUpO1xuICAgICAgdGhpcy5fcGFnZUNvbnRlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9ib3VuZERvdWJsZUZpcmVPblRvdWNoZW5kLCB0cnVlKTtcbiAgICB9XG5cbiAgICB3aW5kb3cuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fYm91bmRPbkNoYW5nZSwgdHJ1ZSk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX3JlbW92ZUFsbEVsZW1lbnRzKCk7XG4gICAgdGhpcy5fZGVsZWdhdGUuZGVzdHJveSgpO1xuICAgIHRoaXMuX3BhcmVudEVsZW1lbnQgPSB0aGlzLl9kZWxlZ2F0ZSA9IHRoaXMuX3JlbmRlcmVkSXRlbXMgPSBudWxsO1xuICAgIHRoaXMuX3JlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cbn1cblxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cbmltcG9ydCBpbnRlcm5hbCBmcm9tICcuL2ludGVybmFsJztcbmltcG9ydCBBbmltYXRvckZhY3RvcnkgZnJvbSAnLi9hbmltYXRvci1mYWN0b3J5JztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi9tb2RpZmllci11dGlsJztcbmltcG9ydCB7TGF6eVJlcGVhdFByb3ZpZGVyLCBMYXp5UmVwZWF0RGVsZWdhdGV9IGZyb20gJy4vbGF6eS1yZXBlYXQnO1xuXG5pbnRlcm5hbC5BbmltYXRvckZhY3RvcnkgPSBBbmltYXRvckZhY3Rvcnk7XG5pbnRlcm5hbC5Nb2RpZmllclV0aWwgPSBNb2RpZmllclV0aWw7XG5pbnRlcm5hbC5MYXp5UmVwZWF0UHJvdmlkZXIgPSBMYXp5UmVwZWF0UHJvdmlkZXI7XG5pbnRlcm5hbC5MYXp5UmVwZWF0RGVsZWdhdGUgPSBMYXp5UmVwZWF0RGVsZWdhdGU7XG5cbmV4cG9ydCBkZWZhdWx0IGludGVybmFsO1xuXG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5jb25zdCBjcmVhdGUgPSAoKSA9PiB7XG5cbiAgLyoqXG4gICAqIEBvYmplY3Qgb25zLm9yaWVudGF0aW9uXG4gICAqIEBjYXRlZ29yeSB1dGlsXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1VdGlsaXR5IG1ldGhvZHMgZm9yIG9yaWVudGF0aW9uIGRldGVjdGlvbi5bL2VuXVxuICAgKiAgIFtqYV3nlLvpnaLjga7jgqrjg6rjgqjjg7Pjg4bjg7zjgrfjg6fjg7PmpJznn6Xjga7jgZ/jgoHjga7jg6bjg7zjg4bjgqPjg6rjg4bjgqPjg6Hjgr3jg4Pjg4njgpLlj47jgoHjgabjgYTjgovjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgKi9cbiAgY29uc3Qgb2JqID0ge1xuICAgIC8qKlxuICAgICAqIEBldmVudCBjaGFuZ2VcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiAgIFtlbl1GaXJlZCB3aGVuIHRoZSBkZXZpY2Ugb3JpZW50YXRpb24gY2hhbmdlcy5bL2VuXVxuICAgICAqICAgW2phXeODh+ODkOOCpOOCueOBruOCquODquOCqOODs+ODhuODvOOCt+ODp+ODs+OBjOWkieWMluOBl+OBn+mam+OBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LmlzUG9ydHJhaXRcbiAgICAgKiAgIFtlbl1XaWxsIGJlIHRydWUgaWYgdGhlIGN1cnJlbnQgb3JpZW50YXRpb24gaXMgcG9ydHJhaXQgbW9kZS5bL2VuXVxuICAgICAqICAgW2phXeePvuWcqOOBruOCquODquOCqOODs+ODhuODvOOCt+ODp+ODs+OBjHBvcnRyYWl044Gu5aC05ZCI44GrdHJ1ZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIG9uXG4gICAgICogQHNpZ25hdHVyZSBvbihldmVudE5hbWUsIGxpc3RlbmVyKVxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqICAgW2VuXUFkZCBhbiBldmVudCBsaXN0ZW5lci5bL2VuXVxuICAgICAqICAgW2phXeOCpOODmeODs+ODiOODquOCueODiuODvOOCkui/veWKoOOBl+OBvuOBmeOAglsvamFdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxuICAgICAqICAgW2VuXU5hbWUgb2YgdGhlIGV2ZW50LlsvZW5dXG4gICAgICogICBbamFd44Kk44OZ44Oz44OI5ZCN44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICAgICAqICAgW2VuXUZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkLlsvZW5dXG4gICAgICogICBbamFd44GT44Gu44Kk44OZ44Oz44OI44GM55m654Gr44GV44KM44Gf6Zqb44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtZXRob2Qgb25jZVxuICAgICAqIEBzaWduYXR1cmUgb25jZShldmVudE5hbWUsIGxpc3RlbmVyKVxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqICBbZW5dQWRkIGFuIGV2ZW50IGxpc3RlbmVyIHRoYXQncyBvbmx5IHRyaWdnZXJlZCBvbmNlLlsvZW5dXG4gICAgICogIFtqYV3kuIDluqbjgaDjgZHlkbzjgbPlh7rjgZXjgozjgovjgqTjg5njg7Pjg4jjg6rjgrnjg4rjg7zjgpLov73liqDjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWVcbiAgICAgKiAgIFtlbl1OYW1lIG9mIHRoZSBldmVudC5bL2VuXVxuICAgICAqICAgW2phXeOCpOODmeODs+ODiOWQjeOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAgICAgKiAgIFtlbl1GdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gdGhlIGV2ZW50IGlzIHRyaWdnZXJlZC5bL2VuXVxuICAgICAqICAgW2phXeOCpOODmeODs+ODiOOBjOeZuueBq+OBl+OBn+mam+OBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIG9mZlxuICAgICAqIEBzaWduYXR1cmUgb2ZmKGV2ZW50TmFtZSwgW2xpc3RlbmVyXSlcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiAgW2VuXVJlbW92ZSBhbiBldmVudCBsaXN0ZW5lci4gSWYgdGhlIGxpc3RlbmVyIGlzIG5vdCBzcGVjaWZpZWQgYWxsIGxpc3RlbmVycyBmb3IgdGhlIGV2ZW50IHR5cGUgd2lsbCBiZSByZW1vdmVkLlsvZW5dXG4gICAgICogIFtqYV3jgqTjg5njg7Pjg4jjg6rjgrnjg4rjg7zjgpLliYrpmaTjgZfjgb7jgZnjgILjgoLjgZfjgqTjg5njg7Pjg4jjg6rjgrnjg4rjg7zjgpLmjIflrprjgZfjgarjgYvjgaPjgZ/loLTlkIjjgavjga/jgIHjgZ3jga7jgqTjg5njg7Pjg4jjgavntJDjgaXjgY/lhajjgabjga7jgqTjg5njg7Pjg4jjg6rjgrnjg4rjg7zjgYzliYrpmaTjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWVcbiAgICAgKiAgIFtlbl1OYW1lIG9mIHRoZSBldmVudC5bL2VuXVxuICAgICAqICAgW2phXeOCpOODmeODs+ODiOWQjeOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAgICAgKiAgIFtlbl1GdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gdGhlIGV2ZW50IGlzIHRyaWdnZXJlZC5bL2VuXVxuICAgICAqICAgW2phXeWJiumZpOOBmeOCi+OCpOODmeODs+ODiOODquOCueODiuODvOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICovXG5cbiAgICAvLyBhY3R1YWwgaW1wbGVtZW50YXRpb24gdG8gZGV0ZWN0IGlmIHdoZXRoZXIgY3VycmVudCBzY3JlZW4gaXMgcG9ydHJhaXQgb3Igbm90XG4gICAgX2lzUG9ydHJhaXQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBpc1BvcnRyYWl0XG4gICAgICogQHNpZ25hdHVyZSBpc1BvcnRyYWl0KClcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqICAgW2VuXVdpbGwgYmUgdHJ1ZSBpZiB0aGUgY3VycmVudCBvcmllbnRhdGlvbiBpcyBwb3J0cmFpdCBtb2RlLlsvZW5dXG4gICAgICogICBbamFd44Kq44Oq44Ko44Oz44OG44O844K344On44Oz44GMcG9ydHJhaXTjg6Ljg7zjg4njga7loLTlkIjjgat0cnVl44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGN1cnJlbnQgc2NyZWVuIG9yaWVudGF0aW9uIGlzIHBvcnRyYWl0IG9yIG5vdC5bL2VuXVxuICAgICAqICAgW2phXeOCquODquOCqOODs+ODhuODvOOCt+ODp+ODs+OBjHBvcnRyYWl044Oi44O844OJ44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICAgKi9cbiAgICBpc1BvcnRyYWl0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pc1BvcnRyYWl0KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZXRob2QgaXNMYW5kc2NhcGVcbiAgICAgKiBAc2lnbmF0dXJlIGlzTGFuZHNjYXBlKClcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqICAgW2VuXVdpbGwgYmUgdHJ1ZSBpZiB0aGUgY3VycmVudCBvcmllbnRhdGlvbiBpcyBsYW5kc2NhcGUgbW9kZS5bL2VuXVxuICAgICAqICAgW2phXeOCquODquOCqOODs+ODhuODvOOCt+ODp+ODs+OBjGxhbmRzY2FwZeODouODvOODieOBruWgtOWQiOOBq3RydWXjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgY3VycmVudCBzY3JlZW4gb3JpZW50YXRpb24gaXMgbGFuZHNjYXBlIG9yIG5vdC5bL2VuXVxuICAgICAqICAgW2phXeOCquODquOCqOODs+ODhuODvOOCt+ODp+ODs+OBjGxhbmRzY2FwZeODouODvOODieOBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAgICovXG4gICAgaXNMYW5kc2NhcGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICF0aGlzLmlzUG9ydHJhaXQoKTtcbiAgICB9LFxuXG4gICAgX2luaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIHRoaXMuX29uRE9NQ29udGVudExvYWRlZC5iaW5kKHRoaXMpLCBmYWxzZSk7XG5cbiAgICAgIGlmICgnb3JpZW50YXRpb24nIGluIHdpbmRvdykge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb3JpZW50YXRpb25jaGFuZ2UnLCB0aGlzLl9vbk9yaWVudGF0aW9uQ2hhbmdlLmJpbmQodGhpcyksIGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9vblJlc2l6ZS5iaW5kKHRoaXMpLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2lzUG9ydHJhaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5pbm5lckhlaWdodCA+IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9vbkRPTUNvbnRlbnRMb2FkZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5faW5zdGFsbElzUG9ydHJhaXRJbXBsZW1lbnRhdGlvbigpO1xuICAgICAgdGhpcy5lbWl0KCdjaGFuZ2UnLCB7aXNQb3J0cmFpdDogdGhpcy5pc1BvcnRyYWl0KCl9KTtcbiAgICB9LFxuXG4gICAgX2luc3RhbGxJc1BvcnRyYWl0SW1wbGVtZW50YXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgaXNQb3J0cmFpdCA9IHdpbmRvdy5pbm5lcldpZHRoIDwgd2luZG93LmlubmVySGVpZ2h0O1xuXG4gICAgICBpZiAoISgnb3JpZW50YXRpb24nIGluIHdpbmRvdykpIHtcbiAgICAgICAgdGhpcy5faXNQb3J0cmFpdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB3aW5kb3cuaW5uZXJIZWlnaHQgPiB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAod2luZG93Lm9yaWVudGF0aW9uICUgMTgwID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2lzUG9ydHJhaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5hYnMod2luZG93Lm9yaWVudGF0aW9uICUgMTgwKSA9PT0gMCA/IGlzUG9ydHJhaXQgOiAhaXNQb3J0cmFpdDtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2lzUG9ydHJhaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5hYnMod2luZG93Lm9yaWVudGF0aW9uICUgMTgwKSA9PT0gOTAgPyBpc1BvcnRyYWl0IDogIWlzUG9ydHJhaXQ7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9vbk9yaWVudGF0aW9uQ2hhbmdlOiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGlzUG9ydHJhaXQgPSB0aGlzLl9pc1BvcnRyYWl0KCk7XG5cbiAgICAgIC8vIFdhaXQgZm9yIHRoZSBkaW1lbnNpb25zIHRvIGNoYW5nZSBiZWNhdXNlXG4gICAgICAvLyBvZiBBbmRyb2lkIGluY29uc2lzdGVuY3kuXG4gICAgICBsZXQgbkl0ZXIgPSAwO1xuICAgICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIG5JdGVyKys7XG5cbiAgICAgICAgY29uc3QgdyA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICBjb25zdCBoID0gd2luZG93LmlubmVySGVpZ2h0O1xuXG4gICAgICAgIGlmICgoaXNQb3J0cmFpdCAmJiB3IDw9IGgpIHx8XG4gICAgICAgICAgICghaXNQb3J0cmFpdCAmJiB3ID49IGgpKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdjaGFuZ2UnLCB7aXNQb3J0cmFpdDogaXNQb3J0cmFpdH0pO1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICB9IGVsc2UgaWYgKG5JdGVyID09PSA1MCkge1xuICAgICAgICAgIHRoaXMuZW1pdCgnY2hhbmdlJywge2lzUG9ydHJhaXQ6IGlzUG9ydHJhaXR9KTtcbiAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgfVxuICAgICAgfSwgMjApO1xuICAgIH0sXG5cbiAgICAvLyBSdW4gb24gbm90IG1vYmlsZSBicm93c2VyLlxuICAgIF9vblJlc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmVtaXQoJ2NoYW5nZScsIHtpc1BvcnRyYWl0OiB0aGlzLmlzUG9ydHJhaXQoKX0pO1xuICAgIH1cbiAgfTtcblxuICBNaWNyb0V2ZW50Lm1peGluKG9iaik7XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZSgpLl9pbml0KCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5jb25zdCBzb2Z0d2FyZUtleWJvYXJkID0gbmV3IE1pY3JvRXZlbnQoKTtcbnNvZnR3YXJlS2V5Ym9hcmQuX3Zpc2libGUgPSBmYWxzZTtcblxuY29uc3Qgb25TaG93ID0gKCkgPT4ge1xuICBzb2Z0d2FyZUtleWJvYXJkLl92aXNpYmxlID0gdHJ1ZTtcbiAgc29mdHdhcmVLZXlib2FyZC5lbWl0KCdzaG93Jyk7XG59O1xuXG5jb25zdCBvbkhpZGUgPSAoKSA9PiB7XG4gIHNvZnR3YXJlS2V5Ym9hcmQuX3Zpc2libGUgPSBmYWxzZTtcbiAgc29mdHdhcmVLZXlib2FyZC5lbWl0KCdoaWRlJyk7XG59O1xuXG5jb25zdCBiaW5kRXZlbnRzID0gKCkgPT4ge1xuICBpZiAodHlwZW9mIEtleWJvYXJkICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJ0aW5tb3NlL2NvcmRvdmEta2V5Ym9hcmQvYmxvYi85NWYzZGEzYTM4ZDhmOGUxZmE0MWZiZjQwMTQ1MzUyYzEzNTM1YTAwL1JFQURNRS5tZFxuICAgIEtleWJvYXJkLm9uc2hvdyA9IG9uU2hvdztcbiAgICBLZXlib2FyZC5vbmhpZGUgPSBvbkhpZGU7XG4gICAgc29mdHdhcmVLZXlib2FyZC5lbWl0KCdpbml0Jywge3Zpc2libGU6IEtleWJvYXJkLmlzVmlzaWJsZX0pO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNvcmRvdmEucGx1Z2lucyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvcmRvdmEucGx1Z2lucy5LZXlib2FyZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZHJpZnR5Y28vaW9uaWMtcGx1Z2lucy1rZXlib2FyZC9ibG9iL2NhMjdlY2YvUkVBRE1FLm1kXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ25hdGl2ZS5rZXlib2FyZHNob3cnLCBvblNob3cpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCduYXRpdmUua2V5Ym9hcmRoaWRlJywgb25IaWRlKTtcbiAgICBzb2Z0d2FyZUtleWJvYXJkLmVtaXQoJ2luaXQnLCB7dmlzaWJsZTogY29yZG92YS5wbHVnaW5zLktleWJvYXJkLmlzVmlzaWJsZX0pO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5jb25zdCBub1BsdWdpbkVycm9yID0gKCkgPT4ge1xuICBjb25zb2xlLndhcm4oJ29ucy1rZXlib2FyZDogQ29yZG92YSBLZXlib2FyZCBwbHVnaW4gaXMgbm90IHByZXNlbnQuJyk7XG59O1xuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsICgpID0+IHtcbiAgaWYgKCFiaW5kRXZlbnRzKCkpIHtcbiAgICBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW29ucy1rZXlib2FyZC1hY3RpdmVdJykgfHxcbiAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tvbnMta2V5Ym9hcmQtaW5hY3RpdmVdJykpIHtcbiAgICAgIG5vUGx1Z2luRXJyb3IoKTtcbiAgICB9XG5cbiAgICBzb2Z0d2FyZUtleWJvYXJkLm9uID0gbm9QbHVnaW5FcnJvcjtcbiAgfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHNvZnR3YXJlS2V5Ym9hcmQ7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi9wbGF0Zm9ybSc7XG5cblxuY29uc3QgdXRpbCA9IHtcbiAgX3JlYWR5OiBmYWxzZSxcblxuICBfZG9tQ29udGVudExvYWRlZDogZmFsc2UsXG5cbiAgX29uRE9NQ29udGVudExvYWRlZDogKCkgPT4ge1xuICAgIHV0aWwuX2RvbUNvbnRlbnRMb2FkZWQgPSB0cnVlO1xuXG4gICAgaWYgKHBsYXRmb3JtLmlzV2ViVmlldygpKSB7XG4gICAgICB3aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZGV2aWNlcmVhZHknLCAoKSA9PiB7XG4gICAgICAgIHV0aWwuX3JlYWR5ID0gdHJ1ZTtcbiAgICAgIH0sIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXRpbC5fcmVhZHkgPSB0cnVlO1xuICAgIH1cbiAgfSxcblxuICBhZGRCYWNrQnV0dG9uTGlzdGVuZXI6IGZ1bmN0aW9uKGZuKSB7XG4gICAgaWYgKCF0aGlzLl9kb21Db250ZW50TG9hZGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIGF2YWlsYWJsZSBhZnRlciBET01Db250ZW50TG9hZGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3JlYWR5KSB7XG4gICAgICB3aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignYmFja2J1dHRvbicsIGZuLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB3aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignYmFja2J1dHRvbicsIGZuLCBmYWxzZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgcmVtb3ZlQmFja0J1dHRvbkxpc3RlbmVyOiBmdW5jdGlvbihmbikge1xuICAgIGlmICghdGhpcy5fZG9tQ29udGVudExvYWRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBhdmFpbGFibGUgYWZ0ZXIgRE9NQ29udGVudExvYWRlZCcpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9yZWFkeSkge1xuICAgICAgd2luZG93LmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JhY2tidXR0b24nLCBmbiwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZGV2aWNlcmVhZHknLCBmdW5jdGlvbigpIHtcbiAgICAgICAgd2luZG93LmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JhY2tidXR0b24nLCBmbiwgZmFsc2UpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59O1xud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCAoKSA9PiB1dGlsLl9vbkRPTUNvbnRlbnRMb2FkZWQoKSwgZmFsc2UpO1xuXG5jb25zdCBIYW5kbGVyUmVwb3NpdG9yeSA9IHtcbiAgX3N0b3JlOiB7fSxcblxuICBfZ2VuSWQ6ICgoKSA9PiB7XG4gICAgbGV0IGkgPSAwO1xuICAgIHJldHVybiAoKSA9PiBpKys7XG4gIH0pKCksXG5cbiAgc2V0OiBmdW5jdGlvbihlbGVtZW50LCBoYW5kbGVyKSB7XG4gICAgaWYgKGVsZW1lbnQuZGF0YXNldC5kZXZpY2VCYWNrQnV0dG9uSGFuZGxlcklkKSB7XG4gICAgICB0aGlzLnJlbW92ZShlbGVtZW50KTtcbiAgICB9XG4gICAgY29uc3QgaWQgPSBlbGVtZW50LmRhdGFzZXQuZGV2aWNlQmFja0J1dHRvbkhhbmRsZXJJZCA9IEhhbmRsZXJSZXBvc2l0b3J5Ll9nZW5JZCgpO1xuICAgIHRoaXMuX3N0b3JlW2lkXSA9IGhhbmRsZXI7XG4gIH0sXG5cbiAgcmVtb3ZlOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQuZGF0YXNldC5kZXZpY2VCYWNrQnV0dG9uSGFuZGxlcklkKSB7XG4gICAgICBkZWxldGUgdGhpcy5fc3RvcmVbZWxlbWVudC5kYXRhc2V0LmRldmljZUJhY2tCdXR0b25IYW5kbGVySWRdO1xuICAgICAgZGVsZXRlIGVsZW1lbnQuZGF0YXNldC5kZXZpY2VCYWNrQnV0dG9uSGFuZGxlcklkO1xuICAgIH1cbiAgfSxcblxuICBnZXQ6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBpZiAoIWVsZW1lbnQuZGF0YXNldC5kZXZpY2VCYWNrQnV0dG9uSGFuZGxlcklkKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IGlkID0gZWxlbWVudC5kYXRhc2V0LmRldmljZUJhY2tCdXR0b25IYW5kbGVySWQ7XG5cbiAgICBpZiAoIXRoaXMuX3N0b3JlW2lkXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3N0b3JlW2lkXTtcbiAgfSxcblxuICBoYXM6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBpZiAoIWVsZW1lbnQuZGF0YXNldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGlkID0gZWxlbWVudC5kYXRhc2V0LmRldmljZUJhY2tCdXR0b25IYW5kbGVySWQ7XG5cbiAgICByZXR1cm4gISF0aGlzLl9zdG9yZVtpZF07XG4gIH1cbn07XG5cbmNsYXNzIERldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5faXNFbmFibGVkID0gZmFsc2U7XG4gICAgdGhpcy5fYm91bmRDYWxsYmFjayA9IHRoaXMuX2NhbGxiYWNrLmJpbmQodGhpcyk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBFbmFibGUgdG8gaGFuZGxlICdiYWNrYnV0dG9uJyBldmVudHMuXG4gICAqL1xuICBlbmFibGUoKSB7XG4gICAgaWYgKCF0aGlzLl9pc0VuYWJsZWQpIHtcbiAgICAgIHV0aWwuYWRkQmFja0J1dHRvbkxpc3RlbmVyKHRoaXMuX2JvdW5kQ2FsbGJhY2spO1xuICAgICAgdGhpcy5faXNFbmFibGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGlzYWJsZSB0byBoYW5kbGUgJ2JhY2tidXR0b24nIGV2ZW50cy5cbiAgICovXG4gIGRpc2FibGUoKSB7XG4gICAgaWYgKHRoaXMuX2lzRW5hYmxlZCkge1xuICAgICAgdXRpbC5yZW1vdmVCYWNrQnV0dG9uTGlzdGVuZXIodGhpcy5fYm91bmRDYWxsYmFjayk7XG4gICAgICB0aGlzLl9pc0VuYWJsZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmlyZSBhICdiYWNrYnV0dG9uJyBldmVudCBtYW51YWxseS5cbiAgICovXG4gIGZpcmVEZXZpY2VCYWNrQnV0dG9uRXZlbnQoKSB7XG4gICAgY29uc3QgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBldmVudC5pbml0RXZlbnQoJ2JhY2tidXR0b24nLCB0cnVlLCB0cnVlKTtcbiAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgfVxuXG4gIF9jYWxsYmFjaygpIHtcbiAgICB0aGlzLl9kaXNwYXRjaERldmljZUJhY2tCdXR0b25FdmVudCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIGNyZWF0ZUhhbmRsZXIoZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICBpZiAoIShlbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VsZW1lbnQgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBIVE1MRWxlbWVudCcpO1xuICAgIH1cblxuICAgIGlmICghKGNhbGxiYWNrIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxiYWNrIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgRnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICBjb25zdCBoYW5kbGVyID0ge1xuICAgICAgX2NhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgIF9lbGVtZW50OiBlbGVtZW50LFxuXG4gICAgICBkaXNhYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgSGFuZGxlclJlcG9zaXRvcnkucmVtb3ZlKGVsZW1lbnQpO1xuICAgICAgfSxcblxuICAgICAgc2V0TGlzdGVuZXI6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICB9LFxuXG4gICAgICBlbmFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBIYW5kbGVyUmVwb3NpdG9yeS5zZXQoZWxlbWVudCwgdGhpcyk7XG4gICAgICB9LFxuXG4gICAgICBpc0VuYWJsZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gSGFuZGxlclJlcG9zaXRvcnkuZ2V0KGVsZW1lbnQpID09PSB0aGlzO1xuICAgICAgfSxcblxuICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgIEhhbmRsZXJSZXBvc2l0b3J5LnJlbW92ZShlbGVtZW50KTtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2sgPSB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaGFuZGxlci5lbmFibGUoKTtcblxuICAgIHJldHVybiBoYW5kbGVyO1xuICB9XG5cbiAgX2Rpc3BhdGNoRGV2aWNlQmFja0J1dHRvbkV2ZW50KCkge1xuICAgIGNvbnN0IHRyZWUgPSB0aGlzLl9jYXB0dXJlVHJlZSgpO1xuXG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2ZpbmRIYW5kbGVyTGVhZkVsZW1lbnQodHJlZSk7XG5cbiAgICBsZXQgaGFuZGxlciA9IEhhbmRsZXJSZXBvc2l0b3J5LmdldChlbGVtZW50KTtcbiAgICBoYW5kbGVyLl9jYWxsYmFjayhjcmVhdGVFdmVudChlbGVtZW50KSk7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVFdmVudChlbGVtZW50KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBfZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgY2FsbFBhcmVudEhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGU7XG5cbiAgICAgICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgICAgICBoYW5kbGVyID0gSGFuZGxlclJlcG9zaXRvcnkuZ2V0KHBhcmVudCk7XG4gICAgICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlci5fY2FsbGJhY2soY3JlYXRlRXZlbnQocGFyZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIF9jYXB0dXJlVHJlZSgpIHtcbiAgICByZXR1cm4gY3JlYXRlVHJlZShkb2N1bWVudC5ib2R5KTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVRyZWUoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgY2hpbGRyZW46IEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGFycmF5T2YoZWxlbWVudC5jaGlsZHJlbikubWFwKGZ1bmN0aW9uKGNoaWxkRWxlbWVudCkge1xuXG4gICAgICAgICAgaWYgKGNoaWxkRWxlbWVudC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY2hpbGRFbGVtZW50LmNoaWxkcmVuLmxlbmd0aCA9PT0gMCAmJiAhSGFuZGxlclJlcG9zaXRvcnkuaGFzKGNoaWxkRWxlbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBjcmVhdGVUcmVlKGNoaWxkRWxlbWVudCk7XG5cbiAgICAgICAgICBpZiAocmVzdWx0LmNoaWxkcmVuLmxlbmd0aCA9PT0gMCAmJiAhSGFuZGxlclJlcG9zaXRvcnkuaGFzKHJlc3VsdC5lbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBbcmVzdWx0XTtcbiAgICAgICAgfSkpXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFycmF5T2YodGFyZ2V0KSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFyZ2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRhcmdldFtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJlZVxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIF9maW5kSGFuZGxlckxlYWZFbGVtZW50KHRyZWUpIHtcbiAgICByZXR1cm4gZmluZCh0cmVlKTtcblxuICAgIGZ1bmN0aW9uIGZpbmQobm9kZSkge1xuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBub2RlLmVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gZmluZChub2RlLmNoaWxkcmVuWzBdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGUuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uKGNoaWxkTm9kZSkge1xuICAgICAgICByZXR1cm4gY2hpbGROb2RlLmVsZW1lbnQ7XG4gICAgICB9KS5yZWR1Y2UoZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKCFsZWZ0KSB7XG4gICAgICAgICAgcmV0dXJuIHJpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbGVmdFogPSBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShsZWZ0LCAnJykuekluZGV4LCAxMCk7XG4gICAgICAgIGNvbnN0IHJpZ2h0WiA9IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHJpZ2h0LCAnJykuekluZGV4LCAxMCk7XG5cbiAgICAgICAgaWYgKCFpc05hTihsZWZ0WikgJiYgIWlzTmFOKHJpZ2h0WikpIHtcbiAgICAgICAgICByZXR1cm4gbGVmdFogPiByaWdodFogPyBsZWZ0IDogcmlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhcHR1cmluZyBiYWNrYnV0dG9uLWhhbmRsZXIgaXMgZmFpbHVyZS4nKTtcbiAgICAgIH0sIG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBuZXcgRGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIoKTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNQbGF0Zm9ybSBmcm9tICcuL3BsYXRmb3JtJztcbmltcG9ydCB1dGlsIGZyb20gJy4vdXRpbCc7XG5cbmxldCBhdXRvU3R5bGVFbmFibGVkID0gdHJ1ZTtcblxuLy8gTW9kaWZpZXJzXG5jb25zdCBtb2RpZmllcnNNYXAgPSB7XG4gICdxdWlldCc6ICdtYXRlcmlhbC0tZmxhdCcsXG4gICdsaWdodCc6ICdtYXRlcmlhbC0tZmxhdCcsXG4gICdvdXRsaW5lJzogJ21hdGVyaWFsLS1mbGF0JyxcbiAgJ2N0YSc6ICcnLFxuICAnbGFyZ2UtLXF1aWV0JzogJ21hdGVyaWFsLS1mbGF0IGxhcmdlJyxcbiAgJ2xhcmdlLS1jdGEnOiAnbGFyZ2UnLFxuICAnbm9ib3JkZXInOiAnJyxcbiAgJ2NoZXZyb24nOiAnJyxcbiAgJ3RhcHBhYmxlJzogJydcbn07XG5cbmNvbnN0IHBsYXRmb3JtcyA9IHt9O1xuXG5wbGF0Zm9ybXMuYW5kcm9pZCA9IGVsZW1lbnQgPT4ge1xuXG4gIGlmICghL29ucy1mYWJ8b25zLXNwZWVkLWRpYWx8b25zLXByb2dyZXNzLy50ZXN0KGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSAmJlxuICAgICEvbWF0ZXJpYWwvLnRlc3QoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykpKSB7XG5cbiAgICBjb25zdCBvbGRNb2RpZmllciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpIHx8ICcnO1xuXG4gICAgY29uc3QgbmV3TW9kaWZpZXIgPSBvbGRNb2RpZmllci50cmltKCkuc3BsaXQoL1xccysvKS5tYXAoZSA9PiBtb2RpZmllcnNNYXAuaGFzT3duUHJvcGVydHkoZSkgPyBtb2RpZmllcnNNYXBbZV0gOiBlKTtcbiAgICBuZXdNb2RpZmllci51bnNoaWZ0KCdtYXRlcmlhbCcpO1xuXG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJywgbmV3TW9kaWZpZXIuam9pbignICcpLnRyaW0oKSk7XG4gIH1cblxuICAvLyBFZmZlY3RzXG4gIGlmICgvb25zLWJ1dHRvbnxvbnMtbGlzdC1pdGVtfG9ucy1mYWJ8b25zLXNwZWVkLWRpYWx8b25zLXRhYiQvLnRlc3QoZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgJiYgIWVsZW1lbnQuaGFzQXR0cmlidXRlKCdyaXBwbGUnKVxuICAgICYmICF1dGlsLmZpbmRDaGlsZChlbGVtZW50LCAnb25zLXJpcHBsZScpKSB7XG5cbiAgICBpZiAoZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvbnMtbGlzdC1pdGVtJykge1xuICAgICAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YXBwYWJsZScpKSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdyaXBwbGUnLCAnJyk7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd0YXBwYWJsZScpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgncmlwcGxlJywgJycpO1xuICAgIH1cbiAgfVxufTtcblxucGxhdGZvcm1zLmlvcyA9IGVsZW1lbnQgPT4ge1xuXG4gLy8gTW9kaWZpZXJzXG4gaWYgKC9tYXRlcmlhbC8udGVzdChlbGVtZW50LmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKSkpIHtcbiAgIHV0aWwucmVtb3ZlTW9kaWZpZXIoZWxlbWVudCwgJ21hdGVyaWFsJyk7XG5cbiAgIGlmICh1dGlsLnJlbW92ZU1vZGlmaWVyKGVsZW1lbnQsICdtYXRlcmlhbC0tZmxhdCcpKSB7XG4gICAgIHV0aWwuYWRkTW9kaWZpZXIoZWxlbWVudCwgKHV0aWwucmVtb3ZlTW9kaWZpZXIoZWxlbWVudCwgJ2xhcmdlJykpID8gJ2xhcmdlLS1xdWlldCcgOiAncXVpZXQnKTtcbiAgIH1cblxuICAgaWYgKCFlbGVtZW50LmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKSkge1xuICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnbW9kaWZpZXInKTtcbiAgIH1cbiB9XG5cbiAvLyBFZmZlY3RzXG4gaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCdyaXBwbGUnKSkge1xuICAgaWYgKGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb25zLWxpc3QtaXRlbScpIHtcbiAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhcHBhYmxlJywgJycpO1xuICAgfVxuXG4gICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgncmlwcGxlJyk7XG4gfVxufTtcblxuY29uc3QgdW5sb2NrZWQgPSB7XG4gIGFuZHJvaWQ6IHRydWVcbn07XG5cbmNvbnN0IHByZXBhcmVBdXRvU3R5bGUgPSAoZWxlbWVudCwgZm9yY2UpID0+IHtcbiAgaWYgKGF1dG9TdHlsZUVuYWJsZWQgJiYgIWVsZW1lbnQuaGFzQXR0cmlidXRlKCdkaXNhYmxlLWF1dG8tc3R5bGluZycpKSB7XG4gICAgY29uc3QgbW9iaWxlT1MgPSBvbnNQbGF0Zm9ybS5nZXRNb2JpbGVPUygpO1xuICAgIGlmIChwbGF0Zm9ybXMuaGFzT3duUHJvcGVydHkobW9iaWxlT1MpICYmICh1bmxvY2tlZC5oYXNPd25Qcm9wZXJ0eShtb2JpbGVPUykgfHwgZm9yY2UpKSB7XG4gICAgICBwbGF0Zm9ybXNbbW9iaWxlT1NdKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBpc0VuYWJsZWQ6ICgpID0+IGF1dG9TdHlsZUVuYWJsZWQsXG4gIGVuYWJsZTogKCkgPT4gYXV0b1N0eWxlRW5hYmxlZCA9IHRydWUsXG4gIGRpc2FibGU6ICgpID0+IGF1dG9TdHlsZUVuYWJsZWQgPSBmYWxzZSxcbiAgcHJlcGFyZTogcHJlcGFyZUF1dG9TdHlsZVxufTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmNvbnN0IGdlbmVyYXRlSWQgPSAoZnVuY3Rpb24oKSB7XG4gIGxldCBpID0gMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpKys7XG4gIH07XG59KSgpO1xuXG4vKipcbiAqIERvb3IgbG9ja2luZyBzeXN0ZW0uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMubG9nXVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEb29yTG9jayB7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5fbG9ja0xpc3QgPSBbXTtcbiAgICB0aGlzLl93YWl0TGlzdCA9IFtdO1xuICAgIHRoaXMuX2xvZyA9IG9wdGlvbnMubG9nIHx8IGZ1bmN0aW9uKCkge307XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBsb2NrLlxuICAgKlxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gQ2FsbGJhY2sgZm9yIHVubG9ja2luZy5cbiAgICovXG4gIGxvY2soKSB7XG4gICAgY29uc3QgdW5sb2NrID0gKCkgPT4ge1xuICAgICAgdGhpcy5fdW5sb2NrKHVubG9jayk7XG4gICAgfTtcbiAgICB1bmxvY2suaWQgPSBnZW5lcmF0ZUlkKCk7XG4gICAgdGhpcy5fbG9ja0xpc3QucHVzaCh1bmxvY2spO1xuICAgIHRoaXMuX2xvZygnbG9jazogJyArICh1bmxvY2suaWQpKTtcblxuICAgIHJldHVybiB1bmxvY2s7XG4gIH1cblxuICBfdW5sb2NrKGZuKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9sb2NrTGlzdC5pbmRleE9mKGZuKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgZnVuY3Rpb24gaXMgbm90IHJlZ2lzdGVyZWQgaW4gdGhlIGxvY2sgbGlzdC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLl9sb2NrTGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHRoaXMuX2xvZygndW5sb2NrOiAnICsgZm4uaWQpO1xuXG4gICAgdGhpcy5fdHJ5VG9GcmVlV2FpdExpc3QoKTtcbiAgfVxuXG4gIF90cnlUb0ZyZWVXYWl0TGlzdCgpIHtcbiAgICB3aGlsZSAoIXRoaXMuaXNMb2NrZWQoKSAmJiB0aGlzLl93YWl0TGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLl93YWl0TGlzdC5zaGlmdCgpKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgZm9yIHdhaXRpbmcgdW5sb2NrZWQgZG9vci5cbiAgICpcbiAgICogQHBhcmFtcyB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIG9uIHVubG9ja2luZyB0aGUgZG9vciBjb21wbGV0ZWx5LlxuICAgKi9cbiAgd2FpdFVubG9jayhjYWxsYmFjaykge1xuICAgIGlmICghKGNhbGxiYWNrIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjYWxsYmFjayBwYXJhbSBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNMb2NrZWQoKSkge1xuICAgICAgdGhpcy5fd2FpdExpc3QucHVzaChjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0xvY2tlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9ja0xpc3QubGVuZ3RoID4gMDtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cbmNvbnN0IHJlYWR5TWFwID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHF1ZXVlTWFwID0gbmV3IFdlYWtNYXAoKTtcblxuZnVuY3Rpb24gaXNDb250ZW50UmVhZHkoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICBzZXRDb250ZW50UmVhZHkoZWxlbWVudCk7XG4gIH1cbiAgcmV0dXJuIHJlYWR5TWFwLmhhcyhlbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gc2V0Q29udGVudFJlYWR5KGVsZW1lbnQpIHtcbiAgcmVhZHlNYXAuc2V0KGVsZW1lbnQsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBhZGRDYWxsYmFjayhlbGVtZW50LCBmbikge1xuICBpZiAoIXF1ZXVlTWFwLmhhcyhlbGVtZW50KSkge1xuICAgIHF1ZXVlTWFwLnNldChlbGVtZW50LCBbXSk7XG4gIH1cbiAgcXVldWVNYXAuZ2V0KGVsZW1lbnQpLnB1c2goZm4pO1xufVxuXG5mdW5jdGlvbiBjb25zdW1lUXVldWUoZWxlbWVudCkge1xuICBjb25zdCBjYWxsYmFja3MgPSBxdWV1ZU1hcC5nZXQoZWxlbWVudCwgW10pIHx8IFtdO1xuICBxdWV1ZU1hcC5kZWxldGUoZWxlbWVudCk7XG4gIGNhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKCkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb250ZW50UmVhZHkoZWxlbWVudCwgZm4pIHtcbiAgYWRkQ2FsbGJhY2soZWxlbWVudCwgZm4pO1xuXG4gIGlmIChpc0NvbnRlbnRSZWFkeShlbGVtZW50KSkge1xuICAgIGNvbnN1bWVRdWV1ZShlbGVtZW50KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGNoYW5nZXMgPT4ge1xuICAgIHNldENvbnRlbnRSZWFkeShlbGVtZW50KTtcbiAgICBjb25zdW1lUXVldWUoZWxlbWVudCk7XG4gIH0pO1xuICBvYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQsIHtjaGlsZExpc3Q6IHRydWUsIGNoYXJhY3RlckRhdGE6IHRydWV9KTtcblxuICAvLyBmYWlsYmFjayBmb3IgZWxlbWVudHMgaGFzIGVtcHR5IGNvbnRlbnQuXG4gIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgc2V0Q29udGVudFJlYWR5KGVsZW1lbnQpO1xuICAgIGNvbnN1bWVRdWV1ZShlbGVtZW50KTtcbiAgfSk7XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuaW1wb3J0IGludGVybmFsIGZyb20gJ29ucy9pbnRlcm5hbCc7XG5cbi8vIERlZmF1bHQgaW1wbGVtZW50YXRpb24gZm9yIGdsb2JhbCBQYWdlTG9hZGVyLlxuZnVuY3Rpb24gbG9hZFBhZ2Uoe3BhZ2UsIHBhcmVudCwgcGFyYW1zID0ge30sIHJlcGxhY2V9LCBkb25lKSB7XG4gIGludGVybmFsLmdldFBhZ2VIVE1MQXN5bmMocGFnZSkudGhlbihodG1sID0+IHtcbiAgICBpZiAocmVwbGFjZSkge1xuICAgICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24ocGFyZW50LCAnX2Rlc3Ryb3knKTtcbiAgICAgIHBhcmVudC5pbm5lckhUTUwgPSAnJztcbiAgICB9XG5cbiAgICBjb25zdCBlbGVtZW50ID0gdXRpbC5jcmVhdGVFbGVtZW50KGh0bWwudHJpbSgpKTtcbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG5cbiAgICBkb25lKHtcbiAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICB1bmxvYWQ6ICgpID0+IGVsZW1lbnQucmVtb3ZlKClcbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydCBjbGFzcyBQYWdlTG9hZGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl0gUmV0dXJucyBhbiBvYmplY3QgdGhhdCBoYXMgXCJlbGVtZW50XCIgcHJvcGVydHkgYW5kIFwidW5sb2FkXCIgZnVuY3Rpb24uXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihmbikge1xuICAgIHRoaXMuX2xvYWRlciA9IGZuIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBmbiA6IGxvYWRQYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBpbnRlcm5hbCBsb2FkZXIgaW1wbGVtZW50YXRpb24uXG4gICAqL1xuICBzZXQgaW50ZXJuYWxMb2FkZXIoZm4pIHtcbiAgICBpZiAoIShmbiBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0ZpcnN0IHBhcmFtZXRlciBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHRoaXMuX2xvYWRlciA9IGZuO1xuICB9XG5cbiAgZ2V0IGludGVybmFsTG9hZGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9sb2FkZXI7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHthbnl9IG9wdGlvbnMucGFnZVxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG9wdGlvbnMucGFyZW50IEEgbG9jYXRpb24gdG8gbG9hZCBwYWdlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucGFyYW1zXSBFeHRyYSBwYXJhbWV0ZXJzIGZvciBvbnMtcGFnZS5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yZXBsYWNlXSBSZW1vdmUgdGhlIHByZXZpb3VzIGNvbnRlbnQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmUgVGFrZSBhbiBvYmplY3QgdGhhdCBoYXMgXCJlbGVtZW50XCIgcHJvcGVydHkgYW5kIFwidW5sb2FkXCIgZnVuY3Rpb24uXG4gICAqL1xuICBsb2FkKHtwYWdlLCBwYXJlbnQsIHBhcmFtcyA9IHt9LCByZXBsYWNlfSwgZG9uZSkge1xuICAgIHRoaXMuX2xvYWRlcih7cGFnZSwgcGFyZW50LCBwYXJhbXMsIHJlcGxhY2V9LCByZXN1bHQgPT4ge1xuICAgICAgaWYgKCEocmVzdWx0LmVsZW1lbnQgaW5zdGFuY2VvZiBFbGVtZW50KSkge1xuICAgICAgICB0aHJvdyBFcnJvcigndGFyZ2V0LmVsZW1lbnQgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBFbGVtZW50LicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIShyZXN1bHQudW5sb2FkIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gICAgICAgIHRocm93IEVycm9yKCd0YXJnZXQudW5sb2FkIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgRnVuY3Rpb24uJyk7XG4gICAgICB9XG5cbiAgICAgIGRvbmUocmVzdWx0KTtcbiAgICB9LCBwYXJhbXMpO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0UGFnZUxvYWRlciA9IG5ldyBQYWdlTG9hZGVyKCk7XG5cbmV4cG9ydCBjb25zdCBpbnN0YW50UGFnZUxvYWRlciA9IG5ldyBQYWdlTG9hZGVyKGZ1bmN0aW9uKHtwYWdlLCBwYXJlbnQsIHBhcmFtcyA9IHt9LCByZXBsYWNlfSwgZG9uZSkge1xuICBpZiAocmVwbGFjZSkge1xuICAgIHV0aWwucHJvcGFnYXRlQWN0aW9uKHBhcmVudCwgJ19kZXN0cm95Jyk7XG4gICAgcGFyZW50LmlubmVySFRNTCA9ICcnO1xuICB9XG5cbiAgY29uc3QgZWxlbWVudCA9IHV0aWwuY3JlYXRlRWxlbWVudChwYWdlLnRyaW0oKSk7XG4gIHBhcmVudC5hcHBlbmRDaGlsZChlbGVtZW50KTtcblxuICBkb25lKHtcbiAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgIHVubG9hZDogKCkgPT4gZWxlbWVudC5yZW1vdmUoKVxuICB9KTtcbn0pO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi91dGlsJztcbmltcG9ydCBHZXN0dXJlRGV0ZWN0b3IgZnJvbSAnLi9nZXN0dXJlLWRldGVjdG9yJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuL3BsYXRmb3JtJztcbmltcG9ydCBub3RpZmljYXRpb24gZnJvbSAnLi9ub3RpZmljYXRpb24nO1xuaW1wb3J0IGludGVybmFsIGZyb20gJy4vaW50ZXJuYWwnO1xuaW1wb3J0IG9yaWVudGF0aW9uIGZyb20gJy4vb3JpZW50YXRpb24nO1xuaW1wb3J0IHNvZnR3YXJlS2V5Ym9hcmQgZnJvbSAnLi9zb2Z0d2FyZS1rZXlib2FyZCc7XG5pbXBvcnQgUGFnZUF0dHJpYnV0ZUV4cHJlc3Npb24gZnJvbSAnLi9wYWdlLWF0dHJpYnV0ZS1leHByZXNzaW9uJztcbmltcG9ydCBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciBmcm9tICcuL2RldmljZS1iYWNrLWJ1dHRvbi1kaXNwYXRjaGVyJztcbmltcG9ydCBhbmltYXRpb25PcHRpb25zUGFyc2VyIGZyb20gJy4vYW5pbWF0aW9uLW9wdGlvbnMtcGFyc2VyJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi9hdXRvc3R5bGUnO1xuaW1wb3J0IERvb3JMb2NrIGZyb20gJy4vZG9vcmxvY2snO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuL2NvbnRlbnQtcmVhZHknO1xuaW1wb3J0IHtkZWZhdWx0UGFnZUxvYWRlciwgUGFnZUxvYWRlcn0gZnJvbSAnLi9wYWdlLWxvYWRlcic7XG5cbi8qKlxuICogQG9iamVjdCBvbnNcbiAqIEBjYXRlZ29yeSB1dGlsXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2phXU9uc2VuIFVJ44Gn5Yip55So44Gn44GN44KL44Kw44Ot44O844OQ44Or44Gq44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAqICAgW2VuXUEgZ2xvYmFsIG9iamVjdCB0aGF0J3MgdXNlZCBpbiBPbnNlbiBVSS4gWy9lbl1cbiAqL1xuY29uc3Qgb25zID0ge307XG5cbm9ucy5fdXRpbCA9IHV0aWw7XG5vbnMuX2RldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyID0gZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXI7XG5vbnMuX2ludGVybmFsID0gaW50ZXJuYWw7XG5vbnMuR2VzdHVyZURldGVjdG9yID0gR2VzdHVyZURldGVjdG9yO1xub25zLnBsYXRmb3JtID0gcGxhdGZvcm07XG5vbnMuc29mdHdhcmVLZXlib2FyZCA9IHNvZnR3YXJlS2V5Ym9hcmQ7XG5vbnMucGFnZUF0dHJpYnV0ZUV4cHJlc3Npb24gPSBQYWdlQXR0cmlidXRlRXhwcmVzc2lvbjtcbm9ucy5vcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uO1xub25zLm5vdGlmaWNhdGlvbiA9IG5vdGlmaWNhdGlvbjtcbm9ucy5fYW5pbWF0aW9uT3B0aW9uc1BhcnNlciA9IGFuaW1hdGlvbk9wdGlvbnNQYXJzZXI7XG5vbnMuX2F1dG9TdHlsZSA9IGF1dG9TdHlsZTtcbm9ucy5fRG9vckxvY2sgPSBEb29yTG9jaztcbm9ucy5fY29udGVudFJlYWR5ID0gY29udGVudFJlYWR5O1xub25zLmRlZmF1bHRQYWdlTG9hZGVyID0gZGVmYXVsdFBhZ2VMb2FkZXI7XG5vbnMuUGFnZUxvYWRlciA9IFBhZ2VMb2FkZXI7XG5cbm9ucy5fcmVhZHlMb2NrID0gbmV3IERvb3JMb2NrKCk7XG5cbm9ucy5wbGF0Zm9ybS5zZWxlY3QoKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gubWF0Y2goL3BsYXRmb3JtPShbXFx3LV0rKS8pIHx8IFtdKVsxXSk7XG5cbndhaXREZXZpY2VSZWFkeSgpO1xuXG4vKipcbiAqIEBtZXRob2QgaXNSZWFkeVxuICogQHNpZ25hdHVyZSBpc1JlYWR5KClcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiAgIFtlbl1XaWxsIGJlIHRydWUgaWYgT25zZW4gVUkgaXMgaW5pdGlhbGl6ZWQuWy9lbl1cbiAqICAgW2phXeWIneacn+WMluOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVJldHVybnMgdHJ1ZSBpZiBPbnNlbiBVSSBpcyBpbml0aWFsaXplZC5bL2VuXVxuICogICBbamFdT25zZW4gVUnjgYzjgZnjgafjgavliJ3mnJ/ljJbjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZnjg6Hjgr3jg4Pjg4njgafjgZnjgIJbL2phXVxuICovXG5vbnMuaXNSZWFkeSA9ICgpID0+IHtcbiAgcmV0dXJuICFvbnMuX3JlYWR5TG9jay5pc0xvY2tlZCgpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGlzV2ViVmlld1xuICogQHNpZ25hdHVyZSBpc1dlYlZpZXcoKVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqICAgW2VuXVdpbGwgYmUgdHJ1ZSBpZiB0aGUgYXBwIGlzIHJ1bm5pbmcgaW4gQ29yZG92YS5bL2VuXVxuICogICBbamFdQ29yZG92YeOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq3RydWXjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1SZXR1cm5zIHRydWUgaWYgcnVubmluZyBpbnNpZGUgQ29yZG92YS5bL2VuXVxuICogICBbamFdQ29yZG92YeOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBmeODoeOCveODg+ODieOBp+OBmeOAglsvamFdXG4gKi9cbm9ucy5pc1dlYlZpZXcgPSBvbnMucGxhdGZvcm0uaXNXZWJWaWV3O1xuXG4vKipcbiAqIEBtZXRob2QgcmVhZHlcbiAqIEBzaWduYXR1cmUgcmVhZHkoY2FsbGJhY2spXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2phXeOCouODl+ODquOBruWIneacn+WMluOBq+WIqeeUqOOBmeOCi+ODoeOCveODg+ODieOBp+OBmeOAgua4oeOBleOCjOOBn+mWouaVsOOBr+OAgU9uc2VuIFVJ44Gu5Yid5pyf5YyW44GM57WC5LqG44GX44Gm44GE44KL5pmC54K544Gn5b+F44Ga5ZG844Gw44KM44G+44GZ44CCWy9qYV1cbiAqICAgW2VuXU1ldGhvZCB1c2VkIHRvIHdhaXQgZm9yIGFwcCBpbml0aWFsaXphdGlvbi4gVGhlIGNhbGxiYWNrIHdpbGwgbm90IGJlIGV4ZWN1dGVkIHVudGlsIE9uc2VuIFVJIGhhcyBiZWVuIGNvbXBsZXRlbHkgaW5pdGlhbGl6ZWQuWy9lbl1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiAgIFtlbl1GdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIGFmdGVyIE9uc2VuIFVJIGhhcyBiZWVuIGluaXRpYWxpemVkLlsvZW5dXG4gKiAgIFtqYV1PbnNlbiBVSeOBjOWIneacn+WMluOBjOWujOS6huOBl+OBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKi9cbm9ucy5yZWFkeSA9IGNhbGxiYWNrID0+IHtcbiAgaWYgKG9ucy5pc1JlYWR5KCkpIHtcbiAgICBjYWxsYmFjaygpO1xuICB9IGVsc2Uge1xuICAgIG9ucy5fcmVhZHlMb2NrLndhaXRVbmxvY2soY2FsbGJhY2spO1xuICB9XG59O1xuXG4vKipcbiAqIEBtZXRob2Qgc2V0RGVmYXVsdERldmljZUJhY2tCdXR0b25MaXN0ZW5lclxuICogQHNpZ25hdHVyZSBzZXREZWZhdWx0RGV2aWNlQmFja0J1dHRvbkxpc3RlbmVyKGxpc3RlbmVyKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAqICAgW2VuXUZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgd2hlbiBkZXZpY2UgYmFjayBidXR0b24gaXMgcHJlc3NlZC5bL2VuXVxuICogICBbamFd44OH44OQ44Kk44K544Gu44OQ44OD44Kv44Oc44K/44Oz44GM5oq844GV44KM44Gf5pmC44Gr5a6f6KGM44GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dU2V0IGRlZmF1bHQgaGFuZGxlciBmb3IgZGV2aWNlIGJhY2sgYnV0dG9uLlsvZW5dXG4gKiAgIFtqYV3jg4fjg5DjgqTjgrnjga7jg5Djg4Pjgq/jg5zjgr/jg7Pjga7jgZ/jgoHjga7jg4fjg5Xjgqnjg6vjg4jjga7jg4/jg7Pjg4njg6njgpLoqK3lrprjgZfjgb7jgZnjgIJbL2phXVxuICovXG5vbnMuc2V0RGVmYXVsdERldmljZUJhY2tCdXR0b25MaXN0ZW5lciA9IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gIG9ucy5fZGVmYXVsdERldmljZUJhY2tCdXR0b25IYW5kbGVyLnNldExpc3RlbmVyKGxpc3RlbmVyKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBkaXNhYmxlRGV2aWNlQmFja0J1dHRvbkhhbmRsZXJcbiAqIEBzaWduYXR1cmUgZGlzYWJsZURldmljZUJhY2tCdXR0b25IYW5kbGVyKClcbiAqIEBkZXNjcmlwdGlvblxuICogW2VuXURpc2FibGUgZGV2aWNlIGJhY2sgYnV0dG9uIGV2ZW50IGhhbmRsZXIuWy9lbl1cbiAqIFtqYV3jg4fjg5DjgqTjgrnjga7jg5Djg4Pjgq/jg5zjgr/jg7Pjga7jgqTjg5njg7Pjg4jjgpLlj5fjgZHku5jjgZHjgarjgYTjgojjgYbjgavjgZfjgb7jgZnjgIJbL2phXVxuICovXG5vbnMuZGlzYWJsZURldmljZUJhY2tCdXR0b25IYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gIG9ucy5fZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIuZGlzYWJsZSgpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGVuYWJsZURldmljZUJhY2tCdXR0b25IYW5kbGVyXG4gKiBAc2lnbmF0dXJlIGVuYWJsZURldmljZUJhY2tCdXR0b25IYW5kbGVyKClcbiAqIEBkZXNjcmlwdGlvblxuICogW2VuXUVuYWJsZSBkZXZpY2UgYmFjayBidXR0b24gZXZlbnQgaGFuZGxlci5bL2VuXVxuICogW2phXeODh+ODkOOCpOOCueOBruODkOODg+OCr+ODnOOCv+ODs+OBruOCpOODmeODs+ODiOOCkuWPl+OBkeS7mOOBkeOCi+OCiOOBhuOBq+OBl+OBvuOBmeOAglsvamFdXG4gKi9cbm9ucy5lbmFibGVEZXZpY2VCYWNrQnV0dG9uSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICBvbnMuX2RldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyLmVuYWJsZSgpO1xufTtcblxuXG4vKipcbiAqIEBtZXRob2QgZW5hYmxlQXV0b1N0YXR1c0JhckZpbGxcbiAqIEBzaWduYXR1cmUgZW5hYmxlQXV0b1N0YXR1c0JhckZpbGwoKVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1FbmFibGUgc3RhdHVzIGJhciBmaWxsIGZlYXR1cmUgb24gaU9TNyBhbmQgYWJvdmUuWy9lbl1cbiAqICAgW2phXWlPUzfku6XkuIrjgafjgIHjgrnjg4bjg7zjgr/jgrnjg5Djg7zpg6jliIbjga7pq5jjgZXjgpLoh6rli5XnmoTjgavln4vjgoHjgovlh6bnkIbjgpLmnInlirnjgavjgZfjgb7jgZnjgIJbL2phXVxuICovXG5vbnMuZW5hYmxlQXV0b1N0YXR1c0JhckZpbGwgPSAoKSA9PiB7XG4gIGlmIChvbnMuaXNSZWFkeSgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgb25zLmlzUmVhZHkoKSBpcyB0cnVlLicpO1xuICB9XG4gIG9ucy5faW50ZXJuYWwuY29uZmlnLmF1dG9TdGF0dXNCYXJGaWxsID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBkaXNhYmxlQXV0b1N0YXR1c0JhckZpbGxcbiAqIEBzaWduYXR1cmUgZGlzYWJsZUF1dG9TdGF0dXNCYXJGaWxsKClcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dRGlzYWJsZSBzdGF0dXMgYmFyIGZpbGwgZmVhdHVyZSBvbiBpT1M3IGFuZCBhYm92ZS5bL2VuXVxuICogICBbamFdaU9TN+S7peS4iuOBp+OAgeOCueODhuODvOOCv+OCueODkOODvOmDqOWIhuOBrumrmOOBleOCkuiHquWLleeahOOBq+Wfi+OCgeOCi+WHpueQhuOCkueEoeWKueOBq+OBl+OBvuOBmeOAglsvamFdXG4gKi9cbm9ucy5kaXNhYmxlQXV0b1N0YXR1c0JhckZpbGwgPSAoKSA9PiB7XG4gIGlmIChvbnMuaXNSZWFkeSgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgb25zLmlzUmVhZHkoKSBpcyB0cnVlLicpO1xuICB9XG4gIG9ucy5faW50ZXJuYWwuY29uZmlnLmF1dG9TdGF0dXNCYXJGaWxsID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZGlzYWJsZUFuaW1hdGlvbnNcbiAqIEBzaWduYXR1cmUgZGlzYWJsZUFuaW1hdGlvbnMoKVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1EaXNhYmxlIGFsbCBhbmltYXRpb25zLiBDb3VsZCBiZSBoYW5keSBmb3IgdGVzdGluZyBhbmQgb2xkZXIgZGV2aWNlcy5bL2VuXVxuICogICBbamFd44Ki44OL44Oh44O844K344On44Oz44KS5YWo44Gm54Sh5Yq544Gr44GX44G+44GZ44CC44OG44K544OI44Gu6Zqb44Gr5L6/5Yip44Gn44GZ44CCWy9qYV1cbiAqL1xub25zLmRpc2FibGVBbmltYXRpb25zID0gKCkgPT4ge1xuICBvbnMuX2ludGVybmFsLmNvbmZpZy5hbmltYXRpb25zRGlzYWJsZWQgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGVuYWJsZUFuaW1hdGlvbnNcbiAqIEBzaWduYXR1cmUgZW5hYmxlQW5pbWF0aW9ucygpXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUVuYWJsZSBhbmltYXRpb25zIChkZWZhdWx0KS5bL2VuXVxuICogICBbamFd44Ki44OL44Oh44O844K344On44Oz44KS5pyJ5Yq544Gr44GX44G+44GZ44CCWy9qYV1cbiAqL1xub25zLmVuYWJsZUFuaW1hdGlvbnMgPSAoKSA9PiB7XG4gIG9ucy5faW50ZXJuYWwuY29uZmlnLmFuaW1hdGlvbnNEaXNhYmxlZCA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGRpc2FibGVBdXRvU3R5bGluZ1xuICogQHNpZ25hdHVyZSBkaXNhYmxlQXV0b1N0eWxpbmcoKVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1EaXNhYmxlIGF1dG9tYXRpYyBzdHlsaW5nLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICovXG5vbnMuZGlzYWJsZUF1dG9TdHlsaW5nID0gb25zLl9hdXRvU3R5bGUuZGlzYWJsZTtcblxuLyoqXG4gKiBAbWV0aG9kIGVuYWJsZUF1dG9TdHlsaW5nXG4gKiBAc2lnbmF0dXJlIGVuYWJsZUF1dG9TdHlsaW5nKClcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dRW5hYmxlIGF1dG9tYXRpYyBzdHlsaW5nIGJhc2VkIG9uIE9TIChkZWZhdWx0KS5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqL1xub25zLmVuYWJsZUF1dG9TdHlsaW5nID0gb25zLl9hdXRvU3R5bGUuZW5hYmxlO1xuXG4vKipcbiAqIEBtZXRob2QgZm9yY2VQbGF0Zm9ybVN0eWxpbmdcbiAqIEBzaWduYXR1cmUgZm9yY2VQbGF0Zm9ybVN0eWxpbmcocGxhdGZvcm0pXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVJlZnJlc2ggc3R5bGluZyBmb3IgdGhlIGdpdmVuIHBsYXRmb3JtLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtzdHJpbmd9IHBsYXRmb3JtIE5ldyBwbGF0Zm9ybSB0byBzdHlsZSB0aGUgZWxlbWVudHMuXG4gKi9cbm9ucy5mb3JjZVBsYXRmb3JtU3R5bGluZyA9IG5ld1BsYXRmb3JtID0+IHtcbiAgb25zLmVuYWJsZUF1dG9TdHlsaW5nKCk7XG4gIG9ucy5wbGF0Zm9ybS5zZWxlY3QobmV3UGxhdGZvcm0gfHwgJ2lvcycpO1xuXG4gIG9ucy5fdXRpbC5hcnJheUZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnKicpKVxuICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIGlmIChlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29ucy1pZicpIHtcbiAgICAgICAgZWxlbWVudC5fcGxhdGZvcm1VcGRhdGUoKTtcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC50YWdOYW1lLm1hdGNoKC9eb25zLS9pKSkge1xuICAgICAgICBvbnMuX2F1dG9TdHlsZS5wcmVwYXJlKGVsZW1lbnQsIHRydWUpO1xuICAgICAgICBpZiAoZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvbnMtdGFiYmFyJykge1xuICAgICAgICAgIGVsZW1lbnQuX3VwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmxpbmtdXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICovXG5vbnMuX2NyZWF0ZVBvcG92ZXJPcmlnaW5hbCA9IGZ1bmN0aW9uKHBhZ2UsIG9wdGlvbnMgPSB7fSkge1xuXG4gIGlmICghcGFnZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGFnZSB1cmwgbXVzdCBiZSBkZWZpbmVkLicpO1xuICB9XG5cbiAgcmV0dXJuIG9ucy5faW50ZXJuYWwuZ2V0UGFnZUhUTUxBc3luYyhwYWdlKS50aGVuKGh0bWwgPT4ge1xuICAgIGh0bWwgPSBodG1sLm1hdGNoKC88b25zLXBvcG92ZXIvZ2kpID8gYDxkaXY+JHtodG1sfTwvZGl2PmAgOiBgPG9ucy1wb3BvdmVyPiR7aHRtbH08L29ucy1wb3BvdmVyPmA7XG4gICAgY29uc3QgZGl2ID0gb25zLl91dGlsLmNyZWF0ZUVsZW1lbnQoJzxkaXY+JyArIGh0bWwgKyAnPC9kaXY+Jyk7XG5cbiAgICBjb25zdCBwb3BvdmVyID0gZGl2LnF1ZXJ5U2VsZWN0b3IoJ29ucy1wb3BvdmVyJyk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChwb3BvdmVyKTtcblxuICAgIGlmIChvcHRpb25zLmxpbmsgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgb3B0aW9ucy5saW5rKHBvcG92ZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBwb3BvdmVyO1xuICB9KTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBjcmVhdGVQb3BvdmVyXG4gKiBAc2lnbmF0dXJlIGNyZWF0ZVBvcG92ZXIocGFnZSwgW29wdGlvbnNdKVxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAqICAgW2VuXVBhZ2UgbmFtZS4gQ2FuIGJlIGVpdGhlciBhbiBIVE1MIGZpbGUgb3IgYW4gPG9ucy10ZW1wbGF0ZT4gY29udGFpbmluZyBhIDxvbnMtZGlhbG9nPiBjb21wb25lbnQuWy9lbl1cbiAqICAgW2phXXBhZ2Xjga5VUkzjgYvjgIHjgoLjgZfjgY/jga9vbnMtdGVtcGxhdGXjgaflrqPoqIDjgZfjgZ/jg4bjg7Pjg5fjg6zjg7zjg4jjga5pZOWxnuaAp+OBruWApOOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnBhcmVudFNjb3BlXVxuICogICBbZW5dUGFyZW50IHNjb3BlIG9mIHRoZSBkaWFsb2cuIFVzZWQgdG8gYmluZCBtb2RlbHMgYW5kIGFjY2VzcyBzY29wZSBtZXRob2RzIGZyb20gdGhlIGRpYWxvZy5bL2VuXVxuICogICBbamFd44OA44Kk44Ki44Ot44Kw5YaF44Gn5Yip55So44GZ44KL6Kaq44K544Kz44O844OX44KS5oyH5a6a44GX44G+44GZ44CC44OA44Kk44Ki44Ot44Kw44GL44KJ44Oi44OH44Or44KE44K544Kz44O844OX44Gu44Oh44K944OD44OJ44Gr44Ki44Kv44K744K544GZ44KL44Gu44Gr5L2/44GE44G+44GZ44CC44GT44Gu44OR44Op44Oh44O844K/44GvQW5ndWxhckpT44OQ44Kk44Oz44OH44Kj44Oz44Kw44Gn44Gu44G/5Yip55So44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiAgIFtlbl1Qcm9taXNlIG9iamVjdCB0aGF0IHJlc29sdmVzIHRvIHRoZSBwb3BvdmVyIGNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBruOCs+ODs+ODneODvOODjeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOCkuino+axuuOBmeOCi1Byb21pc2Xjgqrjg5bjgrjjgqfjgq/jg4jjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1DcmVhdGUgYSBwb3BvdmVyIGluc3RhbmNlIGZyb20gYSB0ZW1wbGF0ZS5bL2VuXVxuICogICBbamFd44OG44Oz44OX44Os44O844OI44GL44KJ44Od44OD44OX44Kq44O844OQ44O844Gu44Kk44Oz44K544K/44Oz44K544KS55Sf5oiQ44GX44G+44GZ44CCWy9qYV1cbiAqL1xub25zLmNyZWF0ZVBvcG92ZXIgPSBvbnMuX2NyZWF0ZVBvcG92ZXJPcmlnaW5hbDtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFnZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMubGlua11cbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKi9cbm9ucy5fY3JlYXRlRGlhbG9nT3JpZ2luYWwgPSBmdW5jdGlvbihwYWdlLCBvcHRpb25zID0ge30pIHtcblxuICBpZiAoIXBhZ2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhZ2UgdXJsIG11c3QgYmUgZGVmaW5lZC4nKTtcbiAgfVxuXG4gIHJldHVybiBvbnMuX2ludGVybmFsLmdldFBhZ2VIVE1MQXN5bmMocGFnZSkudGhlbihodG1sID0+IHtcbiAgICBodG1sID0gaHRtbC5tYXRjaCgvPG9ucy1kaWFsb2cvZ2kpID8gYDxkaXY+JHtodG1sfTwvZGl2PmAgOiBgPG9ucy1kaWFsb2c+JHtodG1sfTwvb25zLWRpYWxvZz5gO1xuICAgIGNvbnN0IGRpdiA9IG9ucy5fdXRpbC5jcmVhdGVFbGVtZW50KCc8ZGl2PicgKyBodG1sICsgJzwvZGl2PicpO1xuXG4gICAgY29uc3QgZGlhbG9nID0gZGl2LnF1ZXJ5U2VsZWN0b3IoJ29ucy1kaWFsb2cnKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpYWxvZyk7XG5cbiAgICBpZiAob3B0aW9ucy5saW5rIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIG9wdGlvbnMubGluayhkaWFsb2cpO1xuICAgIH1cblxuICAgIHJldHVybiBkaWFsb2c7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGNyZWF0ZURpYWxvZ1xuICogQHNpZ25hdHVyZSBjcmVhdGVEaWFsb2cocGFnZSwgW29wdGlvbnNdKVxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAqICAgW2VuXVBhZ2UgbmFtZS4gQ2FuIGJlIGVpdGhlciBhbiBIVE1MIGZpbGUgb3IgYW4gPG9ucy10ZW1wbGF0ZT4gY29udGFpbmluZyBhIDxvbnMtZGlhbG9nPiBjb21wb25lbnQuWy9lbl1cbiAqICAgW2phXXBhZ2Xjga5VUkzjgYvjgIHjgoLjgZfjgY/jga9vbnMtdGVtcGxhdGXjgaflrqPoqIDjgZfjgZ/jg4bjg7Pjg5fjg6zjg7zjg4jjga5pZOWxnuaAp+OBruWApOOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqICAgW2VuXVByb21pc2Ugb2JqZWN0IHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGRpYWxvZyBjb21wb25lbnQgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgpLop6PmsbrjgZnjgotQcm9taXNl44Kq44OW44K444Kn44Kv44OI44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dQ3JlYXRlIGEgZGlhbG9nIGluc3RhbmNlIGZyb20gYSB0ZW1wbGF0ZS5bL2VuXVxuICogICBbamFd44OG44Oz44OX44Os44O844OI44GL44KJ44OA44Kk44Ki44Ot44Kw44Gu44Kk44Oz44K544K/44Oz44K544KS55Sf5oiQ44GX44G+44GZ44CCWy9qYV1cbiAqL1xub25zLmNyZWF0ZURpYWxvZyA9IG9ucy5fY3JlYXRlRGlhbG9nT3JpZ2luYWw7XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmxpbmtdXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICovXG5vbnMuX2NyZWF0ZUFsZXJ0RGlhbG9nT3JpZ2luYWwgPSBmdW5jdGlvbihwYWdlLCBvcHRpb25zID0ge30pIHtcblxuICBpZiAoIXBhZ2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhZ2UgdXJsIG11c3QgYmUgZGVmaW5lZC4nKTtcbiAgfVxuXG4gIHJldHVybiBvbnMuX2ludGVybmFsLmdldFBhZ2VIVE1MQXN5bmMocGFnZSkudGhlbihodG1sID0+IHtcbiAgICBodG1sID0gaHRtbC5tYXRjaCgvPG9ucy1hbGVydC1kaWFsb2cvZ2kpID8gYDxkaXY+JHtodG1sfTwvZGl2PmAgOiBgPG9ucy1hbGVydC1kaWFsb2c+JHtodG1sfTwvb25zLWFsZXJ0LWRpYWxvZz5gO1xuICAgIGNvbnN0IGRpdiA9IG9ucy5fdXRpbC5jcmVhdGVFbGVtZW50KCc8ZGl2PicgKyBodG1sICsgJzwvZGl2PicpO1xuXG4gICAgY29uc3QgYWxlcnREaWFsb2cgPSBkaXYucXVlcnlTZWxlY3Rvcignb25zLWFsZXJ0LWRpYWxvZycpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYWxlcnREaWFsb2cpO1xuXG4gICAgaWYgKG9wdGlvbnMubGluayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICBvcHRpb25zLmxpbmsoYWxlcnREaWFsb2cpO1xuICAgIH1cblxuICAgIHJldHVybiBhbGVydERpYWxvZztcbiAgfSk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgY3JlYXRlQWxlcnREaWFsb2dcbiAqIEBzaWduYXR1cmUgY3JlYXRlQWxlcnREaWFsb2cocGFnZSwgW29wdGlvbnNdKVxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAqICAgW2VuXVBhZ2UgbmFtZS4gQ2FuIGJlIGVpdGhlciBhbiBIVE1MIGZpbGUgb3IgYW4gPG9ucy10ZW1wbGF0ZT4gY29udGFpbmluZyBhIDxvbnMtYWxlcnQtZGlhbG9nPiBjb21wb25lbnQuWy9lbl1cbiAqICAgW2phXXBhZ2Xjga5VUkzjgYvjgIHjgoLjgZfjgY/jga9vbnMtdGVtcGxhdGXjgaflrqPoqIDjgZfjgZ/jg4bjg7Pjg5fjg6zjg7zjg4jjga5pZOWxnuaAp+OBruWApOOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqICAgW2VuXVByb21pc2Ugb2JqZWN0IHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGFsZXJ0IGRpYWxvZyBjb21wb25lbnQgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgpLop6PmsbrjgZnjgotQcm9taXNl44Kq44OW44K444Kn44Kv44OI44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dQ3JlYXRlIGEgYWxlcnQgZGlhbG9nIGluc3RhbmNlIGZyb20gYSB0ZW1wbGF0ZS5bL2VuXVxuICogICBbamFd44OG44Oz44OX44Os44O844OI44GL44KJ44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44Gu44Kk44Oz44K544K/44Oz44K544KS55Sf5oiQ44GX44G+44GZ44CCWy9qYV1cbiAqL1xub25zLmNyZWF0ZUFsZXJ0RGlhbG9nID0gb25zLl9jcmVhdGVBbGVydERpYWxvZ09yaWdpbmFsO1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaW5rXG4gKi9cbm9ucy5fcmVzb2x2ZUxvYWRpbmdQbGFjZWhvbGRlck9yaWdpbmFsID0gZnVuY3Rpb24ocGFnZSwgbGluaykge1xuICBjb25zdCBlbGVtZW50cyA9IG9ucy5fdXRpbC5hcnJheUZyb20od2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tvbnMtbG9hZGluZy1wbGFjZWhvbGRlcl0nKSk7XG5cbiAgaWYgKGVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICBlbGVtZW50c1xuICAgICAgLmZpbHRlcihlbGVtZW50ID0+ICFlbGVtZW50LmdldEF0dHJpYnV0ZSgncGFnZScpKVxuICAgICAgLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdvbnMtbG9hZGluZy1wbGFjZWhvbGRlcicsIHBhZ2UpO1xuICAgICAgICBvbnMuX3Jlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXIoZWxlbWVudCwgcGFnZSwgbGluayk7XG4gICAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG9ucy1sb2FkaW5nLXBsYWNlaG9sZGVyIGV4aXN0cy4nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAbWV0aG9kIHJlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXJcbiAqIEBzaWduYXR1cmUgcmVzb2x2ZUxvYWRpbmdQbGFjZWhvbGRlcihwYWdlKVxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAqICAgW2VuXVBhZ2UgbmFtZS4gQ2FuIGJlIGVpdGhlciBhbiBIVE1MIGZpbGUgb3IgYW4gPG9ucy10ZW1wbGF0ZT4gZWxlbWVudC5bL2VuXVxuICogICBbamFdcGFnZeOBrlVSTOOBi+OAgeOCguOBl+OBj+OBr29ucy10ZW1wbGF0ZeOBp+Wuo+iogOOBl+OBn+ODhuODs+ODl+ODrOODvOODiOOBrmlk5bGe5oCn44Gu5YCk44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dSWYgbm8gcGFnZSBpcyBkZWZpbmVkIGZvciB0aGUgYG9ucy1sb2FkaW5nLXBsYWNlaG9sZGVyYCBhdHRyaWJ1dGUgaXQgd2lsbCB3YWl0IGZvciB0aGlzIG1ldGhvZCBiZWluZyBjYWxsZWQgYmVmb3JlIGxvYWRpbmcgdGhlIHBhZ2UuWy9lbl1cbiAqICAgW2phXW9ucy1sb2FkaW5nLXBsYWNlaG9sZGVy44Gu5bGe5oCn5YCk44Go44GX44Gm44Oa44O844K444GM5oyH5a6a44GV44KM44Gm44GE44Gq44GE5aC05ZCI44Gv44CB44Oa44O844K444Ot44O844OJ5YmN44Gr5ZG844Gw44KM44KLb25zLnJlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXLlh6bnkIbjgYzooYzjgo/jgozjgovjgb7jgafooajnpLrjgZXjgozjgb7jgZvjgpPjgIJbL2phXVxuICovXG5vbnMucmVzb2x2ZUxvYWRpbmdQbGFjZWhvbGRlciA9IG9ucy5fcmVzb2x2ZUxvYWRpbmdQbGFjZWhvbGRlck9yaWdpbmFsO1xuXG5vbnMuX3NldHVwTG9hZGluZ1BsYWNlSG9sZGVycyA9IGZ1bmN0aW9uKCkge1xuICBvbnMucmVhZHkoKCkgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gb25zLl91dGlsLmFycmF5RnJvbSh3aW5kb3cuZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW29ucy1sb2FkaW5nLXBsYWNlaG9sZGVyXScpKTtcblxuICAgIGVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICBjb25zdCBwYWdlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ29ucy1sb2FkaW5nLXBsYWNlaG9sZGVyJyk7XG4gICAgICBpZiAodHlwZW9mIHBhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9ucy5fcmVzb2x2ZUxvYWRpbmdQbGFjZWhvbGRlcihlbGVtZW50LCBwYWdlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59O1xuXG5vbnMuX3Jlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXIgPSBmdW5jdGlvbihlbGVtZW50LCBwYWdlLCBsaW5rKSB7XG4gIGxpbmsgPSBsaW5rIHx8IGZ1bmN0aW9uKGVsZW1lbnQsIGRvbmUpIHsgZG9uZSgpOyB9O1xuICBvbnMuX2ludGVybmFsLmdldFBhZ2VIVE1MQXN5bmMocGFnZSkudGhlbihodG1sID0+IHtcblxuICAgIHdoaWxlIChlbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQ2hpbGQoZWxlbWVudC5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb250ZW50RWxlbWVudCA9IG9ucy5fdXRpbC5jcmVhdGVFbGVtZW50KCc8ZGl2PicgKyBodG1sICsgJzwvZGl2PicpO1xuICAgIGNvbnRlbnRFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICBlbGVtZW50LmFwcGVuZENoaWxkKGNvbnRlbnRFbGVtZW50KTtcblxuICAgIGxpbmsoY29udGVudEVsZW1lbnQsIGZ1bmN0aW9uKCkge1xuICAgICAgY29udGVudEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgIH0pO1xuXG4gIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZWQgdG8gcmVzb2x2ZSBwbGFjZWhvbGRlcjogJyArIGVycm9yKTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiB3YWl0RGV2aWNlUmVhZHkoKSB7XG4gIGNvbnN0IHVubG9ja0RldmljZVJlYWR5ID0gb25zLl9yZWFkeUxvY2subG9jaygpO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsICgpID0+IHtcbiAgICBpZiAob25zLmlzV2ViVmlldygpKSB7XG4gICAgICB3aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZGV2aWNlcmVhZHknLCB1bmxvY2tEZXZpY2VSZWFkeSwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1bmxvY2tEZXZpY2VSZWFkeSgpO1xuICAgIH1cbiAgfSwgZmFsc2UpO1xufVxuXG53aW5kb3cuX3N1cGVyU2VjcmV0T25zID0gb25zO1xuZXhwb3J0IGRlZmF1bHQgb25zO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuZnVuY3Rpb24gZ2V0RWxlbWVudENsYXNzKCkge1xuICBpZiAodHlwZW9mIEhUTUxFbGVtZW50ICE9PSAnZnVuY3Rpb24nKSB7IC8vIGNhc2Ugb2YgU2FmYXJpXG4gICAgY29uc3QgQmFzZUVsZW1lbnQgPSAoKSA9PiB7fTtcbiAgICBCYXNlRWxlbWVudC5wcm90b3R5cGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICByZXR1cm4gQmFzZUVsZW1lbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEhUTUxFbGVtZW50O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2VFbGVtZW50IGV4dGVuZHMgZ2V0RWxlbWVudENsYXNzKCkge1xuICBjb25zdHJ1Y3RvcihzZWxmKSB7XG4gICAgc2VsZiA9IHN1cGVyKHNlbGYpO1xuICAgIHNlbGYuaW5pdCgpO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG5cbiAgaW5pdCgpIHsgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy10ZW1wbGF0ZVxuICogQGNhdGVnb3J5IHV0aWxcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgRGVmaW5lIGEgc2VwYXJhdGUgSFRNTCBmcmFnbWVudCBhbmQgdXNlIGFzIGEgdGVtcGxhdGUuXG4gKlxuICogICAgIFRoZXNlIHRlbXBsYXRlcyBjYW4gYmUgbG9hZGVkIGFzIHBhZ2VzIGluIGA8b25zLW5hdmlnYXRvcj5gLCBgPG9ucy10YWJiYXI+YCBhbmQgYDxvbnMtc3BsaXR0ZXI+YC4gVGhleSBjYW4gYWxzbyBiZSB1c2VkIHRvIGdlbmVyYXRlIGRpYWxvZ3MuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV3jg4bjg7Pjg5fjg6zjg7zjg4jjgajjgZfjgabkvb/nlKjjgZnjgovjgZ/jgoHjga5IVE1M44OV44Op44Kw44Oh44Oz44OI44KS5a6a576p44GX44G+44GZ44CC44GT44Gu6KaB57Sg44GnSFRNTOOCkuWuo+iogOOBmeOCi+OBqOOAgWlk5bGe5oCn44Gr5oyH5a6a44GX44Gf5ZCN5YmN44KScGFnZeOBrlVSTOOBqOOBl+OBpm9ucy1uYXZpZ2F0b3Ljgarjganjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgYvjgonlj4LnhafjgafjgY3jgb7jgZnjgIJbL2phXVxuICogQGd1aWRlIHRlbXBsYXRlc1xuICogICBbZW5dRGVmaW5pbmcgbXVsdGlwbGUgcGFnZXMgaW4gc2luZ2xlIGh0bWxbL2VuXVxuICogICBbamFd6KSH5pWw44Gu44Oa44O844K444KSMeOBpOOBrkhUTUzjgavoqJjov7DjgZnjgotbL2phXVxuICogQHNlZWFsc28gb25zLW5hdmlnYXRvclxuICogICBbZW5dVGhlIGA8b25zLW5hdmlnYXRvcj5gIGNvbXBvbmVudCBlbmFibGVzIHN0YWNrIGJhc2VkIG5hdmlnYXRpb24uWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtdGFiYmFyXG4gKiAgIFtlbl1UaGUgYDxvbnMtdGFiYmFyPmAgY29tcG9uZW50IGlzIHVzZWQgdG8gYWRkIHRhYiBuYXZpZ2F0aW9uLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLXNwbGl0dGVyXG4gKiAgIFtlbl1UaGUgYDxvbnMtc3BsaXR0ZXI+YCBjb21wb25lbnQgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGEgZHJhZ2dhYmxlIG1lbnUgb3IgY29sdW1uIGJhc2VkIGxheW91dC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXRlbXBsYXRlIGlkPVwiZm9vYmFyLmh0bWxcIj5cbiAqICAgPG9ucy1wYWdlPlxuICogICAgIFBhZ2UgY29udGVudFxuICogICA8L29ucy1wYWdlPlxuICogPC9vbnMtdGVtcGxhdGU+XG4gKlxuICogPG9ucy1uYXZpZ2F0b3IgcGFnZT1cImZvb2Jhci5odG1sXCI+XG4gKiA8L29ucy1uYXZpZ2F0b3I+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRlbXBsYXRlRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQHByb3BlcnR5IHRlbXBsYXRlXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRlbXBsYXRlIGNvbnRlbnQuIFRoaXMgcHJvcGVydHkgY2FuIG5vdCBiZSB1c2VkIHdpdGggQW5ndWxhckpTIGJpbmRpbmdzLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLnRlbXBsYXRlID0gdGhpcy5pbm5lckhUTUw7XG5cbiAgICB3aGlsZSAodGhpcy5maXJzdENoaWxkKSB7XG4gICAgICB0aGlzLnJlbW92ZUNoaWxkKHRoaXMuZmlyc3RDaGlsZCk7XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdmFyIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdfdGVtcGxhdGVsb2FkZWQnLCB7YnViYmxlczogdHJ1ZSwgY2FuY2VsYWJsZTogdHJ1ZX0pO1xuICAgIGV2ZW50LnRlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZTtcbiAgICBldmVudC50ZW1wbGF0ZUlkID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXRlbXBsYXRlJywgVGVtcGxhdGVFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvcmllbnRhdGlvbiBmcm9tICdvbnMvb3JpZW50YXRpb24nO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJ29ucy9wbGF0Zm9ybSc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJ29ucy9jb250ZW50LXJlYWR5JztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtaWZcbiAqIEBjYXRlZ29yeSBjb25kaXRpb25hbFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2lmXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIENvbmRpdGlvbmFsbHkgZGlzcGxheSBjb250ZW50IGRlcGVuZGluZyBvbiB0aGUgcGxhdGZvcm0sIGRldmljZSBvcmllbnRhdGlvbiBvciBib3RoLlxuICpcbiAqICAgICBTb21ldGltZXMgaXQgaXMgdXNlZnVsIHRvIGNvbmRpdGlvbmFsbHkgaGlkZSBvciBzaG93IGNlcnRhaW4gY29tcG9uZW50cyBiYXNlZCBvbiBwbGF0Zm9ybS4gV2hlbiBydW5uaW5nIG9uIGlPUyB0aGUgYDxvbnMtaWY+YCBlbGVtZW50IGNhbiBiZSB1c2VkIHRvIGhpZGUgdGhlIGA8b25zLWZhYj5gIGVsZW1lbnQuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGd1aWRlIGNyb3NzLXBsYXRmb3JtLXN0eWxpbmcgW2VuXUluZm9ybWF0aW9uIGFib3V0IGNyb3NzIHBsYXRmb3JtIHN0eWxpbmdbL2VuXVtqYV1JbmZvcm1hdGlvbiBhYm91dCBjcm9zcyBwbGF0Zm9ybSBzdHlsaW5nWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXBhZ2U+XG4gKiAgIDxvbnMtaWYgb3JpZW50YXRpb249XCJsYW5kc2NhcGVcIj5cbiAqICAgICBMYW5kc2NhcGUgdmlldyFcbiAqICAgPC9vbnMtaWY+XG4gKiAgIDxvbnMtaWYgcGxhdGZvcm09XCJhbmRyb2lkXCI+XG4gKiAgICAgVGhpcyBpcyBBbmRyb2lkLlxuICogICA8L29ucy1pZj5cbiAqICAgPG9ucy1pZiBwbGF0Zm9ybT1cImlvcyBvdGhlclwiPlxuICogICAgIFRoaXMgaXMgbm90IEFuZHJvaWQuXG4gKiAgIDwvb25zLWlmPlxuICogPC9vbnMtcGFnZT5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSWZFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHBsYXRmb3JtXG4gICAqIEBpbml0b25seVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGFjZS1zZXBhcmF0ZWQgcGxhdGZvcm0gbmFtZXMuIFBvc3NpYmxlIHZhbHVlcyBhcmUgYFwiaW9zXCJgLCBgXCJhbmRyb2lkXCJgLCBgXCJ3aW5kb3dzXCJgIGFuZCBgXCJvdGhlclwiYC5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG9yaWVudGF0aW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUVpdGhlciBgXCJwb3J0cmFpdFwiYCBvciBgXCJsYW5kc2NhcGVcImAuWy9lbl1cbiAgICogIFtqYV1wb3J0cmFpdOOCguOBl+OBj+OBr2xhbmRzY2FwZeOCkuaMh+WumuOBl+OBvuOBmVsvamFdXG4gICAqL1xuXG4gIGluaXQoKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIGlmIChwbGF0Zm9ybS5fcmVuZGVyUGxhdGZvcm0gIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fcGxhdGZvcm1VcGRhdGUoKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2lzQWxsb3dlZFBsYXRmb3JtKCkpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuY2hpbGROb2Rlc1swXSkge1xuICAgICAgICAgIHRoaXMuY2hpbGROb2Rlc1swXS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wbGF0Zm9ybVVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5fb25PcmllbnRhdGlvbkNoYW5nZSgpO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgb3JpZW50YXRpb24ub24oJ2NoYW5nZScsIHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UuYmluZCh0aGlzKSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydvcmllbnRhdGlvbiddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUpIHtcbiAgICBpZiAobmFtZSA9PT0gJ29yaWVudGF0aW9uJykge1xuICAgICAgdGhpcy5fb25PcmllbnRhdGlvbkNoYW5nZSgpO1xuICAgIH1cbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIG9yaWVudGF0aW9uLm9mZignY2hhbmdlJywgdGhpcy5fb25PcmllbnRhdGlvbkNoYW5nZSk7XG4gIH1cblxuICBfcGxhdGZvcm1VcGRhdGUoKSB7XG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gdGhpcy5faXNBbGxvd2VkUGxhdGZvcm0oKSA/ICcnIDogJ25vbmUnO1xuICB9XG5cbiAgX2lzQWxsb3dlZFBsYXRmb3JtKCkge1xuICAgIHJldHVybiAhdGhpcy5nZXRBdHRyaWJ1dGUoJ3BsYXRmb3JtJykgfHwgdGhpcy5nZXRBdHRyaWJ1dGUoJ3BsYXRmb3JtJykuc3BsaXQoL1xccysvKS5pbmRleE9mKHBsYXRmb3JtLmdldE1vYmlsZU9TKCkpID49IDA7XG4gIH1cblxuICBfb25PcmllbnRhdGlvbkNoYW5nZSgpIHtcbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ29yaWVudGF0aW9uJykgJiYgdGhpcy5faXNBbGxvd2VkUGxhdGZvcm0oKSkge1xuICAgICAgY29uc3QgY29uZGl0aW9uYWxPcmllbnRhdGlvbiA9IHRoaXMuZ2V0QXR0cmlidXRlKCdvcmllbnRhdGlvbicpLnRvTG93ZXJDYXNlKCk7XG4gICAgICBjb25zdCBjdXJyZW50T3JpZW50YXRpb24gPSBvcmllbnRhdGlvbi5pc1BvcnRyYWl0KCkgPyAncG9ydHJhaXQnIDogJ2xhbmRzY2FwZSc7XG5cbiAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9IChjb25kaXRpb25hbE9yaWVudGF0aW9uID09PSBjdXJyZW50T3JpZW50YXRpb24pID8gJycgOiAnbm9uZSc7XG4gICAgfVxuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWlmJywgSWZFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmV4cG9ydCBjbGFzcyBBbGVydERpYWxvZ0FuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2xpbmVhcicsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjJ9ID0ge30pIHtcbiAgICB0aGlzLnRpbWluZyA9IHRpbWluZztcbiAgICB0aGlzLmRlbGF5ID0gZGVsYXk7XG4gICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBzaG93KGRpYWxvZywgZG9uZSkge1xuICAgIGRvbmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgaGlkZShkaWFsb2csIGRvbmUpIHtcbiAgICBkb25lKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBbmRyb2lkIHN0eWxlIGFuaW1hdG9yIGZvciBhbGVydCBkaWFsb2cuXG4gKi9cbmV4cG9ydCBjbGFzcyBBbmRyb2lkQWxlcnREaWFsb2dBbmltYXRvciBleHRlbmRzIEFsZXJ0RGlhbG9nQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnY3ViaWMtYmV6aWVyKC4xLCAuNywgLjQsIDEpJywgZHVyYXRpb24gPSAwLjIsIGRlbGF5ID0gMH0gPSB7fSkge1xuICAgIHN1cGVyKHtkdXJhdGlvbiwgdGltaW5nLCBkZWxheX0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHNob3coZGlhbG9nLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX2RpYWxvZylcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKSBzY2FsZTNkKDAuOSwgMC45LCAxLjApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApIHNjYWxlM2QoMS4wLCAxLjAsIDEuMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2spXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fZGlhbG9nKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApIHNjYWxlM2QoMS4wLCAxLjAsIDEuMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTUwJSwgMCkgc2NhbGUzZCgwLjksIDAuOSwgMS4wKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIGlPUyBzdHlsZSBhbmltYXRvciBmb3IgYWxlcnQgZGlhbG9nLlxuICovXG5leHBvcnQgY2xhc3MgSU9TQWxlcnREaWFsb2dBbmltYXRvciBleHRlbmRzIEFsZXJ0RGlhbG9nQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnY3ViaWMtYmV6aWVyKC4xLCAuNywgLjQsIDEpJywgZHVyYXRpb24gPSAwLjIsIGRlbGF5ID0gMH0gPSB7fSkge1xuICAgIHN1cGVyKHtkdXJhdGlvbiwgdGltaW5nLCBkZWxheX0pO1xuICB9XG5cbiAgLypcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgc2hvdyhkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2spXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fZGlhbG9nKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApIHNjYWxlM2QoMS4zLCAxLjMsIDEuMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMC4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTUwJSwgMCkgc2NhbGUzZCgxLjAsIDEuMCwgMS4wKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBoaWRlKGRpYWxvZywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaylcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9kaWFsb2cpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgb3BhY2l0eTogMC4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuXG4gICAgKTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICdvbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEFuaW1hdG9yRmFjdG9yeSBmcm9tICdvbnMvaW50ZXJuYWwvYW5pbWF0b3ItZmFjdG9yeSc7XG5pbXBvcnQge0FsZXJ0RGlhbG9nQW5pbWF0b3IsIElPU0FsZXJ0RGlhbG9nQW5pbWF0b3IsIEFuZHJvaWRBbGVydERpYWxvZ0FuaW1hdG9yfSBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICdvbnMvcGxhdGZvcm0nO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyIGZyb20gJ29ucy9kZXZpY2UtYmFjay1idXR0b24tZGlzcGF0Y2hlcic7XG5pbXBvcnQgRG9vckxvY2sgZnJvbSAnb25zL2Rvb3Jsb2NrJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcuYWxlcnQtZGlhbG9nJzogJ2FsZXJ0LWRpYWxvZy0tKicsXG4gICcuYWxlcnQtZGlhbG9nLWNvbnRhaW5lcic6ICdhbGVydC1kaWFsb2ctY29udGFpbmVyLS0qJyxcbiAgJy5hbGVydC1kaWFsb2ctdGl0bGUnOiAnYWxlcnQtZGlhbG9nLXRpdGxlLS0qJyxcbiAgJy5hbGVydC1kaWFsb2ctY29udGVudCc6ICdhbGVydC1kaWFsb2ctY29udGVudC0tKicsXG4gICcuYWxlcnQtZGlhbG9nLWZvb3Rlcic6ICdhbGVydC1kaWFsb2ctZm9vdGVyLS0qJyxcbiAgJy5hbGVydC1kaWFsb2ctYnV0dG9uJzogJ2FsZXJ0LWRpYWxvZy1idXR0b24tLSonLFxuICAnLmFsZXJ0LWRpYWxvZy1mb290ZXItLW9uZSc6ICdhbGVydC1kaWFsb2ctZm9vdGVyLS1vbmUtLSonLFxuICAnLmFsZXJ0LWRpYWxvZy1idXR0b24tLW9uZSc6ICdhbGVydC1kaWFsb2ctYnV0dG9uLS1vbmUtLSonLFxuICAnLmFsZXJ0LWRpYWxvZy1idXR0b24tLXByaW1hbCc6ICdhbGVydC1kaWFsb2ctYnV0dG9uLS1wcmltYWwtLSonLFxuICAnLmFsZXJ0LWRpYWxvZy1tYXNrJzogJ2FsZXJ0LWRpYWxvZy1tYXNrLS0qJ1xufTtcblxuY29uc3QgX2FuaW1hdG9yRGljdCA9IHtcbiAgJ25vbmUnOiBBbGVydERpYWxvZ0FuaW1hdG9yLFxuICAnZGVmYXVsdCc6ICgpID0+IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gQW5kcm9pZEFsZXJ0RGlhbG9nQW5pbWF0b3IgOiBJT1NBbGVydERpYWxvZ0FuaW1hdG9yLFxuICAnZmFkZSc6ICgpID0+IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gQW5kcm9pZEFsZXJ0RGlhbG9nQW5pbWF0b3IgOiBJT1NBbGVydERpYWxvZ0FuaW1hdG9yXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1hbGVydC1kaWFsb2dcbiAqIEBjYXRlZ29yeSBkaWFsb2dcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgQWxlcnQgZGlhbG9nIHRoYXQgaXMgZGlzcGxheWVkIG9uIHRvcCBvZiB0aGUgY3VycmVudCBzY3JlZW4uIFVzZWZ1bCBmb3IgZGlzcGxheWluZyBxdWVzdGlvbnMsIHdhcm5pbmdzIG9yIGVycm9yIG1lc3NhZ2VzIHRvIHRoZSB1c2VyLiBUaGUgdGl0bGUsIGNvbnRlbnQgYW5kIGJ1dHRvbnMgY2FuIGJlIGVhc2lseSBjdXN0b21pemVkIGFuZCBpdCB3aWxsIGF1dG9tYXRpY2FsbHkgc3dpdGNoIHN0eWxlIGJhc2VkIG9uIHRoZSBwbGF0Zm9ybS5cbiAqXG4gKiAgICAgVG8gdXNlIHRoZSBlbGVtZW50IGl0IGNhbiBlaXRoZXIgYmUgYXR0YWNoZWQgZGlyZWN0bHkgdG8gdGhlIGA8Ym9keT5gIGVsZW1lbnQgb3IgZHluYW1pY2FsbHkgY3JlYXRlZCBmcm9tIGEgdGVtcGxhdGUgdXNpbmcgdGhlIGBvbnMuY3JlYXRlQWxlcnREaWFsb2codGVtcGxhdGUpYCB1dGlsaXR5IGZ1bmN0aW9uIGFuZCB0aGUgYDxvbnMtdGVtcGxhdGU+YCB0YWcuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGNvZGVwZW4gUXd3eHlwXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvZGlhbG9nXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiBzdHlsZVsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGd1aWRlIGRpYWxvZ3NcbiAqICAgW2VuXURpYWxvZyBjb21wb25lbnRzWy9lbl1cbiAqICAgW2phXURpYWxvZyBjb21wb25lbnRzWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1kaWFsb2dcbiAqICAgW2VuXW9ucy1kaWFsb2cgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1kaWFsb2fjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLXBvcG92ZXJcbiAqICAgW2VuXW9ucy1wb3BvdmVyIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtZGlhbG9n44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy5ub3RpZmljYXRpb25cbiAqICAgW2VuXVVzaW5nIG9ucy5ub3RpZmljYXRpb24gdXRpbGl0eSBmdW5jdGlvbnMuWy9lbl1cbiAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOCkuihqOekuuOBmeOCi+OBq+OBr+OAgW9ucy5ub3RpZmljYXRpb27jgqrjg5bjgrjjgqfjgq/jg4jjga7jg6Hjgr3jg4Pjg4njgpLkvb/jgYbjgZPjgajjgoLjgafjgY3jgb7jgZnjgIJbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtYWxlcnQtZGlhbG9nIGlkPVwiYWxlcnQtZGlhbG9nXCI+XG4gKiAgIDxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2ctdGl0bGVcIj5XYXJuaW5nITwvZGl2PlxuICogICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLWNvbnRlbnRcIj5cbiAqICAgICBBbiBlcnJvciBoYXMgb2NjdXJyZWQhXG4gKiAgIDwvZGl2PlxuICogICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLWZvb3RlclwiPlxuICogICAgIDxidXR0b24gaWQ9XCJhbGVydC1kaWFsb2ctYnV0dG9uXCIgY2xhc3M9XCJhbGVydC1kaWFsb2ctYnV0dG9uXCI+T0s8L2J1dHRvbj5cbiAqICAgPC9kaXY+XG4gKiA8L29ucy1hbGVydC1kaWFsb2c+XG4gKiA8c2NyaXB0PlxuICogICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYWxlcnQtZGlhbG9nJykuc2hvdygpO1xuICogPC9zY3JpcHQ+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFsZXJ0RGlhbG9nRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGV2ZW50IHByZXNob3dcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYmVmb3JlIHRoZSBhbGVydCBkaWFsb2cgaXMgZGlzcGxheWVkLlsvZW5dXG4gICAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBjOihqOekuuOBleOCjOOCi+ebtOWJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5hbGVydERpYWxvZ1xuICAgKiAgIFtlbl1BbGVydCBkaWFsb2cgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LmNhbmNlbFxuICAgKiAgIFtlbl1FeGVjdXRlIHRvIHN0b3AgdGhlIGRpYWxvZyBmcm9tIHNob3dpbmcuWy9lbl1cbiAgICogICBbamFd44GT44Gu6Zai5pWw44KS5a6f6KGM44GZ44KL44Go44CB44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44Gu6KGo56S644KS5q2i44KB44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0c2hvd1xuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgYWxlcnQgZGlhbG9nIGlzIGRpc3BsYXllZC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgYzooajnpLrjgZXjgozjgZ/nm7TlvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuYWxlcnREaWFsb2dcbiAgICogICBbZW5dQWxlcnQgZGlhbG9nIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHByZWhpZGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYmVmb3JlIHRoZSBhbGVydCBkaWFsb2cgaXMgaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBjOmaoOOCjOOCi+ebtOWJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5hbGVydERpYWxvZ1xuICAgKiAgIFtlbl1BbGVydCBkaWFsb2cgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LmNhbmNlbFxuICAgKiAgIFtlbl1FeGVjdXRlIHRvIHN0b3AgdGhlIGRpYWxvZyBmcm9tIGhpZGluZy5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlrp/ooYzjgZnjgovjgajjgIHjgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgYzplonjgZjjgojjgYbjgajjgZnjgovjga7jgpLmraLjgoHjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RoaWRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgYWxlcnQgZGlhbG9nIGlzIGhpZGRlbi5bL2VuXVxuICAgKiBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44GM6Zqg44KM44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmFsZXJ0RGlhbG9nXG4gICAqICAgW2VuXUFsZXJ0IGRpYWxvZyBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGRpYWxvZy5bL2VuXVxuICAgKiAgW2phXeODgOOCpOOCouODreOCsOOBruimi+OBn+ebruOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGNhbmNlbGFibGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBkaWFsb2cgY2FuIGJlIGNsb3NlZCBieSB0YXBwaW5nIHRoZSBiYWNrZ3JvdW5kIG9yIGJ5IHByZXNzaW5nIHRoZSBiYWNrIGJ1dHRvbiBvbiBBbmRyb2lkIGRldmljZXMuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXNhYmxlZFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGRpYWxvZyBpcyBkaXNhYmxlZC5bL2VuXVxuICAgKiAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBr2Rpc2FibGVk54q25oWL44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IGRlZmF1bHRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIGFuaW1hdGlvbiB1c2VkIHdoZW4gc2hvd2luZyBhbmQgaGlkaW5nIHRoZSBkaWFsb2cuIENhbiBiZSBlaXRoZXIgYFwibm9uZVwiYCBvciBgXCJkZWZhdWx0XCJgLlsvZW5dXG4gICAqICBbamFd44OA44Kk44Ki44Ot44Kw44KS6KGo56S644GZ44KL6Zqb44Gu44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CC44OH44OV44Kp44Or44OI44Gn44GvXCJub25lXCLjgYtcImRlZmF1bHRcIuOBjOaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvbi1vcHRpb25zXG4gICAqIEB0eXBlIHtFeHByZXNzaW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgdGltaW5nIGFuZCBkZWxheSB3aXRoIGFuIG9iamVjdCBsaXRlcmFsLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgdGltaW5nLCBkZWxheeOCkuOCquODluOCuOOCp+OCr+ODiOODquODhuODqeODq+OBp+aMh+WumuOBl+OBvuOBmeOAguS+i++8mntkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbWFzay1jb2xvclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCByZ2JhKDAsIDAsIDAsIDAuMilcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dQ29sb3Igb2YgdGhlIGJhY2tncm91bmQgbWFzay4gRGVmYXVsdCBpcyBcInJnYmEoMCwgMCwgMCwgMC4yKVwiLlsvZW5dXG4gICAqICBbamFd6IOM5pmv44Gu44Oe44K544Kv44Gu6Imy44KS5oyH5a6a44GX44G+44GZ44CCXCJyZ2JhKDAsIDAsIDAsIDAuMilcIuOBjOODh+ODleOCqeODq+ODiOWApOOBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIGluaXQoKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX2NvbXBpbGUoKSk7XG5cbiAgICB0aGlzLl92aXNpYmxlID0gZmFsc2U7XG4gICAgdGhpcy5fZG9vckxvY2sgPSBuZXcgRG9vckxvY2soKTtcbiAgICB0aGlzLl9ib3VuZENhbmNlbCA9IHRoaXMuX2NhbmNlbC5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5fdXBkYXRlQW5pbWF0b3JGYWN0b3J5KClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKi9cbiAgZ2V0IF9tYXNrKCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLmFsZXJ0LWRpYWxvZy1tYXNrJyk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICovXG4gIGdldCBfZGlhbG9nKCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLmFsZXJ0LWRpYWxvZycpO1xuXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICovXG4gIGdldCBfdGl0bGVFbGVtZW50KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLl9kaWFsb2cuY2hpbGRyZW5bMF0sICcuYWxlcnQtZGlhbG9nLXRpdGxlJyk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICovXG4gIGdldCBfY29udGVudEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMuX2RpYWxvZy5jaGlsZHJlblswXSwgJy5hbGVydC1kaWFsb2ctY29udGVudCcpO1xuICB9XG5cbiAgX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpIHtcbiAgICB0aGlzLl9hbmltYXRvckZhY3RvcnkgPSBuZXcgQW5pbWF0b3JGYWN0b3J5KHtcbiAgICAgIGFuaW1hdG9yczogX2FuaW1hdG9yRGljdCxcbiAgICAgIGJhc2VDbGFzczogQWxlcnREaWFsb2dBbmltYXRvcixcbiAgICAgIGJhc2VDbGFzc05hbWU6ICdBbGVydERpYWxvZ0FuaW1hdG9yJyxcbiAgICAgIGRlZmF1bHRBbmltYXRpb246IHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24nKVxuICAgIH0pO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAvKipcbiAgICAgKiBFeHBlY3RlZCByZXN1bHQgYWZ0ZXIgY29tcGlsZTpcbiAgICAgKlxuICAgICAqIDxvbnMtYWxlcnQtZGlhbG9nIHN0eWxlPVwibm9uZVwiPlxuICAgICAqICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1tYXNrXCI+PC9kaXY+XG4gICAgICogICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nXCI+XG4gICAgICogICAgIDxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2ctY29udGFpbmVyXCI+Li4uPC9kaXY+XG4gICAgICogICA8L2Rpdj5cbiAgICAgKiA8L29ucy1hbGVydC1kaWFsb2c+XG4gICAgICovXG5cbiAgICBjb25zdCBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gICAgaWYgKCF0aGlzLl9tYXNrICYmICF0aGlzLl9kaWFsb2cpIHtcbiAgICAgIHdoaWxlICh0aGlzLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZCh0aGlzLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGhpcy5fbWFzaykge1xuICAgICAgY29uc3QgbWFzayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgbWFzay5jbGFzc0xpc3QuYWRkKCdhbGVydC1kaWFsb2ctbWFzaycpO1xuICAgICAgdGhpcy5pbnNlcnRCZWZvcmUobWFzaywgdGhpcy5jaGlsZHJlblswXSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9kaWFsb2cpIHtcbiAgICAgIGNvbnN0IGRpYWxvZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZGlhbG9nLmNsYXNzTGlzdC5hZGQoJ2FsZXJ0LWRpYWxvZycpO1xuICAgICAgdGhpcy5pbnNlcnRCZWZvcmUoZGlhbG9nLCBudWxsKTtcbiAgICB9XG5cbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKHRoaXMuX2RpYWxvZywgJy5hbGVydC1kaWFsb2ctY29udGFpbmVyJykpIHtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2FsZXJ0LWRpYWxvZy1jb250YWluZXInKTtcbiAgICAgIHRoaXMuX2RpYWxvZy5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgIH1cblxuICAgIHRoaXMuX2RpYWxvZy5jaGlsZHJlblswXS5hcHBlbmRDaGlsZChjb250ZW50KTtcblxuICAgIHRoaXMuX2RpYWxvZy5zdHlsZS56SW5kZXggPSAyMDAwMTtcbiAgICB0aGlzLl9tYXNrLnN0eWxlLnpJbmRleCA9IDIwMDAwO1xuXG4gICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlKCdtYXNrLWNvbG9yJykpIHtcbiAgICAgIHRoaXMuX21hc2suc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ21hc2stY29sb3InKTtcbiAgICB9XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBjYW5jZWxhYmxlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZGlhbG9nIGlzIGNhbmNlbGFibGUgb3Igbm90LiBBIGNhbmNlbGFibGUgZGlhbG9nIGNhbiBiZSBjbG9zZWQgYnkgdGFwcGluZyB0aGUgYmFja2dyb3VuZCBvciBieSBwcmVzc2luZyB0aGUgYmFjayBidXR0b24gb24gQW5kcm9pZCBkZXZpY2VzLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBzZXQgY2FuY2VsYWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnY2FuY2VsYWJsZScsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBjYW5jZWxhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnY2FuY2VsYWJsZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2hvd1xuICAgKiBAc2lnbmF0dXJlIHNob3coW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJmYWRlXCJgIGFuZCBgXCJub25lXCJgLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAguaMh+WumuOBp+OBjeOCi+OBruOBr+OAgVwiZmFkZVwiLCBcIm5vbmVcIuOBruOBhOOBmuOCjOOBi+OBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiAgYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiA8Y29kZT57ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9PC9jb2RlPiBbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dRnVuY3Rpb24gdG8gZXhlY3V0ZSBhZnRlciB0aGUgZGlhbG9nIGhhcyBiZWVuIHJldmVhbGVkLlsvZW5dXG4gICAqICAgW2phXeODgOOCpOOCouODreOCsOOBjOihqOekuuOBleOCjOe1guOCj+OBo+OBn+aZguOBq+WRvOOBs+WHuuOBleOCjOOCi+OCs+ODvOODq+ODkOODg+OCr+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IHRoZSBhbGVydCBkaWFsb2cuWy9lbl1cbiAgICogICBbamFd44OA44Kk44Ki44Ot44Kw44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dQSBgUHJvbWlzZWAgb2JqZWN0IHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGRpc3BsYXllZCBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBzaG93KG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBjYW5jZWwgPSBmYWxzZTtcbiAgICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcblxuICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyA9IHV0aWwuZXh0ZW5kKFxuICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9LFxuICAgICAgQW5pbWF0b3JGYWN0b3J5LnBhcnNlQW5pbWF0aW9uT3B0aW9uc1N0cmluZyh0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uLW9wdGlvbnMnKSlcbiAgICApO1xuXG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwcmVzaG93Jywge1xuICAgICAgYWxlcnREaWFsb2c6IHRoaXMsXG4gICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjYW5jZWwgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCFjYW5jZWwpIHtcbiAgICAgIGNvbnN0IHRyeVNob3cgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHVubG9jayA9IHRoaXMuX2Rvb3JMb2NrLmxvY2soKTtcbiAgICAgICAgY29uc3QgYW5pbWF0b3IgPSB0aGlzLl9hbmltYXRvckZhY3RvcnkubmV3QW5pbWF0b3Iob3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgdGhpcy5fbWFzay5zdHlsZS5vcGFjaXR5ID0gJzEnO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICAgICAgYW5pbWF0b3Iuc2hvdyh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuX3Zpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgICB1bmxvY2soKTtcblxuICAgICAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3Bvc3RzaG93Jywge2FsZXJ0RGlhbG9nOiB0aGlzfSk7XG5cbiAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgdGhpcy5fZG9vckxvY2sud2FpdFVubG9jaygoKSA9PiByZXNvbHZlKHRyeVNob3coKSkpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnQ2FuY2VsZWQgaW4gcHJlc2hvdyBldmVudC4nKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBoaWRlXG4gICAqIEBzaWduYXR1cmUgaGlkZShbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcImZhZGVcImAgYW5kIGBcIm5vbmVcImAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJmYWRlXCIsIFwibm9uZVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuICA8Y29kZT57ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9PC9jb2RlPlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiA8Y29kZT57ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9PC9jb2RlPiBbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dRnVuY3Rpb24gdG8gZXhlY3V0ZSBhZnRlciB0aGUgZGlhbG9nIGhhcyBiZWVuIGhpZGRlbi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7jg4DjgqTjgqLjg63jgrDjgYzplonjgZjjgZ/mmYLjgavlkbzjgbPlh7rjgZXjgozjgovjgrPjg7zjg6vjg5Djg4Pjgq/jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSGlkZSB0aGUgYWxlcnQgZGlhbG9nLlsvZW5dXG4gICAqICAgW2phXeODgOOCpOOCouODreOCsOOCkumWieOBmOOBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBoaWRkZW4gZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBoaWRlKG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBjYW5jZWwgPSBmYWxzZTtcbiAgICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcblxuICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyA9IHV0aWwuZXh0ZW5kKFxuICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9LFxuICAgICAgQW5pbWF0b3JGYWN0b3J5LnBhcnNlQW5pbWF0aW9uT3B0aW9uc1N0cmluZyh0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uLW9wdGlvbnMnKSlcbiAgICApO1xuXG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwcmVoaWRlJywge1xuICAgICAgYWxlcnREaWFsb2c6IHRoaXMsXG4gICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjYW5jZWwgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCFjYW5jZWwpIHtcbiAgICAgIGNvbnN0IHRyeUhpZGUgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHVubG9jayA9IHRoaXMuX2Rvb3JMb2NrLmxvY2soKTtcbiAgICAgICAgY29uc3QgYW5pbWF0b3IgPSB0aGlzLl9hbmltYXRvckZhY3RvcnkubmV3QW5pbWF0b3Iob3B0aW9ucyk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgICBhbmltYXRvci5oaWRlKHRoaXMsICgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICB0aGlzLl92aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgIHVubG9jaygpO1xuXG4gICAgICAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncG9zdGhpZGUnLCB7YWxlcnREaWFsb2c6IHRoaXN9KTtcblxuICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICByZXNvbHZlKHRoaXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICB0aGlzLl9kb29yTG9jay53YWl0VW5sb2NrKCgpID0+IHJlc29sdmUodHJ5SGlkZSgpKSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYW5jZWxlZCBpbiBwcmVoaWRlIGV2ZW50LicpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmlzaWJsZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBkaWFsb2cgaXMgdmlzaWJsZSBvciBub3QuWy9lbl1cbiAgICogICBbamFd6KaB57Sg44GM6KaL44GI44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl92aXNpYmxlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvbkRldmljZUJhY2tCdXR0b25cbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUJhY2stYnV0dG9uIGhhbmRsZXIuWy9lbl1cbiAgICogICBbamFd44OQ44OD44Kv44Oc44K/44Oz44OP44Oz44OJ44Op44CCWy9qYV1cbiAgICovXG4gIGdldCBvbkRldmljZUJhY2tCdXR0b24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyO1xuICB9XG5cbiAgc2V0IG9uRGV2aWNlQmFja0J1dHRvbihjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcikge1xuICAgICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyID0gZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIuY3JlYXRlSGFuZGxlcih0aGlzLCBjYWxsYmFjayk7XG4gIH1cblxuICBfY2FuY2VsKCkge1xuICAgIGlmICh0aGlzLmNhbmNlbGFibGUgJiYgIXRoaXMuX3J1bm5pbmcpIHtcbiAgICAgIHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xuICAgICAgdGhpcy5oaWRlKHtcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdkaWFsb2ctY2FuY2VsJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMub25EZXZpY2VCYWNrQnV0dG9uID0gZSA9PiB0aGlzLmNhbmNlbGFibGUgPyB0aGlzLl9jYW5jZWwoKSA6IGUuY2FsbFBhcmVudEhhbmRsZXIoKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9tYXNrLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRDYW5jZWwsIGZhbHNlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IG51bGw7XG5cbiAgICB0aGlzLl9tYXNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRDYW5jZWwuYmluZCh0aGlzKSwgZmFsc2UpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAnYW5pbWF0aW9uJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChuYW1lID09PSAnbW9kaWZpZXInKSB7XG4gICAgICByZXR1cm4gTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5hbWUgPT09ICdhbmltYXRpb24nKSB7XG4gICAgICB0aGlzLl91cGRhdGVBbmltYXRvckZhY3RvcnkoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtEaWFsb2dBbmltYXRvcn0gQW5pbWF0b3JcbiAgICovXG4gIHN0YXRpYyByZWdpc3RlckFuaW1hdG9yKG5hbWUsIEFuaW1hdG9yKSB7XG4gICAgaWYgKCEoQW5pbWF0b3IucHJvdG90eXBlIGluc3RhbmNlb2YgQWxlcnREaWFsb2dBbmltYXRvcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJBbmltYXRvclwiIHBhcmFtIG11c3QgaW5oZXJpdCBPbnNBbGVydERpYWxvZ0VsZW1lbnQuQWxlcnREaWFsb2dBbmltYXRvcicpO1xuICAgIH1cbiAgICBfYW5pbWF0b3JEaWN0W25hbWVdID0gQW5pbWF0b3I7XG4gIH1cblxuICBzdGF0aWMgZ2V0IEFsZXJ0RGlhbG9nQW5pbWF0b3IoKSB7XG4gICAgcmV0dXJuIEFsZXJ0RGlhbG9nQW5pbWF0b3I7XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtYWxlcnQtZGlhbG9nJywgQWxlcnREaWFsb2dFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJ29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnb25zL2NvbnRlbnQtcmVhZHknO1xuXG52YXIgc2NoZW1lID0ge1xuICAnJzogJ2JhY2stYnV0dG9uLS0qJyxcbiAgJy5iYWNrLWJ1dHRvbl9faWNvbic6ICdiYWNrLWJ1dHRvbi0tKl9faWNvbicsXG4gICcuYmFjay1idXR0b25fX2xhYmVsJzogJ2JhY2stYnV0dG9uLS0qX19sYWJlbCdcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWJhY2stYnV0dG9uXG4gKiBAY2F0ZWdvcnkgbmF2aWdhdGlvblxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBCYWNrIGJ1dHRvbiBjb21wb25lbnQgZm9yIGA8b25zLXRvb2xiYXI+YC4gUHV0IGl0IGluIHRoZSBsZWZ0IHBhcnQgb2YgdGhlIGA8b25zLXRvb2xiYXI+YC5cbiAqXG4gKiAgICAgSXQgd2lsbCBmaW5kIHRoZSBwYXJlbnQgYDxvbnMtbmF2aWdhdG9yPmAgZWxlbWVudCBhbmQgcG9wIGEgcGFnZSB3aGVuIGNsaWNrZWQuIFRoaXMgYmVoYXZpb3IgY2FuIGJlIG92ZXJyaWRlbiBieSBzcGVjaWZ5aW5nIHRoZSBgb25DbGlja2AgcHJvcGVydHkuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGNvZGVwZW4gYUhtR0xcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9uYXZpZ2F0b3JcbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dTWF0ZXJpYWwgRGVzaWduIHN0eWxlWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtdG9vbGJhclxuICogICBbZW5db25zLXRvb2xiYXIgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy10b29sYmFy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1uYXZpZ2F0b3JcbiAqICAgW2VuXW9ucy1uYXZpZ2F0b3IgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1uYXZpZ2F0b3LjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtdG9vbGJhcj5cbiAqICAgPGRpdiBjbGFzcz1cImxlZnRcIj5cbiAqICAgICA8b25zLWJhY2stYnV0dG9uPkJhY2s8L29ucy1iYWNrLWJ1dHRvbj5cbiAqICAgPC9kaXY+XG4gKiAgIDxkaXYgY2xhc3M9XCJjZW50ZXJcIj5cbiAqICAgICBUaXRsZVxuICogICA8ZGl2PlxuICogPC9vbnMtdG9vbGJhcj5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYWNrQnV0dG9uRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGJhY2sgYnV0dG9uLlsvZW5dXG4gICAqICBbamFd44OQ44OD44Kv44Oc44K/44Oz44Gu6KaL44Gf55uu44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgaW5pdCgpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fb3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuX2JvdW5kT25DbGljayA9IHRoaXMuX29uQ2xpY2suYmluZCh0aGlzKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdiYWNrLWJ1dHRvbicpO1xuXG4gICAgaWYgKCF1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLmJhY2stYnV0dG9uX19sYWJlbCcpKSB7XG4gICAgICBjb25zdCBsYWJlbCA9IHV0aWwuY3JlYXRlKCdzcGFuLmJhY2stYnV0dG9uX19sYWJlbCcpO1xuXG4gICAgICB3aGlsZSAodGhpcy5jaGlsZE5vZGVzWzBdKSB7XG4gICAgICAgIGxhYmVsLmFwcGVuZENoaWxkKHRoaXMuY2hpbGROb2Rlc1swXSk7XG4gICAgICB9XG4gICAgICB0aGlzLmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgICB9XG5cbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKHRoaXMsICcuYmFjay1idXR0b25fX2ljb24nKSkge1xuICAgICAgY29uc3QgaWNvbiA9IHV0aWwuY3JlYXRlKCdzcGFuLmJhY2stYnV0dG9uX19pY29uJyk7XG5cbiAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKGljb24sIHRoaXMuY2hpbGRyZW5bMF0pO1xuICAgIH1cblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb3B0aW9uc1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dT3B0aW9ucyBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvcHRpb25zLmFuaW1hdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBcInNsaWRlXCIsIFwibGlmdFwiLCBcImZhZGVcIiBhbmQgXCJub25lXCIuXG4gICAqICAgICBUaGVzZSBhcmUgcGxhdGZvcm0gYmFzZWQgYW5pbWF0aW9ucy4gRm9yIGZpeGVkIGFuaW1hdGlvbnMsIGFkZCBcIi1pb3NcIiBvciBcIi1tZFwiXG4gICAqICAgICBzdWZmaXggdG8gdGhlIGFuaW1hdGlvbiBuYW1lLiBFLmcuIFwibGlmdC1pb3NcIiwgXCJsaWZ0LW1kXCIuIERlZmF1bHRzIHZhbHVlcyBhcmUgXCJzbGlkZS1pb3NcIiBhbmQgXCJmYWRlLW1kXCIuXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuICBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWBbL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gIFsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb3B0aW9ucy5jYWxsYmFja1xuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgdHJhbnNpdGlvbiBoYXMgZW5kZWQuWy9lbl1cbiAgICogICBbamFd44GT44Gu44Oh44K944OD44OJ44Gr44KI44KL55S76Z2i6YG356e744GM57WC5LqG44GX44Gf6Zqb44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvcHRpb25zLnJlZnJlc2hcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBwcmV2aW91cyBwYWdlIHdpbGwgYmUgcmVmcmVzaGVkIChkZXN0cm95ZWQgYW5kIGNyZWF0ZWQgYWdhaW4pIGJlZm9yZSBwb3BQYWdlIGFjdGlvbi5bL2VuXVxuICAgKiAgIFtqYV1wb3BQYWdl44GZ44KL5YmN44Gr44CB5YmN44Gr44GC44KL44Oa44O844K444KS55Sf5oiQ44GX44Gq44GK44GX44Gm5pu05paw44GZ44KL5aC05ZCI44GrdHJ1ZeOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgfVxuXG4gIHNldCBvcHRpb25zKG9iamVjdCkge1xuICAgIHRoaXMuX29wdGlvbnMgPSBvYmplY3Q7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9uQ2xpY2tcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVXNlZCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiYWNrIGJ1dHRvbiBiZWhhdmlvci5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgX29uQ2xpY2soKSB7XG4gICAgaWYgKHRoaXMub25DbGljaykge1xuICAgICAgdGhpcy5vbkNsaWNrLmFwcGx5KHRoaXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IG5hdmlnYXRvciA9IHV0aWwuZmluZFBhcmVudCh0aGlzLCAnb25zLW5hdmlnYXRvcicpO1xuICAgICAgaWYgKG5hdmlnYXRvcikge1xuICAgICAgICBuYXZpZ2F0b3IucG9wUGFnZSh0aGlzLm9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE9uQ2xpY2ssIGZhbHNlKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChuYW1lID09PSAnbW9kaWZpZXInKSB7XG4gICAgICByZXR1cm4gTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgfVxuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljaywgZmFsc2UpO1xuICB9XG5cbiAgc2hvdygpIHtcbiAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztcbiAgfVxuXG4gIGhpZGUoKSB7XG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWJhY2stYnV0dG9uJywgQmFja0J1dHRvbkVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICdvbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xuXG5jb25zdCBzY2hlbWUgPSB7Jyc6ICdib3R0b20tYmFyLS0qJ307XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWJvdHRvbS10b29sYmFyXG4gKiBAY2F0ZWdvcnkgcGFnZVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1Ub29sYmFyIGNvbXBvbmVudCB0aGF0IGlzIHBvc2l0aW9uZWQgYXQgdGhlIGJvdHRvbSBvZiB0aGUgcGFnZS5bL2VuXVxuICogICBbamFd44Oa44O844K45LiL6YOo44Gr6YWN572u44GV44KM44KL44OE44O844Or44OQ44O855So44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciB0cmFuc3BhcmVudFxuICogICBbZW5dTWFrZSB0aGUgdG9vbGJhciB0cmFuc3BhcmVudC5bL2VuXVxuICogICBbamFd44OE44O844Or44OQ44O844Gu6IOM5pmv44KS6YCP5piO44Gr44GX44Gm6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy10b29sYmFyIFtlbl1vbnMtdG9vbGJhciBjb21wb25lbnRbL2VuXVtqYV1vbnMtdG9vbGJhcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1ib3R0b20tdG9vbGJhcj5cbiAqICAgQ29udGVudFxuICogPC9vbnMtYm90dG9tLXRvb2xiYXI+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJvdHRvbVRvb2xiYXJFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIHRvb2xiYXIuWy9lbl1cbiAgICogICBbamFd44OE44O844Or44OQ44O844Gu6KaL44Gf55uu44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2JvdHRvbS1iYXInKTtcbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBpZiAodXRpbC5tYXRjaCh0aGlzLnBhcmVudE5vZGUsICdvbnMtcGFnZScpKSB7XG4gICAgICB0aGlzLnBhcmVudE5vZGUuY2xhc3NMaXN0LmFkZCgncGFnZS13aXRoLWJvdHRvbS10b29sYmFyJyk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgIH1cbiAgfVxuXG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWJvdHRvbS10b29sYmFyJywgQm90dG9tVG9vbGJhckVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICdvbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xuXG5jb25zdCBzY2hlbWUgPSB7Jyc6ICdidXR0b24tLSonfTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtYnV0dG9uXG4gKiBAY2F0ZWdvcnkgZm9ybVxuICogQG1vZGlmaWVyIG91dGxpbmVcbiAqICAgW2VuXUJ1dHRvbiB3aXRoIG91dGxpbmUgYW5kIHRyYW5zcGFyZW50IGJhY2tncm91bmRbL2VuXVxuICogICBbamFd44Ki44Km44OI44Op44Kk44Oz44KS5oyB44Gj44Gf44Oc44K/44Oz44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciBsaWdodFxuICogICBbZW5dQnV0dG9uIHRoYXQgZG9lc24ndCBzdGFuZCBvdXQuWy9lbl1cbiAqICAgW2phXeebrueri+OBn+OBquOBhOODnOOCv+ODs+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAbW9kaWZpZXIgcXVpZXRcbiAqICAgW2VuXUJ1dHRvbiB3aXRoIG5vIG91dGxpbmUgYW5kIG9yIGJhY2tncm91bmQuLlsvZW5dXG4gKiAgIFtqYV3mnqDnt5rjgoTog4zmma/jgYznhKHjgYTmloflrZfjgaDjgZHjga7jg5zjgr/jg7PjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIGN0YVxuICogICBbZW5dQnV0dG9uIHRoYXQgcmVhbGx5IHN0YW5kcyBvdXQuWy9lbl1cbiAqICAgW2phXeebrueri+OBpOODnOOCv+ODs+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAbW9kaWZpZXIgbGFyZ2VcbiAqICAgW2VuXUxhcmdlIGJ1dHRvbiB0aGF0IGNvdmVycyB0aGUgd2lkdGggb2YgdGhlIHNjcmVlbi5bL2VuXVxuICogICBbamFd5qiq44GE44Gj44Gx44GE44Gr5bqD44GM44KL5aSn44GN44Gq44Oc44K/44Oz44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciBsYXJnZS0tcXVpZXRcbiAqICAgW2VuXUxhcmdlIHF1aWV0IGJ1dHRvbi5bL2VuXVxuICogICBbamFd5qiq44GE44Gj44Gx44GE44Gr5bqD44GM44KLcXVpZXTjg5zjgr/jg7PjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIGxhcmdlLS1jdGFcbiAqICAgW2VuXUxhcmdlIGNhbGwgdG8gYWN0aW9uIGJ1dHRvbi5bL2VuXVxuICogICBbamFd5qiq44GE44Gj44Gx44GE44Gr5bqD44GM44KLY3Rh44Oc44K/44Oz44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dTWF0ZXJpYWwgRGVzaWduIGJ1dHRvblsvZW5dXG4gKiAgIFtqYV3jg57jg4bjg6rjgqLjg6vjg4fjgrbjgqTjg7Pjga7jg5zjgr/jg7NbL2phXVxuICogQG1vZGlmaWVyIG1hdGVyaWFsLS1mbGF0XG4gKiAgIFtlbl1NYXRlcmlhbCBEZXNpZ24gZmxhdCBidXR0b25bL2VuXVxuICogICBbamFd44Oe44OG44Oq44Ki44Or44OH44K244Kk44Oz44Gu44OV44Op44OD44OI44Oc44K/44OzWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgQnV0dG9uIGNvbXBvbmVudC4gSWYgeW91IHdhbnQgdG8gcGxhY2UgYSBidXR0b24gaW4gYSB0b29sYmFyLCB1c2UgYDxvbnMtdG9vbGJhci1idXR0b24+YCBvciBgPG9ucy1iYWNrLWJ1dHRvbj5gIGluc3RlYWQuXG4gKlxuICogICAgIFdpbGwgYXV0b21hdGljYWxseSBkaXNwbGF5IGFzIGEgTWF0ZXJpYWwgRGVzaWduIGJ1dHRvbiB3aXRoIGEgcmlwcGxlIGVmZmVjdCBvbiBBbmRyb2lkLlxuICogICBbL2VuXVxuICogICBbamFd44Oc44K/44Oz55So44Kz44Oz44Od44O844ON44Oz44OI44CC44OE44O844Or44OQ44O844Gr44Oc44K/44Oz44KS6Kit572u44GZ44KL5aC05ZCI44Gv44CBb25zLXRvb2xiYXItYnV0dG9u44KC44GX44GP44Gvb25zLWJhY2stYnV0dG9u44Kz44Oz44Od44O844ON44Oz44OI44KS5L2/55So44GX44G+44GZ44CCWy9qYV1cbiAqIEBjb2RlcGVuIGhMYXl4XG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvYnV0dG9uXG4gKiBAZ3VpZGUgQnV0dG9uIFtlbl1HdWlkZSBmb3IgYDxvbnMtYnV0dG9uPmBbL2VuXVtqYV08b25zLWJ1dHRvbj7jga7kvb/jgYTmlrlbL2phXVxuICogQGd1aWRlIHVzaW5nLW1vZGlmaWVyIFtlbl1Nb3JlIGRldGFpbHMgYWJvdXQgdGhlIGBtb2RpZmllcmAgYXR0cmlidXRlWy9lbl1bamFdbW9kaWZpZXLlsZ7mgKfjga7kvb/jgYTmlrlbL2phXVxuICogQGd1aWRlIGNyb3NzLXBsYXRmb3JtLXN0eWxpbmcgW2VuXUluZm9ybWF0aW9uIGFib3V0IGNyb3NzIHBsYXRmb3JtIHN0eWxpbmdbL2VuXVtqYV1JbmZvcm1hdGlvbiBhYm91dCBjcm9zcyBwbGF0Zm9ybSBzdHlsaW5nWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWJ1dHRvbiBtb2RpZmllcj1cImxhcmdlLS1jdGFcIj5cbiAqICAgVGFwIE1lXG4gKiA8L29ucy1idXR0b24+XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnV0dG9uRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgYnV0dG9uLlsvZW5dXG4gICAqICBbamFd44Oc44K/44Oz44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcmlwcGxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIGRlZmluZWQsIHRoZSBidXR0b24gd2lsbCBoYXZlIGEgcmlwcGxlIGVmZmVjdC5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IGlmIGJ1dHRvbiBzaG91bGQgYmUgZGlzYWJsZWQuWy9lbl1cbiAgICogICBbamFd44Oc44K/44Oz44KS54Sh5Yq55YyW44GZ44KL5aC05ZCI44Gv5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgaW5pdCgpIHtcbiAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKCdfY29tcGlsZWQnKSkge1xuICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ3JpcHBsZSddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlwcGxlJzpcbiAgICAgICAgdGhpcy5fdXBkYXRlUmlwcGxlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGJ1dHRvbiBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2J1dHRvbicpO1xuXG4gICAgdGhpcy5fdXBkYXRlUmlwcGxlKCk7XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG5cbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnX2NvbXBpbGVkJywgJycpO1xuICB9XG5cbiAgX3VwZGF0ZVJpcHBsZSgpIHtcbiAgICB1dGlsLnVwZGF0ZVJpcHBsZSh0aGlzKTtcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1idXR0b24nLCBCdXR0b25FbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuY29uc3Qgc2NoZW1lID0geycnOiAnY2Fyb3VzZWwtaXRlbS0tKid9O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1jYXJvdXNlbC1pdGVtXG4gKiBAY2F0ZWdvcnkgY2Fyb3VzZWxcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgQ2Fyb3VzZWwgaXRlbSBjb21wb25lbnQuIFVzZWQgYXMgYSBjaGlsZCBvZiB0aGUgYDxvbnMtY2Fyb3VzZWw+YCBlbGVtZW50LlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIHhiYnpPUVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2Nhcm91c2VsXG4gKiBAc2VlYWxzbyBvbnMtY2Fyb3VzZWxcbiAqICAgW2VuXWA8b25zLWNhcm91c2VsPmAgY29tcG9uZW50c1svZW5dXG4gKiAgIFtqYV08b25zLWNhcm91c2VsPuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1jYXJvdXNlbCBzdHlsZT1cIndpZHRoOiAxMDAlOyBoZWlnaHQ6IDIwMHB4XCI+XG4gKiAgIDxvbnMtY2Fyb3VzZWwtaXRlbT5cbiAqICAgIC4uLlxuICogICA8L29ucy1jYXJvdXNlbC1pdGVtPlxuICogICA8b25zLWNhcm91c2VsLWl0ZW0+XG4gKiAgICAuLi5cbiAqICAgPC9vbnMtY2Fyb3VzZWwtaXRlbT5cbiAqIDwvb25zLWNhcm91c2VsPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYXJvdXNlbEl0ZW1FbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllciddXG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChuYW1lID09PSAnbW9kaWZpZXInKSB7XG4gICAgICByZXR1cm4gTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgfVxuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWNhcm91c2VsLWl0ZW0nLCBDYXJvdXNlbEl0ZW1FbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBHZXN0dXJlRGV0ZWN0b3IgZnJvbSAnb25zL2dlc3R1cmUtZGV0ZWN0b3InO1xuaW1wb3J0IERvb3JMb2NrIGZyb20gJ29ucy9kb29ybG9jayc7XG5cbmNvbnN0IFZlcnRpY2FsTW9kZVRyYWl0ID0ge1xuXG4gIF9nZXRTY3JvbGxEZWx0YTogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQuZ2VzdHVyZS5kZWx0YVk7XG4gIH0sXG5cbiAgX2dldFNjcm9sbFZlbG9jaXR5OiBmdW5jdGlvbihldmVudCkge1xuICAgIHJldHVybiBldmVudC5nZXN0dXJlLnZlbG9jaXR5WTtcbiAgfSxcblxuICBfZ2V0RWxlbWVudFNpemU6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5fY3VycmVudEVsZW1lbnRTaXplKSB7XG4gICAgICB0aGlzLl9jdXJyZW50RWxlbWVudFNpemUgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fY3VycmVudEVsZW1lbnRTaXplO1xuICB9LFxuXG4gIF9nZW5lcmF0ZVNjcm9sbFRyYW5zZm9ybTogZnVuY3Rpb24oc2Nyb2xsKSB7XG4gICAgcmV0dXJuICd0cmFuc2xhdGUzZCgwcHgsICcgKyAtc2Nyb2xsICsgJ3B4LCAwcHgpJztcbiAgfSxcblxuICBfdXBkYXRlRGltZW5zaW9uRGF0YTogZnVuY3Rpb24oKXtcbiAgICB0aGlzLl9zdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMpO1xuICAgIHRoaXMuX2RpbWVuc2lvbnMgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB9LFxuXG4gIF91cGRhdGVPZmZzZXQ6IGZ1bmN0aW9uKCl7XG4gICAgaWYgKHRoaXMuY2VudGVyZWQpIHtcbiAgICAgIGNvbnN0IGhlaWdodCA9ICh0aGlzLl9kaW1lbnNpb25zLmhlaWdodCB8fCAwKSAtIHBhcnNlSW50KHRoaXMuX3N0eWxlLnBhZGRpbmdUb3AsIDEwKSAtIHBhcnNlSW50KHRoaXMuX3N0eWxlLnBhZGRpbmdCb3R0b20sIDEwKTtcbiAgICAgIHRoaXMuX29mZnNldCA9IC0oaGVpZ2h0IC0gdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtU2l6ZSgpKSAvIDI7XG4gICAgfVxuICB9LFxuXG4gIF9sYXlvdXRDYXJvdXNlbEl0ZW1zOiBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuX2dldENhcm91c2VsSXRlbUVsZW1lbnRzKCk7XG5cbiAgICBjb25zdCBzaXplQXR0ciA9IHRoaXMuX2dldENhcm91c2VsSXRlbVNpemVBdHRyKCk7XG4gICAgY29uc3Qgc2l6ZUluZm8gPSB0aGlzLl9kZWNvbXBvc2VTaXplU3RyaW5nKHNpemVBdHRyKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLmhlaWdodCA9IHNpemVBdHRyO1xuICAgICAgY2hpbGRyZW5baV0uc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnRvcCA9IChpICogc2l6ZUluZm8ubnVtYmVyKSArIHNpemVJbmZvLnVuaXQ7XG4gICAgfVxuICB9LFxuXG4gIF9zZXR1cDogZnVuY3Rpb24oKXtcbiAgICB0aGlzLl91cGRhdGVEaW1lbnNpb25EYXRhKCk7XG4gICAgdGhpcy5fdXBkYXRlT2Zmc2V0KCk7XG4gICAgdGhpcy5fbGF5b3V0Q2Fyb3VzZWxJdGVtcygpO1xuICB9XG59O1xuXG5jb25zdCBIb3Jpem9udGFsTW9kZVRyYWl0ID0ge1xuXG4gIF9nZXRTY3JvbGxEZWx0YTogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQuZ2VzdHVyZS5kZWx0YVg7XG4gIH0sXG5cbiAgX2dldFNjcm9sbFZlbG9jaXR5OiBmdW5jdGlvbihldmVudCkge1xuICAgIHJldHVybiBldmVudC5nZXN0dXJlLnZlbG9jaXR5WDtcbiAgfSxcblxuICBfZ2V0RWxlbWVudFNpemU6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5fY3VycmVudEVsZW1lbnRTaXplKSB7XG4gICAgICB0aGlzLl9jdXJyZW50RWxlbWVudFNpemUgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9jdXJyZW50RWxlbWVudFNpemU7XG4gIH0sXG5cbiAgX2dlbmVyYXRlU2Nyb2xsVHJhbnNmb3JtOiBmdW5jdGlvbihzY3JvbGwpIHtcbiAgICByZXR1cm4gJ3RyYW5zbGF0ZTNkKCcgKyAtc2Nyb2xsICsgJ3B4LCAwcHgsIDBweCknO1xuICB9LFxuXG4gIF91cGRhdGVEaW1lbnNpb25EYXRhOiBmdW5jdGlvbigpe1xuICAgIHRoaXMuX3N0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcyk7XG4gICAgdGhpcy5fZGltZW5zaW9ucyA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH0sXG5cbiAgX3VwZGF0ZU9mZnNldDogZnVuY3Rpb24oKXtcbiAgICBpZiAodGhpcy5jZW50ZXJlZCkge1xuICAgICAgY29uc3Qgd2lkdGggPSAodGhpcy5fZGltZW5zaW9ucy53aWR0aCB8fCAwKSAtIHBhcnNlSW50KHRoaXMuX3N0eWxlLnBhZGRpbmdMZWZ0LCAxMCkgLSBwYXJzZUludCh0aGlzLl9zdHlsZS5wYWRkaW5nUmlnaHQsIDEwKTtcbiAgICAgIHRoaXMuX29mZnNldCA9IC0od2lkdGggLSB0aGlzLl9nZXRDYXJvdXNlbEl0ZW1TaXplKCkpIC8gMjtcbiAgICB9XG4gIH0sXG5cbiAgX2xheW91dENhcm91c2VsSXRlbXM6IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtRWxlbWVudHMoKTtcblxuICAgIGNvbnN0IHNpemVBdHRyID0gdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtU2l6ZUF0dHIoKTtcbiAgICBjb25zdCBzaXplSW5mbyA9IHRoaXMuX2RlY29tcG9zZVNpemVTdHJpbmcoc2l6ZUF0dHIpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRyZW5baV0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgY2hpbGRyZW5baV0uc3R5bGUud2lkdGggPSBzaXplQXR0cjtcbiAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgICBjaGlsZHJlbltpXS5zdHlsZS5sZWZ0ID0gKGkgKiBzaXplSW5mby5udW1iZXIpICsgc2l6ZUluZm8udW5pdDtcbiAgICB9XG4gIH0sXG5cbiAgX3NldHVwOiBmdW5jdGlvbigpe1xuICAgIHRoaXMuX3VwZGF0ZURpbWVuc2lvbkRhdGEoKTtcbiAgICB0aGlzLl91cGRhdGVPZmZzZXQoKTtcbiAgICB0aGlzLl9sYXlvdXRDYXJvdXNlbEl0ZW1zKCk7XG4gIH1cbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWNhcm91c2VsXG4gKiBAY2F0ZWdvcnkgY2Fyb3VzZWxcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgQ2Fyb3VzZWwgY29tcG9uZW50LiBBIGNhcm91c2VsIGNhbiBiZSB1c2VkIHRvIGRpc3BsYXkgc2V2ZXJhbCBpdGVtcyBpbiB0aGUgc2FtZSBzcGFjZS5cbiAqXG4gKiAgICAgVGhlIGNvbXBvbmVudCBzdXBwb3J0cyBkaXNwbGF5aW5nIGNvbnRlbnQgYm90aCBob3Jpem9udGFsbHkgYW5kIHZlcnRpY2FsbHkuIFRoZSB1c2VyIGNhbiBzY3JvbGwgdGhyb3VnaCB0aGUgaXRlbXMgYnkgZHJhZ2dpbmcgYW5kIGl0IGNhbiBhbHNvIGJlIGNvbnRyb2xsZXIgcHJvZ3JhbW1hdGljYWxseS5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiB4YmJ6T1FcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9jYXJvdXNlbFxuICogQHNlZWFsc28gb25zLWNhcm91c2VsLWl0ZW1cbiAqICAgW2VuXWA8b25zLWNhcm91c2VsLWl0ZW0+YCBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWNhcm91c2VsLWl0ZW3jgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtY2Fyb3VzZWwgc3R5bGU9XCJ3aWR0aDogMTAwJTsgaGVpZ2h0OiAyMDBweFwiPlxuICogICA8b25zLWNhcm91c2VsLWl0ZW0+XG4gKiAgICAuLi5cbiAqICAgPC9vbnMtY2Fyb3VzZWwtaXRlbT5cbiAqICAgPG9ucy1jYXJvdXNlbC1pdGVtPlxuICogICAgLi4uXG4gKiAgIDwvb25zLWNhcm91c2VsLWl0ZW0+XG4gKiA8L29ucy1jYXJvdXNlbD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2Fyb3VzZWxFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdGNoYW5nZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgY3VycmVudCBjYXJvdXNlbCBpdGVtIGhhcyBjaGFuZ2VkLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOihqOekuuOBl+OBpuOBhOOCi+OCq+ODq+ODvOOCu+ODq+OBruimgee0oOOBjOWkieOCj+OBo+OBn+aZguOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmNhcm91c2VsXG4gICAqICAgW2VuXUNhcm91c2VsIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgYznmbrngavjgZfjgZ9DYXJvdXNlbOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudC5hY3RpdmVJbmRleFxuICAgKiAgIFtlbl1DdXJyZW50IGFjdGl2ZSBpbmRleC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjgqLjgq/jg4bjgqPjg5bjgavjgarjgaPjgabjgYTjgovopoHntKDjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgIJbL2phXVxuICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQubGFzdEFjdGl2ZUluZGV4XG4gICAqICAgW2VuXVByZXZpb3VzIGFjdGl2ZSBpbmRleC5bL2VuXVxuICAgKiAgIFtqYV3ku6XliY3jgqLjgq/jg4bjgqPjg5bjgaDjgaPjgZ/opoHntKDjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHJlZnJlc2hcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIHdoZW4gdGhlIGNhcm91c2VsIGhhcyBiZWVuIHJlZnJlc2hlZC5bL2VuXVxuICAgKiAgIFtqYV3jgqvjg6vjg7zjgrvjg6vjgYzmm7TmlrDjgZXjgozjgZ/mmYLjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5jYXJvdXNlbFxuICAgKiAgIFtlbl1DYXJvdXNlbCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44GM55m654Gr44GX44GfQ2Fyb3VzZWzjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IG92ZXJzY3JvbGxcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIHdoZW4gdGhlIGNhcm91c2VsIGhhcyBiZWVuIG92ZXJzY3JvbGxlZC5bL2VuXVxuICAgKiAgIFtqYV3jgqvjg6vjg7zjgrvjg6vjgYzjgqrjg7zjg5Djg7zjgrnjgq/jg63jg7zjg6vjgZfjgZ/mmYLjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5jYXJvdXNlbFxuICAgKiAgIFtlbl1GaXJlZCB3aGVuIHRoZSBjYXJvdXNlbCBoYXMgYmVlbiByZWZyZXNoZWQuWy9lbl1cbiAgICogICBbamFd44Kr44Or44O844K744Or44GM5pu05paw44GV44KM44Gf5pmC44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50LmFjdGl2ZUluZGV4XG4gICAqICAgW2VuXUN1cnJlbnQgYWN0aXZlIGluZGV4LlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOCouOCr+ODhuOCo+ODluOBq+OBquOBo+OBpuOBhOOCi+imgee0oOOBruOCpOODs+ODh+ODg+OCr+OCueOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudC5kaXJlY3Rpb25cbiAgICogICBbZW5dQ2FuIGJlIG9uZSBvZiBlaXRoZXIgXCJ1cFwiLCBcImRvd25cIiwgXCJsZWZ0XCIgb3IgXCJyaWdodFwiLlsvZW5dXG4gICAqICAgW2phXeOCquODvOODkOODvOOCueOCr+ODreODvOODq+OBleOCjOOBn+aWueWQkeOBjOW+l+OCieOCjOOBvuOBmeOAglwidXBcIiwgXCJkb3duXCIsIFwibGVmdFwiLCBcInJpZ2h0XCLjga7jgYTjgZrjgozjgYvjga7mlrnlkJHjgYzmuKHjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC53YWl0VG9SZXR1cm5cbiAgICogICBbZW5dVGFrZXMgYSA8Y29kZT5Qcm9taXNlPC9jb2RlPiBvYmplY3QgYXMgYW4gYXJndW1lbnQuIFRoZSBjYXJvdXNlbCB3aWxsIG5vdCBzY3JvbGwgYmFjayB1bnRpbCB0aGUgcHJvbWlzZSBoYXMgYmVlbiByZXNvbHZlZCBvciByZWplY3RlZC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjga9Qcm9taXNl44Kq44OW44K444Kn44Kv44OI44KS5byV5pWw44Go44GX44Gm5Y+X44GR5Y+W44KK44G+44GZ44CC5rih44GX44GfUHJvbWlzZeOCquODluOCuOOCp+OCr+ODiOOBjHJlc29sdmXjgZXjgozjgovjgYtyZWplY3TjgZXjgozjgovjgb7jgafjgIHjgqvjg6vjg7zjgrvjg6vjga/jgrnjgq/jg63jg7zjg6vjg5Djg4Pjgq/jgZfjgb7jgZvjgpPjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXJlY3Rpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBkaXJlY3Rpb24gb2YgdGhlIGNhcm91c2VsLiBDYW4gYmUgZWl0aGVyIFwiaG9yaXpvbnRhbFwiIG9yIFwidmVydGljYWxcIi4gRGVmYXVsdCBpcyBcImhvcml6b250YWxcIi5bL2VuXVxuICAgKiAgIFtqYV3jgqvjg6vjg7zjgrvjg6vjga7mlrnlkJHjgpLmjIflrprjgZfjgb7jgZnjgIJcImhvcml6b250YWxcIuOBi1widmVydGljYWxcIuOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglwiaG9yaXpvbnRhbFwi44GM44OH44OV44Kp44Or44OI5YCk44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZnVsbHNjcmVlblxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBjYXJvdXNlbCB3aWxsIGNvdmVyIHRoZSB3aG9sZSBzY3JlZW4uWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL44Go44CBYWJzb2x1dGXjg53jgrjjgrfjg6fjg7PjgpLkvb/jgaPjgabjgqvjg6vjg7zjgrvjg6vjgYzoh6rli5XnmoTjgavnlLvpnaLjgYTjgaPjgbHjgYTjgavluoPjgYzjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBvdmVyc2Nyb2xsYWJsZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBjYXJvdXNlbCB3aWxsIGJlIHNjcm9sbGFibGUgb3ZlciB0aGUgZWRnZS4gSXQgd2lsbCBib3VuY2UgYmFjayB3aGVuIHJlbGVhc2VkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgeOCv+ODg+ODgeOChOODieODqeODg+OCsOOBp+err+OBvuOBp+OCueOCr+ODreODvOODq+OBl+OBn+aZguOBq+OAgeODkOOCpuODs+ODieOBmeOCi+OCiOOBhuOBquWKueaenOOBjOW9k+OBn+OCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGNlbnRlcmVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIHRoZW4gdGhlIHNlbGVjdGVkIGl0ZW0gd2lsbCBiZSBpbiB0aGUgY2VudGVyIG9mIHRoZSBjYXJvdXNlbCBpbnN0ZWFkIG9mIHRoZSBiZWdpbm5pbmcuIFVzZWZ1bCBvbmx5IHdoZW4gdGhlIGl0ZW1zIGFyZSBzbWFsbGVyIHRoYW4gdGhlIGNhcm91c2VsLiBbL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovmmYLjgIHpgbjjgpPjgafjgYTjgotvbnMtY2Fyb3VzZWwtaXRlbeOBr+OCq+ODq+ODvOOCu+ODq+OBruecn+OCk+S4reOBuOihjOOBjeOBvuOBmeOAgumgheebruOBjOOCq+ODq+ODvOOCu+ODq+OCiOOCiuOCguWwj+OBleOBhOWgtOWQiOOBq+OBruOBv+OAgeOBk+OCjOOBr+S+v+WIqeOBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGl0ZW0td2lkdGhcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgIFtlbl1vbnMtY2Fyb3VzZWwtaXRlbSdzIHdpZHRoLiBPbmx5IHdvcmtzIHdoZW4gdGhlIGRpcmVjdGlvbiBpcyBzZXQgdG8gXCJob3Jpem9udGFsXCIuWy9lbl1cbiAgICogICAgW2phXW9ucy1jYXJvdXNlbC1pdGVt44Gu5bmF44KS5oyH5a6a44GX44G+44GZ44CC44GT44Gu5bGe5oCn44Gv44CBZGlyZWN0aW9u5bGe5oCn44GrXCJob3Jpem9udGFsXCLjgpLmjIflrprjgZfjgZ/mmYLjga7jgb/mnInlirnjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBpdGVtLWhlaWdodFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5db25zLWNhcm91c2VsLWl0ZW0ncyBoZWlnaHQuIE9ubHkgd29ya3Mgd2hlbiB0aGUgZGlyZWN0aW9uIGlzIHNldCB0byBcInZlcnRpY2FsXCIuWy9lbl1cbiAgICogICBbamFdb25zLWNhcm91c2VsLWl0ZW3jga7pq5jjgZXjgpLmjIflrprjgZfjgb7jgZnjgILjgZPjga7lsZ7mgKfjga/jgIFkaXJlY3Rpb27lsZ7mgKfjgatcInZlcnRpY2FsXCLjgpLmjIflrprjgZfjgZ/mmYLjga7jgb/mnInlirnjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhdXRvLXNjcm9sbFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBjYXJvdXNlbCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgc2Nyb2xsZWQgdG8gdGhlIGNsb3Nlc3QgaXRlbSBib3JkZXIgd2hlbiByZWxlYXNlZC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovmmYLjgIHkuIDnlarov5HjgYRjYXJvdXNlbC1pdGVt44Gu5aKD55WM44G+44Gn6Ieq5YuV55qE44Gr44K544Kv44Ot44O844Or44GZ44KL44KI44GG44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYXV0by1zY3JvbGwtcmF0aW9cbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgIFtlbl1BIG51bWJlciBiZXR3ZWVuIDAuMCBhbmQgMS4wIHRoYXQgc3BlY2lmaWVzIGhvdyBtdWNoIHRoZSB1c2VyIG11c3QgZHJhZyB0aGUgY2Fyb3VzZWwgaW4gb3JkZXIgZm9yIGl0IHRvIGF1dG8gc2Nyb2xsIHRvIHRoZSBuZXh0IGl0ZW0uWy9lbl1cbiAgICogICAgW2phXTAuMOOBi+OCiTEuMOOBvuOBp+OBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAguOCq+ODq+ODvOOCu+ODq+OBruimgee0oOOCkuOBqeOCjOOBkOOCieOBhOOBruWJsuWQiOOBvuOBp+ODieODqeODg+OCsOOBmeOCi+OBqOasoeOBruimgee0oOOBq+iHquWLleeahOOBq+OCueOCr+ODreODvOODq+OBmeOCi+OBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHN3aXBlYWJsZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBjYXJvdXNlbCBjYW4gYmUgc2Nyb2xsZWQgYnkgZHJhZyBvciBzd2lwZS5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovmmYLjgIHjgqvjg6vjg7zjgrvjg6vjgpLjgrnjg6/jgqTjg5fjgoTjg4njg6njg4PjgrDjgafnp7vli5XjgafjgY3jgovjgojjgYbjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXNhYmxlZFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBjYXJvdXNlbCBpcyBkaXNhYmxlZC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovmmYLjgIFkcmFn44KEdG91Y2jjgoRzd2lwZeOCkuWPl+OBkeS7mOOBkeOBquOBj+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGluaXRpYWwtaW5kZXhcbiAgICogQGluaXRvbmx5XG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBpbmRleCBvZiB0aGUgb25zLWNhcm91c2VsLWl0ZW0gdG8gc2hvdyBpbml0aWFsbHkuIERlZmF1bHQgaXMgMC5bL2VuXVxuICAgKiAgIFtqYV3mnIDliJ3jgavooajnpLrjgZnjgotvbnMtY2Fyb3VzZWwtaXRlbeOCkjDlp4vjgb7jgorjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgafmjIflrprjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jlgKTjga8gMCDjgafjgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhdXRvLXJlZnJlc2hcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZW4gdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBjYXJvdXNlbCB3aWxsIGF1dG9tYXRpY2FsbHkgcmVmcmVzaCB3aGVuIHRoZSBudW1iZXIgb2YgY2hpbGQgbm9kZXMgY2hhbmdlLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgeWtkOimgee0oOOBruaVsOOBjOWkieOCj+OCi+OBqOOCq+ODq+ODvOOCu+ODq+OBr+iHquWLleeahOOBq+abtOaWsOOBleOCjOOCi+OCiOOBhuOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvbi1vcHRpb25zXG4gICAqIEB0eXBlIHtFeHByZXNzaW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIHRpbWluZyBhbmQgZGVsYXkgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbC4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCB0aW1pbmcsIGRlbGF544KS44Kq44OW44K444Kn44Kv44OI44Oq44OG44Op44Or44Gn5oyH5a6a44GX44G+44GZ44CC5L6L77yae2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31bL2phXVxuICAgKi9cblxuICBpbml0KCkge1xuICAgIHRoaXMuX2Rvb3JMb2NrID0gbmV3IERvb3JMb2NrKCk7XG4gICAgdGhpcy5fc2Nyb2xsID0gMDtcbiAgICB0aGlzLl9vZmZzZXQgPSAwO1xuICAgIHRoaXMuX2xhc3RBY3RpdmVJbmRleCA9IDA7XG5cbiAgICB0aGlzLl9ib3VuZE9uRHJhZyA9IHRoaXMuX29uRHJhZy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kT25EcmFnRW5kID0gdGhpcy5fb25EcmFnRW5kLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fYm91bmRPblJlc2l6ZSA9IHRoaXMuX29uUmVzaXplLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLl9taXhpbih0aGlzLl9pc1ZlcnRpY2FsKCkgPyBWZXJ0aWNhbE1vZGVUcmFpdCA6IEhvcml6b250YWxNb2RlVHJhaXQpO1xuICB9XG5cbiAgX29uUmVzaXplKCkge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9zY3JvbGwgLyB0aGlzLl9jdXJyZW50RWxlbWVudFNpemU7XG4gICAgZGVsZXRlIHRoaXMuX2N1cnJlbnRFbGVtZW50U2l6ZTtcbiAgICB0aGlzLnNldEFjdGl2ZUluZGV4KGkpO1xuICB9XG5cbiAgX29uRGlyZWN0aW9uQ2hhbmdlKCkge1xuICAgIGlmICh0aGlzLl9pc1ZlcnRpY2FsKCkpIHtcbiAgICAgIHRoaXMuc3R5bGUub3ZlcmZsb3dYID0gJ2F1dG8nO1xuICAgICAgdGhpcy5zdHlsZS5vdmVyZmxvd1kgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdHlsZS5vdmVyZmxvd1ggPSAnJztcbiAgICAgIHRoaXMuc3R5bGUub3ZlcmZsb3dZID0gJ2F1dG8nO1xuICAgIH1cblxuICAgIHRoaXMucmVmcmVzaCgpO1xuICB9XG5cbiAgX3NhdmVMYXN0U3RhdGUoKSB7XG4gICAgdGhpcy5fbGFzdFN0YXRlID0ge1xuICAgICAgZWxlbWVudFNpemU6IHRoaXMuX2dldENhcm91c2VsSXRlbVNpemUoKSxcbiAgICAgIGNhcm91c2VsRWxlbWVudENvdW50OiB0aGlzLml0ZW1Db3VudCxcbiAgICAgIHdpZHRoOiB0aGlzLl9nZXRDYXJvdXNlbEl0ZW1TaXplKCkgKiB0aGlzLml0ZW1Db3VudFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgX2dldENhcm91c2VsSXRlbVNpemUoKSB7XG4gICAgY29uc3Qgc2l6ZUF0dHIgPSB0aGlzLl9nZXRDYXJvdXNlbEl0ZW1TaXplQXR0cigpO1xuICAgIGNvbnN0IHNpemVJbmZvID0gdGhpcy5fZGVjb21wb3NlU2l6ZVN0cmluZyhzaXplQXR0cik7XG4gICAgY29uc3QgZWxlbWVudFNpemUgPSB0aGlzLl9nZXRFbGVtZW50U2l6ZSgpO1xuXG4gICAgaWYgKHNpemVJbmZvLnVuaXQgPT09ICclJykge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQoc2l6ZUluZm8ubnVtYmVyIC8gMTAwICogZWxlbWVudFNpemUpO1xuICAgIH0gZWxzZSBpZiAoc2l6ZUluZm8udW5pdCA9PT0gJ3B4Jykge1xuICAgICAgcmV0dXJuIHNpemVJbmZvLm51bWJlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0YXRlJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIF9nZXRJbml0aWFsSW5kZXgoKSB7XG4gICAgY29uc3QgaW5kZXggPSBwYXJzZUludCh0aGlzLmdldEF0dHJpYnV0ZSgnaW5pdGlhbC1pbmRleCcpLCAxMCk7XG5cbiAgICBpZiAodHlwZW9mIGluZGV4ID09PSAnbnVtYmVyJyAmJiAhaXNOYU4oaW5kZXgpKSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4oaW5kZXgsIHRoaXMuaXRlbUNvdW50IC0gMSksIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgX2dldENhcm91c2VsSXRlbVNpemVBdHRyKCkge1xuICAgIGNvbnN0IGF0dHJOYW1lID0gJ2l0ZW0tJyArICh0aGlzLl9pc1ZlcnRpY2FsKCkgPyAnaGVpZ2h0JyA6ICd3aWR0aCcpO1xuICAgIGNvbnN0IGl0ZW1TaXplQXR0ciA9ICgnJyArIHRoaXMuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKSkudHJpbSgpO1xuXG4gICAgcmV0dXJuIGl0ZW1TaXplQXR0ci5tYXRjaCgvXlxcZCsocHh8JSkkLykgPyBpdGVtU2l6ZUF0dHIgOiAnMTAwJSc7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgX2RlY29tcG9zZVNpemVTdHJpbmcoc2l6ZSkge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBzaXplLm1hdGNoKC9eKFxcZCspKHB4fCUpLyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbnVtYmVyOiBwYXJzZUludChtYXRjaGVzWzFdLCAxMCksXG4gICAgICB1bml0OiBtYXRjaGVzWzJdLFxuICAgIH07XG4gIH1cblxuICBfc2V0dXBJbml0aWFsSW5kZXgoKSB7XG4gICAgdGhpcy5fc2Nyb2xsID0gKHRoaXMuX29mZnNldCB8fCAwKSArIHRoaXMuX2dldENhcm91c2VsSXRlbVNpemUoKSAqIHRoaXMuX2dldEluaXRpYWxJbmRleCgpO1xuICAgIHRoaXMuX2xhc3RBY3RpdmVJbmRleCA9IHRoaXMuX2dldEluaXRpYWxJbmRleCgpO1xuICAgIHRoaXMuX3Njcm9sbFRvKHRoaXMuX3Njcm9sbCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBzZXRBY3RpdmVJbmRleFxuICAgKiBAc2lnbmF0dXJlIHNldEFjdGl2ZUluZGV4KGluZGV4LCBbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiAgIFtlbl1UaGUgaW5kZXggdGhhdCB0aGUgY2Fyb3VzZWwgc2hvdWxkIGJlIHNldCB0by5bL2VuXVxuICAgKiAgIFtqYV1jYXJvdXNlbOimgee0oOOBruOCpOODs+ODh+ODg+OCr+OCueOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSBhbmltYXRpb24gaXMgZmluaXNoZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRvIGBcIm5vbmVcImAgdGhlIHRyYW5zaXRpb25zIHdpbGwgbm90IGJlIGFuaW1hdGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1BbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nIGZ1bmN0aW9uIG9mIHRoZSBhbmltYXRpb24uWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGluZGV4IG9mIHRoZSBgPG9ucy1jYXJvdXNlbC1pdGVtPmAgdG8gc2hvdy5bL2VuXVxuICAgKiAgIFtqYV3ooajnpLrjgZnjgotvbnMtY2Fyb3VzZWwtaXRlbeOCkmluZGV444Gn5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIGNhcm91c2VsIGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHNldEFjdGl2ZUluZGV4KGluZGV4LCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucyAhPSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0LiBZb3Ugc3VwcGxpZWQgJyArIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyA9IHV0aWwuZXh0ZW5kKFxuICAgICAgeyBkdXJhdGlvbjogMC4zLCB0aW1pbmc6ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuMSwgMSknIH0sXG4gICAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgfHwge30sXG4gICAgICB0aGlzLmhhc0F0dHJpYnV0ZSgnYW5pbWF0aW9uLW9wdGlvbnMnKSA/IHV0aWwuYW5pbWF0aW9uT3B0aW9uc1BhcnNlKHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpKSA6IHt9XG4gICAgKTtcblxuICAgIGluZGV4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oaW5kZXgsIHRoaXMuaXRlbUNvdW50IC0gMSkpO1xuICAgIGNvbnN0IHNjcm9sbCA9ICh0aGlzLl9vZmZzZXQgfHwgMCkgKyB0aGlzLl9nZXRDYXJvdXNlbEl0ZW1TaXplKCkgKiBpbmRleDtcbiAgICBjb25zdCBtYXggPSB0aGlzLl9jYWxjdWxhdGVNYXhTY3JvbGwoKTtcblxuICAgIHRoaXMuX3Njcm9sbCA9IE1hdGgubWF4KDAsIE1hdGgubWluKG1heCwgc2Nyb2xsKSk7XG4gICAgcmV0dXJuIHRoaXMuX3Njcm9sbFRvKHRoaXMuX3Njcm9sbCwgb3B0aW9ucykudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLl90cnlGaXJlUG9zdENoYW5nZUV2ZW50KCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcblxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgZ2V0QWN0aXZlSW5kZXhcbiAgICogQHNpZ25hdHVyZSBnZXRBY3RpdmVJbmRleCgpXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICogICBbZW5dVGhlIGN1cnJlbnQgY2Fyb3VzZWwgaXRlbSBpbmRleC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjooajnpLrjgZfjgabjgYTjgovjgqvjg6vjg7zjgrvjg6vopoHntKDjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgYzov5TjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGN1cnJlbnRseSB2aXNpYmxlIGA8b25zLWNhcm91c2VsLWl0ZW0+YC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjooajnpLrjgZXjgozjgabjgYTjgotvbnMtY2Fyb3VzZWwtaXRlbeimgee0oOOBruOCpOODs+ODh+ODg+OCr+OCueOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXRBY3RpdmVJbmRleCgpIHtcbiAgICBjb25zdCBzY3JvbGwgPSB0aGlzLl9zY3JvbGwgLSAodGhpcy5fb2Zmc2V0IHx8IDApO1xuICAgIGNvbnN0IGNvdW50ID0gdGhpcy5pdGVtQ291bnQ7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuX2dldENhcm91c2VsSXRlbVNpemUoKTtcblxuICAgIGlmIChzY3JvbGwgPCAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgaWYgKHNpemUgKiBpIDw9IHNjcm9sbCAmJiBzaXplICogKGkgKyAxKSA+IHNjcm9sbCkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBtYXggY2Fyb3VzZWwgaW5kZXhcbiAgICByZXR1cm4gaTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIG5leHRcbiAgICogQHNpZ25hdHVyZSBuZXh0KFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1BIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhZnRlciB0aGUgYW5pbWF0aW9uIGhhcyBmaW5pc2hlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdG8gYFwibm9uZVwiYCB0aGUgdHJhbnNpdGlvbnMgd2lsbCBub3QgYmUgYW5pbWF0ZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXUFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHNwZWNpZnkgdGhlIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nIGZ1bmN0aW9uIG9mIHRoZSBhbmltYXRpb24uWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIGNhcm91c2VsIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdyBuZXh0IGA8b25zLWNhcm91c2VsLWl0ZW0+YC5bL2VuXVxuICAgKiAgIFtqYV3mrKHjga5vbnMtY2Fyb3VzZWwtaXRlbeOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBuZXh0KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRBY3RpdmVJbmRleCh0aGlzLmdldEFjdGl2ZUluZGV4KCkgKyAxLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHByZXZcbiAgICogQHNpZ25hdHVyZSBwcmV2KFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1BIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhZnRlciB0aGUgYW5pbWF0aW9uIGhhcyBmaW5pc2hlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdG8gYFwibm9uZVwiYCB0aGUgdHJhbnNpdGlvbnMgd2lsbCBub3QgYmUgYW5pbWF0ZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXUFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHNwZWNpZnkgdGhlIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nIGZ1bmN0aW9uIG9mIHRoZSBhbmltYXRpb24uWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIGNhcm91c2VsIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdyBwcmV2aW91cyBgPG9ucy1jYXJvdXNlbC1pdGVtPmAuWy9lbl1cbiAgICogICBbamFd5YmN44Gub25zLWNhcm91c2VsLWl0ZW3jgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgcHJldihvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0QWN0aXZlSW5kZXgodGhpcy5nZXRBY3RpdmVJbmRleCgpIC0gMSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIF9pc0VuYWJsZWRDaGFuZ2VFdmVudCgpIHtcbiAgICBjb25zdCBlbGVtZW50U2l6ZSA9IHRoaXMuX2dldEVsZW1lbnRTaXplKCk7XG4gICAgY29uc3QgY2Fyb3VzZWxJdGVtU2l6ZSA9IHRoaXMuX2dldENhcm91c2VsSXRlbVNpemUoKTtcblxuICAgIHJldHVybiB0aGlzLmF1dG9TY3JvbGwgJiYgZWxlbWVudFNpemUgPT09IGNhcm91c2VsSXRlbVNpemU7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIF9pc1ZlcnRpY2FsKCkge1xuICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnZGlyZWN0aW9uJykgPT09ICd2ZXJ0aWNhbCc7XG4gIH1cblxuICBfcHJlcGFyZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuX2dlc3R1cmVEZXRlY3RvciA9IG5ldyBHZXN0dXJlRGV0ZWN0b3IodGhpcywge1xuICAgICAgZHJhZ01pbkRpc3RhbmNlOiAxLFxuICAgICAgZHJhZ0xvY2tUb0F4aXM6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLl9tdXRhdGlvbk9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4gdGhpcy5yZWZyZXNoKCkpO1xuXG4gICAgdGhpcy5fdXBkYXRlU3dpcGVhYmxlKCk7XG4gICAgdGhpcy5fdXBkYXRlQXV0b1JlZnJlc2goKTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9ib3VuZE9uUmVzaXplLCB0cnVlKTtcbiAgfVxuXG4gIF9yZW1vdmVFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IuZGlzcG9zZSgpO1xuICAgIHRoaXMuX2dlc3R1cmVEZXRlY3RvciA9IG51bGw7XG5cbiAgICB0aGlzLl9tdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLl9tdXRhdGlvbk9ic2VydmVyID0gbnVsbDtcblxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9ib3VuZE9uUmVzaXplLCB0cnVlKTtcbiAgfVxuXG4gIF91cGRhdGVTd2lwZWFibGUoKSB7XG4gICAgaWYgKHRoaXMuX2dlc3R1cmVEZXRlY3Rvcikge1xuICAgICAgaWYgKHRoaXMuc3dpcGVhYmxlKSB7XG4gICAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5vbignZHJhZyBkcmFnbGVmdCBkcmFncmlnaHQgZHJhZ3VwIGRyYWdkb3duIHN3aXBlIHN3aXBlbGVmdCBzd2lwZXJpZ2h0IHN3aXBldXAgc3dpcGVkb3duJywgdGhpcy5fYm91bmRPbkRyYWcpO1xuICAgICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3Iub24oJ2RyYWdlbmQnLCB0aGlzLl9ib3VuZE9uRHJhZ0VuZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3Iub2ZmKCdkcmFnIGRyYWdsZWZ0IGRyYWdyaWdodCBkcmFndXAgZHJhZ2Rvd24gc3dpcGUgc3dpcGVsZWZ0IHN3aXBlcmlnaHQgc3dpcGV1cCBzd2lwZWRvd24nLCB0aGlzLl9ib3VuZE9uRHJhZyk7XG4gICAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5vZmYoJ2RyYWdlbmQnLCB0aGlzLl9ib3VuZE9uRHJhZ0VuZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZUF1dG9SZWZyZXNoKCkge1xuICAgIGlmICh0aGlzLl9tdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ2F1dG8tcmVmcmVzaCcpKSB7XG4gICAgICAgIHRoaXMuX211dGF0aW9uT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLCB7Y2hpbGRMaXN0OiB0cnVlfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9tdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfdHJ5RmlyZVBvc3RDaGFuZ2VFdmVudCgpIHtcbiAgICBjb25zdCBjdXJyZW50SW5kZXggPSB0aGlzLmdldEFjdGl2ZUluZGV4KCk7XG5cbiAgICBpZiAodGhpcy5fbGFzdEFjdGl2ZUluZGV4ICE9PSBjdXJyZW50SW5kZXgpIHtcbiAgICAgIGNvbnN0IGxhc3RBY3RpdmVJbmRleCA9IHRoaXMuX2xhc3RBY3RpdmVJbmRleDtcbiAgICAgIHRoaXMuX2xhc3RBY3RpdmVJbmRleCA9IGN1cnJlbnRJbmRleDtcblxuICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwb3N0Y2hhbmdlJywge1xuICAgICAgICBjYXJvdXNlbDogdGhpcyxcbiAgICAgICAgYWN0aXZlSW5kZXg6IGN1cnJlbnRJbmRleCxcbiAgICAgICAgbGFzdEFjdGl2ZUluZGV4OiBsYXN0QWN0aXZlSW5kZXhcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIF9pc1dyb25nRGlyZWN0aW9uKGQpIHtcbiAgICAvLyB0aGlzLl9sYXN0RHJhZ0RpcmVjdGlvbiA9IGQ7XG4gICAgcmV0dXJuIHRoaXMuX2lzVmVydGljYWwoKSA/IChkID09PSAnbGVmdCcgfHwgZCA9PT0gJ3JpZ2h0JykgOiAoZCA9PT0gJ3VwJyB8fCBkID09PSAnZG93bicpO1xuICB9XG5cbiAgX29uRHJhZyhldmVudCkge1xuICAgIGlmICh0aGlzLl9pc1dyb25nRGlyZWN0aW9uKGV2ZW50Lmdlc3R1cmUuZGlyZWN0aW9uKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgdGhpcy5fbGFzdERyYWdFdmVudCA9IGV2ZW50O1xuXG4gICAgY29uc3Qgc2Nyb2xsID0gdGhpcy5fc2Nyb2xsIC0gdGhpcy5fZ2V0U2Nyb2xsRGVsdGEoZXZlbnQpO1xuICAgIHRoaXMuX3Njcm9sbFRvKHNjcm9sbCk7XG4gICAgZXZlbnQuZ2VzdHVyZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgdGhpcy5fdHJ5RmlyZVBvc3RDaGFuZ2VFdmVudCgpO1xuICB9XG5cbiAgX29uRHJhZ0VuZChldmVudCkge1xuICAgIGlmICghdGhpcy5fbGFzdERyYWdFdmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudFNpemUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc2Nyb2xsID0gdGhpcy5fc2Nyb2xsIC0gdGhpcy5fZ2V0U2Nyb2xsRGVsdGEoZXZlbnQpO1xuXG4gICAgLy8gaWYgKCF0aGlzLl9pc1dyb25nRGlyZWN0aW9uKHRoaXMuX2xhc3REcmFnRGlyZWN0aW9uKSAmJiB0aGlzLl9nZXRTY3JvbGxEZWx0YShldmVudCkgIT09IDApIHtcbiAgICAvLyAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIC8vIH1cblxuICAgIGlmICh0aGlzLl9pc092ZXJTY3JvbGwodGhpcy5fc2Nyb2xsKSkge1xuICAgICAgbGV0IHdhaXRGb3JBY3Rpb24gPSBmYWxzZTtcbiAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnb3ZlcnNjcm9sbCcsIHtcbiAgICAgICAgY2Fyb3VzZWw6IHRoaXMsXG4gICAgICAgIGFjdGl2ZUluZGV4OiB0aGlzLmdldEFjdGl2ZUluZGV4KCksXG4gICAgICAgIGRpcmVjdGlvbjogdGhpcy5fZ2V0T3ZlclNjcm9sbERpcmVjdGlvbigpLFxuICAgICAgICB3YWl0VG9SZXR1cm46IChwcm9taXNlKSA9PiB7XG4gICAgICAgICAgd2FpdEZvckFjdGlvbiA9IHRydWU7XG4gICAgICAgICAgcHJvbWlzZS50aGVuKCgpID0+IHRoaXMuX3Njcm9sbFRvS2lsbE92ZXJTY3JvbGwoKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXdhaXRGb3JBY3Rpb24pIHtcbiAgICAgICAgdGhpcy5fc2Nyb2xsVG9LaWxsT3ZlclNjcm9sbCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zdGFydE1vbWVudHVtU2Nyb2xsKCk7XG4gICAgfVxuICAgIHRoaXMuX2xhc3REcmFnRXZlbnQgPSBudWxsO1xuXG4gICAgZXZlbnQuZ2VzdHVyZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFpdFxuICAgKi9cbiAgX21peGluKHRyYWl0KSB7XG4gICAgT2JqZWN0LmtleXModHJhaXQpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICB0aGlzW2tleV0gPSB0cmFpdFtrZXldO1xuICAgIH0uYmluZCh0aGlzKSk7XG4gIH1cblxuICBfc3RhcnRNb21lbnR1bVNjcm9sbCgpIHtcbiAgICBpZiAodGhpcy5fbGFzdERyYWdFdmVudCkge1xuICAgICAgY29uc3QgdmVsb2NpdHkgPSB0aGlzLl9nZXRTY3JvbGxWZWxvY2l0eSh0aGlzLl9sYXN0RHJhZ0V2ZW50KTtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gMC4zO1xuICAgICAgY29uc3Qgc2Nyb2xsRGVsdGEgPSBkdXJhdGlvbiAqIDEwMCAqIHZlbG9jaXR5O1xuICAgICAgY29uc3Qgc2Nyb2xsID0gdGhpcy5fbm9ybWFsaXplU2Nyb2xsUG9zaXRpb24oXG4gICAgICAgIHRoaXMuX3Njcm9sbCArICh0aGlzLl9nZXRTY3JvbGxEZWx0YSh0aGlzLl9sYXN0RHJhZ0V2ZW50KSA+IDAgPyAtc2Nyb2xsRGVsdGEgOiBzY3JvbGxEZWx0YSlcbiAgICAgICk7XG5cbiAgICAgIHRoaXMuX3Njcm9sbCA9IHNjcm9sbDtcblxuICAgICAgYW5pbWl0KHRoaXMuX2dldENhcm91c2VsSXRlbUVsZW1lbnRzKCkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiB0aGlzLl9nZW5lcmF0ZVNjcm9sbFRyYW5zZm9ybSh0aGlzLl9zY3JvbGwpXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiAnY3ViaWMtYmV6aWVyKC4xLCAuNywgLjEsIDEpJ1xuICAgICAgICB9KVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICB0aGlzLl90cnlGaXJlUG9zdENoYW5nZUV2ZW50KCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSlcbiAgICAgICAgLnBsYXkoKTtcbiAgICB9XG4gIH1cblxuICBfbm9ybWFsaXplU2Nyb2xsUG9zaXRpb24oc2Nyb2xsKSB7XG4gICAgY29uc3QgbWF4ID0gdGhpcy5fY2FsY3VsYXRlTWF4U2Nyb2xsKCk7XG5cbiAgICBpZiAoIXRoaXMuYXV0b1Njcm9sbCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKG1heCwgc2Nyb2xsKSk7XG4gICAgfVxuICAgIGxldCBhcnIgPSBbXTtcbiAgICBjb25zdCBzaXplID0gdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtU2l6ZSgpO1xuICAgIGNvbnN0IG5ick9mSXRlbXMgPSB0aGlzLml0ZW1Db3VudDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmJyT2ZJdGVtczsgaSsrKSB7XG4gICAgICBpZiAoaSAqIHNpemUgKyB0aGlzLl9vZmZzZXQgPCBtYXgpIHtcbiAgICAgICAgYXJyLnB1c2goaSAqIHNpemUgKyB0aGlzLl9vZmZzZXQpO1xuICAgICAgfVxuICAgIH1cbiAgICBhcnIucHVzaChtYXgpO1xuXG4gICAgYXJyLnNvcnQoZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICAgIGxlZnQgPSBNYXRoLmFicyhsZWZ0IC0gc2Nyb2xsKTtcbiAgICAgIHJpZ2h0ID0gTWF0aC5hYnMocmlnaHQgLSBzY3JvbGwpO1xuXG4gICAgICByZXR1cm4gbGVmdCAtIHJpZ2h0O1xuICAgIH0pO1xuXG4gICAgYXJyID0gYXJyLmZpbHRlcihmdW5jdGlvbihpdGVtLCBwb3MpIHtcbiAgICAgIHJldHVybiAhcG9zIHx8IGl0ZW0gIT0gYXJyW3BvcyAtIDFdO1xuICAgIH0pO1xuXG4gICAgY29uc3QgbGFzdFNjcm9sbCA9IHRoaXMuX2xhc3RBY3RpdmVJbmRleCAqIHNpemUgKyB0aGlzLl9vZmZzZXQ7XG4gICAgY29uc3Qgc2Nyb2xsUmF0aW8gPSBNYXRoLmFicyhzY3JvbGwgLSBsYXN0U2Nyb2xsKSAvIHNpemU7XG4gICAgbGV0IHJlc3VsdCA9IGFyclswXTtcblxuICAgIGlmIChzY3JvbGxSYXRpbyA8PSB0aGlzLmF1dG9TY3JvbGxSYXRpbykge1xuICAgICAgcmVzdWx0ID0gbGFzdFNjcm9sbDtcbiAgICB9IGVsc2UgaWYgKHNjcm9sbFJhdGlvIDwgMS4wKSB7XG4gICAgICBpZiAoYXJyWzBdID09PSBsYXN0U2Nyb2xsICYmIGFyci5sZW5ndGggPiAxKSB7XG4gICAgICAgIHJlc3VsdCA9IGFyclsxXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4obWF4LCByZXN1bHQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIF9nZXRDYXJvdXNlbEl0ZW1FbGVtZW50cygpIHtcbiAgICByZXR1cm4gdXRpbC5hcnJheUZyb20odGhpcy5jaGlsZHJlbilcbiAgICAgIC5maWx0ZXIoKGNoaWxkKSA9PiBjaGlsZC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb25zLWNhcm91c2VsLWl0ZW0nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge051bWJlcn0gc2Nyb2xsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZXMgdG8gdGhlIGNhcm91c2VsIGVsZW1lbnRcbiAgICovXG4gIF9zY3JvbGxUbyhzY3JvbGwsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGlzT3ZlcnNjcm9sbGFibGUgPSB0aGlzLm92ZXJzY3JvbGxhYmxlO1xuXG4gICAgY29uc3Qgbm9ybWFsaXplU2Nyb2xsID0gKHNjcm9sbCkgPT4ge1xuICAgICAgY29uc3QgcmF0aW8gPSAwLjM1O1xuXG4gICAgICBpZiAoc2Nyb2xsIDwgMCkge1xuICAgICAgICByZXR1cm4gaXNPdmVyc2Nyb2xsYWJsZSA/IE1hdGgucm91bmQoc2Nyb2xsICogcmF0aW8pIDogMDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbWF4U2Nyb2xsID0gdGhpcy5fY2FsY3VsYXRlTWF4U2Nyb2xsKCk7XG4gICAgICBpZiAobWF4U2Nyb2xsIDwgc2Nyb2xsKSB7XG4gICAgICAgIHJldHVybiBpc092ZXJzY3JvbGxhYmxlID8gbWF4U2Nyb2xsICsgTWF0aC5yb3VuZCgoc2Nyb2xsIC0gbWF4U2Nyb2xsKSAqIHJhdGlvKSA6IG1heFNjcm9sbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNjcm9sbDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgYW5pbWl0KHRoaXMuX2dldENhcm91c2VsSXRlbUVsZW1lbnRzKCkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiB0aGlzLl9nZW5lcmF0ZVNjcm9sbFRyYW5zZm9ybShub3JtYWxpemVTY3JvbGwoc2Nyb2xsKSlcbiAgICAgICAgfSwgb3B0aW9ucy5hbmltYXRpb24gICE9PSAnbm9uZScgPyBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgOiB7fSlcbiAgICAgICAgLnBsYXkoKCkgPT4ge1xuICAgICAgICAgIGlmIChvcHRpb25zLmNhbGxiYWNrIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jYWxjdWxhdGVNYXhTY3JvbGwoKSB7XG4gICAgY29uc3QgbWF4ID0gdGhpcy5pdGVtQ291bnQgKiB0aGlzLl9nZXRDYXJvdXNlbEl0ZW1TaXplKCkgLSB0aGlzLl9nZXRFbGVtZW50U2l6ZSgpO1xuICAgIHJldHVybiBNYXRoLmNlaWwobWF4IDwgMCA/IDAgOiBtYXgpOyAvLyBOZWVkIHRvIHJldHVybiBhbiBpbnRlZ2VyIHZhbHVlLlxuICB9XG5cbiAgX2lzT3ZlclNjcm9sbChzY3JvbGwpIHtcbiAgICBpZiAoc2Nyb2xsIDwgMCB8fCBzY3JvbGwgPiB0aGlzLl9jYWxjdWxhdGVNYXhTY3JvbGwoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIF9nZXRPdmVyU2Nyb2xsRGlyZWN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9pc1ZlcnRpY2FsKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zY3JvbGwgPD0gMCA/ICd1cCcgOiAnZG93bic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9zY3JvbGwgPD0gMCA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgfVxuICB9XG5cbiAgX3Njcm9sbFRvS2lsbE92ZXJTY3JvbGwoKSB7XG4gICAgY29uc3QgZHVyYXRpb24gPSAwLjQ7XG5cbiAgICBpZiAodGhpcy5fc2Nyb2xsIDwgMCkge1xuICAgICAgYW5pbWl0KHRoaXMuX2dldENhcm91c2VsSXRlbUVsZW1lbnRzKCkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiB0aGlzLl9nZW5lcmF0ZVNjcm9sbFRyYW5zZm9ybSgwKVxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogJ2N1YmljLWJlemllciguMSwgLjQsIC4xLCAxKSdcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgdGhpcy5fdHJ5RmlyZVBvc3RDaGFuZ2VFdmVudCgpO1xuICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgIC5wbGF5KCk7XG4gICAgICB0aGlzLl9zY3JvbGwgPSAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG1heFNjcm9sbCA9IHRoaXMuX2NhbGN1bGF0ZU1heFNjcm9sbCgpO1xuXG4gICAgaWYgKG1heFNjcm9sbCA8IHRoaXMuX3Njcm9sbCkge1xuICAgICAgYW5pbWl0KHRoaXMuX2dldENhcm91c2VsSXRlbUVsZW1lbnRzKCkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiB0aGlzLl9nZW5lcmF0ZVNjcm9sbFRyYW5zZm9ybShtYXhTY3JvbGwpXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiAnY3ViaWMtYmV6aWVyKC4xLCAuNCwgLjEsIDEpJ1xuICAgICAgICB9KVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICB0aGlzLl90cnlGaXJlUG9zdENoYW5nZUV2ZW50KCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSlcbiAgICAgICAgLnBsYXkoKTtcbiAgICAgIHRoaXMuX3Njcm9sbCA9IG1heFNjcm9sbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGl0ZW1Db3VudFxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBudW1iZXIgb2YgY2Fyb3VzZWwgaXRlbXMuWy9lbl1cbiAgICogICBbamFd44Kr44Or44O844K744Or6KaB57Sg44Gu5pWw44Gn44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBpdGVtQ291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldENhcm91c2VsSXRlbUVsZW1lbnRzKCkubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcmVmcmVzaFxuICAgKiBAc2lnbmF0dXJlIHJlZnJlc2goKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVXBkYXRlIHRoZSBsYXlvdXQgb2YgdGhlIGNhcm91c2VsLiBVc2VkIHdoZW4gYWRkaW5nIGA8b25zLWNhcm91c2VsLWl0ZW1zPmAgZHluYW1pY2FsbHkgb3IgdG8gYXV0b21hdGljYWxseSBhZGp1c3QgdGhlIHNpemUuWy9lbl1cbiAgICogICBbamFd44Os44Kk44Ki44Km44OI44KE5YaF6YOo44Gu54q25oWL44KS5pyA5paw44Gu44KC44Gu44Gr5pu05paw44GX44G+44GZ44CCb25zLWNhcm91c2VsLWl0ZW3jgpLli5XnmoTjgavlopfjgoTjgZfjgZ/jgorjgIFvbnMtY2Fyb3VzZWzjga7lpKfjgY3jgZXjgpLli5XnmoTjgavlpInjgYjjgovpmpvjgavliKnnlKjjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgcmVmcmVzaCgpIHtcbiAgICAvLyBCdWcgZml4XG4gICAgaWYgKHRoaXMuX2dldENhcm91c2VsSXRlbVNpemUoKSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX21peGluKHRoaXMuX2lzVmVydGljYWwoKSA/IFZlcnRpY2FsTW9kZVRyYWl0IDogSG9yaXpvbnRhbE1vZGVUcmFpdCk7XG4gICAgdGhpcy5fc2V0dXAoKTtcblxuICAgIGlmICh0aGlzLl9sYXN0U3RhdGUgJiYgdGhpcy5fbGFzdFN0YXRlLndpZHRoID4gMCkge1xuICAgICAgbGV0IHNjcm9sbCA9IHRoaXMuX3Njcm9sbDsvLyAtIHRoaXMuX29mZnNldDtcblxuICAgICAgaWYgKHRoaXMuX2lzT3ZlclNjcm9sbChzY3JvbGwpKSB7XG4gICAgICAgIHRoaXMuX3Njcm9sbFRvS2lsbE92ZXJTY3JvbGwoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmF1dG9TY3JvbGwpIHtcbiAgICAgICAgICBzY3JvbGwgPSB0aGlzLl9ub3JtYWxpemVTY3JvbGxQb3NpdGlvbihzY3JvbGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2Nyb2xsVG8oc2Nyb2xsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9zYXZlTGFzdFN0YXRlKCk7XG5cbiAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3JlZnJlc2gnLCB7Y2Fyb3VzZWw6IHRoaXN9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGZpcnN0XG4gICAqIEBzaWduYXR1cmUgZmlyc3QoKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZSBhbmltYXRpb24gaGFzIGZpbmlzaGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0byBgXCJub25lXCJgIHRoZSB0cmFuc2l0aW9ucyB3aWxsIG5vdCBiZSBhbmltYXRlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dQW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSB0aGUgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcgZnVuY3Rpb24gb2YgdGhlIGFuaW1hdGlvbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgY2Fyb3VzZWwgZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IGZpcnN0IGA8b25zLWNhcm91c2VsLWl0ZW0+YC5bL2VuXVxuICAgKiAgIFtqYV3mnIDliJ3jga5vbnMtY2Fyb3VzZWwtaXRlbeOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBmaXJzdChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0QWN0aXZlSW5kZXgoMCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBsYXN0XG4gICAqIEBzaWduYXR1cmUgbGFzdCgpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBoYXMgZmluaXNoZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRvIGBcIm5vbmVcImAgdGhlIHRyYW5zaXRpb25zIHdpbGwgbm90IGJlIGFuaW1hdGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1BbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IHRoZSBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZyBmdW5jdGlvbiBvZiB0aGUgYW5pbWF0aW9uLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBjYXJvdXNlbCBlbGVtZW50Wy9lbl1cbiAgICogICBbamFdUmVzb2x2ZXMgdG8gdGhlIGNhcm91c2VsIGVsZW1lbnRbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdyBsYXN0IG9ucy1jYXJvdXNlbCBpdGVtLlsvZW5dXG4gICAqICAgW2phXeacgOW+jOOBrm9ucy1jYXJvdXNlbC1pdGVt44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGxhc3Qob3B0aW9ucykge1xuICAgIHRoaXMuc2V0QWN0aXZlSW5kZXgoXG4gICAgICBNYXRoLm1heCh0aGlzLml0ZW1Db3VudCAtIDEsIDApLCBvcHRpb25zXG4gICAgKTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX3ByZXBhcmVFdmVudExpc3RlbmVycygpO1xuXG4gICAgdGhpcy5fc2V0dXAoKTtcbiAgICB0aGlzLl9zZXR1cEluaXRpYWxJbmRleCgpO1xuXG4gICAgdGhpcy5fc2F2ZUxhc3RTdGF0ZSgpO1xuXG4gICAgLy8gRml4IHJlbmRlcmluZyBnbGl0Y2ggb24gQW5kcm9pZCA0LjFcbiAgICBpZiAodGhpcy5vZmZzZXRIZWlnaHQgPT09IDApIHtcbiAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLnJlZnJlc2goKSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnc3dpcGVhYmxlJywgJ2F1dG8tcmVmcmVzaCcsICdkaXJlY3Rpb24nXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdzd2lwZWFibGUnOlxuICAgICAgICB0aGlzLl91cGRhdGVTd2lwZWFibGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdhdXRvLXJlZnJlc2gnOlxuICAgICAgICB0aGlzLl91cGRhdGVBdXRvUmVmcmVzaCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2RpcmVjdGlvbic6XG4gICAgICAgIHRoaXMuX29uRGlyZWN0aW9uQ2hhbmdlKCk7XG4gICAgfVxuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgYXV0b1Njcm9sbFJhdGlvXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgY3VycmVudCBhdXRvIHNjcm9sbCByYXRpby4gWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu44Kq44O844OI44K544Kv44Ot44O844Or44GucmF0aW/lgKTjgIJbL2phXVxuICAgKi9cbiAgZ2V0IGF1dG9TY3JvbGxSYXRpbygpIHtcbiAgICBjb25zdCBhdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2F1dG8tc2Nyb2xsLXJhdGlvJyk7XG5cbiAgICBpZiAoIWF0dHIpIHtcbiAgICAgIHJldHVybiAwLjU7XG4gICAgfVxuXG4gICAgY29uc3Qgc2Nyb2xsUmF0aW8gPSBwYXJzZUZsb2F0KGF0dHIpO1xuICAgIGlmIChzY3JvbGxSYXRpbyA8IDAuMCB8fCBzY3JvbGxSYXRpbyA+IDEuMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJhdGlvLicpO1xuICAgIH1cblxuICAgIHJldHVybiBpc05hTihzY3JvbGxSYXRpbykgPyAwLjUgOiBzY3JvbGxSYXRpbztcbiAgfVxuXG4gIHNldCBhdXRvU2Nyb2xsUmF0aW8ocmF0aW8pIHtcbiAgICBpZiAocmF0aW8gPCAwLjAgfHwgcmF0aW8gPiAxLjApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByYXRpby4nKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYXV0by1zY3JvbGwtcmF0aW8nLCByYXRpbyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHN3aXBlYWJsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXXRydWUgaWYgdGhlIGNhcm91c2VsIGlzIHN3aXBlYWJsZS5bL2VuXVxuICAgKiAgIFtqYV1zd2lwZWFibGXjgafjgYLjgozjgbB0cnVl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBzd2lwZWFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdzd2lwZWFibGUnKTtcbiAgfVxuXG4gIHNldCBzd2lwZWFibGUodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ3N3aXBlYWJsZScsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgYXV0b1Njcm9sbFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXXRydWUgaWYgYXV0byBzY3JvbGwgaXMgZW5hYmxlZC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg7zjg4jjgrnjgq/jg63jg7zjg6vjgYzmnInlirnjgafjgYLjgozjgbB0cnVl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBhdXRvU2Nyb2xsKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnYXV0by1zY3JvbGwnKTtcbiAgfVxuXG4gIHNldCBhdXRvU2Nyb2xsKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdhdXRvLXNjcm9sbCcsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBjYXJvdXNlbCBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gIH1cblxuICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvdmVyc2Nyb2xsYWJsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGNhcm91c2VsIGlzIG92ZXJzY3JvbGxhYmxlIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV1vdmVyc2Nyb2xs44Gn44GN44KM44GwdHJ1ZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXQgb3ZlcnNjcm9sbGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdvdmVyc2Nyb2xsYWJsZScpO1xuICB9XG5cbiAgc2V0IG92ZXJzY3JvbGxhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdvdmVyc2Nyb2xsYWJsZScsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgY2VudGVyZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBjYXJvdXNlbCBpcyBjZW50ZXJlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFdY2VudGVyZWTnirbmhYvjgavjgarjgaPjgabjgYTjgozjgbB0cnVl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBjZW50ZXJlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2NlbnRlcmVkJyk7XG4gIH1cblxuICBzZXQgY2VudGVyZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2NlbnRlcmVkJywgdmFsdWUpO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWNhcm91c2VsJywgQ2Fyb3VzZWxFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtY29sXG4gKiBAY2F0ZWdvcnkgZ3JpZFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1SZXByZXNlbnRzIGEgY29sdW1uIGluIHRoZSBncmlkIHN5c3RlbS4gVXNlIHdpdGggYDxvbnMtcm93PmAgdG8gbGF5b3V0IGNvbXBvbmVudHMuWy9lbl1cbiAqICAgW2phXeOCsOODquODg+ODieOCt+OCueODhuODoOOBq+OBpuWIl+OCkuWumue+qeOBl+OBvuOBmeOAgm9ucy1yb3fjgajjgajjgoLjgavkvb/nlKjjgZfjgIHjgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jg6zjgqTjgqLjgqbjg4jjgavliKnnlKjjgZfjgb7jgZnjgIJbL2phXVxuICogQG5vdGVcbiAqICAgW2VuXUZvciBBbmRyb2lkIDQuMyBhbmQgZWFybGllciwgYW5kIGlPUzYgYW5kIGVhcmxpZXIsIHdoZW4gdXNpbmcgbWl4ZWQgYWxpZ25tZW50IHdpdGggb25zLXJvdyBhbmQgb25zLWNvbHVtbiwgdGhleSBtYXkgbm90IGJlIGRpc3BsYXllZCBjb3JyZWN0bHkuIFlvdSBjYW4gdXNlIG9ubHkgb25lIGFsaWdubWVudC5bL2VuXVxuICogICBbamFdQW5kcm9pZCA0LjPku6XliY3jgIHjgoLjgZfjgY/jga9pT1MgNuS7peWJjeOBrk9T44Gu5aC05ZCI44CBb25zLXJvd+OBqG9ucy1jb2x1bW7jgpLntYTjgb/lkIjjgo/jgZvjgZ/loLTlkIjjgavmj4/nlLvjgYzltKnjgozjgovloLTlkIjjgYzjgYLjgorjgb7jgZnjgIJbL2phXVxuICogQGNvZGVwZW4gR2d1akMge3dpZGV9XG4gKiBAZ3VpZGUgbGF5b3V0aW5nIFtlbl1MYXlvdXRpbmcgZ3VpZGVbL2VuXVtqYV3jg6zjgqTjgqLjgqbjg4jmqZ/og71bL2phXVxuICogQHNlZWFsc28gb25zLXJvd1xuICogICBbZW5dVGhlIGA8b25zLXJvdz5gIGNvbXBvbmVudCBpcyB0aGUgcGFyZW50IG9mIGA8b25zLWNvbD5gLlsvZW5dXG4gKiAgIFtqYV1vbnMtcm9344Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXJvdz5cbiAqICAgPG9ucy1jb2wgd2lkdGg9XCI1MHB4XCI+PG9ucy1pY29uIGljb249XCJmYS10d2l0dGVyXCI+PC9vbnMtaWNvbj48L29ucy1jb2w+XG4gKiAgIDxvbnMtY29sPlRleHQ8L29ucy1jb2w+XG4gKiA8L29ucy1yb3c+XG4gKi9cblxuLyoqXG4gKiBAYXR0cmlidXRlIHZlcnRpY2FsLWFsaWduXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1WZXJ0aWNhbCBhbGlnbm1lbnQgb2YgdGhlIGNvbHVtbi4gVmFsaWQgdmFsdWVzIGFyZSBcInRvcFwiLCBcImNlbnRlclwiLCBhbmQgXCJib3R0b21cIi5bL2VuXVxuICogICBbamFd57im44Gu6YWN572u44KS5oyH5a6a44GZ44KL44CCXCJ0b3BcIiwgXCJjZW50ZXJcIiwgXCJib3R0b21cIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKi9cblxuLyoqXG4gKiBAYXR0cmlidXRlIHdpZHRoXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1UaGUgd2lkdGggb2YgdGhlIGNvbHVtbi4gVmFsaWQgdmFsdWVzIGFyZSBjc3Mgd2lkdGggdmFsdWVzIChcIjEwJVwiLCBcIjUwcHhcIikuWy9lbl1cbiAqICAgW2phXeOCq+ODqeODoOOBruaoquW5heOCkuaMh+WumuOBmeOCi+OAguODkeODvOOCu+ODs+ODiOOCguOBl+OBj+OBr+ODlOOCr+OCu+ODq+OBp+aMh+WumuOBl+OBvuOBme+8iDEwJeOChDUwcHjvvInjgIJbL2phXVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb2xFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIGluaXQoKSB7XG4gICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcpKSB7XG4gICAgICB0aGlzLl91cGRhdGVXaWR0aCgpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ3dpZHRoJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChuYW1lID09PSAnd2lkdGgnKSB7XG4gICAgICB0aGlzLl91cGRhdGVXaWR0aCgpO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVXaWR0aCgpIHtcbiAgICBsZXQgd2lkdGggPSB0aGlzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKTtcbiAgICBpZiAodHlwZW9mIHdpZHRoICA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHdpZHRoID0gKCcnICsgd2lkdGgpLnRyaW0oKTtcbiAgICAgIHdpZHRoID0gd2lkdGgubWF0Y2goL15cXGQrJC8pID8gd2lkdGggKyAnJScgOiB3aWR0aDtcblxuICAgICAgdGhpcy5zdHlsZS53ZWJraXRCb3hGbGV4ID0gJzAnO1xuICAgICAgdGhpcy5zdHlsZS53ZWJraXRGbGV4ID0gJzAgMCAnICsgd2lkdGg7XG4gICAgICB0aGlzLnN0eWxlLm1vekJveEZsZXggPSAnMCc7XG4gICAgICB0aGlzLnN0eWxlLm1vekZsZXggPSAnMCAwICcgKyB3aWR0aDtcbiAgICAgIHRoaXMuc3R5bGUubXNGbGV4ID0gJzAgMCAnICsgd2lkdGg7XG4gICAgICB0aGlzLnN0eWxlLmZsZXggPSAnMCAwICcgKyB3aWR0aDtcbiAgICAgIHRoaXMuc3R5bGUubWF4V2lkdGggPSB3aWR0aDtcbiAgICB9XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtY29sJywgQ29sRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5leHBvcnQgY2xhc3MgRGlhbG9nQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnbGluZWFyJywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuMn0gPSB7fSkge1xuICAgIHRoaXMudGltaW5nID0gdGltaW5nO1xuICAgIHRoaXMuZGVsYXkgPSBkZWxheTtcbiAgICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIHNob3coZGlhbG9nLCBkb25lKSB7XG4gICAgZG9uZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBoaWRlKGRpYWxvZywgZG9uZSkge1xuICAgIGRvbmUoKTtcbiAgfVxufVxuXG4vKipcbiAqIEFuZHJvaWQgc3R5bGUgYW5pbWF0b3IgZm9yIGRpYWxvZy5cbiAqL1xuZXhwb3J0IGNsYXNzIEFuZHJvaWREaWFsb2dBbmltYXRvciBleHRlbmRzIERpYWxvZ0FuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2Vhc2UtaW4tb3V0JywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuM30gPSB7fSkge1xuICAgIHN1cGVyKHt0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbn0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHNob3coZGlhbG9nLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX2RpYWxvZylcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNjAlLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBoaWRlKGRpYWxvZywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaylcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9kaWFsb2cpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTUwJSwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTYwJSwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMC4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIGlPUyBzdHlsZSBhbmltYXRvciBmb3IgZGlhbG9nLlxuICovXG5leHBvcnQgY2xhc3MgSU9TRGlhbG9nQW5pbWF0b3IgZXh0ZW5kcyBEaWFsb2dBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdlYXNlLWluLW91dCcsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjN9ID0ge30pIHtcbiAgICBzdXBlcih7dGltaW5nLCBkZWxheSwgZHVyYXRpb259KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBzaG93KGRpYWxvZywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaylcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9kaWFsb2cpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgMzAwJSwgMCknXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTUwJSwgMCknXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2spXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fZGlhbG9nKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIDMwMCUsIDApJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcblxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBTbGlkZSBhbmltYXRvciBmb3IgZGlhbG9nLlxuICovXG5leHBvcnQgY2xhc3MgU2xpZGVEaWFsb2dBbmltYXRvciBleHRlbmRzIERpYWxvZ0FuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2N1YmljLWJlemllciguMSwgLjcsIC40LCAxKScsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjJ9ID0ge30pIHtcbiAgICBzdXBlcih7dGltaW5nLCBkZWxheSwgZHVyYXRpb259KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBzaG93KGRpYWxvZywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaylcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9kaWFsb2cpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoLTUwJSwgLTM1MCUsIDApJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgtNTAlLCAtNTAlLCAwKScsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2spXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fZGlhbG9nKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKC01MCUsIC01MCUsIDApJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKC01MCUsIC0zNTAlLCAwKSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICdvbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEFuaW1hdG9yRmFjdG9yeSBmcm9tICdvbnMvaW50ZXJuYWwvYW5pbWF0b3ItZmFjdG9yeSc7XG5pbXBvcnQge0RpYWxvZ0FuaW1hdG9yLCBJT1NEaWFsb2dBbmltYXRvciwgQW5kcm9pZERpYWxvZ0FuaW1hdG9yLCBTbGlkZURpYWxvZ0FuaW1hdG9yfSBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICdvbnMvcGxhdGZvcm0nO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IERvb3JMb2NrIGZyb20gJ29ucy9kb29ybG9jayc7XG5pbXBvcnQgZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIgZnJvbSAnb25zL2RldmljZS1iYWNrLWJ1dHRvbi1kaXNwYXRjaGVyJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcuZGlhbG9nJzogJ2RpYWxvZy0tKicsXG4gICcuZGlhbG9nLWNvbnRhaW5lcic6ICdkaWFsb2ctY29udGFpbmVyLS0qJyxcbiAgJy5kaWFsb2ctbWFzayc6ICdkaWFsb2ctbWFzay0tKidcbn07XG5cbmNvbnN0IF9hbmltYXRvckRpY3QgPSB7XG4gICdkZWZhdWx0JzogKCkgPT4gcGxhdGZvcm0uaXNBbmRyb2lkKCkgPyBBbmRyb2lkRGlhbG9nQW5pbWF0b3IgOiBJT1NEaWFsb2dBbmltYXRvcixcbiAgJ3NsaWRlJzogU2xpZGVEaWFsb2dBbmltYXRvcixcbiAgJ25vbmUnOiBEaWFsb2dBbmltYXRvclxufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtZGlhbG9nXG4gKiBAY2F0ZWdvcnkgZGlhbG9nXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIERpYWxvZyB0aGF0IGlzIGRpc3BsYXllZCBvbiB0b3Agb2YgY3VycmVudCBzY3JlZW4uIEFzIG9wcG9zZWQgdG8gdGhlIGA8b25zLWFsZXJ0LWRpYWxvZz5gIGVsZW1lbnQsIHRoaXMgY29tcG9uZW50IGNhbiBjb250YWluIGFueSBraW5kIG9mIGNvbnRlbnQuXG4gKlxuICogICAgIFRvIHVzZSB0aGUgZWxlbWVudCBpdCBjYW4gZWl0aGVyIGJlIGF0dGFjaGVkIGRpcmVjdGx5IHRvIHRoZSBgPGJvZHk+YCBlbGVtZW50IG9yIGR5bmFtaWNhbGx5IGNyZWF0ZWQgZnJvbSBhIHRlbXBsYXRlIHVzaW5nIHRoZSBgb25zLmNyZWF0ZURpYWxvZyh0ZW1wbGF0ZSlgIHV0aWxpdHkgZnVuY3Rpb24gYW5kIHRoZSBgPG9ucy10ZW1wbGF0ZT5gIHRhZy5cbiAqXG4gKiAgICAgVGhlIGRpYWxvZyBpcyB1c2VmdWwgZm9yIGRpc3BsYXlpbmcgbWVudXMsIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gb3IgdG8gYXNrIHRoZSB1c2VyIHRvIG1ha2UgYSBkZWNpc2lvbi5cbiAqXG4gKiAgICAgSXQgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIGRpc3BsYXllZCBhcyBNYXRlcmlhbCBEZXNpZ24gd2hlbiBydW5uaW5nIG9uIGFuIEFuZHJvaWQgZGV2aWNlLlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dRGlzcGxheSBhIE1hdGVyaWFsIERlc2lnbiBkaWFsb2cuWy9lbl1cbiAqICAgW2phXeODnuODhuODquOCouODq+ODh+OCtuOCpOODs+OBruODgOOCpOOCouODreOCsOOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAY29kZXBlbiB6eHhhR2FcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9kaWFsb2dcbiAqIEBndWlkZSBkaWFsb2dzXG4gKiAgIFtlbl1EaWFsb2cgY29tcG9uZW50c1svZW5dXG4gKiAgIFtqYV1EaWFsb2cgY29tcG9uZW50c1svamFdXG4gKiBAZ3VpZGUgdXNpbmctbW9kaWZpZXIgW2VuXU1vcmUgZGV0YWlscyBhYm91dCB0aGUgYG1vZGlmaWVyYCBhdHRyaWJ1dGVbL2VuXVtqYV1tb2RpZmllcuWxnuaAp+OBruS9v+OBhOaWuVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtYWxlcnQtZGlhbG9nXG4gKiAgIFtlbl1gPG9ucy1hbGVydC1kaWFsb2c+YCBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWFsZXJ0LWRpYWxvZ+OCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtcG9wb3ZlclxuICogICBbZW5dYDxvbnMtcG9wb3Zlcj5gIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtcG9wb3ZlcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtbW9kYWxcbiAqICAgW2VuXWA8b25zLW1vZGFsPmAgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1tb2RhbOOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1kaWFsb2cgaWQ9XCJkaWFsb2dcIj5cbiAqICAgPHA+VGhpcyBpcyBhIGRpYWxvZyE8L3A+XG4gKiA8L29ucy1kaWFsb2c+XG4gKlxuICogPHNjcmlwdD5cbiAqICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RpYWxvZycpLnNob3coKTtcbiAqIDwvc2NyaXB0PlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEaWFsb2dFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcHJlc2hvd1xuICAgKiBAZGVzY3JpcHRpb25cbiAgICogW2VuXUZpcmVkIGp1c3QgYmVmb3JlIHRoZSBkaWFsb2cgaXMgZGlzcGxheWVkLlsvZW5dXG4gICAqIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzooajnpLrjgZXjgozjgovnm7TliY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuZGlhbG9nXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUV4ZWN1dGUgdGhpcyBmdW5jdGlvbiB0byBzdG9wIHRoZSBkaWFsb2cgZnJvbSBiZWluZyBzaG93bi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlrp/ooYzjgZnjgovjgajjgIHjg4DjgqTjgqLjg63jgrDjga7ooajnpLrjgYzjgq3jg6Pjg7Pjgrvjg6vjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgZGlhbG9nIGlzIGRpc3BsYXllZC5bL2VuXVxuICAgKiBbamFd44OA44Kk44Ki44Ot44Kw44GM6KGo56S644GV44KM44Gf55u05b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmRpYWxvZ1xuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcHJlaGlkZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogW2VuXUZpcmVkIGp1c3QgYmVmb3JlIHRoZSBkaWFsb2cgaXMgaGlkZGVuLlsvZW5dXG4gICAqIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzpmqDjgozjgovnm7TliY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuZGlhbG9nXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUV4ZWN1dGUgdGhpcyBmdW5jdGlvbiB0byBzdG9wIHRoZSBkaWFsb2cgZnJvbSBiZWluZyBoaWRkZW4uWy9lbl1cbiAgICogICBbamFd44GT44Gu6Zai5pWw44KS5a6f6KGM44GZ44KL44Go44CB44OA44Kk44Ki44Ot44Kw44Gu6Z2e6KGo56S644GM44Kt44Oj44Oz44K744Or44GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0aGlkZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIGRpYWxvZyBpcyBoaWRkZW4uWy9lbl1cbiAgICogW2phXeODgOOCpOOCouODreOCsOOBjOmaoOOCjOOBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5kaWFsb2dcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgZGlhbG9nLlsvZW5dXG4gICAqICBbamFd44OA44Kk44Ki44Ot44Kw44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgY2FuY2VsYWJsZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGRpYWxvZyBjYW4gYmUgY2xvc2VkIGJ5IHRhcHBpbmcgdGhlIGJhY2tncm91bmQgb3IgYnkgcHJlc3NpbmcgdGhlIGJhY2sgYnV0dG9uIG9uIEFuZHJvaWQgZGV2aWNlcy5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgZGlhbG9nIGlzIGRpc2FibGVkLlsvZW5dXG4gICAqICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CB44OA44Kk44Ki44Ot44Kw44GvZGlzYWJsZWTnirbmhYvjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgZGVmYXVsdFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYW5pbWF0aW9uIHVzZWQgd2hlbiBzaG93aW5nIGFuZCBoaWRpbmcgdGhlIGRpYWxvZy4gQ2FuIGJlIGVpdGhlciBgXCJub25lXCJgIG9yIGBcImRlZmF1bHRcImAuWy9lbl1cbiAgICogIFtqYV3jg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZnjgovpmpvjga7jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIuOCguOBl+OBj+OBr1wiZGVmYXVsdFwi44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uLW9wdGlvbnNcbiAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCB0aW1pbmcgYW5kIGRlbGF5IHdpdGggYW4gb2JqZWN0IGxpdGVyYWwuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCB0aW1pbmcsIGRlbGF544KS44Kq44OW44K444Kn44Kv44OI44Oq44OG44Op44Or44Gn5oyH5a6a44GX44G+44GZ44CCZS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbWFzay1jb2xvclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCByZ2JhKDAsIDAsIDAsIDAuMilcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dQ29sb3Igb2YgdGhlIGJhY2tncm91bmQgbWFzay4gRGVmYXVsdCBpcyBgXCJyZ2JhKDAsIDAsIDAsIDAuMilcImAuWy9lbl1cbiAgICogIFtqYV3og4zmma/jga7jg57jgrnjgq/jga7oibLjgpLmjIflrprjgZfjgb7jgZnjgIJcInJnYmEoMCwgMCwgMCwgMC4yKVwi44GM44OH44OV44Kp44Or44OI5YCk44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgZ2V0IF9tYXNrKCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLmRpYWxvZy1tYXNrJyk7XG4gIH1cblxuICBnZXQgX2RpYWxvZygpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5kaWFsb2cnKTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX2NvbXBpbGUoKSk7XG5cbiAgICB0aGlzLl92aXNpYmxlID0gZmFsc2U7XG4gICAgdGhpcy5fZG9vckxvY2sgPSBuZXcgRG9vckxvY2soKTtcbiAgICB0aGlzLl9ib3VuZENhbmNlbCA9IHRoaXMuX2NhbmNlbC5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5fdXBkYXRlQW5pbWF0b3JGYWN0b3J5KCk7XG4gIH1cblxuICBfdXBkYXRlQW5pbWF0b3JGYWN0b3J5KCkge1xuICAgIHRoaXMuX2FuaW1hdG9yRmFjdG9yeSA9IG5ldyBBbmltYXRvckZhY3Rvcnkoe1xuICAgICAgYW5pbWF0b3JzOiBfYW5pbWF0b3JEaWN0LFxuICAgICAgYmFzZUNsYXNzOiBEaWFsb2dBbmltYXRvcixcbiAgICAgIGJhc2VDbGFzc05hbWU6ICdEaWFsb2dBbmltYXRvcicsXG4gICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJylcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG4gICAgLyogRXhwZWN0ZWQgcmVzdWx0OlxuICAgICAqICAgPG9ucy1kaWFsb2c+XG4gICAgICogICAgIDxkaXYgY2xhc3M9XCJkaWFsb2ctbWFza1wiPjwvZGl2PlxuICAgICAqICAgICA8ZGl2IGNsYXNzPVwiZGlhbG9nXCI+XG4gICAgICogICAgICAgPGRpdiBjbGFzcz1cImRpYWxvZy1jb250YWluZXJcIj4uLi48L2Rpdj5cbiAgICAgKiAgICAgPC9kaXY+XG4gICAgICogICA8L29ucy1kaWFsb2c+XG4gICAgICovXG5cbiAgICBpZiAoIXRoaXMuX2RpYWxvZykge1xuICAgICAgY29uc3QgZGlhbG9nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkaWFsb2cuY2xhc3NMaXN0LmFkZCgnZGlhbG9nJyk7XG5cbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZGlhbG9nLmNsYXNzTGlzdC5hZGQoJ2RpYWxvZy1jb250YWluZXInKTtcblxuICAgICAgZGlhbG9nLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG5cbiAgICAgIHdoaWxlICh0aGlzLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZmlyc3RDaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoZGlhbG9nKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX21hc2spIHtcbiAgICAgIGNvbnN0IG1hc2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIG1hc2suY2xhc3NMaXN0LmFkZCgnZGlhbG9nLW1hc2snKTtcbiAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKG1hc2ssIHRoaXMuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGlhbG9nLnN0eWxlLnpJbmRleCA9IDIwMDAxO1xuICAgIHRoaXMuX21hc2suc3R5bGUuekluZGV4ID0gMjAwMDA7XG5cbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnc3RhdHVzLWJhci1maWxsJywgJycpO1xuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvbkRldmljZUJhY2tCdXR0b25cbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUJhY2stYnV0dG9uIGhhbmRsZXIuWy9lbl1cbiAgICogICBbamFd44OQ44OD44Kv44Oc44K/44Oz44OP44Oz44OJ44Op44CCWy9qYV1cbiAgICovXG4gIGdldCBvbkRldmljZUJhY2tCdXR0b24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyO1xuICB9XG5cbiAgc2V0IG9uRGV2aWNlQmFja0J1dHRvbihjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcikge1xuICAgICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyID0gZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIuY3JlYXRlSGFuZGxlcih0aGlzLCBjYWxsYmFjayk7XG4gIH1cblxuICBfY2FuY2VsKCkge1xuICAgIGlmICh0aGlzLmNhbmNlbGFibGUgJiYgIXRoaXMuX3J1bm5pbmcpIHtcbiAgICAgIHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xuICAgICAgdGhpcy5oaWRlKHtcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdkaWFsb2ctY2FuY2VsJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNob3dcbiAgICogQHNpZ25hdHVyZSBzaG93KFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwibm9uZVwiYCBhbmQgYFwic2xpZGVcImAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJub25lXCIsIFwic2xpZGVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YCBbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYWZ0ZXIgdGhlIGRpYWxvZyBoYXMgYmVlbiByZXZlYWxlZC5bL2VuXVxuICAgKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzooajnpLrjgZXjgozntYLjgo/jgaPjgZ/lvozjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TaG93IHRoZSBkaWFsb2cuWy9lbl1cbiAgICogIFtqYV3jg4DjgqTjgqLjg63jgrDjgpLplovjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlcyB0byB0aGUgZGlzcGxheWVkIGVsZW1lbnQuXG4gICAqL1xuICBzaG93KG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBjYW5jZWwgPSBmYWxzZTtcbiAgICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcblxuICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyA9IHV0aWwuZXh0ZW5kKFxuICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9LFxuICAgICAgQW5pbWF0b3JGYWN0b3J5LnBhcnNlQW5pbWF0aW9uT3B0aW9uc1N0cmluZyh0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uLW9wdGlvbnMnKSlcbiAgICApO1xuXG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwcmVzaG93Jywge1xuICAgICAgZGlhbG9nOiB0aGlzLFxuICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY2FuY2VsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICghY2FuY2VsKSB7XG4gICAgICBjb25zdCB0cnlTaG93ID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB1bmxvY2sgPSB0aGlzLl9kb29yTG9jay5sb2NrKCk7XG4gICAgICAgIGNvbnN0IGFuaW1hdG9yID0gdGhpcy5fYW5pbWF0b3JGYWN0b3J5Lm5ld0FuaW1hdG9yKG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIHRoaXMuX21hc2suc3R5bGUub3BhY2l0eSA9ICcxJztcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgICAgIGFuaW1hdG9yLnNob3codGhpcywgKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLl92aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdW5sb2NrKCk7XG5cbiAgICAgICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwb3N0c2hvdycsIHtkaWFsb2c6IHRoaXN9KTtcblxuICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICByZXNvbHZlKHRoaXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICB0aGlzLl9kb29yTG9jay53YWl0VW5sb2NrKCgpID0+IHJlc29sdmUodHJ5U2hvdygpKSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYW5jZWxlZCBpbiBwcmVzaG93IGV2ZW50LicpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGhpZGVcbiAgICogQHNpZ25hdHVyZSBoaWRlKFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwibm9uZVwiYCBhbmQgYFwic2xpZGVcImAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJub25lXCIsIFwic2xpZGVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YFsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1UaGlzIGZ1bmN0aW9ucyBpcyBjYWxsZWQgYWZ0ZXIgdGhlIGRpYWxvZyBoYXMgYmVlbiBoaWRkZW4uWy9lbl1cbiAgICogICBbamFd44OA44Kk44Ki44Ot44Kw44GM6Zqg44KM44Gf5b6M44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUhpZGUgdGhlIGRpYWxvZy5bL2VuXVxuICAgKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgpLplonjgZjjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgaGlkZGVuIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgaGlkZShvcHRpb25zID0ge30pIHtcbiAgICBsZXQgY2FuY2VsID0gZmFsc2U7XG4gICAgY29uc3QgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrIHx8IGZ1bmN0aW9uKCkge307XG5cbiAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgPSB1dGlsLmV4dGVuZChcbiAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fSxcbiAgICAgIEFuaW1hdG9yRmFjdG9yeS5wYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpXG4gICAgKTtcblxuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncHJlaGlkZScsIHtcbiAgICAgIGRpYWxvZzogdGhpcyxcbiAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNhbmNlbCA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoIWNhbmNlbCkge1xuICAgICAgY29uc3QgdHJ5SGlkZSA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgdW5sb2NrID0gdGhpcy5fZG9vckxvY2subG9jaygpO1xuICAgICAgICBjb25zdCBhbmltYXRvciA9IHRoaXMuX2FuaW1hdG9yRmFjdG9yeS5uZXdBbmltYXRvcihvcHRpb25zKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgICAgIGFuaW1hdG9yLmhpZGUodGhpcywgKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgIHRoaXMuX3Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdW5sb2NrKCk7XG5cbiAgICAgICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwb3N0aGlkZScsIHtkaWFsb2c6IHRoaXN9KTtcblxuICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICByZXNvbHZlKHRoaXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICB0aGlzLl9kb29yTG9jay53YWl0VW5sb2NrKCgpID0+IHJlc29sdmUodHJ5SGlkZSgpKSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYW5jZWxlZCBpbiBwcmVoaWRlIGV2ZW50LicpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmlzaWJsZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBkaWFsb2cgaXMgdmlzaWJsZSBvciBub3QuWy9lbl1cbiAgICogICBbamFd6KaB57Sg44GM6KaL44GI44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl92aXNpYmxlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGRpYWxvZyBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBjYW5jZWxhYmxlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZGlhbG9nIGlzIGNhbmNlbGFibGUgb3Igbm90LiBBIGNhbmNlbGFibGUgZGlhbG9nIGNhbiBiZSBjbG9zZWQgYnkgdGFwcGluZyB0aGUgYmFja2dyb3VuZCBvciBieSBwcmVzc2luZyB0aGUgYmFjayBidXR0b24gb24gQW5kcm9pZCBkZXZpY2VzLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBzZXQgY2FuY2VsYWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnY2FuY2VsYWJsZScsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBjYW5jZWxhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnY2FuY2VsYWJsZScpO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5vbkRldmljZUJhY2tCdXR0b24gPSBlID0+IHRoaXMuY2FuY2VsYWJsZSA/IHRoaXMuX2NhbmNlbCgpIDogZS5jYWxsUGFyZW50SGFuZGxlcigpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX21hc2suYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZENhbmNlbCwgZmFsc2UpO1xuICAgIH0pO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyID0gbnVsbDtcblxuICAgIHRoaXMuX21hc2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZENhbmNlbC5iaW5kKHRoaXMpLCBmYWxzZSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdhbmltYXRpb24nXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgIHJldHVybiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmFtZSA9PT0gJ2FuaW1hdGlvbicpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge0RpYWxvZ0FuaW1hdG9yfSBBbmltYXRvclxuICAgKi9cbiAgc3RhdGljIHJlZ2lzdGVyQW5pbWF0b3IobmFtZSwgQW5pbWF0b3IpIHtcbiAgICBpZiAoIShBbmltYXRvci5wcm90b3R5cGUgaW5zdGFuY2VvZiBEaWFsb2dBbmltYXRvcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJBbmltYXRvclwiIHBhcmFtIG11c3QgaW5oZXJpdCBPbnNEaWFsb2dFbGVtZW50LkRpYWxvZ0FuaW1hdG9yJyk7XG4gICAgfVxuICAgIF9hbmltYXRvckRpY3RbbmFtZV0gPSBBbmltYXRvcjtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgRGlhbG9nQW5pbWF0b3IoKSB7XG4gICAgcmV0dXJuIERpYWxvZ0FuaW1hdG9yO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWRpYWxvZycsIERpYWxvZ0VsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJ29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcnOiAnZmFiLS0qJ1xufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtZmFiXG4gKiBAY2F0ZWdvcnkgZm9ybVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBUaGUgRmxvYXRpbmcgYWN0aW9uIGJ1dHRvbiBpcyBhIGNpcmN1bGFyIGJ1dHRvbiBkZWZpbmVkIGluIHRoZSBbTWF0ZXJpYWwgRGVzaWduIHNwZWNpZmljYXRpb25dKGh0dHBzOi8vd3d3Lmdvb2dsZS5jb20vZGVzaWduL3NwZWMvY29tcG9uZW50cy9idXR0b25zLWZsb2F0aW5nLWFjdGlvbi1idXR0b24uaHRtbCkuIFRoZXkgYXJlIG9mdGVuIHVzZWQgdG8gcHJvbW90ZSB0aGUgcHJpbWFyeSBhY3Rpb24gb2YgdGhlIGFwcC5cbiAqXG4gKiAgICAgSXQgY2FuIGJlIGRpc3BsYXllZCBlaXRoZXIgYXMgYW4gaW5saW5lIGVsZW1lbnQgb3IgaW4gb25lIG9mIHRoZSBjb3JuZXJzLiBOb3JtYWxseSBpdCB3aWxsIGJlIHBvc2l0aW9uZWQgaW4gdGhlIGxvd2VyIHJpZ2h0IGNvcm5lciBvZiB0aGUgc2NyZWVuLlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9mYWJcbiAqIEBndWlkZSBjcm9zcy1wbGF0Zm9ybS1zdHlsaW5nIFtlbl1JbmZvcm1hdGlvbiBhYm91dCBjcm9zcyBwbGF0Zm9ybSBzdHlsaW5nWy9lbl1bamFdSW5mb3JtYXRpb24gYWJvdXQgY3Jvc3MgcGxhdGZvcm0gc3R5bGluZ1svamFdXG4gKiBAc2VlYWxzbyBvbnMtc3BlZWQtZGlhbFxuICogICBbZW5dVGhlIGA8b25zLXNwZWVkLWRpYWw+YCBjb21wb25lbnQgaXMgYSBGbG9hdGluZyBhY3Rpb24gYnV0dG9uIHRoYXQgZGlzcGxheXMgYSBtZW51IHdoZW4gdGFwcGVkLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGYWJFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBidXR0b24uWy9lbl1cbiAgICogIFtqYV3jg5zjgr/jg7Pjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSByaXBwbGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgZGVmaW5lZCwgdGhlIGJ1dHRvbiB3aWxsIGhhdmUgYSByaXBwbGUgZWZmZWN0IHdoZW4gdGFwcGVkLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcG9zaXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIHBvc2l0aW9uIG9mIHRoZSBidXR0b24uIFNob3VsZCBiZSBhIHN0cmluZyBsaWtlIGBcImJvdHRvbSByaWdodFwiYCBvciBgXCJ0b3AgbGVmdFwiYC4gSWYgdGhpcyBhdHRyaWJ1dGUgaXMgbm90IGRlZmluZWQgaXQgd2lsbCBiZSBkaXNwbGF5ZWQgYXMgYW4gaW5saW5lIGVsZW1lbnQuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXNhYmxlZFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSBpZiBidXR0b24gc2hvdWxkIGJlIGRpc2FibGVkLlsvZW5dXG4gICAqICAgW2phXeODnOOCv+ODs+OCkueEoeWKueWMluOBmeOCi+WgtOWQiOOBr+aMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGluaXQoKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWInKTtcblxuICAgIGlmICghdXRpbC5maW5kQ2hpbGQodGhpcywgJy5mYWJfX2ljb24nKSkge1xuICAgICAgY29uc3QgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZCgnZmFiX19pY29uJyk7XG5cbiAgICAgIHV0aWwuYXJyYXlGcm9tKHRoaXMuY2hpbGROb2RlcykuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgaWYgKCFlbGVtZW50LnRhZ05hbWUgfHwgZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdvbnMtcmlwcGxlJykge1xuICAgICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVSaXBwbGUoKTtcblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcblxuICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XG5cbiAgICB0aGlzLnNob3coKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ3JpcHBsZScsICdwb3NpdGlvbiddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlwcGxlJzpcbiAgICAgICAgdGhpcy5fdXBkYXRlUmlwcGxlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncG9zaXRpb24nOlxuICAgICAgICB0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xuICAgIH1cbiAgfVxuXG4gIF9zaG93KCkge1xuICAgIHRoaXMuc2hvdygpO1xuICB9XG5cbiAgX2hpZGUoKSB7XG4gICAgdGhpcy5oaWRlKCk7XG4gIH1cblxuICBfdXBkYXRlUmlwcGxlKCkge1xuICAgIHV0aWwudXBkYXRlUmlwcGxlKHRoaXMpO1xuICB9XG5cbiAgX3VwZGF0ZVBvc2l0aW9uKCkge1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJyk7XG4gICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgJ2ZhYi0tdG9wX19sZWZ0JyxcbiAgICAgICdmYWItLWJvdHRvbV9fcmlnaHQnLFxuICAgICAgJ2ZhYi0tYm90dG9tX19sZWZ0JyxcbiAgICAgICdmYWItLXRvcF9fcmlnaHQnLFxuICAgICAgJ2ZhYi0tdG9wX19jZW50ZXInLFxuICAgICAgJ2ZhYi0tYm90dG9tX19jZW50ZXInKTtcbiAgICBzd2l0Y2ggKHBvc2l0aW9uKSB7XG4gICAgICBjYXNlICd0b3AgcmlnaHQnOlxuICAgICAgY2FzZSAncmlnaHQgdG9wJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLXRvcF9fcmlnaHQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3AgbGVmdCc6XG4gICAgICBjYXNlICdsZWZ0IHRvcCc6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS10b3BfX2xlZnQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdib3R0b20gcmlnaHQnOlxuICAgICAgY2FzZSAncmlnaHQgYm90dG9tJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLWJvdHRvbV9fcmlnaHQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdib3R0b20gbGVmdCc6XG4gICAgICBjYXNlICdsZWZ0IGJvdHRvbSc6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS1ib3R0b21fX2xlZnQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjZW50ZXIgdG9wJzpcbiAgICAgIGNhc2UgJ3RvcCBjZW50ZXInOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tdG9wX19jZW50ZXInKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjZW50ZXIgYm90dG9tJzpcbiAgICAgIGNhc2UgJ2JvdHRvbSBjZW50ZXInOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tYm90dG9tX19jZW50ZXInKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBzaG93XG4gICAqIEBzaWduYXR1cmUgc2hvdygpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNob3cgdGhlIGZsb2F0aW5nIGFjdGlvbiBidXR0b24uWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cbiAgc2hvdyhvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLnN0eWxlLnRyYW5zZm9ybSA9ICdzY2FsZSgxKSc7XG4gICAgdGhpcy5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAnc2NhbGUoMSknO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaGlkZVxuICAgKiBAc2lnbmF0dXJlIGhpZGUoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1IaWRlIHRoZSBmbG9hdGluZyBhY3Rpb24gYnV0dG9uLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG4gIGhpZGUob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5zdHlsZS50cmFuc2Zvcm0gPSAnc2NhbGUoMCknO1xuICAgIHRoaXMuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3NjYWxlKDApJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdkaXNhYmxlZCcsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZpc2libGVcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3opoHntKDjgYzopovjgYjjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3R5bGUudHJhbnNmb3JtID09PSAnc2NhbGUoMSknICYmIHRoaXMuc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgdG9nZ2xlXG4gICAqIEBzaWduYXR1cmUgdG9nZ2xlKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRvZ2dsZSB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgYnV0dG9uLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICB0b2dnbGUoKSB7XG4gICAgdGhpcy52aXNpYmxlID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3coKTtcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1mYWInLCBGYWJFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBHZXN0dXJlRGV0ZWN0b3IgZnJvbSAnb25zL2dlc3R1cmUtZGV0ZWN0b3InO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1nZXN0dXJlLWRldGVjdG9yXG4gKiBAY2F0ZWdvcnkgZ2VzdHVyZVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBDb21wb25lbnQgdG8gZGV0ZWN0IGZpbmdlciBnZXN0dXJlcyB3aXRoaW4gdGhlIHdyYXBwZWQgZWxlbWVudC4gRm9sbG93aW5nIGdlc3R1cmVzIGFyZSBzdXBwb3J0ZWQ6XG4gKiAgICAgLSBEcmFnIGdlc3R1cmVzOiBgZHJhZ2AsIGBkcmFnbGVmdGAsIGBkcmFncmlnaHRgLCBgZHJhZ3VwYCwgYGRyYWdkb3duYFxuICogICAgIC0gSG9sZCBnZXN0dXJlczogYGhvbGRgLCBgcmVsZWFzZWBcbiAqICAgICAtIFN3aXBlIGdlc3R1cmVzOiBgc3dpcGVgLCBgc3dpcGVsZWZ0YCwgYHN3aXBlcmlnaHRgLCBgc3dpcGV1cGAsIGBzd2lwZWRvd25gXG4gKiAgICAgLSBUYXAgZ2VzdHVyZXM6IGB0YXBgLCBgZG91YmxldGFwYFxuICogICAgIC0gUGluY2ggZ2VzdHVyZXM6IGBwaW5jaGAsIGBwaW5jaGluYCwgYHBpbmNob3V0YFxuICogICAgIC0gT3RoZXIgZ2VzdHVyZXM6IGB0b3VjaGAsIGB0cmFuc2Zvcm1gLCBgcm90YXRlYFxuICogICBbL2VuXVxuICogICBbamFd6KaB57Sg5YaF44Gu44K444Kn44K544OB44Oj44O85pON5L2c44KS5qSc55+l44GX44G+44GZ44CC6Kmz44GX44GP44Gv44Ks44Kk44OJ44KS5Y+C54Wn44GX44Gm44GP44Gg44GV44GE44CCWy9qYV1cbiAqIEBndWlkZSBnZXN0dXJlLWRldGVjdG9yXG4gKiAgIFtlbl1EZXRlY3RpbmcgZmluZ2VyIGdlc3R1cmVzWy9lbl1cbiAqICAgW2phXeOCuOOCp+OCueODgeODo+ODvOaTjeS9nOOBruaknOefpVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1nZXN0dXJlLWRldGVjdG9yPlxuICogICA8ZGl2IGlkPVwiZGV0ZWN0LWFyZWFcIiBzdHlsZT1cIndpZHRoOiAxMDBweDsgaGVpZ2h0OiAxMDBweDtcIj5cbiAqICAgICBTd2lwZSBIZXJlXG4gKiAgIDwvZGl2PlxuICogPC9vbnMtZ2VzdHVyZS1kZXRlY3Rvcj5cbiAqXG4gKiA8c2NyaXB0PlxuICogICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzd2lwZWxlZnQnLCBmdW5jdGlvbihldmVudCkge1xuICogICAgIGlmIChldmVudC50YXJnZXQubWF0Y2hlcygnI2RldGVjdC1hcmVhJykpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKCdTd2lwZSBsZWZ0IGlzIGRldGVjdGVkLicpO1xuICogICAgIH1cbiAqICAgfSk7XG4gKiA8L3NjcmlwdD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2VzdHVyZURldGVjdG9yRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcbiAgaW5pdCgpIHtcbiAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IgPSBuZXcgR2VzdHVyZURldGVjdG9yKHRoaXMpO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWdlc3R1cmUtZGV0ZWN0b3InLCBHZXN0dXJlRGV0ZWN0b3JFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWljb25cbiAqIEBjYXRlZ29yeSB2aXN1YWxcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgRGlzcGxheXMgYW4gaWNvbi4gVGhlIGZvbGxvd2luZyBpY29uIHN1aXRlcyBhcmUgYXZhaWxhYmxlOlxuICpcbiAqICAgICAqIFtGb250IEF3ZXNvbWVdKGh0dHBzOi8vZm9ydGF3ZXNvbWUuZ2l0aHViLmlvL0ZvbnQtQXdlc29tZS8pXG4gKiAgICAgKiBbSW9uaWNvbnNdKGh0dHA6Ly9pb25pY29ucy5jb20vKVxuICogICAgICogW01hdGVyaWFsIERlc2lnbiBJY29uaWMgRm9udF0oaHR0cDovL3phdm9sb2tsb20uZ2l0aHViLmlvL21hdGVyaWFsLWRlc2lnbi1pY29uaWMtZm9udC8pXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGNvZGVwZW4geEFodmdcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9pY29uXG4gKiBAZ3VpZGUgY3Jvc3MtcGxhdGZvcm0tc3R5bGluZyBbZW5dSW5mb3JtYXRpb24gYWJvdXQgY3Jvc3MgcGxhdGZvcm0gc3R5bGluZ1svZW5dW2phXUluZm9ybWF0aW9uIGFib3V0IGNyb3NzIHBsYXRmb3JtIHN0eWxpbmdbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtaWNvblxuICogICBpY29uPVwibWQtY2FyXCJcbiAqICAgc2l6ZT1cIjIwcHhcIlxuICogICBzdHlsZT1cImNvbG9yOiByZWRcIj5cbiAqIDwvb25zLWljb24+XG4gKlxuICogPG9ucy1idXR0b24+XG4gKiAgIDxvbnMtaWNvbiBpY29uPVwibWQtY2FyXCI+PC9vbnMtaWNvbj5cbiAqICAgQ2FyXG4gKiA8L29ucy1idXR0b24+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEljb25FbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGljb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVxuICAgKiAgICAgVGhlIGljb24gbmFtZS4gYFwibWQtXCJgIHByZWZpeCBmb3IgTWF0ZXJpYWwgSWNvbnMsIGBcImZhLVwiYCBmb3IgRm9udCBBd2Vzb21lIGFuZCBgXCJpb24tXCJgIHByZWZpeCBmb3IgSW9uaWNvbnMuXG4gICAqXG4gICAqICAgICBTZWUgYWxsIGF2YWlsYWJsZSBpY29ucyBvbiB0aGVpciByZXNwZWN0aXZlIHNpdGVzOlxuICAgKlxuICAgKiAgICAgKiBbRm9udCBBd2Vzb21lXShodHRwczovL2ZvcnRhd2Vzb21lLmdpdGh1Yi5pby9Gb250LUF3ZXNvbWUvKVxuICAgKiAgICAgKiBbSW9uaWNvbnNdKGh0dHA6Ly9pb25pY29ucy5jb20pXG4gICAqICAgICAqIFtNYXRlcmlhbCBEZXNpZ24gSWNvbmljIEZvbnRdKGh0dHA6Ly96YXZvbG9rbG9tLmdpdGh1Yi5pby9tYXRlcmlhbC1kZXNpZ24taWNvbmljLWZvbnQvKVxuICAgKlxuICAgKiAgICAgSWNvbnMgY2FuIGFsc28gYmUgc3R5bGVkIGJhc2VkIG9uIG1vZGlmaWVyIHByZXNlbmNlLiBBZGQgY29tbWEtc2VwYXJhdGVkIGljb25zIHdpdGggYFwibW9kaWZpZXJOYW1lOlwiYCBwcmVmaXguXG4gICAqXG4gICAqICAgICBUaGUgY29kZTpcbiAgICpcbiAgICogICAgIGBgYFxuICAgKiAgICAgPG9ucy1pY29uXG4gICAqICAgICAgIGljb249XCJpb24tZWRpdCwgbWF0ZXJpYWw6bWQtZWRpdFwiPlxuICAgKiAgICAgPC9vbnMtaWNvbj5cbiAgICogICAgIGBgYFxuICAgKlxuICAgKiAgICAgd2lsbCBkaXNwbGF5IGBcIm1kLWVkaXRcImAgZm9yIE1hdGVyaWFsIERlc2lnbiBhbmQgYFwiaW9uLWVkaXRcImAgYXMgdGhlIGRlZmF1bHQgaWNvbi5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzaXplXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIFRoZSBzaXplcyBvZiB0aGUgaWNvbi4gVmFsaWQgdmFsdWVzIGFyZSBsZywgMngsIDN4LCA0eCwgNXgsIG9yIGluIHRoZSBzaXplIGluIHBpeGVscy5cbiAgICogICAgIEljb25zIGNhbiBhbHNvIGJlIHN0eWxlZCBiYXNlZCBvbiBtb2RpZmllciBwcmVzZW5jZS4gQWRkIGNvbW1hLXNlcGFyYXRlZCBpY29ucyB3aXRoIGBcIm1vZGlmaWVyTmFtZTpcImAgcHJlZml4LlxuICAgKlxuICAgKiAgICAgVGhlIGNvZGU6XG4gICAqXG4gICAqICAgICBgYGBcbiAgICogICAgIDxvbnMtaWNvblxuICAgKiAgICAgICBpY29uPVwiaW9uLWVkaXRcIlxuICAgKiAgICAgICBzaXplPVwiMzJweCwgbWF0ZXJpYWw6MjRweFwiPlxuICAgKiAgICAgPC9vbnMtaWNvbj5cbiAgICogICAgIGBgYFxuICAgKlxuICAgKiAgICAgd2lsbCByZW5kZXIgYXMgYSBgMjRweGAgaWNvbiBpZiB0aGUgYFwibWF0ZXJpYWxcImAgbW9kaWZpZXIgaXMgcHJlc2VudCBhbmQgYDMycHhgIG90aGVyd2lzZS5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSByb3RhdGVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXU51bWJlciBvZiBkZWdyZWVzIHRvIHJvdGF0ZSB0aGUgaWNvbi4gVmFsaWQgdmFsdWVzIGFyZSA5MCwgMTgwIGFuZCAyNzAuWy9lbl1cbiAgICogICBbamFd44Ki44Kk44Kz44Oz44KS5Zue6Lui44GX44Gm6KGo56S644GX44G+44GZ44CCOTAsIDE4MCwgMjcw44GL44KJ5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZml4ZWQtd2lkdGhcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVdoZW4gdXNlZCBpbiBhIGxpc3QsIHlvdSB3YW50IHRoZSBpY29ucyB0byBoYXZlIHRoZSBzYW1lIHdpZHRoIHNvIHRoYXQgdGhleSBhbGlnbiB2ZXJ0aWNhbGx5IGJ5IGRlZmluaW5nIHRoaXMgYXR0cmlidXRlLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgc3BpblxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB3aGV0aGVyIHRoZSBpY29uIHNob3VsZCBiZSBzcGlubmluZy5bL2VuXVxuICAgKiAgIFtqYV3jgqLjgqTjgrPjg7PjgpLlm57ou6LjgZnjgovjgYvjganjgYbjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBpbml0KCkge1xuICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ2ljb24nLCAnc2l6ZScsICdtb2RpZmllciddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAoWydpY29uJywgJ3NpemUnLCAnbW9kaWZpZXInXS5pbmRleE9mKG5hbWUpICE9PSAtMSkge1xuICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgfVxuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG4gICAgdGhpcy5fdXBkYXRlKCk7XG4gIH1cblxuICBfdXBkYXRlKCkge1xuICAgIHRoaXMuX2NsZWFuQ2xhc3NBdHRyaWJ1dGUoKTtcbiAgICBjb25zdCB7Y2xhc3NMaXN0LCBzdHlsZX0gPSB0aGlzLl9idWlsZENsYXNzQW5kU3R5bGUodGhpcy5fZ2V0QXR0cmlidXRlKCdpY29uJyksIHRoaXMuX2dldEF0dHJpYnV0ZSgnc2l6ZScpKTtcbiAgICB1dGlsLmV4dGVuZCh0aGlzLnN0eWxlLCBzdHlsZSk7XG5cbiAgICBjbGFzc0xpc3QuZm9yRWFjaChjbGFzc05hbWUgPT4gdGhpcy5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSkpO1xuICB9XG5cbiAgX2dldEF0dHJpYnV0ZShhdHRyKSB7XG4gICAgY29uc3QgcGFydHMgPSAodGhpcy5nZXRBdHRyaWJ1dGUoYXR0cikgfHwgJycpLnNwbGl0KC9cXHMqLFxccyovKTtcbiAgICBjb25zdCBkZWYgPSBwYXJ0c1swXTtcbiAgICBsZXQgbWQgPSBwYXJ0c1sxXTtcbiAgICBtZCA9IChtZCB8fCAnJykuc3BsaXQoL1xccyo6XFxzKi8pO1xuICAgIHJldHVybiAodXRpbC5oYXNNb2RpZmllcih0aGlzLCBtZFswXSkgPyBtZFsxXSA6IGRlZikgfHwgJyc7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHVubmVlZGVkIGNsYXNzIHZhbHVlLlxuICAgKi9cbiAgX2NsZWFuQ2xhc3NBdHRyaWJ1dGUoKSB7XG4gICAgdXRpbC5hcnJheUZyb20odGhpcy5jbGFzc0xpc3QpXG4gICAgICAuZmlsdGVyKGNsYXNzTmFtZSA9PiAvXihmYSR8ZmEtfGlvbi18em1kaS0pLy50ZXN0KGNsYXNzTmFtZSkpXG4gICAgICAuZm9yRWFjaChjbGFzc05hbWUgPT4gdGhpcy5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSkpO1xuXG4gICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCd6bWRpJyk7XG4gICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCdvbnMtaWNvbi0taW9uJyk7XG4gIH1cblxuICBfYnVpbGRDbGFzc0FuZFN0eWxlKGljb25OYW1lLCBzaXplKSB7XG4gICAgY29uc3QgY2xhc3NMaXN0ID0gWydvbnMtaWNvbiddO1xuICAgIGNvbnN0IHN0eWxlID0ge307XG5cbiAgICAvLyBJY29uXG4gICAgaWYgKGljb25OYW1lLmluZGV4T2YoJ2lvbi0nKSA9PT0gMCkge1xuICAgICAgY2xhc3NMaXN0LnB1c2goaWNvbk5hbWUpO1xuICAgICAgY2xhc3NMaXN0LnB1c2goJ29ucy1pY29uLS1pb24nKTtcbiAgICB9IGVsc2UgaWYgKGljb25OYW1lLmluZGV4T2YoJ2ZhLScpID09PSAwKSB7XG4gICAgICBjbGFzc0xpc3QucHVzaChpY29uTmFtZSk7XG4gICAgICBjbGFzc0xpc3QucHVzaCgnZmEnKTtcbiAgICB9IGVsc2UgaWYoaWNvbk5hbWUuaW5kZXhPZignbWQtJykgPT09IDApICB7XG4gICAgICBjbGFzc0xpc3QucHVzaCgnem1kaScpO1xuICAgICAgY2xhc3NMaXN0LnB1c2goJ3ptZGktJyArIGljb25OYW1lLnNwbGl0KC9cXC0oLispPy8pWzFdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xhc3NMaXN0LnB1c2goJ2ZhJyk7XG4gICAgICBjbGFzc0xpc3QucHVzaCgnZmEtJyArIGljb25OYW1lKTtcbiAgICB9XG5cbiAgICAvLyBTaXplXG4gICAgaWYgKHNpemUubWF0Y2goL15bMS01XXh8bGckLykpIHtcbiAgICAgIGNsYXNzTGlzdC5wdXNoKCdmYS0nICsgc2l6ZSk7XG4gICAgICB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KCdmb250LXNpemUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUuZm9udFNpemUgPSBzaXplO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjbGFzc0xpc3Q6IGNsYXNzTGlzdCxcbiAgICAgIHN0eWxlOiBzdHlsZVxuICAgIH07XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtaWNvbicsIEljb25FbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5pbXBvcnQge0xhenlSZXBlYXREZWxlZ2F0ZSwgTGF6eVJlcGVhdFByb3ZpZGVyfSBmcm9tICdvbnMvaW50ZXJuYWwvbGF6eS1yZXBlYXQnO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1sYXp5LXJlcGVhdFxuICogQGNhdGVnb3J5IGxpc3RcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgVXNpbmcgdGhpcyBjb21wb25lbnQgYSBsaXN0IHdpdGggbWlsbGlvbnMgb2YgaXRlbXMgY2FuIGJlIHJlbmRlcmVkIHdpdGhvdXQgYSBkcm9wIGluIHBlcmZvcm1hbmNlLlxuICogICAgIEl0IGRvZXMgdGhhdCBieSBcImxhemlseVwiIGxvYWRpbmcgZWxlbWVudHMgaW50byB0aGUgRE9NIHdoZW4gdGhleSBjb21lIGludG8gdmlldyBhbmRcbiAqICAgICByZW1vdmluZyBpdGVtcyBmcm9tIHRoZSBET00gd2hlbiB0aGV5IGFyZSBub3QgdmlzaWJsZS5cbiAqICAgWy9lbl1cbiAqICAgW2phXVxuICogICAgIOOBk+OBruOCs+ODs+ODneODvOODjeODs+ODiOWGheOBp+aPj+eUu+OBleOCjOOCi+OCouOCpOODhuODoOOBrkRPTeimgee0oOOBruiqreOBv+i+vOOBv+OBr+OAgeeUu+mdouOBq+imi+OBiOOBneOBhuOBq+OBquOBo+OBn+aZguOBvuOBp+iHquWLleeahOOBq+mBheW7tuOBleOCjOOAgVxuICogICAgIOeUu+mdouOBi+OCieimi+OBiOOBquOBj+OBquOBo+OBn+WgtOWQiOOBq+OBr+OBneOBruimgee0oOOBr+WLleeahOOBq+OCouODs+ODreODvOODieOBleOCjOOBvuOBmeOAglxuICogICAgIOOBk+OBruOCs+ODs+ODneODvOODjeODs+ODiOOCkuS9v+OBhuOBk+OBqOOBp+OAgeODkeODleOCqeODvOODnuODs+OCueOCkuWKo+WMluOBleOBm+OCi+OBk+OBqOeEoeOBl+OBq+W3qOWkp+OBquaVsOOBruimgee0oOOCkuaPj+eUu+OBp+OBjeOBvuOBmeOAglxuICogICBbL2phXVxuICogQGNvZGVwZW4gUXdyR0JtXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvbGF6eS1yZXBlYXRcbiAqIEBzZWVhbHNvIG9ucy1saXN0XG4gKiAgIFtlbl1UaGUgYDxvbnMtbGlzdD5gIGVsZW1lbnQgaXMgdXNlZCB0byByZW5kZXIgYSBsaXN0LlsvZW5dXG4gKiAgIFtqYV1gPG9ucy1saXN0PmDopoHntKDjga/jg6rjgrnjg4jjgpLmj4/nlLvjgZnjgovjga7jgavkvb/jgo/jgozjgb7jgZnjgIJbL2phXVxuICogQGd1aWRlIGluZmluaXRlLXNjcm9sbFxuICogICBbZW5dTG9hZGluZyBtb3JlIGl0ZW1zIG9uIGluZmluaXRlIHNjcm9sbFsvZW5dXG4gKiAgIFtqYV1Mb2FkaW5nIG1vcmUgaXRlbXMgb24gaW5maW5pdGUgc2Nyb2xsWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8c2NyaXB0PlxuICogICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uKCkge1xuICogICAgIHZhciBsYXp5UmVwZWF0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2xpc3QnKTtcbiAqICAgICBsYXp5UmVwZWF0LmRlbGVnYXRlID0ge1xuICogICAgICBjcmVhdGVJdGVtQ29udGVudDogZnVuY3Rpb24oaSwgdGVtcGxhdGUpIHtcbiAqICAgICAgICB2YXIgZG9tID0gdGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpO1xuICogICAgICAgIGRvbS5pbm5lclRleHQgPSBpO1xuICpcbiAqICAgICAgICByZXR1cm4gZG9tO1xuICogICAgICB9LFxuICogICAgICBjb3VudEl0ZW1zOiBmdW5jdGlvbigpIHtcbiAqICAgICAgICByZXR1cm4gMTAwMDAwMDA7XG4gKiAgICAgIH0sXG4gKiAgICAgIGRlc3Ryb3lJdGVtOiBmdW5jdGlvbihpbmRleCwgaXRlbSkge1xuICogICAgICAgIGNvbnNvbGUubG9nKCdEZXN0cm95ZWQgaXRlbSB3aXRoIGluZGV4OiAnICsgaW5kZXgpO1xuICogICAgICB9XG4gKiAgICAgfTtcbiAqICAgfSk7XG4gKiA8L3NjcmlwdD5cbiAqXG4gKiA8b25zLWxpc3QgaWQ9XCJsaXN0XCI+XG4gKiAgIDxvbnMtbGF6eS1yZXBlYXQ+XG4gKiAgICAgPG9ucy1saXN0LWl0ZW0+PC9vbnMtbGlzdC1pdGVtPlxuICogICA8L29ucy1sYXp5LXJlcGVhdD5cbiAqIDwvb25zLWxpc3Q+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExhenlSZXBlYXRFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHV0aWwudXBkYXRlUGFyZW50UG9zaXRpb24odGhpcyk7XG5cbiAgICAvLyBub3QgdmVyeSBnb29kIGlkZWEgYW5kIGFsc28gbm90IGRvY3VtZW50ZWRcbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ2RlbGVnYXRlJykpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB3aW5kb3dbdGhpcy5nZXRBdHRyaWJ1dGUoJ2RlbGVnYXRlJyldO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGVsZWdhdGVcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSBhIGRlbGVnYXRlIG9iamVjdCB0byBsb2FkIGFuZCB1bmxvYWQgaXRlbSBlbGVtZW50cy5bL2VuXVxuICAgKiAgW2phXeimgee0oOOBruODreODvOODieOAgeOCouODs+ODreODvOODieOBquOBqeOBruWHpueQhuOCkuWnlOitsuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGVsZWdhdGUuY3JlYXRlSXRlbUNvbnRlbnRcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dXG4gICAqICAgICBUaGlzIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBgSFRNTEVsZW1lbnRgLlxuICAgKlxuICAgKiAgICAgVG8gaGVscCByZW5kZXJpbmcgdGhlIGVsZW1lbnQsIHRoZSBjdXJyZW50IGluZGV4IGFuZCBhIHRlbXBsYXRlIGlzIHN1cHBsaWVkIGFzIGFyZ3VtZW50cy4gVGhlIHRlbXBsYXRlIGlzIHRoZSBpbml0aWFsIGNvbnRlbnQgb2YgdGhlIGA8b25zLWxhenktcmVwZWF0PmAgZWxlbWVudC5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1cbiAgICogICAgIOOBk+OBrumWouaVsOOBr2BIVE1MRWxlbWVudGDjgpLov5TjgZfjgabjgY/jgaDjgZXjgYTjgIJcbiAgICogICAgIOimgee0oOOCkueUn+aIkOOBl+OChOOBmeOBj+OBmeOCi+OBn+OCgeOBq+OAgeePvuWcqOOBruOCouOCpOODhuODoOOBruOCpOODs+ODh+ODg+OCr+OCueOBqOODhuODs+ODl+ODrOODvOODiOOBjOW8leaVsOOBq+a4oeOBleOCjOOBvuOBmeOAglxuICAgKiAgICAg44GT44Gu44OG44Oz44OX44Os44O844OI44Gv44CBYDxvbnMtbGF6eS1yZXBlYXQ+YOimgee0oOOBruOCs+ODs+ODhuODs+ODhOOBjOa4oeOBleOCjOOBvuOBmeOAglxuICAgKiAgIFsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGVsZWdhdGUuY291bnRJdGVtc1xuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG91bGQgcmV0dXJuIHRoZSBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIGxpc3QuWy9lbl1cbiAgICogICBbamFd44Oq44K544OI5YaF44Gu44Ki44Kk44OG44Og5pWw44KS6L+U44GX44Gm44GP44Gg44GV44GE44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkZWxlZ2F0ZS5jYWxjdWxhdGVJdGVtSGVpZ2h0XG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVxuICAgKiAgICAgU2hvdWxkIHJldHVybiB0aGUgaGVpZ2h0IG9mIGFuIGl0ZW0uIFRoZSBpbmRleCBpcyBwcm92aWRlZCBhcyBhbiBhcmd1bWVudC5cbiAgICpcbiAgICogICAgIFRoaXMgaXMgaW1wb3J0YW50IHdoZW4gcmVuZGVyaW5nIGxpc3RzIHdoZXJlIHRoZSBpdGVtcyBoYXZlIGRpZmZlcmVudCBoZWlnaHQuXG4gICAqXG4gICAqICAgICBUaGUgZnVuY3Rpb24gaXMgb3B0aW9uYWwgYW5kIGlmIGl0IGlzbid0IHByZXNlbnQgdGhlIGhlaWdodCBvZiB0aGUgZmlyc3QgaXRlbSB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlZCBhbmQgdXNlZCBmb3IgYWxsIG90aGVyIGl0ZW1zLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVxuICAgKiAgICAg44Ki44Kk44OG44Og44Gu6auY44GVKOODlOOCr+OCu+ODqynjgpLov5TjgZfjgabjgY/jgaDjgZXjgYTjgILjgqLjgqTjg4bjg6Djga7jgqTjg7Pjg4fjg4Pjgq/jgrnlgKTjga/lvJXmlbDjgafmuKHjgZXjgozjgb7jgZnjgIJcbiAgICogICAgIOOBk+OBrumWouaVsOOBr+OAgeOBneOCjOOBnuOCjOOBruOCouOCpOODoOOBjOmBleOBo+OBn+mrmOOBleOCkuaMgeOBpOODquOCueODiOOCkuODrOODs+ODgOODquODs+OCsOOBmeOCi+mam+OBq+mHjeimgeOBp+OBmeOAglxuICAgKiAgICAg44GT44Gu6Zai5pWw44Gv44Kq44OX44K344On44OK44Or44Gn44GZ44CC44KC44GX44GT44Gu6Zai5pWw44GM54Sh44GE5aC05ZCI44Gr44Gv44CBXG4gICAqICAgICDmnIDliJ3jga7jgqLjgqTjg4bjg6Djga7pq5jjgZXjgYzku5bjga7jgZnjgbnjgabjga7jgqLjgqTjg4bjg6Djga7pq5jjgZXjgajjgZfjgabliKnnlKjjgZXjgozjgb7jgZnjgIJcbiAgICogICBbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRlbGVnYXRlLmRlc3Ryb3lJdGVtXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVxuICAgKiAgICAgVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGNhbGxlZCB3aGVuIGFuIGl0ZW0gaXMgcmVtb3ZlZCBmcm9tIHRoZSBET00uIFRoZSBpbmRleCBhbmQgRE9NIGVsZW1lbnQgaXMgcHJvdmlkZWQgYXMgYXJndW1lbnRzLlxuICAgKlxuICAgKiAgICAgVGhlIGZ1bmN0aW9uIGlzIG9wdGlvbmFsIGJ1dCBtYXkgYmUgaW1wb3J0YW50IGluIG9yZGVyIHRvIGF2b2lkIG1lbW9yeSBsZWFrcy5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1cbiAgICogICAgIOOBk+OBrumWouaVsOOBr+OAgeOBguOCi+OCouOCpOODhuODoOOBjERPTeODhOODquODvOOBi+OCiemZpOOBi+OCjOOBn+aZguOBq+WRvOOBs+WHuuOBleOCjOOBvuOBmeOAglxuICAgKiAgICAg44Ki44Kk44OG44Og44Gu44Kk44Oz44OH44OD44Kv44K55YCk44GoRE9N6KaB57Sg44GM5byV5pWw44Go44GX44Gm5rih44GV44KM44G+44GZ44CCXG4gICAqICAgICDjgZPjga7plqLmlbDjga/jgqrjg5fjgrfjg6fjg4rjg6vjgafjgZnjgYzjgIHlkITjgqLjgqTjg4bjg6Djga7lvozlh6bnkIbjgYzlv4XopoHjgarloLTlkIjjgavjga/jg6Hjg6Ljg6rjg7zjg6rjg7zjgq/jgpLpgb/jgZHjgovjgZ/jgoHjgavph43opoHjgafjgZnjgIJcbiAgICogICBbL2phXVxuICAgKi9cblxuICBzZXQgZGVsZWdhdGUodXNlckRlbGVnYXRlKSB7XG4gICAgdGhpcy5fbGF6eVJlcGVhdFByb3ZpZGVyICYmIHRoaXMuX2xhenlSZXBlYXRQcm92aWRlci5kZXN0cm95KCk7XG5cbiAgICBpZiAoIXRoaXMuX3RlbXBsYXRlRWxlbWVudCAmJiB0aGlzLmNoaWxkcmVuWzBdKSB7XG4gICAgICB0aGlzLl90ZW1wbGF0ZUVsZW1lbnQgPSB0aGlzLnJlbW92ZUNoaWxkKHRoaXMuY2hpbGRyZW5bMF0pO1xuICAgIH1cblxuICAgIGNvbnN0IGRlbGVnYXRlID0gbmV3IExhenlSZXBlYXREZWxlZ2F0ZSh1c2VyRGVsZWdhdGUsIHRoaXMuX3RlbXBsYXRlRWxlbWVudCB8fCBudWxsKTtcbiAgICB0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIgPSBuZXcgTGF6eVJlcGVhdFByb3ZpZGVyKHRoaXMucGFyZW50RWxlbWVudCwgZGVsZWdhdGUpO1xuICB9XG5cbiAgZ2V0IGRlbGVnYXRlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBwcm9wZXJ0eSBjYW4gb25seSBiZSB1c2VkIHRvIHNldCB0aGUgZGVsZWdhdGUgb2JqZWN0LicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcmVmcmVzaFxuICAgKiBAc2lnbmF0dXJlIHJlZnJlc2goKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmVmcmVzaCB0aGUgbGlzdC4gVXNlIHRoaXMgbWV0aG9kIHdoZW4gdGhlIGRhdGEgaGFzIGNoYW5nZWQuWy9lbl1cbiAgICogICBbamFd44Oq44K544OI44KS5pu05paw44GX44G+44GZ44CC44KC44GX44OH44O844K/44GM5aSJ44KP44Gj44Gf5aC05ZCI44Gr44Gv44GT44Gu44Oh44K944OD44OJ44KS5L2/44Gj44Gm44GP44Gg44GV44GE44CCWy9qYV1cbiAgICovXG4gIHJlZnJlc2goKSB7XG4gICAgdGhpcy5fbGF6eVJlcGVhdFByb3ZpZGVyICYmIHRoaXMuX2xhenlSZXBlYXRQcm92aWRlci5yZWZyZXNoKCk7XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge31cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBpZiAodGhpcy5fbGF6eVJlcGVhdFByb3ZpZGVyKSB7XG4gICAgICB0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5fbGF6eVJlcGVhdFByb3ZpZGVyID0gbnVsbDtcbiAgICB9XG4gIH1cblxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1sYXp5LXJlcGVhdCcsIExhenlSZXBlYXRFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJ29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcblxuY29uc3Qgc2NoZW1lID0geycnOiAnbGlzdF9faGVhZGVyLS0qJ307XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWxpc3QtaGVhZGVyXG4gKiBAY2F0ZWdvcnkgbGlzdFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1IZWFkZXIgZWxlbWVudCBmb3IgbGlzdCBpdGVtcy4gTXVzdCBiZSBwdXQgaW5zaWRlIHRoZSBgPG9ucy1saXN0PmAgY29tcG9uZW50LlsvZW5dXG4gKiAgIFtqYV3jg6rjgrnjg4jopoHntKDjgavkvb/nlKjjgZnjgovjg5jjg4Pjg4Djg7znlKjjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgIJvbnMtbGlzdOOBqOWFseOBq+S9v+eUqOOBl+OBvuOBmeOAglsvamFdXG4gKiBAc2VlYWxzbyBvbnMtbGlzdFxuICogICBbZW5dVGhlIGA8b25zLWxpc3Q+YCBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWxpc3TjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLWxpc3QtaXRlbVxuICogICBbZW5dVGhlIGA8b25zLWxpc3QtaXRlbT5gIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtbGlzdC1pdGVt44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBndWlkZSBsaXN0cyBbZW5dVXNpbmcgbGlzdHNbL2VuXVtqYV3jg6rjgrnjg4jjgpLkvb/jgYZbL2phXVxuICogQGNvZGVwZW4geXhjQ3RcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9saXN0XG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXURpc3BsYXkgYSBNYXRlcmlhbCBEZXNpZ24gbGlzdCBoZWFkZXIuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1saXN0PlxuICogICA8b25zLWxpc3QtaGVhZGVyPkhlYWRlciBUZXh0PC9vbnMtbGlzdC1oZWFkZXI+XG4gKiAgIDxvbnMtbGlzdC1pdGVtPkl0ZW08L29ucy1saXN0LWl0ZW0+XG4gKiAgIDxvbnMtbGlzdC1pdGVtPkl0ZW08L29ucy1saXN0LWl0ZW0+XG4gKiA8L29ucy1saXN0PlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaXN0SGVhZGVyRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGxpc3QgaGVhZGVyLlsvZW5dXG4gICAqICAgW2phXeODmOODg+ODgOODvOOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGluaXQoKSB7XG4gICAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZSgnX2NvbXBpbGVkJykpIHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICB9XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnbGlzdF9faGVhZGVyJyk7XG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ19jb21waWxlZCcsICcnKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChuYW1lID09PSAnbW9kaWZpZXInKSB7XG4gICAgICByZXR1cm4gTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgfVxuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWxpc3QtaGVhZGVyJywgTGlzdEhlYWRlckVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICdvbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICdvbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJy5saXN0X19pdGVtJzogJ2xpc3RfX2l0ZW0tLSonLFxuICAnLmxpc3RfX2l0ZW1fX2xlZnQnOiAnbGlzdF9faXRlbS0tKl9fbGVmdCcsXG4gICcubGlzdF9faXRlbV9fY2VudGVyJzogJ2xpc3RfX2l0ZW0tLSpfX2NlbnRlcicsXG4gICcubGlzdF9faXRlbV9fcmlnaHQnOiAnbGlzdF9faXRlbS0tKl9fcmlnaHQnLFxuICAnLmxpc3RfX2l0ZW1fX2xhYmVsJzogJ2xpc3RfX2l0ZW0tLSpfX2xhYmVsJyxcbiAgJy5saXN0X19pdGVtX190aXRsZSc6ICdsaXN0X19pdGVtLS0qX190aXRsZScsXG4gICcubGlzdF9faXRlbV9fc3VidGl0bGUnOiAnbGlzdF9faXRlbS0tKl9fc3VidGl0bGUnLFxuICAnLmxpc3RfX2l0ZW1fX3RodW1ibmFpbCc6ICdsaXN0X19pdGVtLS0qX190aHVtYm5haWwnLFxuICAnLmxpc3RfX2l0ZW1fX2ljb24nOiAnbGlzdF9faXRlbS0tKl9faWNvbidcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWxpc3QtaXRlbVxuICogQGNhdGVnb3J5IGxpc3RcbiAqIEBtb2RpZmllciB0YXBwYWJsZVxuICogICBbZW5dTWFrZSB0aGUgbGlzdCBpdGVtIGNoYW5nZSBhcHBlYXJhbmNlIHdoZW4gaXQncyB0YXBwZWQuIE9uIGlPUyBpdCBpcyBiZXR0ZXIgdG8gdXNlIHRoZSBcInRhcHBhYmxlXCIgYW5kIFwidGFwLWJhY2tncm91bmQtY29sb3JcIiBhdHRyaWJ1dGUgZm9yIGJldHRlciBiZWhhdmlvciB3aGVuIHNjcm9sbGluZy5bL2VuXVxuICogICBbamFd44K/44OD44OX44KE44Kv44Oq44OD44Kv44GX44Gf5pmC44Gr5Yq55p6c44GM6KGo56S644GV44KM44KL44KI44GG44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciBjaGV2cm9uXG4gKiAgIFtlbl1EaXNwbGF5IGEgY2hldnJvbiBhdCB0aGUgcmlnaHQgZW5kIG9mIHRoZSBsaXN0IGl0ZW0gYW5kIG1ha2UgaXQgY2hhbmdlIGFwcGVhcmFuY2Ugd2hlbiB0YXBwZWQuIFRoZSBjaGV2cm9uIGlzIG5vdCBkaXNwbGF5ZWQgaW4gTWF0ZXJpYWwgRGVzaWduLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQG1vZGlmaWVyIGxvbmdkaXZpZGVyXG4gKiAgIFtlbl1EaXNwbGF5cyBhIGxvbmcgaG9yaXpvbnRhbCBkaXZpZGVyIGJldHdlZW4gaXRlbXMuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAbW9kaWZpZXIgbm9kaXZpZGVyXG4gKiAgIFtlbl1SZW1vdmVzIHRoZSBkaXZpZGVyIGJldHdlZW4gbGlzdCBpdGVtcy5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dRGlzcGxheSBhIE1hdGVyaWFsIERlc2lnbiBsaXN0IGl0ZW0uWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIENvbXBvbmVudCB0aGF0IHJlcHJlc2VudHMgZWFjaCBpdGVtIGluIHRoZSBsaXN0LiBNdXN0IGJlIHB1dCBpbnNpZGUgdGhlIGA8b25zLWxpc3Q+YCBjb21wb25lbnQuXG4gKlxuICogICAgIFRoZSBsaXN0IGl0ZW0gaXMgY29tcG9zZWQgb2YgdGhyZWUgcGFydHMgdGhhdCBhcmUgcmVwcmVzZW50ZWQgd2l0aCB0aGUgYGxlZnRgLCBgY2VudGVyYCBhbmQgYHJpZ2h0YCBjbGFzc2VzLiBUaGVzZSBjbGFzc2VzIGNhbiBiZSB1c2VkIHRvIGVuc3VyZSB0aGF0IHRoZSBjb250ZW50IG9mIHRoZSBsaXN0IGl0ZW1zIGlzIHByb3Blcmx5IGFsaWduZWQuXG4gKlxuICogICAgIGBgYFxuICogICAgIDxvbnMtbGlzdC1pdGVtPlxuICogICAgICAgPGRpdiBjbGFzcz1cImxlZnRcIj5MZWZ0PC9kaXY+XG4gKiAgICAgICA8ZGl2IGNsYXNzPVwiY2VudGVyXCI+Q2VudGVyPC9kaXY+XG4gKiAgICAgICA8ZGl2IGNsYXNzPVwicmlnaHRcIj5SaWdodDwvZGl2PlxuICogICAgIDwvb25zLWxpc3QtaXRlbT5cbiAqICAgICBgYGBcbiAqXG4gKiAgICAgVGhlcmUgaXMgYWxzbyBhIG51bWJlciBvZiBjbGFzc2VzIChwcmVmaXhlZCB3aXRoIGBsaXN0X19pdGVtX18qYCkgdGhhdCBoZWxwIHdoZW4gcHV0dGluZyB0aGluZ3MgbGlrZSBpY29ucyBhbmQgdGh1bWJuYWlscyBpbnRvIHRoZSBsaXN0IGl0ZW1zLlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1saXN0XG4gKiAgIFtlbl1vbnMtbGlzdCBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWxpc3TjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLWxpc3QtaGVhZGVyXG4gKiAgIFtlbl1vbnMtbGlzdC1oZWFkZXIgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1saXN0LWhlYWRlcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZ3VpZGUgbGlzdHNcbiAqICAgW2VuXVVzaW5nIGxpc3RzWy9lbl1cbiAqICAgW2phXeODquOCueODiOOCkuS9v+OBhlsvamFdXG4gKiBAY29kZXBlbiB5eGNDdFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2xpc3RcbiAqIEBleGFtcGxlXG4gKiA8b25zLWxpc3QtaXRlbT5cbiAqICAgPGRpdiBjbGFzcz1cImxlZnRcIj5cbiAqICAgICA8b25zLWljb24gaWNvbj1cIm1kLWZhY2VcIiBjbGFzcz1cImxpc3RfX2l0ZW1fX2ljb25cIj48L29ucy1pY29uPlxuICogICA8L2Rpdj5cbiAqICAgPGRpdiBjbGFzcz1cImNlbnRlclwiPlxuICogICAgIDxkaXYgY2xhc3M9XCJsaXN0X19pdGVtX190aXRsZVwiPlRpdGxlPC9kaXY+XG4gKiAgICAgPGRpdiBjbGFzcz1cImxpc3RfX2l0ZW1fX3N1YnRpdGxlXCI+U3VidGl0bGU8L2Rpdj5cbiAqICAgPC9kaXY+XG4gKiAgIDxkaXYgY2xhc3M9XCJyaWdodFwiPlxuICogICAgIDxvbnMtc3dpdGNoPjwvb25zLXN3aXRjaD5cbiAqICAgPC9kaXY+XG4gKiA8L29ucy1saXN0LWl0ZW0+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpc3RJdGVtRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGxpc3QgaXRlbS5bL2VuXVxuICAgKiAgIFtqYV3lkITopoHntKDjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBsb2NrLW9uLWRyYWdcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVByZXZlbnQgdmVydGljYWwgc2Nyb2xsaW5nIHdoZW4gdGhlIHVzZXIgZHJhZ3MgaG9yaXpvbnRhbGx5LlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+OBqOOAgeODpuODvOOCtuODvOOBjOOBk+OBruimgee0oOOCkuaoquaWueWQkeOBq+ODieODqeODg+OCsOOBl+OBpuOBhOOCi+aZguOBq+OAgee4puaWueWQkeOBruOCueOCr+ODreODvOODq+OBjOi1t+OBjeOBquOBhOOCiOOBhuOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHRhcHBhYmxlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dTWFrZXMgdGhlIGVsZW1lbnQgcmVhY3QgdG8gdGFwcy5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSB0YXAtYmFja2dyb3VuZC1jb2xvclxuICAgKiBAdHlwZSB7Q29sb3J9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl0gQ2hhbmdlcyB0aGUgYmFja2dyb3VuZCBjb2xvciB3aGVuIHRhcHBlZC4gRm9yIHRoaXMgdG8gd29yaywgdGhlIGF0dHJpYnV0ZSBcInRhcHBhYmxlXCIgbmVlZHMgdG8gYmUgc2V0LiBUaGUgZGVmYXVsdCBjb2xvciBpcyBcIiNkOWQ5ZDlcIi4gSXQgd2lsbCBkaXNwbGF5IGFzIGEgcmlwcGxlIGVmZmVjdCBvbiBBbmRyb2lkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIGluaXQoKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnbGlzdF9faXRlbScpO1xuXG4gICAgbGV0IGxlZnQsIGNlbnRlciwgcmlnaHQ7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGVsID0gdGhpcy5jaGlsZHJlbltpXTtcblxuICAgICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucygnbGVmdCcpKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2xpc3RfX2l0ZW1fX2xlZnQnKTtcbiAgICAgICAgbGVmdCA9IGVsO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdjZW50ZXInKSkge1xuICAgICAgICBjZW50ZXIgPSBlbDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucygncmlnaHQnKSkge1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdsaXN0X19pdGVtX19yaWdodCcpO1xuICAgICAgICByaWdodCA9IGVsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghY2VudGVyKSB7XG4gICAgICBjZW50ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgaWYgKCFsZWZ0ICYmICFyaWdodCkge1xuICAgICAgICB3aGlsZSAodGhpcy5jaGlsZE5vZGVzWzBdKSB7XG4gICAgICAgICAgY2VudGVyLmFwcGVuZENoaWxkKHRoaXMuY2hpbGROb2Rlc1swXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmNoaWxkTm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBjb25zdCBlbCA9IHRoaXMuY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgICBpZiAoZWwgIT09IGxlZnQgJiYgZWwgIT09IHJpZ2h0KSB7XG4gICAgICAgICAgICBjZW50ZXIuaW5zZXJ0QmVmb3JlKGVsLCBjZW50ZXIuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKGNlbnRlciwgcmlnaHQgfHwgbnVsbCk7XG4gICAgfVxuXG4gICAgY2VudGVyLmNsYXNzTGlzdC5hZGQoJ2NlbnRlcicpO1xuICAgIGNlbnRlci5jbGFzc0xpc3QuYWRkKCdsaXN0X19pdGVtX19jZW50ZXInKTtcblxuICAgIHRoaXMuX3VwZGF0ZVJpcHBsZSgpO1xuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuXG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdyaXBwbGUnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpcHBsZSc6XG4gICAgICAgIHRoaXMuX3VwZGF0ZVJpcHBsZSgpO1xuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZHJhZycsIHRoaXMuX29uRHJhZyk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaCk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9vblRvdWNoKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fb25SZWxlYXNlKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX29uUmVsZWFzZSk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMuX29uUmVsZWFzZSk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25SZWxlYXNlKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgdGhpcy5fb25SZWxlYXNlKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobGVhdmUnLCB0aGlzLl9vblJlbGVhc2UpO1xuXG4gICAgdGhpcy5fb3JpZ2luYWxCYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLnN0eWxlLmJhY2tncm91bmRDb2xvcjtcblxuICAgIHRoaXMudGFwcGVkID0gZmFsc2U7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWcnLCB0aGlzLl9vbkRyYWcpO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2gpO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fb25Ub3VjaCk7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX29uUmVsZWFzZSk7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9vblJlbGVhc2UpO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzLl9vblJlbGVhc2UpO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uUmVsZWFzZSk7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIHRoaXMuX29uUmVsZWFzZSk7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGxlYXZlJywgdGhpcy5fb25SZWxlYXNlKTtcbiAgfVxuXG4gIGdldCBfdHJhbnNpdGlvbigpIHtcbiAgICByZXR1cm4gJ2JhY2tncm91bmQtY29sb3IgMC4wcyBsaW5lYXIgMC4wMnMsIGJveC1zaGFkb3cgMC4wcyBsaW5lYXIgMC4wMnMnO1xuICB9XG5cbiAgZ2V0IF90YXBwYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ3RhcHBhYmxlJyk7XG4gIH1cblxuICBnZXQgX3RhcEJhY2tncm91bmRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ3RhcC1iYWNrZ3JvdW5kLWNvbG9yJykgfHwgJyNkOWQ5ZDknO1xuICB9XG5cbiAgX3VwZGF0ZVJpcHBsZSgpIHtcbiAgICB1dGlsLnVwZGF0ZVJpcHBsZSh0aGlzKTtcbiAgfVxuXG4gIF9vbkRyYWcoZXZlbnQpIHtcbiAgICBjb25zdCBnZXN0dXJlID0gZXZlbnQuZ2VzdHVyZTtcbiAgICAvLyBQcmV2ZW50IHZlcnRpY2FsIHNjcm9sbGluZyBpZiB0aGUgdXNlcnMgcGFucyBsZWZ0IG9yIHJpZ2h0LlxuICAgIGlmICh0aGlzLl9zaG91bGRMb2NrT25EcmFnKCkgJiYgWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihnZXN0dXJlLmRpcmVjdGlvbikgPiAtMSkge1xuICAgICAgZ2VzdHVyZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuXG4gIF9vblRvdWNoKCkge1xuICAgIGlmICh0aGlzLnRhcHBlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMudGFwcGVkID0gdHJ1ZTtcblxuICAgIHRoaXMuc3R5bGUudHJhbnNpdGlvbiA9IHRoaXMuX3RyYW5zaXRpb247XG4gICAgdGhpcy5zdHlsZS53ZWJraXRUcmFuc2l0aW9uID0gdGhpcy5fdHJhbnNpdGlvbjtcbiAgICB0aGlzLnN0eWxlLk1velRyYW5zaXRpb24gPSB0aGlzLl90cmFuc2l0aW9uO1xuXG4gICAgaWYgKHRoaXMuX3RhcHBhYmxlKSB7XG4gICAgICBpZiAodGhpcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxCYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLnN0eWxlLmJhY2tncm91bmRDb2xvcjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLl90YXBCYWNrZ3JvdW5kQ29sb3I7XG4gICAgICB0aGlzLnN0eWxlLmJveFNoYWRvdyA9IGAwcHggLTFweCAwcHggMHB4ICR7dGhpcy5fdGFwQmFja2dyb3VuZENvbG9yfWA7XG4gICAgfVxuICB9XG5cbiAgX29uUmVsZWFzZSgpIHtcbiAgICB0aGlzLnRhcHBlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5zdHlsZS50cmFuc2l0aW9uID0gJyc7XG4gICAgdGhpcy5zdHlsZS53ZWJraXRUcmFuc2l0aW9uID0gJyc7XG4gICAgdGhpcy5zdHlsZS5Nb3pUcmFuc2l0aW9uID0gJyc7XG5cbiAgICB0aGlzLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuX29yaWdpbmFsQmFja2dyb3VuZENvbG9yIHx8ICcnO1xuICAgIHRoaXMuc3R5bGUuYm94U2hhZG93ID0gJyc7XG4gIH1cblxuICBfc2hvdWxkTG9ja09uRHJhZygpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2xvY2stb24tZHJhZycpO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWxpc3QtaXRlbScsIExpc3RJdGVtRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJ29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICdvbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XG5cbmNvbnN0IHNjaGVtZSA9IHsnJzogJ2xpc3QtLSonfTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtbGlzdFxuICogQGNhdGVnb3J5IGxpc3RcbiAqIEBtb2RpZmllciBpbnNldFxuICogICBbZW5dSW5zZXQgbGlzdCB0aGF0IGRvZXNuJ3QgY292ZXIgdGhlIHdob2xlIHdpZHRoIG9mIHRoZSBwYXJlbnQuWy9lbl1cbiAqICAgW2phXeimquimgee0oOOBrueUu+mdouOBhOOBo+OBseOBhOOBq+W6g+OBjOOCieOBquOBhOODquOCueODiOOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAbW9kaWZpZXIgbm9ib3JkZXJcbiAqICAgW2VuXUEgbGlzdCB3aXRoIG5vIGJvcmRlcnMgYXQgdGhlIHRvcCBhbmQgYm90dG9tLlsvZW5dXG4gKiAgIFtqYV3jg6rjgrnjg4jjga7kuIrkuIvjga7jg5zjg7zjg4Djg7zjgYznhKHjgYTjg6rjgrnjg4jjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1Db21wb25lbnQgdG8gZGVmaW5lIGEgbGlzdCwgYW5kIHRoZSBjb250YWluZXIgZm9yIG9ucy1saXN0LWl0ZW0ocykuWy9lbl1cbiAqICAgW2phXeODquOCueODiOOCkuihqOePvuOBmeOCi+OBn+OCgeOBruOCs+ODs+ODneODvOODjeODs+ODiOOAgm9ucy1saXN0LWl0ZW3jga7jgrPjg7Pjg4bjg4rjgajjgZfjgabkvb/nlKjjgZfjgb7jgZnjgIJbL2phXVxuICogQHNlZWFsc28gb25zLWxpc3QtaXRlbVxuICogICBbZW5db25zLWxpc3QtaXRlbSBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWxpc3QtaXRlbeOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtbGlzdC1oZWFkZXJcbiAqICAgW2VuXW9ucy1saXN0LWhlYWRlciBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWxpc3QtaGVhZGVy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1sYXp5LXJlcGVhdFxuICogICBbZW5db25zLWxhenktcmVwZWF0IGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtbGF6eS1yZXBlYXTjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGd1aWRlIGxpc3RzXG4gKiAgIFtlbl1Vc2luZyBsaXN0c1svZW5dXG4gKiAgIFtqYV3jg6rjgrnjg4jjgpLkvb/jgYZbL2phXVxuICogQGd1aWRlIGluZmluaXRlLXNjcm9sbFxuICogICBbZW5dTG9hZGluZyBtb3JlIGl0ZW1zIG9uIGluZmluaXRlIHNjcm9sbFsvZW5dXG4gKiAgIFtqYV1Mb2FkaW5nIG1vcmUgaXRlbXMgb24gaW5maW5pdGUgc2Nyb2xsWy9qYV1cbiAqIEBjb2RlcGVuIHl4Y0N0XG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvbGlzdFxuICogQGV4YW1wbGVcbiAqIDxvbnMtbGlzdD5cbiAqICAgPG9ucy1saXN0LWhlYWRlcj5IZWFkZXIgVGV4dDwvb25zLWxpc3QtaGVhZGVyPlxuICogICA8b25zLWxpc3QtaXRlbT5JdGVtPC9vbnMtbGlzdC1pdGVtPlxuICogICA8b25zLWxpc3QtaXRlbT5JdGVtPC9vbnMtbGlzdC1pdGVtPlxuICogPC9vbnMtbGlzdD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGlzdEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBsaXN0LlsvZW5dXG4gICAqICAgW2phXeODquOCueODiOOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGluaXQoKSB7XG4gICAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZSgnX2NvbXBpbGVkJykpIHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICB9XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnbGlzdCcpO1xuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdfY29tcGlsZWQnLCAnJyk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllciddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgIH1cbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1saXN0JywgTGlzdEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJ29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcudGV4dC1pbnB1dCc6ICd0ZXh0LWlucHV0LS0qJyxcbiAgJy50ZXh0LWlucHV0X19sYWJlbCc6ICd0ZXh0LWlucHV0LS0qX19sYWJlbCcsXG4gICcucmFkaW8tYnV0dG9uJzogJ3JhZGlvLWJ1dHRvbi0tKicsXG4gICcucmFkaW8tYnV0dG9uX19pbnB1dCc6ICdyYWRpby1idXR0b24tLSpfX2lucHV0JyxcbiAgJy5yYWRpby1idXR0b25fX2NoZWNrbWFyayc6ICdyYWRpby1idXR0b24tLSpfX2NoZWNrbWFyaycsXG4gICcuY2hlY2tib3gnOiAnY2hlY2tib3gtLSonLFxuICAnLmNoZWNrYm94X19pbnB1dCc6ICdjaGVja2JveC0tKl9faW5wdXQnLFxuICAnLmNoZWNrYm94X19jaGVja21hcmsnOiAnY2hlY2tib3gtLSpfX2NoZWNrbWFyaydcbn07XG5cbmNvbnN0IElOUFVUX0FUVFJJQlVURVMgPSBbXG4gICdhdXRvY2FwaXRhbGl6ZScsXG4gICdhdXRvY29tcGxldGUnLFxuICAnYXV0b2NvcnJlY3QnLFxuICAnYXV0b2ZvY3VzJyxcbiAgJ2Rpc2FibGVkJyxcbiAgJ2lucHV0bW9kZScsXG4gICdtYXgnLFxuICAnbWF4bGVuZ3RoJyxcbiAgJ21pbicsXG4gICdtaW5sZW5ndGgnLFxuICAnbmFtZScsXG4gICdwYXR0ZXJuJyxcbiAgJ3BsYWNlaG9sZGVyJyxcbiAgJ3JlYWRvbmx5JyxcbiAgJ3NpemUnLFxuICAnc3RlcCcsXG4gICd0eXBlJyxcbiAgJ3ZhbGlkYXRvcicsXG4gICd2YWx1ZSdcbl07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWlucHV0XG4gKiBAY2F0ZWdvcnkgZm9ybVxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgW2VuXURpc3BsYXlzIGEgTWF0ZXJpYWwgRGVzaWduIGlucHV0LlsvZW5dXG4gKiAgW2phXVsvamFdXG4gKiBAbW9kaWZpZXIgdW5kZXJiYXJcbiAqICBbZW5dRGlzcGxheXMgYSBob3Jpem9udGFsIGxpbmUgdW5kZXJuZWF0aCBhIHRleHQgaW5wdXQuWy9lbl1cbiAqICBbamFdWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogIFtlbl1cbiAqICAgIEFuIGlucHV0IGVsZW1lbnQuIFRoZSBgdHlwZWAgYXR0cmlidXRlIGNhbiBiZSB1c2VkIHRvIGNoYW5nZSB0aGUgaW5wdXQgdHlwZS4gQWxsIHRleHQgaW5wdXQgdHlwZXMgYXMgd2VsbCBhcyBgY2hlY2tib3hgIGFuZCBgcmFkaW9gIGFyZSBzdXBwb3J0ZWQuXG4gKlxuICogICAgVGhlIGNvbXBvbmVudCB3aWxsIGF1dG9tYXRpY2FsbHkgcmVuZGVyIGFzIGEgTWF0ZXJpYWwgRGVzaWduIGlucHV0IG9uIEFuZHJvaWQgZGV2aWNlcy5cbiAqXG4gKiAgICBNb3N0IGF0dHJpYnV0ZXMgdGhhdCBjYW4gYmUgdXNlZCBmb3IgYSBub3JtYWwgYDxpbnB1dD5gIGVsZW1lbnQgY2FuIGFsc28gYmUgdXNlZCBvbiB0aGUgYDxvbnMtaW5wdXQ+YCBlbGVtZW50LlxuICogIFsvZW5dXG4gKiAgW2phXVsvamFdXG4gKiBAY29kZXBlbiBvalF4TGpcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9pbnB1dFxuICogQHNlZWFsc28gb25zLXJhbmdlXG4gKiAgIFtlbl1UaGUgYDxvbnMtcmFuZ2U+YCBlbGVtZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIHJhbmdlIHNsaWRlci5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1zd2l0Y2hcbiAqICAgW2VuXVRoZSBgPG9ucy1zd2l0Y2g+YCBlbGVtZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIGRyYWdnYWJsZSB0b2dnbGUgc3dpdGNoLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGd1aWRlIGFkZGluZy1wYWdlLWNvbnRlbnRcbiAqICAgW2VuXVVzaW5nIGZvcm0gY29tcG9uZW50c1svZW5dXG4gKiAgIFtqYV3jg5Xjgqnjg7zjg6DjgpLkvb/jgYZbL2phXVxuICogQGd1aWRlIHVzaW5nLW1vZGlmaWVyIFtlbl1Nb3JlIGRldGFpbHMgYWJvdXQgdGhlIGBtb2RpZmllcmAgYXR0cmlidXRlWy9lbl1bamFdbW9kaWZpZXLlsZ7mgKfjga7kvb/jgYTmlrlbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtaW5wdXQgcGxhY2Vob2xkZXI9XCJVc2VybmFtZVwiIGZsb2F0Pjwvb25zLWlucHV0PlxuICogPG9ucy1pbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBjaGVja2VkPjwvb25zLWlucHV0PlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnB1dEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcGxhY2Vob2xkZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVBsYWNlaG9sZGVyIHRleHQuIEluIE1hdGVyaWFsIERlc2lnbiwgdGhpcyBwbGFjZWhvbGRlciB3aWxsIGJlIGEgZmxvYXRpbmcgbGFiZWwuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZmxvYXRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgcHJlc2VudCwgdGhlIHBsYWNlaG9sZGVyIHdpbGwgYmUgYW5pbWF0ZWQgaW4gTWF0ZXJpYWwgRGVzaWduLlsvZW5dXG4gICAqICBbamFd44GT44Gu5bGe5oCn44GM6Kit5a6a44GV44KM44Gf5pmC44CB44Op44OZ44Or44Gv44Ki44OL44Oh44O844K344On44Oz44GZ44KL44KI44GG44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgdHlwZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1cbiAgICogICAgU3BlY2lmeSB0aGUgaW5wdXQgdHlwZS4gVGhpcyBpcyB0aGUgc2FtZSBhcyB0aGUgXCJ0eXBlXCIgYXR0cmlidXRlIGZvciBub3JtYWwgaW5wdXRzLiBIb3dldmVyLCBmb3IgXCJyYW5nZVwiIHlvdSBzaG91bGQgaW5zdGVhZCB1c2UgPG9ucy1yYW5nZT4gZWxlbWVudC5cbiAgICpcbiAgICogICAgUGxlYXNlIHRha2UgYSBsb29rIGF0IFtNRE5dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pbnB1dCNhdHRyLXR5cGUpIGZvciBhbiBleGhhdXN0aXZlIGxpc3Qgb2YgcG9zc2libGUgdmFsdWVzLiBEZXBlbmRpbmcgb24gdGhlIHBsYXRmb3JtIGFuZCBicm93c2VyIHZlcnNpb24gc29tZSBvZiB0aGVzZSBtaWdodCBub3Qgd29yay5cbiAgICogIFsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaW5wdXQtaWRcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgXCJpZFwiIGF0dHJpYnV0ZSBvZiB0aGUgaW5uZXIgYDxpbnB1dD5gIGVsZW1lbnQuIFRoaXMgaXMgdXNlZnVsIHdoZW4gdXNpbmcgPGxhYmVsIGZvcj1cIi4uLlwiPiBlbGVtZW50cy5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGNvbnRlbnQtbGVmdFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgSFRNTCBjb250ZW50IG9mIGA8b25zLWlucHV0PmAgaXMgcGxhY2VkIGJlZm9yZSB0aGUgYWN0dWFsIGlucHV0IGFzIGEgbGFiZWwuIE9taXQgdGhpcyB0byBkaXNwbGF5IGl0IGFmdGVyIHRoZSBpbnB1dC5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIGluaXQoKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICAgIHRoaXMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKCdjaGVja2VkJywgbnVsbCwgdGhpcy5nZXRBdHRyaWJ1dGUoJ2NoZWNrZWQnKSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9ib3VuZE9uSW5wdXQgPSB0aGlzLl9vbklucHV0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fYm91bmRPbkZvY3VzaW4gPSB0aGlzLl9vbkZvY3VzaW4uYmluZCh0aGlzKTtcbiAgICB0aGlzLl9ib3VuZERlbGVnYXRlRXZlbnQgPSB0aGlzLl9kZWxlZ2F0ZUV2ZW50LmJpbmQodGhpcyk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCAhPT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGhlbHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICBoZWxwZXIuY2xhc3NMaXN0LmFkZCgnX2hlbHBlcicpO1xuXG4gICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKSk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGhlbHBlcik7XG5cbiAgICBjb25zdCBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICBsYWJlbC5jbGFzc0xpc3QuYWRkKCdpbnB1dC1sYWJlbCcpO1xuXG4gICAgdXRpbC5hcnJheUZyb20odGhpcy5jaGlsZE5vZGVzKS5mb3JFYWNoKGVsZW1lbnQgPT4gbGFiZWwuYXBwZW5kQ2hpbGQoZWxlbWVudCkpO1xuICAgIHRoaXMuaGFzQXR0cmlidXRlKCdjb250ZW50LWxlZnQnKSA/IGNvbnRhaW5lci5pbnNlcnRCZWZvcmUobGFiZWwsIGNvbnRhaW5lci5maXJzdENoaWxkKSA6IGNvbnRhaW5lci5hcHBlbmRDaGlsZChsYWJlbCk7XG5cbiAgICB0aGlzLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG5cbiAgICBzd2l0Y2ggKHRoaXMuZ2V0QXR0cmlidXRlKCd0eXBlJykpIHtcbiAgICAgIGNhc2UgJ2NoZWNrYm94JzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdjaGVja2JveCcpO1xuICAgICAgICB0aGlzLl9pbnB1dC5jbGFzc0xpc3QuYWRkKCdjaGVja2JveF9faW5wdXQnKTtcbiAgICAgICAgdGhpcy5faGVscGVyLmNsYXNzTGlzdC5hZGQoJ2NoZWNrYm94X19jaGVja21hcmsnKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlQm91bmRBdHRyaWJ1dGVzKCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdyYWRpbyc6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgncmFkaW8tYnV0dG9uJyk7XG4gICAgICAgIHRoaXMuX2lucHV0LmNsYXNzTGlzdC5hZGQoJ3JhZGlvLWJ1dHRvbl9faW5wdXQnKTtcbiAgICAgICAgdGhpcy5faGVscGVyLmNsYXNzTGlzdC5hZGQoJ3JhZGlvLWJ1dHRvbl9fY2hlY2ttYXJrJyk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUJvdW5kQXR0cmlidXRlcygpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5faW5wdXQuY2xhc3NMaXN0LmFkZCgndGV4dC1pbnB1dCcpO1xuICAgICAgICB0aGlzLl9oZWxwZXIuY2xhc3NMaXN0LmFkZCgndGV4dC1pbnB1dF9fbGFiZWwnKTtcbiAgICAgICAgdGhpcy5faW5wdXQucGFyZW50RWxlbWVudC5jbGFzc0xpc3QuYWRkKCd0ZXh0LWlucHV0X19jb250YWluZXInKTtcblxuICAgICAgICB0aGlzLl91cGRhdGVMYWJlbCgpO1xuICAgICAgICB0aGlzLl91cGRhdGVCb3VuZEF0dHJpYnV0ZXMoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlTGFiZWxDbGFzcygpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ2lucHV0LWlkJykpIHtcbiAgICAgIHRoaXMuX2lucHV0LmlkID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2lucHV0LWlkJyk7XG4gICAgfVxuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAncGxhY2Vob2xkZXInLCAnaW5wdXQtaWQnLCAnY2hlY2tlZCcsIC4uLklOUFVUX0FUVFJJQlVURVNdO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgcmV0dXJuIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKSk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAncGxhY2Vob2xkZXInKSB7XG4gICAgICByZXR1cm4gY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX3VwZGF0ZUxhYmVsKCkpO1xuICAgIH0gaWYgKG5hbWUgPT09ICdpbnB1dC1pZCcpIHtcbiAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9pbnB1dC5pZCA9IGN1cnJlbnQpO1xuICAgIH0gaWYgKG5hbWUgPT09ICdjaGVja2VkJykge1xuICAgICAgdGhpcy5jaGVja2VkID0gY3VycmVudCAhPT0gbnVsbDtcbiAgICB9XG4gICAgZWxzZSBpZiAoSU5QVVRfQVRUUklCVVRFUy5pbmRleE9mKG5hbWUpID49IDApIHtcbiAgICAgIHJldHVybiBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fdXBkYXRlQm91bmRBdHRyaWJ1dGVzKCkpO1xuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5faW5wdXQudHlwZSAhPT0gJ2NoZWNrYm94JyAmJiB0aGlzLl9pbnB1dC50eXBlICE9PSAncmFkaW8nKSB7XG4gICAgICAgIHRoaXMuX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5fYm91bmRPbklucHV0KTtcbiAgICAgICAgdGhpcy5faW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIHRoaXMuX2JvdW5kT25Gb2N1c2luKTtcbiAgICAgICAgdGhpcy5faW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCB0aGlzLl9ib3VuZE9uRm9jdXNvdXQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuX2JvdW5kRGVsZWdhdGVFdmVudCk7XG4gICAgICB0aGlzLl9pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy5fYm91bmREZWxlZ2F0ZUV2ZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMuX2JvdW5kT25JbnB1dCk7XG4gICAgICB0aGlzLl9pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c2luJywgdGhpcy5fYm91bmRPbkZvY3VzaW4pO1xuICAgICAgdGhpcy5faW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLl9ib3VuZERlbGVnYXRlRXZlbnQpO1xuICAgICAgdGhpcy5faW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMuX2JvdW5kRGVsZWdhdGVFdmVudCk7XG4gICAgfSk7XG4gIH1cblxuICBfc2V0TGFiZWwodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuX2hlbHBlci50ZXh0Q29udGVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMuX2hlbHBlci50ZXh0Q29udGVudCA9IHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuX2hlbHBlci5pbm5lclRleHQgPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlTGFiZWwoKSB7XG4gICAgdGhpcy5fc2V0TGFiZWwodGhpcy5oYXNBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJykgPyB0aGlzLmdldEF0dHJpYnV0ZSgncGxhY2Vob2xkZXInKSA6ICcnKTtcbiAgfVxuXG4gIF91cGRhdGVCb3VuZEF0dHJpYnV0ZXMoKSB7XG4gICAgSU5QVVRfQVRUUklCVVRFUy5mb3JFYWNoKChhdHRyKSA9PiB7XG4gICAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoYXR0cikpIHtcbiAgICAgICAgdGhpcy5faW5wdXQuc2V0QXR0cmlidXRlKGF0dHIsIHRoaXMuZ2V0QXR0cmlidXRlKGF0dHIpKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9pbnB1dC5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBfdXBkYXRlTGFiZWxDbGFzcygpIHtcbiAgICBpZiAodGhpcy52YWx1ZSA9PT0gJycpIHtcbiAgICAgIHRoaXMuX2hlbHBlci5jbGFzc0xpc3QucmVtb3ZlKCd0ZXh0LWlucHV0LS1tYXRlcmlhbF9fbGFiZWwtLWFjdGl2ZScpO1xuICAgIH1cbiAgICBlbHNlIGlmIChbJ2NoZWNrYm94JywgJ3JhZGlvJ10uaW5kZXhPZih0aGlzLmdldEF0dHJpYnV0ZSgndHlwZScpKSA9PT0gLTEpe1xuICAgICAgdGhpcy5faGVscGVyLmNsYXNzTGlzdC5hZGQoJ3RleHQtaW5wdXQtLW1hdGVyaWFsX19sYWJlbC0tYWN0aXZlJyk7XG4gICAgfVxuICB9XG5cbiAgX2RlbGVnYXRlRXZlbnQoZXZlbnQpIHtcbiAgICBjb25zdCBlID0gbmV3IEN1c3RvbUV2ZW50KGV2ZW50LnR5cGUsIHtcbiAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2hFdmVudChlKTtcbiAgfVxuXG4gIF9vbklucHV0KGV2ZW50KSB7XG4gICAgdGhpcy5fdXBkYXRlTGFiZWxDbGFzcygpO1xuICB9XG5cbiAgX29uRm9jdXNpbihldmVudCkge1xuICAgIHRoaXMuX3VwZGF0ZUxhYmVsQ2xhc3MoKTtcbiAgfVxuXG4gIGdldCBfaW5wdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvcignaW5wdXQnKTtcbiAgfVxuXG4gIGdldCBfaGVscGVyKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJy5faGVscGVyJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZhbHVlXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgaW5wdXQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5wdXQgPT09IG51bGxcbiAgICAgID8gdGhpcy5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJylcbiAgICAgIDogdGhpcy5faW5wdXQudmFsdWU7XG4gIH1cblxuICBzZXQgdmFsdWUodmFsKSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgdmFsKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9pbnB1dC52YWx1ZSA9IHZhbDtcbiAgICAgIHRoaXMuX29uSW5wdXQoKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGNoZWNrZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBpbnB1dCBpcyBjaGVja2VkIG9yIG5vdC4gT25seSB3b3JrcyBmb3IgYHJhZGlvYCBhbmQgYGNoZWNrYm94YCB0eXBlIGlucHV0cy5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgZ2V0IGNoZWNrZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lucHV0LmNoZWNrZWQ7XG4gIH1cblxuICBzZXQgY2hlY2tlZCh2YWwpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5faW5wdXQuY2hlY2tlZCA9IHZhbDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBpbnB1dCBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9XG5cbiAgZ2V0IF9pc1RleHRJbnB1dCgpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlICE9PSAncmFkaW8nICYmIHRoaXMudHlwZSAhPT0gJ2NoZWNrYm94JztcbiAgfVxuXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgndHlwZScpO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWlucHV0JywgSW5wdXRFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vZGFsQW5pbWF0b3Ige1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy50aW1pbmdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZHVyYXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZGVsYXlcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuZGVsYXkgPSAwO1xuICAgIHRoaXMuZHVyYXRpb24gPSAwLjI7XG5cbiAgICB0aGlzLnRpbWluZyA9IG9wdGlvbnMudGltaW5nIHx8IHRoaXMudGltaW5nO1xuICAgIHRoaXMuZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmR1cmF0aW9uIDogdGhpcy5kdXJhdGlvbjtcbiAgICB0aGlzLmRlbGF5ID0gb3B0aW9ucy5kZWxheSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kZWxheSA6IHRoaXMuZGVsYXk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbW9kYWxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHNob3cobW9kYWwsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBtb2RhbFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShtb2RhbCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG59XG4iLCJcbi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBNb2RhbEFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuXG4vKipcbiAqIGlPUyBzdHlsZSBhbmltYXRvciBmb3IgZGlhbG9nLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGYWRlTW9kYWxBbmltYXRvciBleHRlbmRzIE1vZGFsQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zLnRpbWluZyA9IG9wdGlvbnMudGltaW5nIHx8ICdsaW5lYXInO1xuICAgIG9wdGlvbnMuZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uIHx8ICcwLjMnO1xuICAgIG9wdGlvbnMuZGVsYXkgPSBvcHRpb25zLmRlbGF5IHx8IDA7XG5cbiAgICBzdXBlcihvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBtb2RhbFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgc2hvdyhtb2RhbCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0KG1vZGFsKVxuICAgICAgLnF1ZXVlKHtcbiAgICAgICAgb3BhY2l0eTogMFxuICAgICAgfSlcbiAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAucXVldWUoe1xuICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgIH0sIHtcbiAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgIH0pXG4gICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KVxuICAgICAgLnBsYXkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBtb2RhbFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShtb2RhbCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0KG1vZGFsKVxuICAgICAgLnF1ZXVlKHtcbiAgICAgICAgb3BhY2l0eTogMVxuICAgICAgfSlcbiAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAucXVldWUoe1xuICAgICAgICBvcGFjaXR5OiAwXG4gICAgICB9LCB7XG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICB9KVxuICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSlcbiAgICAgIC5wbGF5KCk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEFuaW1hdG9yRmFjdG9yeSBmcm9tICdvbnMvaW50ZXJuYWwvYW5pbWF0b3ItZmFjdG9yeSc7XG5pbXBvcnQgTW9kYWxBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCBGYWRlTW9kYWxBbmltYXRvciBmcm9tICcuL2ZhZGUtYW5pbWF0b3InO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJ29ucy9wbGF0Zm9ybSc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIgZnJvbSAnb25zL2RldmljZS1iYWNrLWJ1dHRvbi1kaXNwYXRjaGVyJztcbmltcG9ydCBEb29yTG9jayBmcm9tICdvbnMvZG9vcmxvY2snO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICdvbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICdtb2RhbC0tKicsXG4gICdtb2RhbF9fY29udGVudCc6ICdtb2RhbC0tKl9fY29udGVudCdcbn07XG5cbmNvbnN0IF9hbmltYXRvckRpY3QgPSB7XG4gICdkZWZhdWx0JzogTW9kYWxBbmltYXRvcixcbiAgJ2ZhZGUnOiBGYWRlTW9kYWxBbmltYXRvcixcbiAgJ25vbmUnOiBNb2RhbEFuaW1hdG9yXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1tb2RhbFxuICogQGNhdGVnb3J5IGRpYWxvZ1xuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBNb2RhbCBjb21wb25lbnQgdGhhdCBtYXNrcyBjdXJyZW50IHNjcmVlbi4gVW5kZXJseWluZyBjb21wb25lbnRzIGFyZSBub3Qgc3ViamVjdCB0byBhbnkgZXZlbnRzIHdoaWxlIHRoZSBtb2RhbCBjb21wb25lbnQgaXMgc2hvd24uXG4gKlxuICogICAgIFRoaXMgY29tcG9uZW50IGNhbiBiZSB1c2VkIHRvIGJsb2NrIHVzZXIgaW5wdXQgd2hpbGUgc29tZSBvcGVyYXRpb24gaXMgcnVubmluZyBvciB0byBzaG93IHNvbWUgaW5mb3JtYXRpb24gdG8gdGhlIHVzZXIuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1cbiAqICAgICDnlLvpnaLlhajkvZPjgpLjg57jgrnjgq/jgZnjgovjg6Ljg7zjg4Djg6vnlKjjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgILkuIvlgbTjgavjgYLjgovjgrPjg7Pjg53jg7zjg43jg7Pjg4jjga/jgIFcbiAqICAgICDjg6Ljg7zjg4Djg6vjgYzooajnpLrjgZXjgozjgabjgYTjgovplpPjga/jgqTjg5njg7Pjg4jpgJrnn6XjgYzooYzjgo/jgozjgb7jgZvjgpPjgIJcbiAqICAgWy9qYV1cbiAqIEBndWlkZSBkaWFsb2dzXG4gKiAgIFtlbl1EaWFsb2cgY29tcG9uZW50c1svZW5dXG4gKiAgIFtqYV1EaWFsb2cgY29tcG9uZW50c1svamFdXG4gKiBAc2VlYWxzbyBvbnMtZGlhbG9nXG4gKiAgIFtlbl1UaGUgYDxvbnMtZGlhbG9nPmAgY29tcG9uZW50IGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhIG1vZGFsIGRpYWxvZy5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIGRldklnXG4gKiBAZXhhbXBsZVxuICogPG9ucy1tb2RhbCBpZD1cIm1vZGFsXCI+XG4gKiAgIE1vZGFsIGNvbnRlbnRcbiAqIDwvb25zLW1vZGFsPlxuICogPHNjcmlwdD5cbiAqICAgdmFyIG1vZGFsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vZGFsJyk7XG4gKiAgIG1vZGFsLnNob3coKTtcbiAqIDwvc2NyaXB0PlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb2RhbEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IGRlZmF1bHRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIGFuaW1hdGlvbiB1c2VkIHdoZW4gc2hvd2luZyBhbmQgaGlkaW5nIHRoZSBtb2RhbC4gQ2FuIGJlIGVpdGhlciBgXCJub25lXCJgIG9yIGBcImZhZGVcImAuWy9lbl1cbiAgICogIFtqYV3jg6Ljg7zjg4Djg6vjgpLooajnpLrjgZnjgovpmpvjga7jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIuOCguOBl+OBj+OBr1wiZmFkZVwi44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uLW9wdGlvbnNcbiAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCB0aW1pbmcgYW5kIGRlbGF5IHdpdGggYW4gb2JqZWN0IGxpdGVyYWwuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCB0aW1pbmcsIGRlbGF544KS44Kq44OW44K444Kn44Kv44OI44Oq44OG44Op44Or44Gn5oyH5a6a44GX44G+44GZ44CCZS5nLiA8Y29kZT57ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfTwvY29kZT5bL2phXVxuICAgKi9cblxuICBpbml0KCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9kb29yTG9jayA9IG5ldyBEb29yTG9jaygpO1xuXG4gICAgdGhpcy5fYW5pbWF0b3JGYWN0b3J5ID0gbmV3IEFuaW1hdG9yRmFjdG9yeSh7XG4gICAgICBhbmltYXRvcnM6IF9hbmltYXRvckRpY3QsXG4gICAgICBiYXNlQ2xhc3M6IE1vZGFsQW5pbWF0b3IsXG4gICAgICBiYXNlQ2xhc3NOYW1lOiAnTW9kYWxBbmltYXRvcicsXG4gICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJylcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25EZXZpY2VCYWNrQnV0dG9uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1CYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAqICAgW2phXeODkOODg+OCr+ODnOOCv+ODs+ODj+ODs+ODieODqeOAglsvamFdXG4gICAqL1xuICBnZXQgb25EZXZpY2VCYWNrQnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcjtcbiAgfVxuXG4gIHNldCBvbkRldmljZUJhY2tCdXR0b24oaGFuZGxlcikge1xuICAgIGlmICh0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcikge1xuICAgICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyID0gZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIuY3JlYXRlSGFuZGxlcih0aGlzLCBoYW5kbGVyKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB0aGlzLnN0eWxlLnpJbmRleCA9IDEwMDAxO1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnbW9kYWwnKTtcblxuICAgIGlmICghdXRpbC5maW5kQ2hpbGQodGhpcywgJy5tb2RhbF9fY29udGVudCcpKSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQoJ21vZGFsX19jb250ZW50Jyk7XG5cbiAgICAgIHdoaWxlICh0aGlzLmNoaWxkTm9kZXNbMF0pIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuY2hpbGROb2Rlc1swXTtcbiAgICAgICAgdGhpcy5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgY29udGVudC5pbnNlcnRCZWZvcmUobm9kZSwgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgfVxuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyKSB7XG4gICAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlci5kZXN0cm95KCk7XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5vbkRldmljZUJhY2tCdXR0b24gPSAoKSA9PiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZpc2libGVcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3opoHntKDjgYzopovjgYjjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2hvd1xuICAgKiBAc2lnbmF0dXJlIHNob3coW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJub25lXCJgIGFuZCBgXCJmYWRlXCJgLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwiLCBcImZhZGVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31bL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdyBtb2RhbC5bL2VuXVxuICAgKiAgIFtqYV3jg6Ljg7zjg4Djg6vjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgZGlzcGxheWVkIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgc2hvdyhvcHRpb25zID0ge30pIHtcbiAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgPSB1dGlsLmV4dGVuZChcbiAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fSxcbiAgICAgIEFuaW1hdG9yRmFjdG9yeS5wYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpXG4gICAgKTtcblxuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjayB8fCBmdW5jdGlvbigpIHt9O1xuXG4gICAgY29uc3QgdHJ5U2hvdyA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHVubG9jayA9IHRoaXMuX2Rvb3JMb2NrLmxvY2soKTtcbiAgICAgIGNvbnN0IGFuaW1hdG9yID0gdGhpcy5fYW5pbWF0b3JGYWN0b3J5Lm5ld0FuaW1hdG9yKG9wdGlvbnMpO1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ3RhYmxlJztcbiAgICAgICAgICBhbmltYXRvci5zaG93KHRoaXMsICgpID0+IHtcbiAgICAgICAgICAgIHVubG9jaygpO1xuXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgcmVzb2x2ZSh0aGlzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgdGhpcy5fZG9vckxvY2sud2FpdFVubG9jaygoKSA9PiByZXNvbHZlKHRyeVNob3coKSkpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgdG9nZ2xlXG4gICAqIEBzaWduYXR1cmUgdG9nZ2xlKFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwibm9uZVwiYCBhbmQgYFwiZmFkZVwiYC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIiwgXCJmYWRlXCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRvZ2dsZSBtb2RhbCB2aXNpYmlsaXR5LlsvZW5dXG4gICAqICAgW2phXeODouODvOODgOODq+OBruihqOekuuOCkuWIh+OCiuabv+OBiOOBvuOBmeOAglsvamFdXG4gICAqL1xuICB0b2dnbGUoKSB7XG4gICAgaWYgKHRoaXMudmlzaWJsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGlkZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5zaG93LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaGlkZVxuICAgKiBAc2lnbmF0dXJlIGhpZGUoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJub25lXCJgIGFuZCBgXCJmYWRlXCJgLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwiLCBcImZhZGVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31bL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSGlkZSBtb2RhbC5bL2VuXVxuICAgKiAgIFtqYV3jg6Ljg7zjg4Djg6vjgpLpnZ7ooajnpLrjgavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgaGlkZGVuIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgaGlkZShvcHRpb25zID0ge30pIHtcbiAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgPSB1dGlsLmV4dGVuZChcbiAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fSxcbiAgICAgIEFuaW1hdG9yRmFjdG9yeS5wYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpXG4gICAgKTtcblxuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjayB8fCBmdW5jdGlvbigpIHt9O1xuXG4gICAgY29uc3QgdHJ5SGlkZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHVubG9jayA9IHRoaXMuX2Rvb3JMb2NrLmxvY2soKTtcbiAgICAgIGNvbnN0IGFuaW1hdG9yID0gdGhpcy5fYW5pbWF0b3JGYWN0b3J5Lm5ld0FuaW1hdG9yKG9wdGlvbnMpO1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgYW5pbWF0b3IuaGlkZSh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB1bmxvY2soKTtcblxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHRoaXMuX2Rvb3JMb2NrLndhaXRVbmxvY2soKCkgPT4gcmVzb2x2ZSh0cnlIaWRlKCkpKTtcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChuYW1lID09PSAnbW9kaWZpZXInKSB7XG4gICAgICByZXR1cm4gTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IEFuaW1hdG9yXG4gICAqL1xuICBzdGF0aWMgcmVnaXN0ZXJBbmltYXRvcihuYW1lLCBBbmltYXRvcikge1xuICAgIGlmICghKEFuaW1hdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIE1vZGFsQW5pbWF0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiQW5pbWF0b3JcIiBwYXJhbSBtdXN0IGluaGVyaXQgT25zTW9kYWxFbGVtZW50Lk1vZGFsQW5pbWF0b3InKTtcbiAgICB9XG4gICAgX2FuaW1hdG9yRGljdFtuYW1lXSA9IEFuaW1hdG9yO1xuICB9XG5cbiAgc3RhdGljIGdldCBNb2RhbEFuaW1hdG9yKCkge1xuICAgIHJldHVybiBNb2RhbEFuaW1hdG9yO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLW1vZGFsJywgTW9kYWxFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIHtcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudGltaW5nXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmR1cmF0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmRlbGF5XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgIHRpbWluZzogJ2xpbmVhcicsXG4gICAgICBkdXJhdGlvbjogJzAuNCcsXG4gICAgICBkZWxheTogJzAnXG4gICAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgICB0aGlzLnRpbWluZyA9IG9wdGlvbnMudGltaW5nO1xuICAgIHRoaXMuZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uO1xuICAgIHRoaXMuZGVsYXkgPSBvcHRpb25zLmRlbGF5O1xuICB9XG5cbiAgcHVzaChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgcG9wKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cblxuICBzdGF0aWMgZXh0ZW5kKHByb3BlcnRpZXMgPSB7fSkge1xuXG4gICAgY29uc3QgZXh0ZW5kZWRBbmltYXRvciA9IHRoaXM7XG4gICAgY29uc3QgbmV3QW5pbWF0b3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIGV4dGVuZGVkQW5pbWF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHV0aWwuZXh0ZW5kKHRoaXMsIHByb3BlcnRpZXMpO1xuICAgIH07XG5cbiAgICBuZXdBbmltYXRvci5wcm90b3R5cGUgPSB0aGlzLnByb3RvdHlwZTtcblxuICAgIHJldHVybiBuZXdBbmltYXRvcjtcbiAgfVxufVxuXG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICdvbnMvY29udGVudC1yZWFkeSc7XG5cbi8qKlxuICogU2xpZGUgYW5pbWF0b3IgZm9yIG5hdmlnYXRvciB0cmFuc2l0aW9uIGxpa2UgaU9TJ3Mgc2NyZWVuIHNsaWRlIHRyYW5zaXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElPU1NsaWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGV4dGVuZHMgTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgIGR1cmF0aW9uOiAwLjQsXG4gICAgICB0aW1pbmc6ICdlYXNlJyxcbiAgICAgIGRlbGF5OiAwXG4gICAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgICBzdXBlcihvcHRpb25zKTtcblxuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoYFxuICAgICAgPGRpdiBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZTsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogYmxhY2s7IG9wYWNpdHk6IDA7IHotaW5kZXg6IDJcIj48L2Rpdj5cbiAgICBgKTtcbiAgfVxuXG4gIF9kZWNvbXBvc2UocGFnZSkge1xuICAgIGNvbnN0IHRvb2xiYXIgPSBwYWdlLl9nZXRUb29sYmFyRWxlbWVudCgpO1xuICAgIGNvbnN0IGxlZnQgPSB0b29sYmFyLl9nZXRUb29sYmFyTGVmdEl0ZW1zRWxlbWVudCgpO1xuICAgIGNvbnN0IHJpZ2h0ID0gdG9vbGJhci5fZ2V0VG9vbGJhclJpZ2h0SXRlbXNFbGVtZW50KCk7XG5cbiAgICBjb25zdCBleGNsdWRlQmFja0J1dHRvbiA9IGZ1bmN0aW9uKGVsZW1lbnRzKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZWxlbWVudHNbaV0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ29ucy1iYWNrLWJ1dHRvbicpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChlbGVtZW50c1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgY29uc3Qgb3RoZXIgPSBbXVxuICAgICAgLmNvbmNhdChsZWZ0LmNoaWxkcmVuLmxlbmd0aCA9PT0gMCA/IGxlZnQgOiBleGNsdWRlQmFja0J1dHRvbihsZWZ0LmNoaWxkcmVuKSlcbiAgICAgIC5jb25jYXQocmlnaHQuY2hpbGRyZW4ubGVuZ3RoID09PSAwID8gcmlnaHQgOiBleGNsdWRlQmFja0J1dHRvbihyaWdodC5jaGlsZHJlbikpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRvb2xiYXJDZW50ZXI6IHRvb2xiYXIuX2dldFRvb2xiYXJDZW50ZXJJdGVtc0VsZW1lbnQoKSxcbiAgICAgIGJhY2tCdXR0b25JY29uOiB0b29sYmFyLl9nZXRUb29sYmFyQmFja0J1dHRvbkljb25FbGVtZW50KCksXG4gICAgICBiYWNrQnV0dG9uTGFiZWw6IHRvb2xiYXIuX2dldFRvb2xiYXJCYWNrQnV0dG9uTGFiZWxFbGVtZW50KCksXG4gICAgICBvdGhlcjogb3RoZXIsXG4gICAgICBjb250ZW50OiBwYWdlLl9nZXRDb250ZW50RWxlbWVudCgpLFxuICAgICAgYmFja2dyb3VuZDogcGFnZS5fZ2V0QmFja2dyb3VuZEVsZW1lbnQoKSxcbiAgICAgIHRvb2xiYXI6IHRvb2xiYXIsXG4gICAgICBib3R0b21Ub29sYmFyOiBwYWdlLl9nZXRCb3R0b21Ub29sYmFyRWxlbWVudCgpXG4gICAgfTtcbiAgfVxuXG4gIF9zaG91bGRBbmltYXRlVG9vbGJhcihlbnRlclBhZ2UsIGxlYXZlUGFnZSkge1xuICAgIGNvbnN0IGJvdGhQYWdlSGFzVG9vbGJhciA9XG4gICAgICBlbnRlclBhZ2UuX2NhbkFuaW1hdGVUb29sYmFyKCkgJiYgbGVhdmVQYWdlLl9jYW5BbmltYXRlVG9vbGJhcigpO1xuXG4gICAgdmFyIG5vTWF0ZXJpYWxUb29sYmFyID1cbiAgICAgICFlbnRlclBhZ2UuX2dldFRvb2xiYXJFbGVtZW50KCkuY2xhc3NMaXN0LmNvbnRhaW5zKCduYXZpZ2F0aW9uLWJhci0tbWF0ZXJpYWwnKSAmJlxuICAgICAgIWxlYXZlUGFnZS5fZ2V0VG9vbGJhckVsZW1lbnQoKS5jbGFzc0xpc3QuY29udGFpbnMoJ25hdmlnYXRpb24tYmFyLS1tYXRlcmlhbCcpO1xuXG4gICAgcmV0dXJuIGJvdGhQYWdlSGFzVG9vbGJhciAmJiBub01hdGVyaWFsVG9vbGJhcjtcbiAgfVxuXG4gIF9jYWxjdWxhdGVEZWx0YShlbGVtZW50LCBkZWNvbXBvc2l0aW9uKSB7XG4gICAgbGV0IHRpdGxlLCBsYWJlbDtcblxuICAgIGNvbnN0IHBhZ2VSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAoZGVjb21wb3NpdGlvbi5iYWNrQnV0dG9uTGFiZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdiYWNrLWJ1dHRvbl9fbGFiZWwnKSkge1xuICAgICAgY29uc3QgbGFiZWxSZWN0ID0gZGVjb21wb3NpdGlvbi5iYWNrQnV0dG9uTGFiZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB0aXRsZSA9IE1hdGgucm91bmQoKHBhZ2VSZWN0LndpZHRoIC8gMikgLSAobGFiZWxSZWN0LndpZHRoIC8gMikgLSBsYWJlbFJlY3QubGVmdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpdGxlID0gTWF0aC5yb3VuZCgocGFnZVJlY3Qud2lkdGggLyAyKSAqIDAuNik7XG4gICAgfVxuXG4gICAgaWYgKGRlY29tcG9zaXRpb24uYmFja0J1dHRvbkljb24uY2xhc3NMaXN0LmNvbnRhaW5zKCdiYWNrLWJ1dHRvbl9faWNvbicpKSB7XG4gICAgICBsYWJlbCA9IGRlY29tcG9zaXRpb24uYmFja0J1dHRvbkljb24uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkucmlnaHQgLSAyO1xuICAgIH1cblxuICAgIHJldHVybiB7dGl0bGUsIGxhYmVsfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGxlYXZlUGFnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcHVzaChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgIGxlYXZlUGFnZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmJhY2tncm91bmRNYXNrLCBsZWF2ZVBhZ2UubmV4dFNpYmxpbmcpO1xuXG4gICAgY29udGVudFJlYWR5KGVudGVyUGFnZSwgKCkgPT4ge1xuICAgICAgY29uc3QgZW50ZXJQYWdlRGVjb21wb3NpdGlvbiA9IHRoaXMuX2RlY29tcG9zZShlbnRlclBhZ2UpO1xuICAgICAgY29uc3QgbGVhdmVQYWdlRGVjb21wb3NpdGlvbiA9IHRoaXMuX2RlY29tcG9zZShsZWF2ZVBhZ2UpO1xuXG4gICAgICBjb25zdCBkZWx0YSA9IHRoaXMuX2NhbGN1bGF0ZURlbHRhKGxlYXZlUGFnZSwgZW50ZXJQYWdlRGVjb21wb3NpdGlvbik7XG5cbiAgICAgIGNvbnN0IG1hc2tDbGVhciA9IGFuaW1pdCh0aGlzLmJhY2tncm91bmRNYXNrKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJ1xuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDAuMDVcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSgoZG9uZSkgPT4ge1xuICAgICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgY29uc3Qgc2hvdWxkQW5pbWF0ZVRvb2xiYXIgPSB0aGlzLl9zaG91bGRBbmltYXRlVG9vbGJhcihlbnRlclBhZ2UsIGxlYXZlUGFnZSk7XG5cbiAgICAgIGlmIChzaG91bGRBbmltYXRlVG9vbGJhcikge1xuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgdGhpcyBmaXhcbiAgICAgICAgY29uc3QgZW50ZXJQYWdlVG9vbGJhckhlaWdodCA9IGVudGVyUGFnZURlY29tcG9zaXRpb24udG9vbGJhci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgKyAncHgnO1xuICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnN0eWxlLnRvcCA9IGVudGVyUGFnZVRvb2xiYXJIZWlnaHQ7XG5cbiAgICAgICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgICAgIG1hc2tDbGVhcixcblxuICAgICAgICAgIGFuaW1pdChbZW50ZXJQYWdlRGVjb21wb3NpdGlvbi5jb250ZW50LCBlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLmJvdHRvbVRvb2xiYXIsIGVudGVyUGFnZURlY29tcG9zaXRpb24uYmFja2dyb3VuZF0pXG4gICAgICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDEwMCUsIDBweCwgMHB4KScsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDBweCwgMHB4LCAwcHgpJyxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucmVzdG9yZVN0eWxlKCksXG5cbiAgICAgICAgICBhbmltaXQoZW50ZXJQYWdlRGVjb21wb3NpdGlvbi50b29sYmFyKVxuICAgICAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgICAgIGFuaW1pdChlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLmJhY2tncm91bmQpXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICB0b3A6IGVudGVyUGFnZVRvb2xiYXJIZWlnaHRcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICAgIH0pLFxuXG4gICAgICAgICAgYW5pbWl0KGVudGVyUGFnZURlY29tcG9zaXRpb24udG9vbGJhckNlbnRlcilcbiAgICAgICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMTI1JSwgMCwgMCknLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgICAgIGFuaW1pdChlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLmJhY2tCdXR0b25MYWJlbClcbiAgICAgICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoJyArIGRlbHRhLnRpdGxlICsgJ3B4LCAwLCAwKScsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnJlc3RvcmVTdHlsZSgpLFxuXG4gICAgICAgICAgYW5pbWl0KGVudGVyUGFnZURlY29tcG9zaXRpb24ub3RoZXIpXG4gICAgICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge29wYWNpdHk6IDB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtvcGFjaXR5OiAxfSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucmVzdG9yZVN0eWxlKCksXG5cbiAgICAgICAgICBhbmltaXQoW2xlYXZlUGFnZURlY29tcG9zaXRpb24uY29udGVudCwgbGVhdmVQYWdlRGVjb21wb3NpdGlvbi5ib3R0b21Ub29sYmFyLCBsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLmJhY2tncm91bmRdKVxuICAgICAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKC0yNSUsIDBweCwgMHB4KScsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICB9KSxcblxuICAgICAgICAgIGFuaW1pdChsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLnRvb2xiYXJDZW50ZXIpXG4gICAgICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLScgKyBkZWx0YS50aXRsZSArICdweCwgMCwgMCknLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnJlc3RvcmVTdHlsZSgpLFxuXG4gICAgICAgICAgYW5pbWl0KGxlYXZlUGFnZURlY29tcG9zaXRpb24uYmFja0J1dHRvbkxhYmVsKVxuICAgICAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC0nICsgZGVsdGEubGFiZWwgKyAncHgsIDAsIDApJyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgICAgIGFuaW1pdChsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLm90aGVyKVxuICAgICAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtvcGFjaXR5OiAxfSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7b3BhY2l0eTogMH0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG5cbiAgICAgICAgKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICAgICAgbWFza0NsZWFyLFxuXG4gICAgICAgICAgYW5pbWl0KGVudGVyUGFnZSlcbiAgICAgICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMTAwJSwgMHB4LCAwcHgpJyxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMHB4LCAwcHgsIDBweCknLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXG4gICAgICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJ1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgtMjUlLCAwcHgsIDBweCknXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIHBvcChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgZG9uZSkge1xuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgZW50ZXJQYWdlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuYmFja2dyb3VuZE1hc2ssIGVudGVyUGFnZS5uZXh0U2libGluZyk7XG5cbiAgICBjb25zdCBlbnRlclBhZ2VEZWNvbXBvc2l0aW9uID0gdGhpcy5fZGVjb21wb3NlKGVudGVyUGFnZSk7XG4gICAgY29uc3QgbGVhdmVQYWdlRGVjb21wb3NpdGlvbiA9IHRoaXMuX2RlY29tcG9zZShsZWF2ZVBhZ2UpO1xuXG4gICAgY29uc3QgZGVsdGEgPSB0aGlzLl9jYWxjdWxhdGVEZWx0YShsZWF2ZVBhZ2UsIGxlYXZlUGFnZURlY29tcG9zaXRpb24pO1xuXG4gICAgY29uc3QgbWFza0NsZWFyID0gYW5pbWl0KHRoaXMuYmFja2dyb3VuZE1hc2spXG4gICAgICAuc2F2ZVN0eWxlKClcbiAgICAgIC5xdWV1ZSh7XG4gICAgICAgIG9wYWNpdHk6IDAuMSxcbiAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknXG4gICAgICB9KVxuICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgIC5xdWV1ZSh7XG4gICAgICAgIG9wYWNpdHk6IDBcbiAgICAgIH0sIHtcbiAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgIH0pXG4gICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgIC5xdWV1ZSgoZG9uZSkgPT4ge1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KTtcblxuICAgIGNvbnN0IHNob3VsZEFuaW1hdGVUb29sYmFyID0gdGhpcy5fc2hvdWxkQW5pbWF0ZVRvb2xiYXIoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UpO1xuXG4gICAgaWYgKHNob3VsZEFuaW1hdGVUb29sYmFyKSB7XG4gICAgICBjb25zdCBlbnRlclBhZ2VUb29sYmFySGVpZ2h0ID0gZW50ZXJQYWdlRGVjb21wb3NpdGlvbi50b29sYmFyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCArICdweCc7XG4gICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnN0eWxlLnRvcCA9IGVudGVyUGFnZVRvb2xiYXJIZWlnaHQ7XG5cbiAgICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgICAgbWFza0NsZWFyLFxuXG4gICAgICAgIGFuaW1pdChbZW50ZXJQYWdlRGVjb21wb3NpdGlvbi5jb250ZW50LCBlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLmJvdHRvbVRvb2xiYXIsIGVudGVyUGFnZURlY29tcG9zaXRpb24uYmFja2dyb3VuZF0pXG4gICAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgtMjUlLCAwcHgsIDBweCknLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAwLjlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDBweCwgMHB4LCAwcHgpJyxcbiAgICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgfSlcbiAgICAgICAgICAucmVzdG9yZVN0eWxlKCksXG5cbiAgICAgICAgYW5pbWl0KGVudGVyUGFnZURlY29tcG9zaXRpb24udG9vbGJhckNlbnRlcilcbiAgICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC0nICsgZGVsdGEudGl0bGUgKyAncHgsIDAsIDApJyxcbiAgICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgfSlcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgICBhbmltaXQoZW50ZXJQYWdlRGVjb21wb3NpdGlvbi5iYWNrQnV0dG9uTGFiZWwpXG4gICAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtJyArIGRlbHRhLmxhYmVsICsgJ3B4LCAwLCAwKSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnJlc3RvcmVTdHlsZSgpLFxuXG4gICAgICAgIGFuaW1pdChlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLm90aGVyKVxuICAgICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtvcGFjaXR5OiAwfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgfSlcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtvcGFjaXR5OiAxfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnJlc3RvcmVTdHlsZSgpLFxuXG4gICAgICAgIGFuaW1pdChsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLmJhY2tncm91bmQpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0b3A6IGVudGVyUGFnZVRvb2xiYXJIZWlnaHRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgIH0pLFxuXG4gICAgICAgIGFuaW1pdChbbGVhdmVQYWdlRGVjb21wb3NpdGlvbi5jb250ZW50LCBsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLmJvdHRvbVRvb2xiYXIsIGxlYXZlUGFnZURlY29tcG9zaXRpb24uYmFja2dyb3VuZF0pXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwcHgsIDBweCwgMHB4KSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDEwMCUsIDBweCwgMHB4KSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICB9KVxuICAgICAgICAgIC53YWl0KDApXG4gICAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGZpbmlzaCkge1xuICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgIGZpbmlzaCgpO1xuICAgICAgICAgIH0uYmluZCh0aGlzKSksXG5cbiAgICAgICAgYW5pbWl0KGxlYXZlUGFnZURlY29tcG9zaXRpb24udG9vbGJhcilcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgfSksXG5cbiAgICAgICAgYW5pbWl0KGxlYXZlUGFnZURlY29tcG9zaXRpb24udG9vbGJhckNlbnRlcilcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgfSlcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMTI1JSwgMCwgMCknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgfSksXG5cbiAgICAgICAgYW5pbWl0KGxlYXZlUGFnZURlY29tcG9zaXRpb24uYmFja0J1dHRvbkxhYmVsKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICB9KVxuICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgnICsgZGVsdGEudGl0bGUgKyAncHgsIDAsIDApJyxcbiAgICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgIH0pXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICAgIG1hc2tDbGVhcixcblxuICAgICAgICBhbmltaXQoZW50ZXJQYWdlKVxuICAgICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoLTI1JSwgMHB4LCAwcHgpJyxcbiAgICAgICAgICAgICAgb3BhY2l0eTogMC45XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICB9KVxuICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwcHgsIDBweCwgMHB4KScsXG4gICAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnJlc3RvcmVTdHlsZSgpLFxuXG4gICAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwcHgsIDBweCwgMHB4KSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDEwMCUsIDBweCwgMHB4KSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5xdWV1ZShmdW5jdGlvbihmaW5pc2gpIHtcbiAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICBmaW5pc2goKTtcbiAgICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcblxuLyoqXG4gKiBMaWZ0IHNjcmVlbiB0cmFuc2l0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJT1NMaWZ0TmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGV4dGVuZHMgTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgIGR1cmF0aW9uOiAwLjQsXG4gICAgICB0aW1pbmc6ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuMSwgMSknLFxuICAgICAgZGVsYXk6IDBcbiAgICB9LCBvcHRpb25zIHx8IHt9KTtcblxuICAgIHN1cGVyKG9wdGlvbnMpO1xuXG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzayA9IHV0aWwuY3JlYXRlRWxlbWVudChgXG4gICAgICA8ZGl2IHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlO1xuICAgICAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoYmxhY2ssIHdoaXRlKTtcIj48L2Rpdj5cbiAgICBgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICBsZWF2ZVBhZ2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5iYWNrZ3JvdW5kTWFzaywgbGVhdmVQYWdlKTtcblxuICAgIGNvbnN0IG1hc2tDbGVhciA9IGFuaW1pdCh0aGlzLmJhY2tncm91bmRNYXNrKVxuICAgICAgLndhaXQodGhpcy5kZWxheSArIHRoaXMuZHVyYXRpb24pXG4gICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pO1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgbWFza0NsZWFyLFxuXG4gICAgICBhbmltaXQoZW50ZXJQYWdlKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDEwMCUsIDApJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGxlYXZlUGFnZSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIC0xMCUsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuOVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHBvcChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgIGVudGVyUGFnZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmJhY2tncm91bmRNYXNrLCBlbnRlclBhZ2UpO1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KHRoaXMuYmFja2dyb3VuZE1hc2spXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkgKyB0aGlzLmR1cmF0aW9uKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQoZW50ZXJQYWdlKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgLTEwJSwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMC45XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQobGVhdmVQYWdlKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMTAwJSwgMCknXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG5cbiAgICApO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuXG4vKipcbiAqIEZhZGUtaW4gc2NyZWVuIHRyYW5zaXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElPU0ZhZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZXh0ZW5kcyBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe1xuICAgICAgdGltaW5nOiAnbGluZWFyJyxcbiAgICAgIGR1cmF0aW9uOiAnMC40JyxcbiAgICAgIGRlbGF5OiAnMCdcbiAgICB9LCBvcHRpb25zIHx8IHt9KTtcblxuICAgIHN1cGVyKG9wdGlvbnMpO1xuICB9XG5cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBwdXNoKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KFtlbnRlclBhZ2UuX2dldENvbnRlbnRFbGVtZW50KCksIGVudGVyUGFnZS5fZ2V0QmFja2dyb3VuZEVsZW1lbnQoKV0pXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQoZW50ZXJQYWdlLl9nZXRUb29sYmFyRWxlbWVudCgpKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgcG9wKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChbbGVhdmVQYWdlLl9nZXRDb250ZW50RWxlbWVudCgpLCBsZWF2ZVBhZ2UuX2dldEJhY2tncm91bmRFbGVtZW50KCldKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UuX2dldFRvb2xiYXJFbGVtZW50KCkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuXG4gICAgKTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuaW1wb3J0IE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcblxuLyoqXG4gKiBTbGlkZSBhbmltYXRvciBmb3IgbmF2aWdhdG9yIHRyYW5zaXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1EU2xpZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZXh0ZW5kcyBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe1xuICAgICAgZHVyYXRpb246IDAuMyxcbiAgICAgIHRpbWluZzogJ2N1YmljLWJlemllciguMSwgLjcsIC40LCAxKScsXG4gICAgICBkZWxheTogMFxuICAgIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICB0aGlzLmJhY2tncm91bmRNYXNrID0gdXRpbC5jcmVhdGVFbGVtZW50KGBcbiAgICAgIDxkaXYgc3R5bGU9XCJwb3NpdGlvbjogYWJzb2x1dGU7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7IHotaW5kZXg6IDI7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IGJsYWNrOyBvcGFjaXR5OiAwO1wiPjwvZGl2PlxuICAgIGApO1xuICAgIHRoaXMuYmxhY2tNYXNrT3BhY2l0eSA9IDAuNDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICBsZWF2ZVBhZ2UucGFyZW50RWxlbWVudC5pbnNlcnRCZWZvcmUodGhpcy5iYWNrZ3JvdW5kTWFzaywgbGVhdmVQYWdlLm5leHRTaWJsaW5nKTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdCh0aGlzLmJhY2tncm91bmRNYXNrKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJ1xuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IHRoaXMuYmxhY2tNYXNrT3BhY2l0eVxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGVudGVyUGFnZSlcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgxMDAlLCAwLCAwKScsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKCksXG5cbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoLTQ1JSwgMHB4LCAwcHgpJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLndhaXQoMC4yKVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIHBvcChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgZG9uZSkge1xuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgZW50ZXJQYWdlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuYmFja2dyb3VuZE1hc2ssIGVudGVyUGFnZS5uZXh0U2libGluZyk7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQodGhpcy5iYWNrZ3JvdW5kTWFzaylcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogdGhpcy5ibGFja01hc2tPcGFjaXR5LFxuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJ1xuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChlbnRlclBhZ2UpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoLTQ1JSwgMHB4LCAwcHgpJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuOVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDBweCwgMHB4LCAwcHgpJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKCksXG5cbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwcHgsIDBweCwgMHB4KSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgxMDAlLCAwcHgsIDBweCknXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KDAuMilcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGZpbmlzaCkge1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICBmaW5pc2goKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuXG4vKipcbiAqIExpZnQgc2NyZWVuIHRyYW5zaXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1ETGlmdE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBleHRlbmRzIE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XG4gICAgICBkdXJhdGlvbjogMC40LFxuICAgICAgdGltaW5nOiAnY3ViaWMtYmV6aWVyKC4xLCAuNywgLjEsIDEpJyxcbiAgICAgIGRlbGF5OiAwLjA1XG4gICAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgICBzdXBlcihvcHRpb25zKTtcblxuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoYFxuICAgICAgPGRpdiBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZTsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogYmxhY2s7XCI+PC9kaXY+XG4gICAgYCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBwdXNoKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgbGVhdmVQYWdlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuYmFja2dyb3VuZE1hc2ssIGxlYXZlUGFnZSk7XG5cbiAgICBjb25zdCBtYXNrQ2xlYXIgPSBhbmltaXQodGhpcy5iYWNrZ3JvdW5kTWFzaylcbiAgICAgIC53YWl0KHRoaXMuZGVsYXkgKyB0aGlzLmR1cmF0aW9uKVxuICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIG1hc2tDbGVhcixcblxuICAgICAgYW5pbWl0KGVudGVyUGFnZSlcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAxMDAlLCAwKScsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICBvcGFjaXR5OiAwLjRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBwb3AoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICBlbnRlclBhZ2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5iYWNrZ3JvdW5kTWFzaywgZW50ZXJQYWdlKTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdCh0aGlzLmJhY2tncm91bmRNYXNrKVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5ICsgdGhpcy5kdXJhdGlvbilcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGVudGVyUGFnZSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuNFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGxlYXZlUGFnZSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDEwMCUsIDApJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5cbi8qKlxuICogRmFkZS1pbiArIExpZnQgc2NyZWVuIHRyYW5zaXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1ERmFkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBleHRlbmRzIE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XG4gICAgICB0aW1pbmc6ICdlYXNlLW91dCcsXG4gICAgICBkdXJhdGlvbjogJzAuMjUnLFxuICAgICAgZGVsYXk6ICcwJ1xuICAgIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gICAgc3VwZXIob3B0aW9ucyk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZW50ZXJQYWdlKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDQycHgsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgcG9wKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KDAuMTUpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAzOHB4LCAwKSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCgwLjA0KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vbmVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZXh0ZW5kcyBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3Ige1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gIH1cbiAgcHVzaChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgcG9wKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcbmltcG9ydCBpbnRlcm5hbCBmcm9tICdvbnMvaW50ZXJuYWwnO1xuaW1wb3J0IEFuaW1hdG9yRmFjdG9yeSBmcm9tICdvbnMvaW50ZXJuYWwvYW5pbWF0b3ItZmFjdG9yeSc7XG5pbXBvcnQgTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IElPU1NsaWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGZyb20gJy4vaW9zLXNsaWRlLWFuaW1hdG9yJztcbmltcG9ydCBJT1NMaWZ0TmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGZyb20gJy4vaW9zLWxpZnQtYW5pbWF0b3InO1xuaW1wb3J0IElPU0ZhZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZnJvbSAnLi9pb3MtZmFkZS1hbmltYXRvcic7XG5pbXBvcnQgTURTbGlkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciBmcm9tICcuL21kLXNsaWRlLWFuaW1hdG9yJztcbmltcG9ydCBNRExpZnROYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZnJvbSAnLi9tZC1saWZ0LWFuaW1hdG9yJztcbmltcG9ydCBNREZhZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgZnJvbSAnLi9tZC1mYWRlLWFuaW1hdG9yJztcbmltcG9ydCBOb25lTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIGZyb20gJy4vbm9uZS1hbmltYXRvcic7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnb25zL3BsYXRmb3JtJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnb25zL2NvbnRlbnQtcmVhZHknO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyIGZyb20gJ29ucy9kZXZpY2UtYmFjay1idXR0b24tZGlzcGF0Y2hlcic7XG5pbXBvcnQge1BhZ2VMb2FkZXIsIGRlZmF1bHRQYWdlTG9hZGVyLCBpbnN0YW50UGFnZUxvYWRlcn0gZnJvbSAnb25zL3BhZ2UtbG9hZGVyJztcblxuY29uc3QgX2FuaW1hdG9yRGljdCA9IHtcbiAgJ2RlZmF1bHQnOiAoKSA9PiBwbGF0Zm9ybS5pc0FuZHJvaWQoKSA/IE1ERmFkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciA6IElPU1NsaWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yLFxuICAnc2xpZGUnOiAoKSA9PiBwbGF0Zm9ybS5pc0FuZHJvaWQoKSA/IE1EU2xpZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgOiBJT1NTbGlkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcixcbiAgJ2xpZnQnOiAoKSA9PiBwbGF0Zm9ybS5pc0FuZHJvaWQoKSA/IE1ETGlmdE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciA6IElPU0xpZnROYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IsXG4gICdmYWRlJzogKCkgPT4gcGxhdGZvcm0uaXNBbmRyb2lkKCkgPyBNREZhZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgOiBJT1NGYWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yLFxuICAnc2xpZGUtaW9zJzogSU9TU2xpZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IsXG4gICdzbGlkZS1tZCc6IE1EU2xpZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IsXG4gICdsaWZ0LWlvcyc6IElPU0xpZnROYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IsXG4gICdsaWZ0LW1kJzogTURMaWZ0TmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yLFxuICAnZmFkZS1pb3MnOiBJT1NGYWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yLFxuICAnZmFkZS1tZCc6IE1ERmFkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcixcbiAgJ25vbmUnOiBOb25lTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yXG59O1xuXG5jb25zdCByZXdyaXRhYmxlcyA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbmF2aWdhdG9yU2lkZUVsZW1lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHJlYWR5KG5hdmlnYXRvckVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBuYXZpZ2F0b3JFbGVtZW50XG4gICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBsaW5rKG5hdmlnYXRvckVsZW1lbnQsIHRhcmdldCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayh0YXJnZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1uYXZpZ2F0b3JcbiAqIEBjYXRlZ29yeSBuYXZpZ2F0aW9uXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIEEgY29tcG9uZW50IHRoYXQgcHJvdmlkZXMgcGFnZSBzdGFjayBtYW5hZ2VtZW50IGFuZCBuYXZpZ2F0aW9uLiBTdGFjayBuYXZpZ2F0aW9uIGlzIHRoZSBtb3N0IGNvbW1vbiBuYXZpZ2F0aW9uIHBhdHRlcm4gZm9yIG1vYmlsZSBhcHBzLlxuICpcbiAqICAgICBXaGVuIGEgcGFnZSBpcyBwdXNoZWQgb24gdG9wIG9mIHRoZSBzdGFjayBpdCBpcyBkaXNwbGF5ZWQgd2l0aCBhIHRyYW5zaXRpb24gYW5pbWF0aW9uLiBXaGVuIHRoZSB1c2VyIHJldHVybnMgdG8gdGhlIHByZXZpb3VzIHBhZ2UgdGhlIHRvcCBwYWdlIHdpbGwgYmUgcG9wcGVkIGZyb20gdGhlIHRvcCBvZiB0aGUgc3RhY2sgYW5kIGhpZGRlbiB3aXRoIGFuIG9wcG9zaXRlIHRyYW5zaXRpb24gYW5pbWF0aW9uLlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIHlyaHR2XG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvbmF2aWdhdG9yXG4gKiBAZ3VpZGUgbXVsdGlwbGUtcGFnZS1uYXZpZ2F0aW9uXG4gKiAgIFtlbl1HdWlkZSBmb3IgcGFnZSBuYXZpZ2F0aW9uWy9lbl1cbiAqICAgW2phXeODmuODvOOCuOODiuODk+OCsuODvOOCt+ODp+ODs+OBruamguimgVsvamFdXG4gKiBAZ3VpZGUgdGVtcGxhdGVzXG4gKiAgIFtlbl1EZWZpbmluZyBtdWx0aXBsZSBwYWdlcyBpbiBzaW5nbGUgaHRtbFsvZW5dXG4gKiAgIFtqYV3opIfmlbDjga7jg5rjg7zjgrjjgpIx44Gk44GuSFRNTOOBq+iomOi/sOOBmeOCi1svamFdXG4gKiBAZ3VpZGUgY3JlYXRpbmctYS1wYWdlXG4gKiAgIFtlbl1TZXR0aW5nIHVwIGEgcGFnZSBpbiBpdHMgYGluaXRgIGV2ZW50Wy9lbl1cbiAqICAgW2phXVNldHRpbmcgdXAgYSBwYWdlIGluIGl0cyBgaW5pdGAgZXZlbnRbL2phXVxuICogQHNlZWFsc28gb25zLXRvb2xiYXJcbiAqICAgW2VuXVRoZSBgPG9ucy10b29sYmFyPmAgY29tcG9uZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIHRvb2xiYXIgb24gdGhlIHRvcCBvZiBhIHBhZ2UuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtYmFjay1idXR0b25cbiAqICAgW2VuXVRoZSBgPG9ucy1iYWNrLWJ1dHRvbj5gIGNvbXBvbmVudCBsZXRzIHRoZSB1c2VyIHJldHVybiB0byB0aGUgcHJldmlvdXMgcGFnZS5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLW5hdmlnYXRvciBpZD1cIm5hdmlnYXRvclwiPlxuICogICA8b25zLXBhZ2U+XG4gKiAgICAgPG9ucy10b29sYmFyPlxuICogICAgICAgPGRpdiBjbGFzcz1cImNlbnRlclwiPlxuICogICAgICAgICBUaXRsZVxuICogICAgICAgPC9kaXY+XG4gKiAgICAgPC9vbnMtdG9vbGJhcj5cbiAqICAgICA8cD5cbiAqICAgICAgIDxvbnMtYnV0dG9uXG4gKiAgICAgICAgIG9uY2xpY2s9XCJkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbmF2aWdhdG9yJykucHVzaFBhZ2UoJ3BhZ2UuaHRtbCcpXCI+XG4gKiAgICAgICAgIFB1c2ggcGFnZVxuICogICAgICAgPC9vbnMtYnV0dG9uPlxuICogICAgIDwvcD5cbiAqICAgPC9vbnMtcGFnZT5cbiAqIDwvb25zLW5hdmlnYXRvcj5cbiAqXG4gKiA8b25zLXRlbXBsYXRlIGlkPVwicGFnZS5odG1sXCI+XG4gKiAgIDxvbnMtcGFnZT5cbiAqICAgICA8b25zLXRvb2xiYXI+XG4gKiAgICAgICA8ZGl2IGNsYXNzPVwibGVmdFwiPlxuICogICAgICAgICA8b25zLWJhY2stYnV0dG9uPkJhY2s8L29ucy1iYWNrLWJ1dHRvbj5cbiAqICAgICAgIDwvZGl2PlxuICogICAgICAgPGRpdiBjbGFzcz1cImNlbnRlclwiPlxuICogICAgICAgICBBbm90aGVyIHBhZ2VcbiAqICAgICAgIDwvZGl2PlxuICogICAgIDwvb25zLXRvb2xiYXI+XG4gKiAgIDwvb25zLXBhZ2U+XG4gKiA8L29ucy10ZW1wbGF0ZT5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmF2aWdhdG9yRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBwYWdlXG4gICAqIEBpbml0b25seVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyc3QgcGFnZSB0byBzaG93IHdoZW4gbmF2aWdhdG9yIGlzIGluaXRpYWxpemVkLlsvZW5dXG4gICAqICAgW2phXeODiuODk+OCsuODvOOCv+ODvOOBjOWIneacn+WMluOBleOCjOOBn+aZguOBq+ihqOekuuOBmeOCi+ODmuODvOOCuOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCBkZWZhdWx0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIEFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwic2xpZGVcImAsIGBcImxpZnRcImAsIGBcImZhZGVcImAgYW5kIGBcIm5vbmVcImAuXG4gICAqXG4gICAqICAgICBUaGVzZSBhcmUgcGxhdGZvcm0gYmFzZWQgYW5pbWF0aW9ucy4gRm9yIGZpeGVkIGFuaW1hdGlvbnMsIGFkZCBgXCItaW9zXCJgIG9yIGBcIi1tZFwiYCBzdWZmaXggdG8gdGhlIGFuaW1hdGlvbiBuYW1lLiBFLmcuIGBcImxpZnQtaW9zXCJgLCBgXCJsaWZ0LW1kXCJgLiBEZWZhdWx0cyB2YWx1ZXMgYXJlIGBcInNsaWRlLWlvc1wiYCBhbmQgYFwiZmFkZS1tZFwiYCBkZXBlbmRpbmcgb24gdGhlIHBsYXRmb3JtLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvbi1vcHRpb25zXG4gICAqIEB0eXBlIHtFeHByZXNzaW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgdGltaW5nIGFuZCBkZWxheSB3aXRoIGFuIG9iamVjdCBsaXRlcmFsLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWBbL2VuXVxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCB0aW1pbmcsIGRlbGF544KS44Kq44OW44K444Kn44Kv44OI44Oq44OG44Op44Or44Gn5oyH5a6a44GX44G+44GZ44CCZS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVwdXNoXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSBhIHBhZ2UgaXMgcHVzaGVkLlsvZW5dXG4gICAqICAgW2phXXBhZ2XjgYxwdXNo44GV44KM44KL55u05YmN44Gr55m654Gr44GV44KM44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm5hdmlnYXRvclxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5jdXJyZW50UGFnZVxuICAgKiAgIFtlbl1DdXJyZW50IHBhZ2Ugb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBrnBhZ2Xjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dQ2FsbCB0aGlzIGZ1bmN0aW9uIHRvIGNhbmNlbCB0aGUgcHVzaC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlkbzjgbPlh7rjgZnjgajjgIFwdXNo5Yem55CG44GM44Kt44Oj44Oz44K744Or44GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVwb3BcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYmVmb3JlIGEgcGFnZSBpcyBwb3BwZWQuWy9lbl1cbiAgICogICBbamFdcGFnZeOBjHBvcOOBleOCjOOCi+ebtOWJjeOBq+eZuueBq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5uYXZpZ2F0b3JcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuY3VycmVudFBhZ2VcbiAgICogICBbZW5dQ3VycmVudCBwYWdlIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga5wYWdl44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUNhbGwgdGhpcyBmdW5jdGlvbiB0byBjYW5jZWwgdGhlIHBvcC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlkbzjgbPlh7rjgZnjgajjgIFwYWdl44GucG9w44GM44Kt44Oj44Oz44K744Or44GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0cHVzaFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBhZnRlciBhIHBhZ2UgaXMgcHVzaGVkLlsvZW5dXG4gICAqICAgW2phXXBhZ2XjgYxwdXNo44GV44KM44Gm44Ki44OL44Oh44O844K344On44Oz44GM57WC5LqG44GX44Gm44GL44KJ55m654Gr44GV44KM44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm5hdmlnYXRvclxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5lbnRlclBhZ2VcbiAgICogICBbZW5dT2JqZWN0IG9mIHRoZSBuZXh0IHBhZ2UuWy9lbl1cbiAgICogICBbamFdcHVzaOOBleOCjOOBn3BhZ2Xjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQubGVhdmVQYWdlXG4gICAqICAgW2VuXU9iamVjdCBvZiB0aGUgcHJldmlvdXMgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV3ku6XliY3jga5wYWdl44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0cG9wXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIGEgcGFnZSBpcyBwb3BwZWQuWy9lbl1cbiAgICogICBbamFdcGFnZeOBjHBvcOOBleOCjOOBpuOCouODi+ODoeODvOOCt+ODp+ODs+OBjOe1guOCj+OBo+OBn+W+jOOBq+eZuueBq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5uYXZpZ2F0b3JcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuZW50ZXJQYWdlXG4gICAqICAgW2VuXU9iamVjdCBvZiB0aGUgbmV4dCBwYWdlLlsvZW5dXG4gICAqICAgW2phXXBvcOOBleOCjOOBpuihqOekuuOBleOCjOOCi+ODmuODvOOCuOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5sZWF2ZVBhZ2VcbiAgICogICBbZW5dT2JqZWN0IG9mIHRoZSBwcmV2aW91cyBwYWdlLlsvZW5dXG4gICAqICAgW2phXXBvcOOBleOCjOOBpua2iOOBiOOCi+ODmuODvOOCuOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIGdldCBhbmltYXRvckZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FuaW1hdG9yRmFjdG9yeTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5faXNSdW5uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcGFnZUxvYWRlciA9IGRlZmF1bHRQYWdlTG9hZGVyO1xuXG4gICAgdGhpcy5fdXBkYXRlQW5pbWF0b3JGYWN0b3J5KCk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHBhZ2VMb2FkZXJcbiAgICogQHR5cGUge1BhZ2VMb2FkZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1bL2VuXVxuICAgKiAgIFtqYV1QYWdlTG9hZGVy44Kk44Oz44K544K/44Oz44K544KS5qC857SN44GX44Gm44GE44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBwYWdlTG9hZGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlTG9hZGVyO1xuICB9XG5cbiAgc2V0IHBhZ2VMb2FkZXIocGFnZUxvYWRlcikge1xuICAgIGlmICghKHBhZ2VMb2FkZXIgaW5zdGFuY2VvZiBQYWdlTG9hZGVyKSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0ZpcnN0IHBhcmFtZXRlciBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFBhZ2VMb2FkZXIuJyk7XG4gICAgfVxuICAgIHRoaXMuX3BhZ2VMb2FkZXIgPSBwYWdlTG9hZGVyO1xuICB9XG5cbiAgX2dldFBhZ2VUYXJnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2UgfHwgdGhpcy5nZXRBdHRyaWJ1dGUoJ3BhZ2UnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgcGFnZVxuICAgKiBAdHlwZSB7Kn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVsvZW5dXG4gICAqICAgW2phXeWIneacn+WMluaZguOBq+iqreOBv+i+vOOCgOODmuODvOOCuOOCkuaMh+WumuOBl+OBvuOBmeOAgmBwYWdlYOWxnuaAp+OBp+aMh+WumuOBl+OBn+WApOOCiOOCiuOCgmBwYWdlYOODl+ODreODkeODhuOCo+OBq+aMh+WumuOBl+OBn+WApOOCkuWEquWFiOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXQgcGFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZTtcbiAgfVxuXG4gIHNldCBwYWdlKHBhZ2UpIHtcbiAgICB0aGlzLl9wYWdlID0gcGFnZTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMub25EZXZpY2VCYWNrQnV0dG9uID0gdGhpcy5fb25EZXZpY2VCYWNrQnV0dG9uLmJpbmQodGhpcyk7XG5cblxuICAgIHJld3JpdGFibGVzLnJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnBhZ2VzLmxlbmd0aCA9PT0gMCAmJiB0aGlzLl9nZXRQYWdlVGFyZ2V0KCkpIHtcbiAgICAgICAgdGhpcy5wdXNoUGFnZSh0aGlzLl9nZXRQYWdlVGFyZ2V0KCksIHthbmltYXRpb246ICdub25lJ30pO1xuICAgICAgfSBpZiAodGhpcy5wYWdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICh0aGlzLnBhZ2VzW2ldLm5vZGVOYW1lICE9PSAnT05TLVBBR0UnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjaGlsZHJlbiBvZiA8b25zLW5hdmlnYXRvcj4gbmVlZCB0byBiZSBvZiB0eXBlIDxvbnMtcGFnZT4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy50b3BQYWdlKSB7XG4gICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudG9wUGFnZS5fc2hvdygpO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlTGFzdFBhZ2VCYWNrQnV0dG9uKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMucGFnZXMubGVuZ3RoID09PSAwICYmIHRoaXMuX2dldFBhZ2VUYXJnZXQoKSkge1xuICAgICAgICAgICAgdGhpcy5wdXNoUGFnZSh0aGlzLl9nZXRQYWdlVGFyZ2V0KCksIHthbmltYXRpb246ICdub25lJ30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBfdXBkYXRlQW5pbWF0b3JGYWN0b3J5KCkge1xuICAgIHRoaXMuX2FuaW1hdG9yRmFjdG9yeSA9IG5ldyBBbmltYXRvckZhY3Rvcnkoe1xuICAgICAgYW5pbWF0b3JzOiBfYW5pbWF0b3JEaWN0LFxuICAgICAgYmFzZUNsYXNzOiBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IsXG4gICAgICBiYXNlQ2xhc3NOYW1lOiAnTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yJyxcbiAgICAgIGRlZmF1bHRBbmltYXRpb246IHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24nKVxuICAgIH0pO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ2FuaW1hdGlvbiddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ2FuaW1hdGlvbicpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHBvcFBhZ2VcbiAgICogQHNpZ25hdHVyZSBwb3BQYWdlKFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXVxuICAgKiAgICAgQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJzbGlkZVwiYCwgYFwibGlmdFwiYCwgYFwiZmFkZVwiYCBhbmQgYFwibm9uZVwiYC5cbiAgICpcbiAgICogICAgIFRoZXNlIGFyZSBwbGF0Zm9ybSBiYXNlZCBhbmltYXRpb25zLiBGb3IgZml4ZWQgYW5pbWF0aW9ucywgYWRkIGBcIi1pb3NcImAgb3IgYFwiLW1kXCJgIHN1ZmZpeCB0byB0aGUgYW5pbWF0aW9uIG5hbWUuIEUuZy4gYFwibGlmdC1pb3NcImAsIGBcImxpZnQtbWRcImAuIERlZmF1bHRzIHZhbHVlcyBhcmUgYFwic2xpZGUtaW9zXCJgIGFuZCBgXCJmYWRlLW1kXCJgLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31bL2phXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJlZnJlc2hdXG4gICAqICAgW2VuXVRoZSBwcmV2aW91cyBwYWdlIHdpbGwgYmUgcmVmcmVzaGVkIChkZXN0cm95ZWQgYW5kIGNyZWF0ZWQgYWdhaW4pIGJlZm9yZSBwb3BQYWdlIGFjdGlvbi5bL2VuXVxuICAgKiAgIFtqYV1wb3BQYWdl44GZ44KL5YmN44Gr44CB5YmN44Gr44GC44KL44Oa44O844K444KS55Sf5oiQ44GX44Gq44GK44GX44Gm5pu05paw44GZ44KL5aC05ZCI44GrdHJ1ZeOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1GdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSB0cmFuc2l0aW9uIGhhcyBlbmRlZC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7jg6Hjgr3jg4Pjg4njgavjgojjgovnlLvpnaLpgbfnp7vjgYzntYLkuobjgZfjgZ/pmpvjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZGF0YV1cbiAgICogICBbZW5dQ3VzdG9tIGRhdGEgdGhhdCB3aWxsIGJlIHN0b3JlZCBpbiB0aGUgbmV3IHBhZ2UgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1Qcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSByZXZlYWxlZCBwYWdlLlsvZW5dXG4gICAqICAgW2phXeaYjuOCieOBi+OBq+OBl+OBn+ODmuODvOOCuOOCkuino+axuuOBmeOCi1Byb21pc2XjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUG9wcyB0aGUgY3VycmVudCBwYWdlIGZyb20gdGhlIHBhZ2Ugc3RhY2suIFRoZSBwcmV2aW91cyBwYWdlIHdpbGwgYmUgZGlzcGxheWVkLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOihqOekuuS4reOBruODmuODvOOCuOOCkuODmuODvOOCuOOCueOCv+ODg+OCr+OBi+OCieWPluOCiumZpOOBjeOBvuOBmeOAguS4gOOBpOWJjeOBruODmuODvOOCuOOBq+aIu+OCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuICBwb3BQYWdlKG9wdGlvbnMgPSB7fSkge1xuICAgICh7b3B0aW9uc30gPSB0aGlzLl9wcmVwYXJlUGFnZUFuZE9wdGlvbnMobnVsbCwgb3B0aW9ucykpO1xuXG4gICAgY29uc3QgcG9wVXBkYXRlID0gKCkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHRoaXMucGFnZXNbdGhpcy5wYWdlcy5sZW5ndGggLSAxXS5fZGVzdHJveSgpO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xuXG4gICAgaWYgKCFvcHRpb25zLnJlZnJlc2gpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wb3BQYWdlKG9wdGlvbnMsIHBvcFVwZGF0ZSk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnBhZ2VzLmxlbmd0aCAtIDI7XG4gICAgY29uc3Qgb2xkUGFnZSA9IHRoaXMucGFnZXNbaW5kZXhdO1xuXG4gICAgaWYgKCFvbGRQYWdlLm5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVmcmVzaCBvcHRpb24gY2Fubm90IGJlIHVzZWQgd2l0aCBwYWdlcyBkaXJlY3RseSBpbnNpZGUgdGhlIE5hdmlnYXRvci4gVXNlIG9ucy10ZW1wbGF0ZSBpbnN0ZWFkLicpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7cGFnZTogb2xkUGFnZS5uYW1lLCBwYXJlbnQ6IHRoaXMsIHBhcmFtczogb2xkUGFnZS5wdXNoZWRPcHRpb25zLmRhdGF9O1xuICAgICAgdGhpcy5fcGFnZUxvYWRlci5sb2FkKG9wdGlvbnMsICh7ZWxlbWVudCwgdW5sb2FkfSkgPT4ge1xuICAgICAgICBlbGVtZW50ID0gdXRpbC5leHRlbmQoZWxlbWVudCwge1xuICAgICAgICAgIG5hbWU6IG9sZFBhZ2UubmFtZSxcbiAgICAgICAgICBkYXRhOiBvbGRQYWdlLmRhdGEsXG4gICAgICAgICAgcHVzaGVkT3B0aW9uczogb2xkUGFnZS5wdXNoZWRPcHRpb25zLFxuICAgICAgICAgIHVubG9hZFxuICAgICAgICB9KTtcblxuICAgICAgICByZXdyaXRhYmxlcy5saW5rKHRoaXMsIGVsZW1lbnQsIG9sZFBhZ2Uub3B0aW9ucywgZWxlbWVudCA9PiB7XG4gICAgICAgICAgdGhpcy5pbnNlcnRCZWZvcmUoZWxlbWVudCwgb2xkUGFnZSA/IG9sZFBhZ2UgOiBudWxsKTtcbiAgICAgICAgICBvbGRQYWdlLl9kZXN0cm95KCk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgfSkudGhlbigoKSA9PiB0aGlzLl9wb3BQYWdlKG9wdGlvbnMsIHBvcFVwZGF0ZSkpO1xuICB9XG5cbiAgX3BvcFBhZ2Uob3B0aW9ucywgdXBkYXRlID0gKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCkpIHtcbiAgICBpZiAodGhpcy5faXNSdW5uaW5nKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ3BvcFBhZ2UgaXMgYWxyZWFkeSBydW5uaW5nLicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBhZ2VzLmxlbmd0aCA8PSAxKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ29ucy1uYXZpZ2F0b3JcXCdzIHBhZ2Ugc3RhY2sgaXMgZW1wdHkuJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2VtaXRQcmVQb3BFdmVudCgpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0NhbmNlbGVkIGluIHByZXBvcCBldmVudC4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBsZW5ndGggPSB0aGlzLnBhZ2VzLmxlbmd0aDtcblxuICAgIHRoaXMuX2lzUnVubmluZyA9IHRydWU7XG5cbiAgICB0aGlzLnBhZ2VzW2xlbmd0aCAtIDJdLnVwZGF0ZUJhY2tCdXR0b24oKGxlbmd0aCAtIDIpID4gMCk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICB2YXIgbGVhdmVQYWdlID0gdGhpcy5wYWdlc1tsZW5ndGggLSAxXTtcbiAgICAgIHZhciBlbnRlclBhZ2UgPSB0aGlzLnBhZ2VzW2xlbmd0aCAtIDJdO1xuICAgICAgZW50ZXJQYWdlLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXG4gICAgICBvcHRpb25zLmFuaW1hdGlvbiA9IG9wdGlvbnMuYW5pbWF0aW9uIHx8IGxlYXZlUGFnZS5wdXNoZWRPcHRpb25zLmFuaW1hdGlvbjtcbiAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyA9IHV0aWwuZXh0ZW5kKFxuICAgICAgICB7fSxcbiAgICAgICAgbGVhdmVQYWdlLnB1c2hlZE9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyxcbiAgICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9XG4gICAgICApO1xuXG4gICAgICBpZiAob3B0aW9ucy5kYXRhKSB7XG4gICAgICAgIGVudGVyUGFnZS5kYXRhID0gdXRpbC5leHRlbmQoe30sIGVudGVyUGFnZS5kYXRhIHx8IHt9LCBvcHRpb25zLmRhdGEgfHwge30pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgdXBkYXRlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgdGhpcy5faXNSdW5uaW5nID0gZmFsc2U7XG5cbiAgICAgICAgICBlbnRlclBhZ2UuX3Nob3coKTtcbiAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3Bvc3Rwb3AnLCB7bGVhdmVQYWdlLCBlbnRlclBhZ2UsIG5hdmlnYXRvcjogdGhpc30pO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzb2x2ZShlbnRlclBhZ2UpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGxlYXZlUGFnZS5faGlkZSgpO1xuICAgICAgY29uc3QgYW5pbWF0b3IgPSB0aGlzLl9hbmltYXRvckZhY3RvcnkubmV3QW5pbWF0b3Iob3B0aW9ucyk7XG4gICAgICBhbmltYXRvci5wb3AodGhpcy5wYWdlc1tsZW5ndGggLSAyXSwgdGhpcy5wYWdlc1tsZW5ndGggLSAxXSwgY2FsbGJhY2spO1xuICAgIH0pLmNhdGNoKCgpID0+IHRoaXMuX2lzUnVubmluZyA9IGZhbHNlKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcHVzaFBhZ2VcbiAgICogQHNpZ25hdHVyZSBwdXNoUGFnZShwYWdlLCBbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gICAqICAgW2VuXVBhZ2UgVVJMLiBDYW4gYmUgZWl0aGVyIGEgSFRNTCBkb2N1bWVudCBvciBhIHRlbXBsYXRlIGRlZmluZWQgd2l0aCB0aGUgYDxvbnMtdGVtcGxhdGU+YCB0YWcuWy9lbl1cbiAgICogICBbamFdcGFnZeOBrlVSTOOBi+OAgeOCguOBl+OBj+OBr29ucy10ZW1wbGF0ZeOBp+Wuo+iogOOBl+OBn+ODhuODs+ODl+ODrOODvOODiOOBrmlk5bGe5oCn44Gu5YCk44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYWdlXVxuICAgKiAgIFtlbl1QYWdlIFVSTC4gT25seSBuZWNlc3NhcnkgaWYgYHBhZ2VgIHBhcmFtZXRlciBpcyBudWxsIG9yIHVuZGVmaW5lZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGFnZUhUTUxdXG4gICAqICAgW2VuXUhUTUwgY29kZSB0aGF0IHdpbGwgYmUgY29tcHV0ZWQgYXMgYSBuZXcgcGFnZS4gT3ZlcndyaXRlcyBgcGFnZWAgcGFyYW1ldGVyLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXVxuICAgKiAgICAgQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJzbGlkZVwiYCwgYFwibGlmdFwiYCwgYFwiZmFkZVwiYCBhbmQgYFwibm9uZVwiYC5cbiAgICpcbiAgICogICAgIFRoZXNlIGFyZSBwbGF0Zm9ybSBiYXNlZCBhbmltYXRpb25zLiBGb3IgZml4ZWQgYW5pbWF0aW9ucywgYWRkIGBcIi1pb3NcImAgb3IgYFwiLW1kXCJgIHN1ZmZpeCB0byB0aGUgYW5pbWF0aW9uIG5hbWUuIEUuZy4gYFwibGlmdC1pb3NcImAsIGBcImxpZnQtbWRcImAuIERlZmF1bHRzIHZhbHVlcyBhcmUgYFwic2xpZGUtaW9zXCJgIGFuZCBgXCJmYWRlLW1kXCJgLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWBbL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gIFsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1GdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSB0cmFuc2l0aW9uIGhhcyBlbmRlZC5bL2VuXVxuICAgKiAgIFtqYV1wdXNoUGFnZSgp44Gr44KI44KL55S76Z2i6YG356e744GM57WC5LqG44GX44Gf5pmC44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmRhdGFdXG4gICAqICAgW2VuXUN1c3RvbSBkYXRhIHRoYXQgd2lsbCBiZSBzdG9yZWQgaW4gdGhlIG5ldyBwYWdlIGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgcHVzaGVkIHBhZ2UuWy9lbl1cbiAgICogICBbamFd6L+95Yqg44GX44Gf44Oa44O844K444KS6Kej5rG644GZ44KLUHJvbWlzZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1QdXNoZXMgdGhlIHNwZWNpZmllZCBwYWdlIGludG8gdGhlIHN0YWNrLlsvZW5dXG4gICAqICAgW2phXeaMh+WumuOBl+OBn3BhZ2XjgpLmlrDjgZfjgYTjg5rjg7zjgrjjgrnjgr/jg4Pjgq/jgavov73liqDjgZfjgb7jgZnjgILmlrDjgZfjgYTjg5rjg7zjgrjjgYzooajnpLrjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgcHVzaFBhZ2UocGFnZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgKHtwYWdlLCBvcHRpb25zfSA9IHRoaXMuX3ByZXBhcmVQYWdlQW5kT3B0aW9ucyhwYWdlLCBvcHRpb25zKSk7XG5cbiAgICBjb25zdCBwcmVwYXJlID0gKGVsZW1lbnQsIHVubG9hZCkgPT4ge1xuICAgICAgdGhpcy5fdmVyaWZ5UGFnZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICBlbGVtZW50ID0gdXRpbC5leHRlbmQoZWxlbWVudCwge1xuICAgICAgICBuYW1lOiBvcHRpb25zLnBhZ2UsXG4gICAgICAgIGRhdGE6IG9wdGlvbnMuZGF0YSxcbiAgICAgICAgdW5sb2FkXG4gICAgICB9KTtcbiAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9O1xuXG4gICAgaWYgKG9wdGlvbnMucGFnZUhUTUwpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wdXNoUGFnZShvcHRpb25zLCAoKSA9PiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgaW5zdGFudFBhZ2VMb2FkZXIubG9hZCh7cGFnZTogb3B0aW9ucy5wYWdlSFRNTCwgcGFyZW50OiB0aGlzLCBwYXJhbXM6IG9wdGlvbnMuZGF0YX0sICh7ZWxlbWVudCwgdW5sb2FkfSkgPT4ge1xuICAgICAgICAgIHByZXBhcmUoZWxlbWVudCwgdW5sb2FkKTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9wdXNoUGFnZShvcHRpb25zLCAoKSA9PiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHRoaXMuX3BhZ2VMb2FkZXIubG9hZCh7cGFnZSwgcGFyZW50OiB0aGlzLCBwYXJhbXM6IG9wdGlvbnMuZGF0YX0sICh7ZWxlbWVudCwgdW5sb2FkfSkgPT4ge1xuICAgICAgICBwcmVwYXJlKGVsZW1lbnQsIHVubG9hZCk7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0pO1xuICAgIH0pKTtcbiAgfVxuXG4gIF9wdXNoUGFnZShvcHRpb25zID0ge30sIHVwZGF0ZSA9ICgpID0+IFByb21pc2UucmVzb2x2ZSgpKSB7XG4gICAgaWYgKHRoaXMuX2lzUnVubmluZykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdwdXNoUGFnZSBpcyBhbHJlYWR5IHJ1bm5pbmcuJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2VtaXRQcmVQdXNoRXZlbnQoKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYW5jZWxlZCBpbiBwcmVwdXNoIGV2ZW50LicpO1xuICAgIH1cblxuICAgIHRoaXMuX2lzUnVubmluZyA9IHRydWU7XG5cbiAgICBjb25zdCBhbmltYXRpb25PcHRpb25zID0gQW5pbWF0b3JGYWN0b3J5LnBhcnNlQW5pbWF0aW9uT3B0aW9uc1N0cmluZyh0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uLW9wdGlvbnMnKSk7XG4gICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMgfHwge30sIHthbmltYXRpb25PcHRpb25zfSwgb3B0aW9ucyk7XG5cbiAgICBjb25zdCBhbmltYXRvciA9IHRoaXMuX2FuaW1hdG9yRmFjdG9yeS5uZXdBbmltYXRvcihvcHRpb25zKTtcblxuICAgIHJldHVybiB1cGRhdGUoKS50aGVuKCgpID0+IHtcbiAgICAgIGNvbnN0IHBhZ2VMZW5ndGggPSB0aGlzLnBhZ2VzLmxlbmd0aDtcblxuICAgICAgdmFyIGVudGVyUGFnZSAgPSB0aGlzLnBhZ2VzW3BhZ2VMZW5ndGggLSAxXTtcbiAgICAgIHZhciBsZWF2ZVBhZ2UgPSB0aGlzLnBhZ2VzW3BhZ2VMZW5ndGggLSAyXTtcblxuICAgICAgaWYgKGVudGVyUGFnZS5ub2RlTmFtZSAhPT0gJ09OUy1QQUdFJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgZWxlbWVudHMgb2YgdHlwZSA8b25zLXBhZ2U+IGNhbiBiZSBwdXNoZWQgdG8gdGhlIG5hdmlnYXRvcicpO1xuICAgICAgfVxuXG4gICAgICBlbnRlclBhZ2UudXBkYXRlQmFja0J1dHRvbihwYWdlTGVuZ3RoIC0gMSk7XG5cbiAgICAgIGVudGVyUGFnZS5wdXNoZWRPcHRpb25zID0gdXRpbC5leHRlbmQoe30sIGVudGVyUGFnZS5wdXNoZWRPcHRpb25zIHx8IHt9LCBvcHRpb25zIHx8IHt9KTtcbiAgICAgIGVudGVyUGFnZS5kYXRhID0gdXRpbC5leHRlbmQoe30sIGVudGVyUGFnZS5kYXRhIHx8IHt9LCBvcHRpb25zLmRhdGEgfHwge30pO1xuICAgICAgZW50ZXJQYWdlLm5hbWUgPSBlbnRlclBhZ2UubmFtZSB8fCBvcHRpb25zLnBhZ2U7XG4gICAgICBlbnRlclBhZ2UudW5sb2FkID0gZW50ZXJQYWdlLnVubG9hZCB8fCBvcHRpb25zLnVubG9hZDtcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICB2YXIgZG9uZSA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLl9pc1J1bm5pbmcgPSBmYWxzZTtcblxuICAgICAgICAgIGlmIChsZWF2ZVBhZ2UpIHtcbiAgICAgICAgICAgIGxlYXZlUGFnZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiBlbnRlclBhZ2UuX3Nob3coKSk7XG4gICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwb3N0cHVzaCcsIHtsZWF2ZVBhZ2UsIGVudGVyUGFnZSwgbmF2aWdhdG9yOiB0aGlzfSk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2soKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXNvbHZlKGVudGVyUGFnZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZW50ZXJQYWdlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgICAgdmFyIHB1c2ggPSAoKSA9PiAge1xuICAgICAgICAgIGVudGVyUGFnZS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICBpZiAobGVhdmVQYWdlKSB7XG4gICAgICAgICAgICBsZWF2ZVBhZ2UuX2hpZGUoKTtcbiAgICAgICAgICAgIGFuaW1hdG9yLnB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGRvbmUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIG9wdGlvbnMuX2xpbmtlZCA/IHB1c2goKSA6IHJld3JpdGFibGVzLmxpbmsodGhpcywgZW50ZXJQYWdlLCBvcHRpb25zLCBwdXNoKTtcbiAgICAgIH0pO1xuICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgdGhpcy5faXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHJlcGxhY2VQYWdlXG4gICAqIEBzaWduYXR1cmUgcmVwbGFjZVBhZ2UocGFnZSwgW29wdGlvbnNdKVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1Qcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBuZXcgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV3mlrDjgZfjgYTjg5rjg7zjgrjjgpLop6PmsbrjgZnjgotQcm9taXNl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJlcGxhY2VzIHRoZSBjdXJyZW50IHRvcCBwYWdlIHdpdGggdGhlIHNwZWNpZmllZCBvbmUuIEV4dGVuZHMgYHB1c2hQYWdlKClgIHBhcmFtZXRlcnMuWy9lbl1cbiAgICogICBbamFd54++5Zyo6KGo56S65Lit44Gu44Oa44O844K444KS44KS5oyH5a6a44GX44Gf44Oa44O844K444Gr572u44GN5o+b44GI44G+44GZ44CCWy9qYV1cbiAgICovXG4gIHJlcGxhY2VQYWdlKHBhZ2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLnB1c2hQYWdlKHBhZ2UsIG9wdGlvbnMpXG4gICAgICAudGhlbihyZXNvbHZlZFZhbHVlID0+IHtcbiAgICAgICAgaWYgKHRoaXMucGFnZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHRoaXMucGFnZXNbdGhpcy5wYWdlcy5sZW5ndGggLSAyXS5fZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VwZGF0ZUxhc3RQYWdlQmFja0J1dHRvbigpO1xuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzb2x2ZWRWYWx1ZSk7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGluc2VydFBhZ2VcbiAgICogQHNpZ25hdHVyZSBpbnNlcnRQYWdlKGluZGV4LCBwYWdlLCBbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiAgIFtlbl1UaGUgaW5kZXggd2hlcmUgaXQgc2hvdWxkIGJlIGluc2VydGVkLlsvZW5dXG4gICAqICAgW2phXeOCueOCv+ODg+OCr+OBq+aMv+WFpeOBmeOCi+S9jee9ruOBruOCpOODs+ODh+ODg+OCr+OCueOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIGluc2VydGVkIHBhZ2UuWy9lbl1cbiAgICogICBbamFd5oyH5a6a44GX44Gf44Oa44O844K444KS6Kej5rG644GZ44KLUHJvbWlzZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JbnNlcnQgdGhlIHNwZWNpZmllZCBwYWdlIGludG8gdGhlIHN0YWNrIHdpdGggYXQgYSBwb3NpdGlvbiBkZWZpbmVkIGJ5IHRoZSBgaW5kZXhgIGFyZ3VtZW50LiBFeHRlbmRzIGBwdXNoUGFnZSgpYCBwYXJhbWV0ZXJzLlsvZW5dXG4gICAqICAgW2phXeaMh+WumuOBl+OBn3BhZ2XjgpLjg5rjg7zjgrjjgrnjgr/jg4Pjgq/jga5pbmRleOOBp+aMh+WumuOBl+OBn+S9jee9ruOBq+i/veWKoOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBpbnNlcnRQYWdlKGluZGV4LCBwYWdlLCBvcHRpb25zID0ge30pIHtcbiAgICAoe3BhZ2UsIG9wdGlvbnN9ID0gdGhpcy5fcHJlcGFyZVBhZ2VBbmRPcHRpb25zKHBhZ2UsIG9wdGlvbnMpKTtcbiAgICBpbmRleCA9IHRoaXMuX25vcm1hbGl6ZUluZGV4KGluZGV4KTtcblxuICAgIGlmIChpbmRleCA+PSB0aGlzLnBhZ2VzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMucHVzaFBhZ2UocGFnZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcGFnZSA9IHR5cGVvZiBvcHRpb25zLnBhZ2VIVE1MID09PSAnc3RyaW5nJyA/IG9wdGlvbnMucGFnZUhUTUwgOiBwYWdlO1xuICAgIGNvbnN0IGxvYWRlciA9IHR5cGVvZiBvcHRpb25zLnBhZ2VIVE1MID09PSAnc3RyaW5nJyA/IGluc3RhbnRQYWdlTG9hZGVyIDogdGhpcy5fcGFnZUxvYWRlcjtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGxvYWRlci5sb2FkKHtwYWdlLCBwYXJlbnQ6IHRoaXN9LCAoe2VsZW1lbnQsIHVubG9hZH0pID0+IHtcbiAgICAgICAgdGhpcy5fdmVyaWZ5UGFnZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgIGVsZW1lbnQgPSB1dGlsLmV4dGVuZChlbGVtZW50LCB7XG4gICAgICAgICAgbmFtZTogb3B0aW9ucy5wYWdlLFxuICAgICAgICAgIGRhdGE6IG9wdGlvbnMuZGF0YSxcbiAgICAgICAgICBwdXNoZWRPcHRpb25zOiBvcHRpb25zLFxuICAgICAgICAgIHVubG9hZFxuICAgICAgICB9KTtcblxuICAgICAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgPSB1dGlsLmV4dGVuZChcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBBbmltYXRvckZhY3RvcnkucGFyc2VBbmltYXRpb25PcHRpb25zU3RyaW5nKHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpKSxcbiAgICAgICAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgfHwge31cbiAgICAgICAgKTtcblxuICAgICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsIHRoaXMucGFnZXNbaW5kZXhdKTtcbiAgICAgICAgdGhpcy50b3BQYWdlLnVwZGF0ZUJhY2tCdXR0b24odHJ1ZSk7XG5cbiAgICAgICAgcmV3cml0YWJsZXMubGluayh0aGlzLCBlbGVtZW50LCBvcHRpb25zLCBlbGVtZW50ID0+IHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnBhZ2VzW2luZGV4XSk7XG4gICAgICAgICAgfSwgMTAwMCAvIDYwKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHJlc2V0VG9QYWdlXG4gICAqIEBzaWduYXR1cmUgcmVzZXRUb1BhZ2UocGFnZSwgW29wdGlvbnNdKVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1Qcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBuZXcgdG9wIHBhZ2UuWy9lbl1cbiAgICogICBbamFd5paw44GX44GE44OI44OD44OX44Oa44O844K444KS6Kej5rG644GZ44KLUHJvbWlzZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DbGVhcnMgcGFnZSBzdGFjayBhbmQgYWRkcyB0aGUgc3BlY2lmaWVkIHBhZ2UgdG8gdGhlIHN0YWNrLiBFeHRlbmRzIGBwdXNoUGFnZSgpYCBwYXJhbWV0ZXJzLlsvZW5dXG4gICAqICAgW2phXeODmuODvOOCuOOCueOCv+ODg+OCr+OCkuODquOCu+ODg+ODiOOBl+OAgeaMh+WumuOBl+OBn+ODmuODvOOCuOOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICByZXNldFRvUGFnZShwYWdlLCBvcHRpb25zID0ge30pIHtcbiAgICAoe3BhZ2UsIG9wdGlvbnN9ID0gdGhpcy5fcHJlcGFyZVBhZ2VBbmRPcHRpb25zKHBhZ2UsIG9wdGlvbnMpKTtcblxuICAgIGlmICghb3B0aW9ucy5hbmltYXRvciAmJiAhb3B0aW9ucy5hbmltYXRpb24pIHtcbiAgICAgIG9wdGlvbnMuYW5pbWF0aW9uID0gJ25vbmUnO1xuICAgIH1cblxuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcblxuICAgIG9wdGlvbnMuY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICB3aGlsZSAodGhpcy5wYWdlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRoaXMucGFnZXNbMF0uX2Rlc3Ryb3koKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wYWdlc1swXS51cGRhdGVCYWNrQnV0dG9uKGZhbHNlKTtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgfTtcblxuICAgIGlmICghb3B0aW9ucy5wYWdlICYmICFvcHRpb25zLnBhZ2VIVE1MICYmIHRoaXMuX2dldFBhZ2VUYXJnZXQoKSkge1xuICAgICAgcGFnZSA9IG9wdGlvbnMucGFnZSA9IHRoaXMuX2dldFBhZ2VUYXJnZXQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wdXNoUGFnZShwYWdlLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGJyaW5nUGFnZVRvcFxuICAgKiBAc2lnbmF0dXJlIGJyaW5nUGFnZVRvcChpdGVtLCBbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gaXRlbVxuICAgKiAgIFtlbl1QYWdlIFVSTCBvciBpbmRleCBvZiBhbiBleGlzdGluZyBwYWdlIGluIG5hdmlnYXRvcidzIHN0YWNrLlsvZW5dXG4gICAqICAgW2phXeODmuODvOOCuOOBrlVSTOOBi+OCguOBl+OBj+OBr29ucy1uYXZpZ2F0b3Ljga7jg5rjg7zjgrjjgrnjgr/jg4Pjgq/jga7jgqTjg7Pjg4fjg4Pjgq/jgrnlgKTjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1Qcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBuZXcgdG9wIHBhZ2UuWy9lbl1cbiAgICogICBbamFd5paw44GX44GE44OI44OD44OX44Oa44O844K444KS6Kej5rG644GZ44KLUHJvbWlzZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1CcmluZ3MgdGhlIGdpdmVuIHBhZ2UgdG8gdGhlIHRvcCBvZiB0aGUgcGFnZSBzdGFjayBpZiBpdCBhbHJlYWR5IGV4aXN0cyBvciBwdXNoZXMgaXQgaW50byB0aGUgc3RhY2sgaWYgZG9lc24ndC4gRXh0ZW5kcyBgcHVzaFBhZ2UoKWAgcGFyYW1ldGVycy5bL2VuXVxuICAgKiAgIFtqYV3mjIflrprjgZfjgZ/jg5rjg7zjgrjjgpLjg5rjg7zjgrjjgrnjgr/jg4Pjgq/jga7kuIDnlarkuIrjgavnp7vli5XjgZfjgb7jgZnjgILjgoLjgZfmjIflrprjgZfjgZ/jg5rjg7zjgrjjgYznhKHjgYvjgaPjgZ/loLTlkIjmlrDjgZfjgY9wdXNo44GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGJyaW5nUGFnZVRvcChpdGVtLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoWydudW1iZXInLCAnc3RyaW5nJ10uaW5kZXhPZih0eXBlb2YgaXRlbSkgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBwYWdlIG5hbWUgb3IgdGhlIGluZGV4IG9mIGFuIGV4aXN0aW5nIHBhZ2UuIFlvdSBzdXBwbGllZCAnICsgaXRlbSk7XG4gICAgfVxuICAgIGNvbnN0IGluZGV4ID0gdHlwZW9mIGl0ZW0gPT09ICdudW1iZXInID8gdGhpcy5fbm9ybWFsaXplSW5kZXgoaXRlbSkgOiB0aGlzLl9sYXN0SW5kZXhPZlBhZ2UoaXRlbSk7XG4gICAgY29uc3QgcGFnZSA9IHRoaXMucGFnZXNbaW5kZXhdO1xuXG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuIHRoaXMucHVzaFBhZ2UoaXRlbSwgb3B0aW9ucyk7XG4gICAgfVxuICAgICh7b3B0aW9uc30gPSB0aGlzLl9wcmVwYXJlUGFnZUFuZE9wdGlvbnMocGFnZSwgb3B0aW9ucykpO1xuXG4gICAgaWYgKGluZGV4ID09PSB0aGlzLnBhZ2VzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocGFnZSk7XG4gICAgfVxuICAgIGlmICghcGFnZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmluZCBpdGVtICcgKyBpdGVtKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2lzUnVubmluZykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdwdXNoUGFnZSBpcyBhbHJlYWR5IHJ1bm5pbmcuJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9lbWl0UHJlUHVzaEV2ZW50KCkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnQ2FuY2VsZWQgaW4gcHJlcHVzaCBldmVudC4nKTtcbiAgICB9XG5cbiAgICB1dGlsLmV4dGVuZChvcHRpb25zLCB7XG4gICAgICBwYWdlOiBwYWdlLm5hbWUsXG4gICAgICBfbGlua2VkOiB0cnVlXG4gICAgfSk7XG4gICAgcGFnZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIHBhZ2Uuc2V0QXR0cmlidXRlKCdfc2tpcGluaXQnLCAnJyk7XG4gICAgcGFnZS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHBhZ2UpO1xuICAgIHJldHVybiB0aGlzLl9wdXNoUGFnZShvcHRpb25zKTtcbiAgfVxuXG4gIF9wcmVwYXJlUGFnZUFuZE9wdGlvbnMocGFnZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QuIFlvdSBzdXBwbGllZCAnICsgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKChwYWdlID09PSBudWxsIHx8IHBhZ2UgPT09IHVuZGVmaW5lZCkgJiYgb3B0aW9ucy5wYWdlKSB7XG4gICAgICBwYWdlID0gb3B0aW9ucy5wYWdlO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zIHx8IHt9LCBvcHRpb25zLCB7cGFnZX0pO1xuXG4gICAgcmV0dXJuIHtwYWdlLCBvcHRpb25zfTtcbiAgfVxuXG4gIF91cGRhdGVMYXN0UGFnZUJhY2tCdXR0b24oKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnBhZ2VzLmxlbmd0aCAtIDE7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHRoaXMucGFnZXNbaW5kZXhdLnVwZGF0ZUJhY2tCdXR0b24oaW5kZXggPiAwKTtcbiAgICB9XG4gIH1cblxuICBfbm9ybWFsaXplSW5kZXgoaW5kZXgpIHtcbiAgICByZXR1cm4gaW5kZXggPj0gMCA/IGluZGV4IDogTWF0aC5hYnModGhpcy5wYWdlcy5sZW5ndGggKyBpbmRleCkgJSB0aGlzLnBhZ2VzLmxlbmd0aDtcbiAgfVxuXG4gIF9vbkRldmljZUJhY2tCdXR0b24oZXZlbnQpIHtcbiAgICBpZiAodGhpcy5wYWdlcy5sZW5ndGggPiAxKSB7XG4gICAgICB0aGlzLnBvcFBhZ2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnQuY2FsbFBhcmVudEhhbmRsZXIoKTtcbiAgICB9XG4gIH1cblxuICBfbGFzdEluZGV4T2ZQYWdlKHBhZ2VOYW1lKSB7XG4gICAgbGV0IGluZGV4O1xuICAgIGZvciAoaW5kZXggPSB0aGlzLnBhZ2VzLmxlbmd0aCAtIDE7IGluZGV4ID49IDA7IGluZGV4LS0pIHtcbiAgICAgIGlmICh0aGlzLnBhZ2VzW2luZGV4XS5uYW1lID09PSBwYWdlTmFtZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgX2VtaXRQcmVFdmVudChuYW1lLCBkYXRhID0ge30pIHtcbiAgICBsZXQgaXNDYW5jZWxlZCA9IGZhbHNlO1xuXG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwcmUnICsgbmFtZSwgdXRpbC5leHRlbmQoe1xuICAgICAgbmF2aWdhdG9yOiB0aGlzLFxuICAgICAgY3VycmVudFBhZ2U6IHRoaXMucGFnZXNbdGhpcy5wYWdlcy5sZW5ndGggLSAxXSxcbiAgICAgIGNhbmNlbDogKCkgPT4gaXNDYW5jZWxlZCA9IHRydWVcbiAgICB9LCBkYXRhKSk7XG5cbiAgICByZXR1cm4gaXNDYW5jZWxlZDtcbiAgfVxuXG4gIF9lbWl0UHJlUHVzaEV2ZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9lbWl0UHJlRXZlbnQoJ3B1c2gnKTtcbiAgfVxuXG4gIF9lbWl0UHJlUG9wRXZlbnQoKSB7XG4gICAgY29uc3QgbCA9IHRoaXMucGFnZXMubGVuZ3RoO1xuICAgIHJldHVybiB0aGlzLl9lbWl0UHJlRXZlbnQoJ3BvcCcsIHtcbiAgICAgIGxlYXZlUGFnZTogdGhpcy5wYWdlc1tsIC0gMV0sXG4gICAgICBlbnRlclBhZ2U6IHRoaXMucGFnZXNbbCAtIDJdXG4gICAgfSk7XG4gIH1cblxuICAvLyBUT0RPOiDmm7jjgY3nm7TjgZlcbiAgX2NyZWF0ZVBhZ2VFbGVtZW50KHRlbXBsYXRlSFRNTCkge1xuICAgIGNvbnN0IHBhZ2VFbGVtZW50ID0gdXRpbC5jcmVhdGVFbGVtZW50KGludGVybmFsLm5vcm1hbGl6ZVBhZ2VIVE1MKHRlbXBsYXRlSFRNTCkpO1xuICAgIHRoaXMuX3ZlcmlmeVBhZ2VFbGVtZW50KHBhZ2VFbGVtZW50KTtcbiAgICByZXR1cm4gcGFnZUVsZW1lbnQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAqL1xuICBfdmVyaWZ5UGFnZUVsZW1lbnQoZWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdvbnMtcGFnZScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3Qgc3VwcGx5IGFuIFwib25zLXBhZ2VcIiBlbGVtZW50IHRvIFwib25zLW5hdmlnYXRvclwiLicpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25EZXZpY2VCYWNrQnV0dG9uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1CYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAqICAgW2phXeODkOODg+OCr+ODnOOCv+ODs+ODj+ODs+ODieODqeOAglsvamFdXG4gICAqL1xuICBnZXQgb25EZXZpY2VCYWNrQnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcjtcbiAgfVxuXG4gIHNldCBvbkRldmljZUJhY2tCdXR0b24oY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5fYmFja0J1dHRvbkhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyLmNyZWF0ZUhhbmRsZXIodGhpcywgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB0b3BQYWdlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DdXJyZW50IHRvcCBwYWdlIGVsZW1lbnQuIFVzZSB0aGlzIG1ldGhvZCB0byBhY2Nlc3Mgb3B0aW9ucyBwYXNzZWQgYnkgYHB1c2hQYWdlKClgLWxpa2UgbWV0aG9kcy5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7jg5rjg7zjgrjjgpLlj5blvpfjgZfjgb7jgZnjgIJwdXNoUGFnZSgp44KEcmVzZXRUb1BhZ2UoKeODoeOCveODg+ODieOBruW8leaVsOOCkuWPluW+l+OBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXQgdG9wUGFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYWdlc1t0aGlzLnBhZ2VzLmxlbmd0aCAtIDFdIHx8IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHBhZ2VzXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7QXJyYXl9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Db3B5IG9mIHRoZSBuYXZpZ2F0b3IncyBwYWdlIHN0YWNrLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgcGFnZXMoKSB7XG4gICAgcmV0dXJuIHV0aWxcbiAgICAgIC5hcnJheUZyb20odGhpcy5jaGlsZHJlbilcbiAgICAgIC5maWx0ZXIobiA9PiBuLnRhZ05hbWUgPT09ICdPTlMtUEFHRScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvcHRpb25zXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1EZWZhdWx0IG9wdGlvbnMgb2JqZWN0LiBBdHRyaWJ1dGVzIGhhdmUgcHJpb3JpdHkgb3ZlciB0aGlzIHByb3BlcnR5LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb3B0aW9ucy5hbmltYXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVxuICAgKiAgICAgQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJzbGlkZVwiYCwgYFwibGlmdFwiYCwgYFwiZmFkZVwiYCBhbmQgYFwibm9uZVwiYC5cbiAgICogICAgIFRoZXNlIGFyZSBwbGF0Zm9ybSBiYXNlZCBhbmltYXRpb25zLiBGb3IgZml4ZWQgYW5pbWF0aW9ucywgYWRkIGBcIi1pb3NcImAgb3IgYFwiLW1kXCJgIHN1ZmZpeCB0byB0aGUgYW5pbWF0aW9uIG5hbWUuIEUuZy4gYFwibGlmdC1pb3NcImAsIGBcImxpZnQtbWRcImAuIERlZmF1bHRzIHZhbHVlcyBhcmUgYFwic2xpZGUtaW9zXCJgIGFuZCBgXCJmYWRlLW1kXCJgLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YCBbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnMuY2FsbGJhY2tcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIHRyYW5zaXRpb24gaGFzIGVuZGVkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruODoeOCveODg+ODieOBq+OCiOOCi+eUu+mdoumBt+enu+OBjOe1guS6huOBl+OBn+mam+OBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb3B0aW9ucy5yZWZyZXNoXG4gICAqIEBkZWZhdWx0ICBmYWxzZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgcGFyYW1ldGVyIGlzIGB0cnVlYCwgdGhlIHByZXZpb3VzIHBhZ2Ugd2lsbCBiZSByZWZyZXNoZWQgKGRlc3Ryb3llZCBhbmQgY3JlYXRlZCBhZ2FpbikgYmVmb3JlIGBwb3BQYWdlKClgIGFjdGlvbi5bL2VuXVxuICAgKiAgIFtqYV1wb3BQYWdl44GZ44KL5YmN44Gr44CB5YmN44Gr44GC44KL44Oa44O844K444KS55Sf5oiQ44GX44Gq44GK44GX44Gm5pu05paw44GZ44KL5aC05ZCI44GrdHJ1ZeOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgfVxuICBzZXQgb3B0aW9ucyhvYmplY3QpIHtcbiAgICB0aGlzLl9vcHRpb25zID0gb2JqZWN0O1xuICB9XG5cbiAgc2V0IF9pc1J1bm5pbmcodmFsdWUpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnX2lzLXJ1bm5pbmcnLCB2YWx1ZSA/ICd0cnVlJyA6ICdmYWxzZScpO1xuICB9XG4gIGdldCBfaXNSdW5uaW5nKCkge1xuICAgcmV0dXJuIEpTT04ucGFyc2UodGhpcy5nZXRBdHRyaWJ1dGUoJ19pcy1ydW5uaW5nJykpO1xuICB9XG5cbiAgX3Nob3coKSB7XG4gICAgaWYgKHRoaXMudG9wUGFnZSkge1xuICAgICAgdGhpcy50b3BQYWdlLl9zaG93KCk7XG4gICAgfVxuICB9XG5cbiAgX2hpZGUoKSB7XG4gICAgaWYgKHRoaXMudG9wUGFnZSkge1xuICAgICAgdGhpcy50b3BQYWdlLl9oaWRlKCk7XG4gICAgfVxuICB9XG5cbiAgX2Rlc3Ryb3koKSB7XG4gICAgZm9yIChsZXQgaSA9IHRoaXMucGFnZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRoaXMucGFnZXNbaV0uX2Rlc3Ryb3koKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbW92ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IEFuaW1hdG9yXG4gICAqL1xuICBzdGF0aWMgcmVnaXN0ZXJBbmltYXRvcihuYW1lLCBBbmltYXRvcikge1xuICAgIGlmICghKEFuaW1hdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJBbmltYXRvclwiIHBhcmFtIG11c3QgaW5oZXJpdCBOYXZpZ2F0b3JFbGVtZW50Lk5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcicpO1xuICAgIH1cblxuICAgIF9hbmltYXRvckRpY3RbbmFtZV0gPSBBbmltYXRvcjtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgYW5pbWF0b3JzKCkge1xuICAgIHJldHVybiBfYW5pbWF0b3JEaWN0O1xuICB9XG5cbiAgc3RhdGljIGdldCBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IoKSB7XG4gICAgcmV0dXJuIE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcjtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgcmV3cml0YWJsZXMoKSB7XG4gICAgcmV0dXJuIHJld3JpdGFibGVzO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLW5hdmlnYXRvcicsIE5hdmlnYXRvckVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuaW1wb3J0IGludGVybmFsIGZyb20gJ29ucy9pbnRlcm5hbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJ29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICdvbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJ29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnJzogJ25hdmlnYXRpb24tYmFyLS0qJyxcbiAgJy5uYXZpZ2F0aW9uLWJhcl9fbGVmdCc6ICduYXZpZ2F0aW9uLWJhci0tKl9fbGVmdCcsXG4gICcubmF2aWdhdGlvbi1iYXJfX2NlbnRlcic6ICduYXZpZ2F0aW9uLWJhci0tKl9fY2VudGVyJyxcbiAgJy5uYXZpZ2F0aW9uLWJhcl9fcmlnaHQnOiAnbmF2aWdhdGlvbi1iYXItLSpfX3JpZ2h0J1xufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtdG9vbGJhclxuICogQGNhdGVnb3J5IHBhZ2VcbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dTWF0ZXJpYWwgRGVzaWduIHRvb2xiYXIuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAbW9kaWZpZXIgdHJhbnNwYXJlbnRcbiAqICAgW2VuXVRyYW5zcGFyZW50IHRvb2xiYXJbL2VuXVxuICogICBbamFd6YCP5piO44Gq6IOM5pmv44KS5oyB44Gk44OE44O844Or44OQ44O844KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgVG9vbGJhciBjb21wb25lbnQgdGhhdCBjYW4gYmUgdXNlZCB3aXRoIG5hdmlnYXRpb24uXG4gKlxuICogICAgIExlZnQsIGNlbnRlciBhbmQgcmlnaHQgY29udGFpbmVyIGNhbiBiZSBzcGVjaWZpZWQgYnkgY2xhc3MgbmFtZXMuXG4gKlxuICogICAgIFRoaXMgY29tcG9uZW50IHdpbGwgYXV0b21hdGljYWxseSBkaXNwbGF5cyBhcyBhIE1hdGVyaWFsIERlc2lnbiB0b29sYmFyIHdoZW4gcnVubmluZyBvbiBBbmRyb2lkIGRldmljZXMuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV3jg4rjg5PjgrLjg7zjgrfjg6fjg7Pjgafkvb/nlKjjgZnjgovjg4Tjg7zjg6vjg5Djg7znlKjjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgILjgq/jg6njgrnlkI3jgavjgojjgorjgIHlt6bjgIHkuK3lpK7jgIHlj7Pjga7jgrPjg7Pjg4bjg4rjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICogQGNvZGVwZW4gYUhtR0xcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9idXR0b25cbiAqIEBndWlkZSBhZGRpbmctYS10b29sYmFyIFtlbl1BZGRpbmcgYSB0b29sYmFyWy9lbl1bamFd44OE44O844Or44OQ44O844Gu6L+95YqgWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1ib3R0b20tdG9vbGJhclxuICogICBbZW5dVGhlIGA8b25zLWJvdHRvbS10b29sYmFyPmAgZGlzcGxheXMgYSB0b29sYmFyIG9uIHRoZSBib3R0b20gb2YgdGhlIHBhZ2UuWy9lbl1cbiAqICAgW2phXW9ucy1ib3R0b20tdG9vbGJhcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtYmFjay1idXR0b25cbiAqICAgW2VuXVRoZSBgPG9ucy1iYWNrLWJ1dHRvbj5gIGNvbXBvbmVudCBkaXNwbGF5cyBhIGJhY2sgYnV0dG9uIGluc2lkZSB0aGUgdG9vbGJhci5bL2VuXVxuICogICBbamFdb25zLWJhY2stYnV0dG9u44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy10b29sYmFyLWJ1dHRvblxuICogICBbZW5dVGhlIGA8b25zLXRvb2xiYXItYnV0dG9uPmAgY29tcG9uZW50IGRpc3BsYXlzIGEgdG9vbGJhciBidXR0b24gaW5zaWRlIHRoZSB0b29sYmFyLlsvZW5dXG4gKiAgIFtqYV1vbnMtdG9vbGJhci1idXR0b27jgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtcGFnZT5cbiAqICAgPG9ucy10b29sYmFyPlxuICogICAgIDxkaXYgY2xhc3M9XCJsZWZ0XCI+XG4gKiAgICAgICA8b25zLWJhY2stYnV0dG9uPlxuICogICAgICAgICBCYWNrXG4gKiAgICAgICA8L29ucy1iYWNrLWJ1dHRvbj5cbiAqICAgICA8L2Rpdj5cbiAqICAgICA8ZGl2IGNsYXNzPVwiY2VudGVyXCI+XG4gKiAgICAgICBUaXRsZVxuICogICAgIDwvZGl2PlxuICogICAgIDxkaXYgY2xhc3M9XCJyaWdodFwiPlxuICogICAgICAgPG9ucy10b29sYmFyLWJ1dHRvbj5cbiAqICAgICAgICAgPG9ucy1pY29uIGljb249XCJtZC1tZW51XCI+PC9vbnMtaWNvbj5cbiAqICAgICAgIDwvb25zLXRvb2xiYXItYnV0dG9uPlxuICogICAgIDwvZGl2PlxuICogICA8L29ucy10b29sYmFyPlxuICogPC9vbnMtcGFnZT5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUb29sYmFyRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBpbmxpbmVcbiAgICogQGluaXRvbmx5XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1EaXNwbGF5IHRoZSB0b29sYmFyIGFzIGFuIGlubGluZSBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXeODhOODvOODq+ODkOODvOOCkuOCpOODs+ODqeOCpOODs+OBq+e9ruOBjeOBvuOBmeOAguOCueOCr+ODreODvOODq+mgmOWfn+WGheOBq+OBneOBruOBvuOBvuihqOekuuOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgdG9vbGJhci5bL2VuXVxuICAgKiAgIFtqYV3jg4Tjg7zjg6vjg5Djg7zjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBpbml0KCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKCdfY29tcGlsZWQnKSkge1xuICAgICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllciddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIF9nZXRUb29sYmFyTGVmdEl0ZW1zRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCcubGVmdCcpIHx8IGludGVybmFsLm51bGxFbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgX2dldFRvb2xiYXJDZW50ZXJJdGVtc0VsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvcignLmNlbnRlcicpIHx8IGludGVybmFsLm51bGxFbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgX2dldFRvb2xiYXJSaWdodEl0ZW1zRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCcucmlnaHQnKSB8fCBpbnRlcm5hbC5udWxsRWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIF9nZXRUb29sYmFyQmFja0J1dHRvbkxhYmVsRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCdvbnMtYmFjay1idXR0b24gLmJhY2stYnV0dG9uX19sYWJlbCcpIHx8IGludGVybmFsLm51bGxFbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgX2dldFRvb2xiYXJCYWNrQnV0dG9uSWNvbkVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3Rvcignb25zLWJhY2stYnV0dG9uIC5iYWNrLWJ1dHRvbl9faWNvbicpIHx8IGludGVybmFsLm51bGxFbGVtZW50O1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKCduYXZpZ2F0aW9uLWJhcicpO1xuICAgIHRoaXMuX2Vuc3VyZVRvb2xiYXJJdGVtRWxlbWVudHMoKTtcbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ19jb21waWxlZCcsICcnKTtcbiAgfVxuXG4gIF9lbnN1cmVUb29sYmFySXRlbUVsZW1lbnRzKCkge1xuICAgIGZvciAobGV0IGkgPSB0aGlzLmNoaWxkTm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwIDsgaS0tKSB7XG4gICAgICAvLyBjYXNlIG9mIG5vdCBlbGVtZW50XG4gICAgICBpZiAodGhpcy5jaGlsZE5vZGVzW2ldLm5vZGVUeXBlICE9IDEpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVDaGlsZCh0aGlzLmNoaWxkTm9kZXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGNlbnRlciA9IHRoaXMuX2Vuc3VyZVRvb2xiYXJFbGVtZW50KCdjZW50ZXInKTtcbiAgICBjZW50ZXIuY2xhc3NMaXN0LmFkZCgnbmF2aWdhdGlvbi1iYXJfX3RpdGxlJyk7XG5cbiAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggIT09IDEgfHwgIXRoaXMuY2hpbGRyZW5bMF0uY2xhc3NMaXN0LmNvbnRhaW5zKCdjZW50ZXInKSkge1xuICAgICAgY29uc3QgbGVmdCA9IHRoaXMuX2Vuc3VyZVRvb2xiYXJFbGVtZW50KCdsZWZ0Jyk7XG4gICAgICBjb25zdCByaWdodCA9IHRoaXMuX2Vuc3VyZVRvb2xiYXJFbGVtZW50KCdyaWdodCcpO1xuXG4gICAgICBpZiAodGhpcy5jaGlsZHJlblswXSAhPT0gbGVmdCB8fCB0aGlzLmNoaWxkcmVuWzFdICE9PSBjZW50ZXIgfHwgdGhpcy5jaGlsZHJlblsyXSAhPT0gcmlnaHQpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChsZWZ0KTtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChjZW50ZXIpO1xuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKHJpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfZW5zdXJlVG9vbGJhckVsZW1lbnQobmFtZSkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLicgKyBuYW1lKSB8fCB1dGlsLmNyZWF0ZSgnLicgKyBuYW1lKTtcblxuICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnbmF2aWdhdGlvbi1iYXJfXycgKyBuYW1lKTtcblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXRvb2xiYXInLCBUb29sYmFyRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnb25zL2ludGVybmFsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJ29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciBmcm9tICdvbnMvZGV2aWNlLWJhY2stYnV0dG9uLWRpc3BhdGNoZXInO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICdvbnMvY29udGVudC1yZWFkeSc7XG5cbmltcG9ydCAnZWxlbWVudHMvb25zLXRvb2xiYXInOyAvLyBlbnN1cmVzIHRoYXQgJ29ucy10b29sYmFyJyBlbGVtZW50IGlzIHJlZ2lzdGVyZWRcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnJzogJ3BhZ2UtLSonLFxuICAnLnBhZ2VfX2NvbnRlbnQnOiAncGFnZS0tKl9fY29udGVudCcsXG4gICcucGFnZV9fYmFja2dyb3VuZCc6ICdwYWdlLS0qX19iYWNrZ3JvdW5kJ1xufTtcblxuY29uc3QgbnVsbFRvb2xiYXJFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb25zLXRvb2xiYXInKTsgLy8gcmVxdWlyZXMgdGhhdCAnb25zLXRvb2xiYXInIGVsZW1lbnQgaXMgcmVnaXN0ZXJlZFxuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1wYWdlXG4gKiBAY2F0ZWdvcnkgcGFnZVxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgIFtlbl1NYXRlcmlhbCBEZXNpZ24gc3R5bGVbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgVGhpcyBjb21wb25lbnQgZGVmaW5lcyB0aGUgcm9vdCBvZiBlYWNoIHBhZ2UuIElmIHRoZSBjb250ZW50IGlzIGxhcmdlIGl0IHdpbGwgYmVjb21lIHNjcm9sbGFibGUuXG4gKlxuICogICAgIEEgbmF2aWdhdGlvbiBiYXIgY2FuIGJlIGFkZGVkIHRvIHRoZSB0b3Agb2YgdGhlIHBhZ2UgdXNpbmcgdGhlIGA8b25zLXRvb2xiYXI+YCBlbGVtZW50LlxuICogICBbL2VuXVxuICogICBbamFd44Oa44O844K45a6a576p44Gu44Gf44KB44Gu44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CC44GT44Gu44Kz44Oz44Od44O844ON44Oz44OI44Gu5YaF5a6544Gv44K544Kv44Ot44O844Or44GM6Kix5Y+v44GV44KM44G+44GZ44CCWy9qYV1cbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9wYWdlXG4gKiBAZ3VpZGUgY3JlYXRpbmctYS1wYWdlXG4gKiAgIFtlbl1TZXR0aW5nIHVwIGEgcGFnZSBpbiBpdHMgYGluaXRgIGV2ZW50Wy9lbl1cbiAqICAgW2phXVNldHRpbmcgdXAgYSBwYWdlIGluIGl0cyBgaW5pdGAgZXZlbnRbL2phXVxuICogQGd1aWRlIHRlbXBsYXRlc1xuICogICBbZW5dRGVmaW5pbmcgbXVsdGlwbGUgcGFnZXMgaW4gc2luZ2xlIGh0bWxbL2VuXVxuICogICBbamFd6KSH5pWw44Gu44Oa44O844K444KSMeOBpOOBrkhUTUzjgavoqJjov7DjgZnjgotbL2phXVxuICogQGd1aWRlIG11bHRpcGxlLXBhZ2UtbmF2aWdhdGlvblxuICogICBbZW5dTWFuYWdpbmcgbXVsdGlwbGUgcGFnZXNbL2VuXVxuICogICBbamFd6KSH5pWw44Gu44Oa44O844K444KS566h55CG44GZ44KLWy9qYV1cbiAqIEBndWlkZSB1c2luZy1tb2RpZmllciBbZW5dTW9yZSBkZXRhaWxzIGFib3V0IHRoZSBgbW9kaWZpZXJgIGF0dHJpYnV0ZVsvZW5dW2phXW1vZGlmaWVy5bGe5oCn44Gu5L2/44GE5pa5Wy9qYV1cbiAqIEBzZWVhbHNvIG9ucy10b29sYmFyXG4gKiAgIFtlbl1Vc2UgdGhlIGA8b25zLXRvb2xiYXI+YCBlbGVtZW50IHRvIGFkZCBhIG5hdmlnYXRpb24gYmFyIHRvIHRoZSB0b3Agb2YgdGhlIHBhZ2UuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1wYWdlPlxuICogICA8b25zLXRvb2xiYXI+XG4gKiAgICAgPGRpdiBjbGFzcz1cImxlZnRcIj5cbiAqICAgICAgIDxvbnMtYmFjay1idXR0b24+QmFjazwvb25zLWJhY2stYnV0dG9uPlxuICogICAgIDwvZGl2PlxuICogICAgIDxkaXYgY2xhc3M9XCJjZW50ZXJcIj5UaXRsZTwvZGl2PlxuICogICAgIDxkaXYgY2xhc3M9XCJyaWdodFwiPlxuICogICAgICAgPG9ucy10b29sYmFyLWJ1dHRvbj5cbiAqICAgICAgICAgPG9ucy1pY29uIGljb249XCJtZC1tZW51XCI+PC9vbnMtaWNvbj5cbiAqICAgICAgIDwvb25zLXRvb2xiYXItYnV0dG9uPlxuICogICAgIDwvZGl2PlxuICogICA8L29ucy10b29sYmFyPlxuICpcbiAqICAgPHA+UGFnZSBjb250ZW50PC9wPlxuICogPC9vbnMtcGFnZT5cbiAqIFxuICogQGV4YW1wbGVcbiAqIDxzY3JpcHQ+XG4gKiAgIG15QXBwLmhhbmRsZXIgPSBmdW5jdGlvbihkb25lKSB7XG4gKiAgICAgbG9hZE1vcmUoKS50aGVuKGRvbmUpO1xuICogICB9XG4gKiA8L3NjcmlwdD5cbiAqXG4gKiA8b25zLXBhZ2Ugb24taW5maW5pdGUtc2Nyb2xsPVwibXlBcHAuaGFuZGxlclwiPlxuICogICA8b25zLXRvb2xiYXI+XG4gKiAgICAgPGRpdiBjbGFzcz1cImNlbnRlclwiPkxpc3Q8L2Rpdj5cbiAqICAgPC9vbnMtdG9vbGJhcj5cbiAqXG4gKiAgIDxvbnMtbGlzdD5cbiAqICAgICA8b25zLWxpc3QtaXRlbT4jMTwvb25zLWxpc3QtaXRlbT5cbiAqICAgICA8b25zLWxpc3QtaXRlbT4jMjwvb25zLWxpc3QtaXRlbT5cbiAqICAgICA8b25zLWxpc3QtaXRlbT4jMzwvb25zLWxpc3QtaXRlbT5cbiAqICAgICAuLi5cbiAqICAgPC9vbnMtbGlzdD5cbiAqIDwvb25zLXBhZ2U+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhZ2VFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgaW5pdFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQgcmlnaHQgYWZ0ZXIgdGhlIHBhZ2UgaXMgYXR0YWNoZWQuWy9lbl1cbiAgICogICBbamFd44Oa44O844K444GM44Ki44K/44OD44OB44GV44KM44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCByaWdodCBhZnRlciB0aGUgcGFnZSBpcyBzaG93bi5bL2VuXVxuICAgKiAgIFtqYV3jg5rjg7zjgrjjgYzooajnpLrjgZXjgozjgZ/lvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IGhpZGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIHJpZ2h0IGFmdGVyIHRoZSBwYWdlIGlzIGhpZGRlbi5bL2VuXVxuICAgKiAgIFtqYV3jg5rjg7zjgrjjgYzpmqDjgozjgZ/lvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IGRlc3Ryb3lcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIHJpZ2h0IGJlZm9yZSB0aGUgcGFnZSBpcyBkZXN0cm95ZWQuWy9lbl1cbiAgICogICBbamFd44Oa44O844K444GM56C05qOE44GV44KM44KL5YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgbW9kaWZpZXIgbmFtZSB0byBzcGVjaWZ5IGN1c3RvbSBzdHlsZXMuWy9lbl1cbiAgICogICBbamFd44K544K/44Kk44Or5a6a576p44KS44Kr44K544K/44Oe44Kk44K644GZ44KL44Gf44KB44Gu5ZCN5YmN44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgb24taW5maW5pdGUtc2Nyb2xsXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1QYXRoIG9mIHRoZSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBvbiBpbmZpbml0ZSBzY3JvbGxpbmcuIEV4YW1wbGU6IGBhcHAubG9hZERhdGFgLiBUaGUgZnVuY3Rpb24gcmVjZWl2ZXMgYSBkb25lIGNhbGxiYWNrIHRoYXQgbXVzdCBiZSBjYWxsZWQgd2hlbiBpdCdzIGZpbmlzaGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdwYWdlJyk7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZSgnX2NvbXBpbGVkJykpIHtcbiAgICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pc1Nob3duID0gZmFsc2U7XG4gICAgICB0aGlzLl9jb250ZW50RWxlbWVudCA9IHRoaXMuX2dldENvbnRlbnRFbGVtZW50KCk7XG4gICAgICB0aGlzLl9pc011dGVkID0gdGhpcy5oYXNBdHRyaWJ1dGUoJ19tdXRlZCcpO1xuICAgICAgdGhpcy5fc2tpcEluaXQgPSB0aGlzLmhhc0F0dHJpYnV0ZSgnX3NraXBpbml0Jyk7XG4gICAgICB0aGlzLnB1c2hlZE9wdGlvbnMgPSB7fTtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX2lzTXV0ZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NraXBJbml0KSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ19za2lwaW5pdCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ2luaXQnKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF1dGlsLmhhc0FueUNvbXBvbmVudEFzUGFyZW50KHRoaXMpKSB7XG4gICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLl9zaG93KCkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl90cnlUb0ZpbGxTdGF0dXNCYXIoKTtcblxuICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdvbi1pbmZpbml0ZS1zY3JvbGwnKSkge1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaygnb24taW5maW5pdGUtc2Nyb2xsJywgbnVsbCwgdGhpcy5nZXRBdHRyaWJ1dGUoJ29uLWluZmluaXRlLXNjcm9sbCcpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHVwZGF0ZUJhY2tCdXR0b24oc2hvdykge1xuICAgIGlmICh0aGlzLmJhY2tCdXR0b24pIHtcbiAgICAgIHNob3cgPyB0aGlzLmJhY2tCdXR0b24uc2hvdygpIDogdGhpcy5iYWNrQnV0dG9uLmhpZGUoKTtcbiAgICB9XG4gIH1cblxuICBzZXQgbmFtZShzdHIpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnbmFtZScsIHN0cik7XG4gIH1cblxuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ25hbWUnKTtcbiAgfVxuXG4gIGdldCBiYWNrQnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ29ucy1iYWNrLWJ1dHRvbicpO1xuICB9XG5cbiAgX3RyeVRvRmlsbFN0YXR1c0Jhcigpe1xuICAgIGludGVybmFsLmF1dG9TdGF0dXNCYXJGaWxsKCgpID0+IHtcbiAgICAgIGNvbnN0IGZpbGxlZCA9IHV0aWwuZmluZFBhcmVudCh0aGlzLCBlID0+IGUuaGFzQXR0cmlidXRlKCdzdGF0dXMtYmFyLWZpbGwnKSk7XG4gICAgICB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnc3RhdHVzLWJhci1maWxsJywgIWZpbGxlZCAmJiAodGhpcy5fY2FuQW5pbWF0ZVRvb2xiYXIoKSB8fCAhdGhpcy5faGFzQVBhZ2VDb250cm9sQ2hpbGQoKSkpO1xuICAgIH0pO1xuICB9XG5cbiAgX2hhc0FQYWdlQ29udHJvbENoaWxkKCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLl9jb250ZW50RWxlbWVudCwgZSA9PiBlLm5vZGVOYW1lLm1hdGNoKC9vbnMtKHNwbGl0dGVyfHNsaWRpbmctbWVudXxuYXZpZ2F0b3J8dGFiYmFyKS9pKSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9uSW5maW5pdGVTY3JvbGxcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dRnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgd2hlbiBzY3JvbGxpbmcgdG8gdGhlIGJvdHRvbSBvZiB0aGUgcGFnZS4gVGhlIGZ1bmN0aW9uIHJlY2VpdmVzIGEgZG9uZSBjYWxsYmFjayBhcyBhbiBhcmd1bWVudCB0aGF0IG11c3QgYmUgY2FsbGVkIHdoZW4gaXQncyBmaW5pc2hlZC5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuICBzZXQgb25JbmZpbml0ZVNjcm9sbCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fb25JbmZpbml0ZVNjcm9sbCA9IG51bGw7XG4gICAgICB0aGlzLl9jb250ZW50RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9ib3VuZE9uU2Nyb2xsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignb25JbmZpbml0ZVNjcm9sbCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgbnVsbCcpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX29uSW5maW5pdGVTY3JvbGwpIHtcbiAgICAgIHRoaXMuX2luZmluaXRlU2Nyb2xsTGltaXQgPSAwLjk7XG4gICAgICB0aGlzLl9ib3VuZE9uU2Nyb2xsID0gdGhpcy5fb25TY3JvbGwuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX2NvbnRlbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX2JvdW5kT25TY3JvbGwpO1xuICAgIH1cbiAgICB0aGlzLl9vbkluZmluaXRlU2Nyb2xsID0gdmFsdWU7XG4gIH1cblxuICBnZXQgb25JbmZpbml0ZVNjcm9sbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fb25JbmZpbml0ZVNjcm9sbDtcbiAgfVxuXG4gIF9vblNjcm9sbCgpIHtcbiAgICBjb25zdCBjID0gdGhpcy5fY29udGVudEVsZW1lbnQsXG4gICAgICBvdmVyTGltaXQgPSAoYy5zY3JvbGxUb3AgKyBjLmNsaWVudEhlaWdodCkgLyBjLnNjcm9sbEhlaWdodCA+PSB0aGlzLl9pbmZpbml0ZVNjcm9sbExpbWl0O1xuXG4gICAgaWYgKHRoaXMuX29uSW5maW5pdGVTY3JvbGwgJiYgIXRoaXMuX2xvYWRpbmdDb250ZW50ICYmIG92ZXJMaW1pdCkge1xuICAgICAgdGhpcy5fbG9hZGluZ0NvbnRlbnQgPSB0cnVlO1xuICAgICAgdGhpcy5fb25JbmZpbml0ZVNjcm9sbCgoKSA9PiB0aGlzLl9sb2FkaW5nQ29udGVudCA9IGZhbHNlKTtcbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25EZXZpY2VCYWNrQnV0dG9uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1CYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAqICAgW2phXeODkOODg+OCr+ODnOOCv+ODs+ODj+ODs+ODieODqeOAglsvamFdXG4gICAqL1xuICBnZXQgb25EZXZpY2VCYWNrQnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcjtcbiAgfVxuXG4gIHNldCBvbkRldmljZUJhY2tCdXR0b24oY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5fYmFja0J1dHRvbkhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyLmNyZWF0ZUhhbmRsZXIodGhpcywgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgX2dldENvbnRlbnRFbGVtZW50KCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcucGFnZV9fY29udGVudCcpO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHRocm93IEVycm9yKCdmYWlsIHRvIGdldCBcIi5wYWdlX19jb250ZW50XCIgZWxlbWVudC4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgX2NhbkFuaW1hdGVUb29sYmFyKCkge1xuICAgIGlmICh1dGlsLmZpbmRDaGlsZCh0aGlzLCAnb25zLXRvb2xiYXInKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiAhIXV0aWwuZmluZENoaWxkKHRoaXMuX2NvbnRlbnRFbGVtZW50LCBlbCA9PiB7XG4gICAgICByZXR1cm4gdXRpbC5tYXRjaChlbCwgJ29ucy10b29sYmFyJykgJiYgIWVsLmhhc0F0dHJpYnV0ZSgnaW5saW5lJyk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBfZ2V0QmFja2dyb3VuZEVsZW1lbnQoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5wYWdlX19iYWNrZ3JvdW5kJyk7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdGhyb3cgRXJyb3IoJ2ZhaWwgdG8gZ2V0IFwiLnBhZ2VfX2JhY2tncm91bmRcIiBlbGVtZW50LicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgX2dldEJvdHRvbVRvb2xiYXJFbGVtZW50KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnb25zLWJvdHRvbS10b29sYmFyJykgfHwgaW50ZXJuYWwubnVsbEVsZW1lbnQ7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIF9nZXRUb29sYmFyRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJ29ucy10b29sYmFyJykgfHwgbnVsbFRvb2xiYXJFbGVtZW50O1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAnX211dGVkJywgJ19za2lwaW5pdCcsICdvbi1pbmZpbml0ZS1zY3JvbGwnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgIHJldHVybiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdfbXV0ZWQnKSB7XG4gICAgICB0aGlzLl9pc011dGVkID0gdGhpcy5oYXNBdHRyaWJ1dGUoJ19tdXRlZCcpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ19za2lwaW5pdCcpIHtcbiAgICAgIHRoaXMuX3NraXBJbml0ID0gdGhpcy5oYXNBdHRyaWJ1dGUoJ19za2lwaW5pdCcpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ29uLWluZmluaXRlLXNjcm9sbCcpIHtcbiAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMub25JbmZpbml0ZVNjcm9sbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uSW5maW5pdGVTY3JvbGwgPSAoZG9uZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGYgPSB1dGlsLmZpbmRGcm9tUGF0aChjdXJyZW50KTtcbiAgICAgICAgICB0aGlzLm9uSW5maW5pdGVTY3JvbGwgPSBmO1xuICAgICAgICAgIGYoZG9uZSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICBpZiAodXRpbC5maW5kQ2hpbGQodGhpcywgJy5jb250ZW50JykpIHtcbiAgICAgIHV0aWwuZmluZENoaWxkKHRoaXMsICcuY29udGVudCcpLmNsYXNzTGlzdC5hZGQoJ3BhZ2VfX2NvbnRlbnQnKTtcbiAgICB9XG5cbiAgICBpZiAodXRpbC5maW5kQ2hpbGQodGhpcywgJy5iYWNrZ3JvdW5kJykpIHtcbiAgICAgIHV0aWwuZmluZENoaWxkKHRoaXMsICcuYmFja2dyb3VuZCcpLmNsYXNzTGlzdC5hZGQoJ3BhZ2VfX2JhY2tncm91bmQnKTtcbiAgICB9XG5cbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKHRoaXMsICcucGFnZV9fY29udGVudCcpKSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdXRpbC5jcmVhdGUoJy5wYWdlX19jb250ZW50Jyk7XG5cbiAgICAgIHV0aWwuYXJyYXlGcm9tKHRoaXMuY2hpbGROb2RlcykuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT09IDEgfHwgdGhpcy5fZWxlbWVudFNob3VsZEJlTW92ZWQobm9kZSkpIHtcbiAgICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcHJldk5vZGUgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnBhZ2VfX2JhY2tncm91bmQnKSB8fCB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnb25zLXRvb2xiYXInKTtcblxuICAgICAgdGhpcy5pbnNlcnRCZWZvcmUoY29udGVudCwgcHJldk5vZGUgJiYgcHJldk5vZGUubmV4dFNpYmxpbmcpO1xuICAgIH1cblxuICAgIGlmICghdXRpbC5maW5kQ2hpbGQodGhpcywgJy5wYWdlX19iYWNrZ3JvdW5kJykpIHtcbiAgICAgIGNvbnN0IGJhY2tncm91bmQgPSB1dGlsLmNyZWF0ZSgnLnBhZ2VfX2JhY2tncm91bmQnKTtcbiAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKGJhY2tncm91bmQsIHV0aWwuZmluZENoaWxkKHRoaXMsICcucGFnZV9fY29udGVudCcpKTtcbiAgICB9XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG5cbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnX2NvbXBpbGVkJywgJycpO1xuICB9XG5cbiAgX2VsZW1lbnRTaG91bGRCZU1vdmVkKGVsKSB7XG4gICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucygncGFnZV9fYmFja2dyb3VuZCcpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHRhZ05hbWUgPSBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKHRhZ05hbWUgPT09ICdvbnMtZmFiJykge1xuICAgICAgcmV0dXJuICFlbC5oYXNBdHRyaWJ1dGUoJ3Bvc2l0aW9uJyk7XG4gICAgfVxuICAgIGNvbnN0IGZpeGVkRWxlbWVudHMgPSBbJ29ucy10b29sYmFyJywgJ29ucy1ib3R0b20tdG9vbGJhcicsICdvbnMtbW9kYWwnLCAnb25zLXNwZWVkLWRpYWwnXTtcbiAgICByZXR1cm4gZWwuaGFzQXR0cmlidXRlKCdpbmxpbmUnKSB8fCBmaXhlZEVsZW1lbnRzLmluZGV4T2YodGFnTmFtZSkgPT09IC0xO1xuICB9XG5cbiAgX3Nob3coKSB7XG4gICAgaWYgKCF0aGlzLl9pc1Nob3duICYmIHV0aWwuaXNBdHRhY2hlZCh0aGlzKSkge1xuICAgICAgdGhpcy5faXNTaG93biA9IHRydWU7XG5cbiAgICAgIGlmICghdGhpcy5faXNNdXRlZCkge1xuICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3Nob3cnKTtcbiAgICAgIH1cblxuICAgICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24odGhpcy5fY29udGVudEVsZW1lbnQsICdfc2hvdycpO1xuICAgIH1cbiAgfVxuXG4gIF9oaWRlKCkge1xuICAgIGlmICh0aGlzLl9pc1Nob3duKSB7XG4gICAgICB0aGlzLl9pc1Nob3duID0gZmFsc2U7XG5cbiAgICAgIGlmICghdGhpcy5faXNNdXRlZCkge1xuICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ2hpZGUnKTtcbiAgICAgIH1cblxuICAgICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24odGhpcy5fY29udGVudEVsZW1lbnQsICdfaGlkZScpO1xuICAgIH1cbiAgfVxuXG4gIF9kZXN0cm95KCkge1xuICAgIHRoaXMuX2hpZGUoKTtcblxuICAgIGlmICghdGhpcy5faXNNdXRlZCkge1xuICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdkZXN0cm95Jyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub25EZXZpY2VCYWNrQnV0dG9uKSB7XG4gICAgICB0aGlzLm9uRGV2aWNlQmFja0J1dHRvbi5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24odGhpcy5fY29udGVudEVsZW1lbnQsICdfZGVzdHJveScpO1xuXG4gICAgaWYgKHRoaXMudW5sb2FkIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIHRoaXMudW5sb2FkKCk7XG4gICAgfVxuXG4gICAgdGhpcy5yZW1vdmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGF0YVxuICAgKiBAdHlwZSB7Kn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVVzZXIncyBjdXN0b20gZGF0YSBwYXNzZWQgdG8gYHB1c2hQYWdlKClgLWxpa2UgbWV0aG9kcy5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtcGFnZScsIFBhZ2VFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5cbmV4cG9ydCBjbGFzcyBQb3BvdmVyQW5pbWF0b3Ige1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy50aW1pbmdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZHVyYXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZGVsYXlcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgIHRpbWluZzogJ2N1YmljLWJlemllciguMSwgLjcsIC40LCAxKScsXG4gICAgICBkdXJhdGlvbjogMC4yLFxuICAgICAgZGVsYXk6IDBcbiAgICB9LCBvcHRpb25zKTtcbiAgfVxuXG4gIHNob3cocG9wb3ZlciwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgaGlkZShwb3BvdmVyLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cblxuICBfYW5pbWF0ZShlbGVtZW50LCB7ZnJvbSwgdG8sIG9wdGlvbnMsIGNhbGxiYWNrLCByZXN0b3JlID0gZmFsc2UsIGFuaW1hdGlvbn0pIHtcbiAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe30sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICBpZiAoYW5pbWF0aW9uKSB7XG4gICAgICBmcm9tID0gYW5pbWF0aW9uLmZyb207XG4gICAgICB0byA9IGFuaW1hdGlvbi50bztcbiAgICB9XG5cbiAgICBhbmltYXRpb24gPSBhbmltaXQoZWxlbWVudCk7XG4gICAgaWYgKHJlc3RvcmUpIHtcbiAgICAgIGFuaW1hdGlvbiA9IGFuaW1hdGlvbi5zYXZlU3R5bGUoKTtcbiAgICB9XG4gICAgYW5pbWF0aW9uID0gYW5pbWF0aW9uLnF1ZXVlKGZyb20pLndhaXQob3B0aW9ucy5kZWxheSkucXVldWUoe1xuICAgICAgY3NzOiB0byxcbiAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuICAgICAgdGltaW5nOiBvcHRpb25zLnRpbWluZ1xuICAgIH0pO1xuICAgIGlmIChyZXN0b3JlKSB7XG4gICAgICBhbmltYXRpb24gPSBhbmltYXRpb24ucmVzdG9yZVN0eWxlKCk7XG4gICAgfVxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgYW5pbWF0aW9uID0gYW5pbWF0aW9uLnF1ZXVlKChkb25lKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbWF0aW9uO1xuICB9XG5cbiAgX2FuaW1hdGVBbGwoZWxlbWVudCwgYW5pbWF0aW9ucykge1xuICAgIE9iamVjdC5rZXlzKGFuaW1hdGlvbnMpLmZvckVhY2goa2V5ID0+IHRoaXMuX2FuaW1hdGUoZWxlbWVudFtrZXldLCBhbmltYXRpb25zW2tleV0pLnBsYXkoKSk7XG4gIH1cblxufVxuXG5jb25zdCBmYWRlID0ge1xuICBvdXQ6IHtcbiAgICBmcm9tOiB7b3BhY2l0eTogMS4wfSxcbiAgICB0bzoge29wYWNpdHk6IDB9XG4gIH0sXG4gIGluOiB7XG4gICAgZnJvbToge29wYWNpdHk6IDB9LFxuICAgIHRvOiB7b3BhY2l0eTogMS4wfVxuICB9XG59O1xuXG5leHBvcnQgY2xhc3MgTURGYWRlUG9wb3ZlckFuaW1hdG9yIGV4dGVuZHMgUG9wb3ZlckFuaW1hdG9yIHtcbiAgc2hvdyhwb3BvdmVyLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX2FuaW1hdGVBbGwocG9wb3Zlciwge1xuICAgICAgX21hc2s6IGZhZGUuaW4sXG4gICAgICBfcG9wb3Zlcjoge2FuaW1hdGlvbjogZmFkZS5pbiwgcmVzdG9yZTogdHJ1ZSwgY2FsbGJhY2t9XG4gICAgfSk7XG4gIH1cblxuICBoaWRlKHBvcG92ZXIsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fYW5pbWF0ZUFsbChwb3BvdmVyLCB7XG4gICAgICBfbWFzazogZmFkZS5vdXQsXG4gICAgICBfcG9wb3Zlcjoge2FuaW1hdGlvbjogZmFkZS5vdXQsIHJlc3RvcmU6IHRydWUsIGNhbGxiYWNrfVxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBJT1NGYWRlUG9wb3ZlckFuaW1hdG9yIGV4dGVuZHMgTURGYWRlUG9wb3ZlckFuaW1hdG9yIHtcbiAgc2hvdyhwb3BvdmVyLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX2FuaW1hdGVBbGwocG9wb3Zlciwge1xuICAgICAgX21hc2s6IGZhZGUuaW4sXG4gICAgICBfcG9wb3Zlcjoge1xuICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGUzZCgxLjMsIDEuMywgMS4wKScsXG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9LFxuICAgICAgICB0bzoge1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3NjYWxlM2QoMS4wLCAxLjAsICAxLjApJyxcbiAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgfSxcbiAgICAgICAgcmVzdG9yZTogdHJ1ZSxcbiAgICAgICAgY2FsbGJhY2tcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICdvbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEFuaW1hdG9yRmFjdG9yeSBmcm9tICdvbnMvaW50ZXJuYWwvYW5pbWF0b3ItZmFjdG9yeSc7XG5pbXBvcnQge1BvcG92ZXJBbmltYXRvciwgSU9TRmFkZVBvcG92ZXJBbmltYXRvciwgTURGYWRlUG9wb3ZlckFuaW1hdG9yfSBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICdvbnMvcGxhdGZvcm0nO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyIGZyb20gJ29ucy9kZXZpY2UtYmFjay1idXR0b24tZGlzcGF0Y2hlcic7XG5pbXBvcnQgRG9vckxvY2sgZnJvbSAnb25zL2Rvb3Jsb2NrJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcucG9wb3Zlcic6ICdwb3BvdmVyLS0qJyxcbiAgJy5wb3BvdmVyLW1hc2snOiAncG9wb3Zlci1tYXNrLS0qJyxcbiAgJy5wb3BvdmVyX19jb250YWluZXInOiAncG9wb3Zlcl9fY29udGFpbmVyLS0qJyxcbiAgJy5wb3BvdmVyX19jb250ZW50JzogJ3BvcG92ZXJfX2NvbnRlbnQtLSonLFxuICAnLnBvcG92ZXJfX2Fycm93JzogJ3BvcG92ZXJfX2Fycm93LS0qJ1xufTtcblxuY29uc3QgX2FuaW1hdG9yRGljdCA9IHtcbiAgJ2RlZmF1bHQnOiAoKSA9PiBwbGF0Zm9ybS5pc0FuZHJvaWQoKSA/IE1ERmFkZVBvcG92ZXJBbmltYXRvciA6IElPU0ZhZGVQb3BvdmVyQW5pbWF0b3IsXG4gICdub25lJzogUG9wb3ZlckFuaW1hdG9yLFxuICAnZmFkZS1pb3MnOiBJT1NGYWRlUG9wb3ZlckFuaW1hdG9yLFxuICAnZmFkZS1tZCc6IE1ERmFkZVBvcG92ZXJBbmltYXRvclxufTtcblxuY29uc3QgdGVtcGxhdGVTb3VyY2UgPSB1dGlsLmNyZWF0ZUZyYWdtZW50KGBcbiAgPGRpdiBjbGFzcz1cInBvcG92ZXItbWFza1wiPjwvZGl2PlxuICA8ZGl2IGNsYXNzPVwicG9wb3Zlcl9fY29udGFpbmVyXCI+XG4gICAgPGRpdiBjbGFzcz1cInBvcG92ZXJfX2NvbnRlbnRcIj48L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwicG9wb3Zlcl9fYXJyb3dcIj48L2Rpdj5cbiAgPC9kaXY+XG5gKTtcblxuY29uc3QgcG9zaXRpb25zID0ge1xuICB1cDogJ2JvdHRvbScsXG4gIGxlZnQ6ICdyaWdodCcsXG4gIGRvd246ICd0b3AnLFxuICByaWdodDogJ2xlZnQnXG59O1xuXG5jb25zdCBkaXJlY3Rpb25zID0gT2JqZWN0LmtleXMocG9zaXRpb25zKTtcbi8qKlxuICogQGVsZW1lbnQgb25zLXBvcG92ZXJcbiAqIEBjYXRlZ29yeSBkaWFsb2dcbiAqIEBkZXNjcmlwdGlvblxuICogIFtlbl1cbiAqICAgIEEgY29tcG9uZW50IHRoYXQgZGlzcGxheXMgYSBwb3BvdmVyIG5leHQgdG8gYW4gZWxlbWVudC4gVGhlIHBvcG92ZXIgY2FuIGJlIHVzZWQgdG8gZGlzcGxheSBleHRyYSBpbmZvcm1hdGlvbiBhYm91dCBhIGNvbXBvbmVudCBvciBhIHRvb2x0aXAuXG4gKlxuICogICAgVG8gdXNlIHRoZSBlbGVtZW50IGl0IGNhbiBlaXRoZXIgYmUgYXR0YWNoZWQgZGlyZWN0bHkgdG8gdGhlIGA8Ym9keT5gIGVsZW1lbnQgb3IgZHluYW1pY2FsbHkgY3JlYXRlZCBmcm9tIGEgdGVtcGxhdGUgdXNpbmcgdGhlIGBvbnMuY3JlYXRlUG9wb3Zlcih0ZW1wbGF0ZSlgIHV0aWxpdHkgZnVuY3Rpb24gYW5kIHRoZSBgPG9ucy10ZW1wbGF0ZT5gIHRhZy5cbiAqIFxuICogICAgQW5vdGhlciBjb21tb24gd2F5IHRvIHVzZSB0aGUgcG9wb3ZlciBpcyB0byBkaXNwbGF5IGEgbWVudSB3aGVuIGEgYnV0dG9uIG9uIHRoZSBzY3JlZW4gaXMgdGFwcGVkLiBGb3IgTWF0ZXJpYWwgRGVzaWduLCBwb3BvdmVyIGxvb2tzIGV4YWN0bHkgYXMgYSBkcm9wZG93biBtZW51LlxuICogIFsvZW5dXG4gKiAgW2phXeOBguOCi+imgee0oOOCkuWvvuixoeOBqOOBmeOCi+ODneODg+ODl+OCquODvOODkOODvOOCkuihqOekuuOBmeOCi+OCs+ODs+ODneODvOODjeODs+ODiOOBp+OBmeOAglsvamFdXG4gKiBAY29kZXBlbiBaWVlSS29cbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9wb3BvdmVyXG4gKiBAZ3VpZGUgZGlhbG9nc1xuICogIFtlbl1EaWFsb2cgY29tcG9uZW50c1svZW5dXG4gKiAgW2phXURpYWxvZyBjb21wb25lbnRzWy9qYV1cbiAqIEBndWlkZSB1c2luZy1tb2RpZmllciBbZW5dTW9yZSBkZXRhaWxzIGFib3V0IHRoZSBgbW9kaWZpZXJgIGF0dHJpYnV0ZVsvZW5dW2phXW1vZGlmaWVy5bGe5oCn44Gu5L2/44GE5pa5Wy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWJ1dHRvbiBvbmNsaWNrPVwic2hvd1BvcG92ZXIodGhpcylcIj5cbiAqICAgQ2xpY2sgbWUhXG4gKiA8L29ucy1idXR0b24+XG4gKlxuICogPG9ucy1wb3BvdmVyIGRpcmVjdGlvbj1cImRvd25cIiBpZD1cInBvcG92ZXJcIj5cbiAqICAgPHA+VGhpcyBpcyBhIHBvcG92ZXIhPC9wPlxuICogPC9vbnMtcG9wb3Zlcj5cbiAqXG4gKiA8c2NyaXB0PlxuICogICB2YXIgc2hvd1BvcG92ZXIgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gKiAgICAgdmFyIHBvcG92ZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncG9wb3ZlcicpO1xuICogICAgIHBvcG92ZXIuc2hvdyhlbGVtZW50KTtcbiAqICAgfTtcbiAqIDwvc2NyaXB0PlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb3BvdmVyRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGV2ZW50IHByZXNob3dcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYmVmb3JlIHRoZSBwb3BvdmVyIGlzIGRpc3BsYXllZC5bL2VuXVxuICAgKiAgIFtqYV3jg53jg4Pjg5fjgqrjg7zjg5Djg7zjgYzooajnpLrjgZXjgozjgovnm7TliY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQucG9wb3ZlclxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LmNhbmNlbFxuICAgKiAgIFtlbl1DYWxsIHRoaXMgZnVuY3Rpb24gdG8gc3RvcCB0aGUgcG9wb3ZlciBmcm9tIGJlaW5nIHNob3duLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWRvOOBs+WHuuOBmeOBqOOAgeODneODg+ODl+OCquODvOODkOODvOOBruihqOekuuOBjOOCreODo+ODs+OCu+ODq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdHNob3dcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIHBvcG92ZXIgaXMgZGlzcGxheWVkLlsvZW5dXG4gICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBjOihqOekuuOBleOCjOOBn+ebtOW+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5wb3BvdmVyXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVoaWRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSB0aGUgcG9wb3ZlciBpcyBoaWRkZW4uWy9lbl1cbiAgICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844GM6Zqg44KM44KL55u05YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnBvcG92ZXJcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dQ2FsbCB0aGlzIGZ1bmN0aW9uIHRvIHN0b3AgdGhlIHBvcG92ZXIgZnJvbSBiZWluZyBoaWRkZW4uWy9lbl1cbiAgICogICBbamFd44GT44Gu6Zai5pWw44KS5ZG844Gz5Ye644GZ44Go44CB44Od44OD44OX44Kq44O844OQ44O844GM6Zqg44KM44KL5Yem55CG44KS44Kt44Oj44Oz44K744Or44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0aGlkZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgcG9wb3ZlciBpcyBoaWRkZW4uWy9lbl1cbiAgICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844GM6Zqg44KM44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnBvcG92ZXJcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgcG9wb3Zlci5bL2VuXVxuICAgKiAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpcmVjdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1cbiAgICogICAgQSBzcGFjZSBzZXBhcmF0ZWQgbGlzdCBvZiBkaXJlY3Rpb25zLiBJZiBtb3JlIHRoYW4gb25lIGRpcmVjdGlvbiBpcyBzcGVjaWZpZWQsXG4gICAqICAgIGl0IHdpbGwgYmUgY2hvc2VuIGF1dG9tYXRpY2FsbHkuIFZhbGlkIGRpcmVjdGlvbnMgYXJlIGBcInVwXCJgLCBgXCJkb3duXCJgLCBgXCJsZWZ0XCJgIGFuZCBgXCJyaWdodFwiYC5cbiAgICogIFsvZW5dXG4gICAqICBbamFdXG4gICAqICAgIOODneODg+ODl+OCquODvOODkOODvOOCkuihqOekuuOBmeOCi+aWueWQkeOCkuepuueZveWMuuWIh+OCiuOBp+ikh+aVsOaMh+WumuOBp+OBjeOBvuOBmeOAglxuICAgKiAgICDmjIflrprjgafjgY3jgovmlrnlkJHjga/jgIFcInVwXCIsIFwiZG93blwiLCBcImxlZnRcIiwgXCJyaWdodFwi44GuNOOBpOOBp+OBmeOAguepuueZveWMuuWIh+OCiuOBp+ikh+aVsOaMh+WumuOBmeOCi+OBk+OBqOOCguOBp+OBjeOBvuOBmeOAglxuICAgKiAgICDopIfmlbDmjIflrprjgZXjgozjgZ/loLTlkIjjgIHlr77osaHjgajjgZnjgovopoHntKDjgavlkIjjgo/jgZvjgabmjIflrprjgZfjgZ/lgKTjgYvjgonoh6rli5XnmoTjgavpgbjmip7jgZXjgozjgb7jgZnjgIJcbiAgICogIFsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGNhbmNlbGFibGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgcG9wb3ZlciBjYW4gYmUgY2xvc2VkIGJ5IHRhcHBpbmcgdGhlIGJhY2tncm91bmQgb3IgYnkgcHJlc3NpbmcgdGhlIGJhY2sgYnV0dG9uLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+OBqOOAgeODneODg+ODl+OCquODvOODkOODvOOBjOihqOekuuOBleOCjOOBn+aZguOBq+OAgeiDjOaZr+OChOODkOODg+OCr+ODnOOCv+ODs+OCkuOCv+ODg+ODl+OBl+OBn+aZguOBq+OCkuODneODg+ODl+OCquODvOODkOODvOmWieOBmOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGNvdmVyLXRhcmdldFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgc2V0IHRoZSBwb3BvdmVyIHdpbGwgY292ZXIgdGhlIHRhcmdldCBvbiB0aGUgc2NyZWVuLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGFuaW1hdGlvbiB1c2VkIHdoZW4gc2hvd2luZyBhbiBoaWRpbmcgdGhlIHBvcG92ZXIuIENhbiBiZSBlaXRoZXIgYFwibm9uZVwiYCwgYFwiZGVmYXVsdFwiYCwgYFwiZmFkZS1pb3NcImAgb3IgYFwiZmFkZS1tZFwiYC5bL2VuXVxuICAgKiAgIFtqYV3jg53jg4Pjg5fjgqrjg7zjg5Djg7zjgpLooajnpLrjgZnjgovpmpvjga7jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb24tb3B0aW9uc1xuICAgKiBAdHlwZSB7RXhwcmVzc2lvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIHRpbWluZyBhbmQgZGVsYXkgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbC4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIHRpbWluZywgZGVsYXnjgpLjgqrjg5bjgrjjgqfjgq/jg4jjg6rjg4bjg6njg6vjgafmjIflrprjgZfjgb7jgZnjgIJlLmcuIHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbWFzay1jb2xvclxuICAgKiBAdHlwZSB7Q29sb3J9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Db2xvciBvZiB0aGUgYmFja2dyb3VuZCBtYXNrLiBEZWZhdWx0IGlzIGBcInJnYmEoMCwgMCwgMCwgMC4yKVwiYC5bL2VuXVxuICAgKiAgIFtqYV3og4zmma/jga7jg57jgrnjgq/jga7oibLjgpLmjIflrprjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga9cInJnYmEoMCwgMCwgMCwgMC4yKVwi44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgZ2V0IF9tYXNrKCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnBvcG92ZXItbWFzaycpO1xuICB9XG5cbiAgZ2V0IF9wb3BvdmVyKCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnBvcG92ZXJfX2NvbnRhaW5lcicpO1xuICB9XG5cbiAgZ2V0IF9jb250ZW50KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLl9wb3BvdmVyLCAnLnBvcG92ZXJfX2NvbnRlbnQnKTtcbiAgfVxuXG4gIGdldCBfYXJyb3coKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMuX3BvcG92ZXIsICcucG9wb3Zlcl9fYXJyb3cnKTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICAgIHRoaXMuX2luaXRBbmltYXRvckZhY3RvcnkoKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2Rvb3JMb2NrID0gbmV3IERvb3JMb2NrKCk7XG4gICAgdGhpcy5fYm91bmRPbkNoYW5nZSA9IHRoaXMuX29uQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fYm91bmRDYW5jZWwgPSB0aGlzLl9jYW5jZWwuYmluZCh0aGlzKTtcbiAgfVxuXG4gIF9pbml0QW5pbWF0b3JGYWN0b3J5KCkge1xuICAgIGNvbnN0IGZhY3RvcnkgPSBuZXcgQW5pbWF0b3JGYWN0b3J5KHtcbiAgICAgIGFuaW1hdG9yczogX2FuaW1hdG9yRGljdCxcbiAgICAgIGJhc2VDbGFzczogUG9wb3ZlckFuaW1hdG9yLFxuICAgICAgYmFzZUNsYXNzTmFtZTogJ1BvcG92ZXJBbmltYXRvcicsXG4gICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJykgfHwgJ2RlZmF1bHQnXG4gICAgfSk7XG4gICAgdGhpcy5fYW5pbWF0b3IgPSAob3B0aW9ucykgPT4gZmFjdG9yeS5uZXdBbmltYXRvcihvcHRpb25zKTtcbiAgfVxuXG4gIF9wb3NpdGlvblBvcG92ZXIodGFyZ2V0KSB7XG4gICAgY29uc3Qge19yYWRpdXM6IHJhZGl1cywgX2NvbnRlbnQ6IGVsLCBfbWFyZ2luOiBtYXJnaW59ID0gdGhpcztcbiAgICBjb25zdCBwb3MgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgaXNNRCA9IHV0aWwuaGFzTW9kaWZpZXIodGhpcywgJ21hdGVyaWFsJyk7XG4gICAgY29uc3QgY292ZXIgPSBpc01EICYmIHRoaXMuaGFzQXR0cmlidXRlKCdjb3Zlci10YXJnZXQnKTtcblxuICAgIGNvbnN0IGRpc3RhbmNlID0ge1xuICAgICAgdG9wOiBwb3MudG9wIC0gbWFyZ2luLFxuICAgICAgbGVmdDogcG9zLmxlZnQgLSBtYXJnaW4sXG4gICAgICByaWdodDogd2luZG93LmlubmVyV2lkdGggLSBwb3MucmlnaHQgLSBtYXJnaW4sXG4gICAgICBib3R0b206IHdpbmRvdy5pbm5lckhlaWdodCAtIHBvcy5ib3R0b20gLSBtYXJnaW5cbiAgICB9O1xuXG4gICAgY29uc3Qge3ZlcnRpY2FsLCBwcmltYXJ5LCBzZWNvbmRhcnl9ID0gdGhpcy5fY2FsY3VsYXRlRGlyZWN0aW9ucyhkaXN0YW5jZSk7XG4gICAgdGhpcy5fcG9wb3Zlci5jbGFzc0xpc3QuYWRkKCdwb3BvdmVyLS0nICsgcHJpbWFyeSk7XG5cbiAgICBjb25zdCBvZmZzZXQgPSBjb3ZlciA/IDAgOiAodmVydGljYWwgPyBwb3MuaGVpZ2h0IDogcG9zLndpZHRoKSArIChpc01EID8gMCA6IDE0KTtcbiAgICB0aGlzLnN0eWxlW3ByaW1hcnldID0gTWF0aC5tYXgoMCwgZGlzdGFuY2VbcHJpbWFyeV0gKyBvZmZzZXQpICsgbWFyZ2luICsgJ3B4JztcbiAgICBlbC5zdHlsZVtwcmltYXJ5XSA9IDA7XG5cbiAgICBjb25zdCBsID0gdmVydGljYWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgY29uc3Qgc2l6ZXMgPSAoc3R5bGUgPT4gKHtcbiAgICAgIHdpZHRoOiBwYXJzZUludChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCd3aWR0aCcpKSxcbiAgICAgIGhlaWdodDogcGFyc2VJbnQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnaGVpZ2h0JykpXG4gICAgfSkpKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKSk7XG5cbiAgICBlbC5zdHlsZVtzZWNvbmRhcnldID0gTWF0aC5tYXgoMCwgZGlzdGFuY2Vbc2Vjb25kYXJ5XSAtIChzaXplc1tsXSAtIHBvc1tsXSkgLyAyKSArICdweCc7XG4gICAgdGhpcy5fYXJyb3cuc3R5bGVbc2Vjb25kYXJ5XSA9IE1hdGgubWF4KHJhZGl1cywgZGlzdGFuY2Vbc2Vjb25kYXJ5XSArIHBvc1tsXSAvIDIpICsgJ3B4JztcblxuICAgIHRoaXMuX3NldFRyYW5zZm9ybU9yaWdpbihkaXN0YW5jZSwgc2l6ZXMsIHBvcywgcHJpbWFyeSk7XG5cbiAgICAvLyBQcmV2ZW50IGFuaW1pdCBmcm9tIHJlc3RvcmluZyB0aGUgc3R5bGUuXG4gICAgZWwucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWFuaW1pdC1vcmlnLXN0eWxlJyk7XG4gIH1cblxuICBfc2V0VHJhbnNmb3JtT3JpZ2luKGRpc3RhbmNlLCBzaXplcywgcG9zLCBwcmltYXJ5KSB7XG4gICAgY29uc3QgY2FsYyA9IChhLCBvLCBsKSA9PiBwcmltYXJ5ID09PSBhID8gc2l6ZXNbbF0gLyAyIDogZGlzdGFuY2VbYV0gKyAocHJpbWFyeSA9PT0gbyA/IC1zaXplc1tsXSA6IHNpemVzW2xdIC0gcG9zW2xdKSAvIDI7XG4gICAgY29uc3QgW3gsIHldID0gW2NhbGMoJ2xlZnQnLCAncmlnaHQnLCAnd2lkdGgnKSArICdweCcsIGNhbGMoJ3RvcCcsICdib3R0b20nLCAnaGVpZ2h0JykgKyAncHgnXTtcbiAgICB1dGlsLmV4dGVuZCh0aGlzLl9wb3BvdmVyLnN0eWxlLCB7XG4gICAgICB0cmFuc2Zvcm1PcmlnaW46IHggKyAnICcgKyB5LFxuICAgICAgd2Via2l0VHJhbnNmb3JtT3JpZ2luWDogeCxcbiAgICAgIHdlYmtpdFRyYW5zZm9ybU9yaWdpblk6IHlcbiAgICB9KTtcbiAgfVxuXG4gIF9jYWxjdWxhdGVEaXJlY3Rpb25zKGRpc3RhbmNlKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9ICh0aGlzLmdldEF0dHJpYnV0ZSgnZGlyZWN0aW9uJykgfHwgJ3VwIGRvd24gbGVmdCByaWdodCcpLnNwbGl0KC9cXHMrLykubWFwKGUgPT4gcG9zaXRpb25zW2VdKTtcbiAgICBjb25zdCBwcmltYXJ5ID0gb3B0aW9ucy5zb3J0KChhLCBiKSA9PiBkaXN0YW5jZVthXSAtIGRpc3RhbmNlW2JdKVswXTtcbiAgICBjb25zdCB2ZXJ0aWNhbCA9IFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocHJpbWFyeSkgIT09IC0xO1xuICAgIGxldCBzZWNvbmRhcnk7XG5cbiAgICBpZiAodmVydGljYWwpIHtcbiAgICAgIHNlY29uZGFyeSA9IGRpc3RhbmNlLmxlZnQgPCBkaXN0YW5jZS5yaWdodCA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlY29uZGFyeSA9IGRpc3RhbmNlLnRvcCA8IGRpc3RhbmNlLmJvdHRvbSA/ICd0b3AnIDogJ2JvdHRvbSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHt2ZXJ0aWNhbCwgcHJpbWFyeSwgc2Vjb25kYXJ5fTtcbiAgfVxuXG4gIF9jbGVhclN0eWxlcygpIHtcbiAgICBbJ3RvcCcsICdib3R0b20nLCAnbGVmdCcsICdyaWdodCddLmZvckVhY2goZSA9PiB7XG4gICAgICB0aGlzLl9hcnJvdy5zdHlsZVtlXSA9IHRoaXMuX2NvbnRlbnQuc3R5bGVbZV0gPSB0aGlzLnN0eWxlW2VdID0gJyc7XG4gICAgICB0aGlzLl9wb3BvdmVyLmNsYXNzTGlzdC5yZW1vdmUoYHBvcG92ZXItLSR7ZX1gKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9vbkNoYW5nZSgpIHtcbiAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX2N1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgdGhpcy5fcG9zaXRpb25Qb3BvdmVyKHRoaXMuX2N1cnJlbnRUYXJnZXQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICBpZiAodGhpcy5jbGFzc0xpc3QuY29udGFpbnMoJ3BvcG92ZXInKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgncG9wb3ZlcicpO1xuXG4gICAgY29uc3QgaGFzRGVmYXVsdENvbnRhaW5lciA9IHRoaXMuX3BvcG92ZXIgJiYgdGhpcy5fY29udGVudDtcblxuICAgIGlmIChoYXNEZWZhdWx0Q29udGFpbmVyKSB7XG5cbiAgICAgIGlmICghdGhpcy5fbWFzaykge1xuICAgICAgICBjb25zdCBtYXNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIG1hc2suY2xhc3NMaXN0LmFkZCgncG9wb3Zlci1tYXNrJyk7XG4gICAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKG1hc2ssIHRoaXMuZmlyc3RDaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5fYXJyb3cpIHtcbiAgICAgICAgY29uc3QgYXJyb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgYXJyb3cuY2xhc3NMaXN0LmFkZCgncG9wb3Zlcl9fYXJyb3cnKTtcbiAgICAgICAgdGhpcy5fcG9wb3Zlci5hcHBlbmRDaGlsZChhcnJvdyk7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRlbXBsYXRlU291cmNlLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB0ZW1wbGF0ZS5xdWVyeVNlbGVjdG9yKCcucG9wb3Zlcl9fY29udGVudCcpO1xuXG4gICAgICB3aGlsZSAodGhpcy5jaGlsZE5vZGVzWzBdKSB7XG4gICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQodGhpcy5jaGlsZE5vZGVzWzBdKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hcHBlbmRDaGlsZCh0ZW1wbGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdzdHlsZScpKSB7XG4gICAgICB0aGlzLl9wb3BvdmVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCB0aGlzLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSk7XG4gICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ21hc2stY29sb3InKSkge1xuICAgICAgdGhpcy5fbWFzay5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLmdldEF0dHJpYnV0ZSgnbWFzay1jb2xvcicpO1xuICAgIH1cblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxuXG4gIF9wcmVwYXJlQW5pbWF0aW9uT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uICYmICEob3B0aW9ucy5hbmltYXRpb24gaW4gX2FuaW1hdG9yRGljdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQW5pbWF0b3IgJHtvcHRpb25zLmFuaW1hdGlvbn0gaXMgbm90IHJlZ2lzdGVyZWQuYCk7XG4gICAgfVxuXG4gICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zID0gdXRpbC5leHRlbmQoXG4gICAgICBBbmltYXRvckZhY3RvcnkucGFyc2VBbmltYXRpb25PcHRpb25zU3RyaW5nKHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpKSxcbiAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fVxuICAgICk7XG4gIH1cblxuICBfZXhlY3V0ZUFjdGlvbihhY3Rpb25zLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2s7XG4gICAgY29uc3Qge2FjdGlvbiwgYmVmb3JlLCBhZnRlcn0gPSBhY3Rpb25zO1xuXG4gICAgdGhpcy5fcHJlcGFyZUFuaW1hdGlvbk9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICBsZXQgY2FuY2VsZWQgPSBmYWxzZTtcbiAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgYHByZSR7YWN0aW9ufWAsIHsgLy8gc3luY2hyb25vdXNcbiAgICAgIHBvcG92ZXI6IHRoaXMsXG4gICAgICBjYW5jZWw6ICgpID0+IGNhbmNlbGVkID0gdHJ1ZVxuICAgIH0pO1xuXG4gICAgaWYgKGNhbmNlbGVkKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoYENhbmNlbGVkIGluIHByZSR7YWN0aW9ufSBldmVudC5gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICB0aGlzLl9kb29yTG9jay53YWl0VW5sb2NrKCgpID0+IHtcbiAgICAgICAgY29uc3QgdW5sb2NrID0gdGhpcy5fZG9vckxvY2subG9jaygpO1xuXG4gICAgICAgIGJlZm9yZSAmJiBiZWZvcmUoKTtcblxuICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX2FuaW1hdG9yKG9wdGlvbnMpW2FjdGlvbl0odGhpcywgKCkgPT4ge1xuICAgICAgICAgICAgYWZ0ZXIgJiYgYWZ0ZXIoKTtcblxuICAgICAgICAgICAgdW5sb2NrKCk7XG5cbiAgICAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCBgcG9zdCR7YWN0aW9ufWAsIHtwb3BvdmVyOiB0aGlzfSk7XG5cbiAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICByZXNvbHZlKHRoaXMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2hvd1xuICAgKiBAc2lnbmF0dXJlIHNob3codGFyZ2V0LCBbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7U3RyaW5nfEV2ZW50fEhUTUxFbGVtZW50fSB0YXJnZXRcbiAgICogICBbZW5dVGFyZ2V0IGVsZW1lbnQuIENhbiBiZSBlaXRoZXIgYSBDU1Mgc2VsZWN0b3IsIGFuIGV2ZW50IG9iamVjdCBvciBhIERPTSBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBruOCv+ODvOOCsuODg+ODiOOBqOOBquOCi+imgee0oOOCkuaMh+WumuOBl+OBvuOBmeOAgkNTU+OCu+ODrOOCr+OCv+OBi2V2ZW5044Kq44OW44K444Kn44Kv44OI44GLRE9N6KaB57Sg44Gu44GE44Ga44KM44GL44KS5rih44Gb44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiAgVXNlIG9uZSBvZiBgXCJmYWRlLWlvc1wiYCwgYFwiZmFkZS1tZFwiYCwgYFwibm9uZVwiYCBhbmQgYFwiZGVmYXVsdFwiYC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcImZhZGUtaW9zXCIsIFwiZmFkZS1tZFwiLCBcIm5vbmVcIiwgXCJkZWZhdWx0XCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXVRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGFmdGVyIHRoZSBwb3BvdmVyIGhhcyBiZWVuIHJldmVhbGVkLlsvZW5dXG4gICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBjOihqOekuuOBleOCjOe1guOCj+OBo+OBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1PcGVuIHRoZSBwb3BvdmVyIGFuZCBwb2ludCBpdCBhdCBhIHRhcmdldC4gVGhlIHRhcmdldCBjYW4gYmUgZWl0aGVyIGFuIGV2ZW50LCBhIENTUyBzZWxlY3RvciBvciBhIERPTSBlbGVtZW50Li5bL2VuXVxuICAgKiAgIFtqYV3lr77osaHjgajjgZnjgovopoHntKDjgavjg53jg4Pjg5fjgqrjg7zjg5Djg7zjgpLooajnpLrjgZfjgb7jgZnjgIJ0YXJnZXTlvJXmlbDjgavjga/jgIEkZXZlbnTjgqrjg5bjgrjjgqfjgq/jg4jjgoRET03jgqjjg6zjg6Hjg7Pjg4jjgoRDU1Pjgrvjg6zjgq/jgr/jgpLmuKHjgZnjgZPjgajjgYzlh7rmnaXjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgZGlzcGxheWVkIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgc2hvdyh0YXJnZXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0IGluc3RhbmNlb2YgRXZlbnQpIHtcbiAgICAgIHRhcmdldCA9IHRhcmdldC50YXJnZXQ7XG4gICAgfVxuICAgIGlmICghKHRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkge1xuICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdGFyZ2V0Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2V4ZWN1dGVBY3Rpb24oe1xuICAgICAgYWN0aW9uOiAnc2hvdycsXG4gICAgICBiZWZvcmU6ICgpID0+IHtcbiAgICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgdGhpcy5fY3VycmVudFRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5fcG9zaXRpb25Qb3BvdmVyKHRhcmdldCk7XG4gICAgICB9XG4gICAgfSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBoaWRlXG4gICAqIEBzaWduYXR1cmUgaGlkZShbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gIFVzZSBvbmUgb2YgYFwiZmFkZS1pb3NcImAsIGBcImZhZGUtbWRcImAsIGBcIm5vbmVcImAgYW5kIGBcImRlZmF1bHRcImAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJmYWRlLWlvc1wiLCBcImZhZGUtbWRcIiwgXCJub25lXCIsIFwiZGVmYXVsdFwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1UaGlzIGZ1bmN0aW9ucyBpcyBjYWxsZWQgYWZ0ZXIgdGhlIHBvcG92ZXIgaGFzIGJlZW4gaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBjOmaoOOCjOOBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DbG9zZSB0aGUgcG9wb3Zlci5bL2VuXVxuICAgKiAgIFtqYV3jg53jg4Pjg5fjgqrjg7zjg5Djg7zjgpLplonjgZjjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgaGlkZGVuIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgaGlkZShvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5fZXhlY3V0ZUFjdGlvbih7XG4gICAgICBhY3Rpb246ICdoaWRlJyxcbiAgICAgIGFmdGVyOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgdGhpcy5fY2xlYXJTdHlsZXMoKTtcbiAgICAgIH1cbiAgICB9LCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmlzaWJsZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIHZpc2libGUgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeimgee0oOOBjOimi+OBiOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBnZXQgdmlzaWJsZSgpIHtcbiAgICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcykuZ2V0UHJvcGVydHlWYWx1ZSgnZGlzcGxheScpICE9PSAnbm9uZSc7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGNhbmNlbGFibGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIEEgYm9vbGVhbiB2YWx1ZSB0aGF0IHNwZWNpZmllcyB3aGV0aGVyIHRoZSBwb3BvdmVyIGlzIGNhbmNlbGFibGUgb3Igbm90LlxuICAgKlxuICAgKiAgICAgV2hlbiB0aGUgcG9wb3ZlciBpcyBjYW5jZWxhYmxlIGl0IGNhbiBiZSBjbG9zZWQgYnkgdGFwcGluZyB0aGUgYmFja2dyb3VuZCBvciBieSBwcmVzc2luZyB0aGUgYmFjayBidXR0b24gb24gQW5kcm9pZCBkZXZpY2VzLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBzZXQgY2FuY2VsYWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnY2FuY2VsYWJsZScsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBjYW5jZWxhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnY2FuY2VsYWJsZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvbkRldmljZUJhY2tCdXR0b25cbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUJhY2stYnV0dG9uIGhhbmRsZXIuWy9lbl1cbiAgICogICBbamFd44OQ44OD44Kv44Oc44K/44Oz44OP44Oz44OJ44Op44CCWy9qYV1cbiAgICovXG4gIGdldCBvbkRldmljZUJhY2tCdXR0b24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyO1xuICB9XG5cbiAgc2V0IG9uRGV2aWNlQmFja0J1dHRvbihjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcikge1xuICAgICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyID0gZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIuY3JlYXRlSGFuZGxlcih0aGlzLCBjYWxsYmFjayk7XG4gIH1cblxuICBfcmVzZXRCYWNrQnV0dG9uSGFuZGxlcigpIHsgLy8gZG8gd2UgbmVlZCB0aGlzIHR3aWNlP1xuICAgIHRoaXMub25EZXZpY2VCYWNrQnV0dG9uID0gZSA9PiB0aGlzLmNhbmNlbGFibGUgPyB0aGlzLl9jYW5jZWwoKSA6IGUuY2FsbFBhcmVudEhhbmRsZXIoKTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX3Jlc2V0QmFja0J1dHRvbkhhbmRsZXIoKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9tYXJnaW4gPSB0aGlzLl9tYXJnaW4gfHwgcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcykuZ2V0UHJvcGVydHlWYWx1ZSgndG9wJykpO1xuICAgICAgdGhpcy5fcmFkaXVzID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5fY29udGVudCkuZ2V0UHJvcGVydHlWYWx1ZSgnYm9yZGVyLXRvcC1sZWZ0LXJhZGl1cycpKTtcblxuICAgICAgdGhpcy5fbWFzay5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kQ2FuY2VsLCBmYWxzZSk7XG5cbiAgICAgIHRoaXMuX3Jlc2V0QmFja0J1dHRvbkhhbmRsZXIoKTtcblxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX2JvdW5kT25DaGFuZ2UsIGZhbHNlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9tYXNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRDYW5jZWwsIGZhbHNlKTtcblxuICAgICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIgPSBudWxsO1xuXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fYm91bmRPbkNoYW5nZSwgZmFsc2UpO1xuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAnZGlyZWN0aW9uJywgJ2FuaW1hdGlvbiddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gJ2RpcmVjdGlvbicpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ib3VuZE9uQ2hhbmdlKCk7XG4gICAgfVxuICAgIGlmIChuYW1lID09PSAnYW5pbWF0aW9uJykge1xuICAgICAgdGhpcy5faW5pdEFuaW1hdG9yRmFjdG9yeSgpO1xuICAgIH1cbiAgfVxuXG5cbiAgX2NhbmNlbCgpIHtcbiAgICBpZiAodGhpcy5jYW5jZWxhYmxlKSB7XG4gICAgICB0aGlzLmhpZGUoe1xuICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnZGlhbG9nLWNhbmNlbCcpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtQb3BvdmVyQW5pbWF0b3J9IEFuaW1hdG9yXG4gICAqL1xuICBzdGF0aWMgcmVnaXN0ZXJBbmltYXRvcihuYW1lLCBBbmltYXRvcikge1xuICAgIGlmICghKEFuaW1hdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIFBvcG92ZXJBbmltYXRvcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJBbmltYXRvclwiIHBhcmFtIG11c3QgaW5oZXJpdCBQb3BvdmVyQW5pbWF0b3InKTtcbiAgICB9XG4gICAgX2FuaW1hdG9yRGljdFtuYW1lXSA9IEFuaW1hdG9yO1xuICB9XG5cbiAgc3RhdGljIGdldCBQb3BvdmVyQW5pbWF0b3IoKSB7XG4gICAgcmV0dXJuIFBvcG92ZXJBbmltYXRvcjtcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1wb3BvdmVyJywgUG9wb3ZlckVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICdvbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJy5wcm9ncmVzcy1iYXInOiAncHJvZ3Jlc3MtYmFyLS0qJyxcbiAgJy5wcm9ncmVzcy1iYXJfX3ByaW1hcnknOiAncHJvZ3Jlc3MtYmFyX19wcmltYXJ5LS0qJyxcbiAgJy5wcm9ncmVzcy1iYXJfX3NlY29uZGFyeSc6ICdwcm9ncmVzcy1iYXJfX3NlY29uZGFyeS0tKidcbn07XG5cbmNvbnN0IHRlbXBsYXRlID0gdXRpbC5jcmVhdGVFbGVtZW50KGBcbiAgPGRpdiBjbGFzcz1cInByb2dyZXNzLWJhclwiPlxuICAgIDxkaXYgY2xhc3M9XCJwcm9ncmVzcy1iYXJfX3NlY29uZGFyeVwiPjwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJwcm9ncmVzcy1iYXJfX3ByaW1hcnlcIj48L2Rpdj5cbiAgPC9kaXY+XG5gKTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtcHJvZ3Jlc3MtYmFyXG4gKiBAY2F0ZWdvcnkgdmlzdWFsXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFRoZSBjb21wb25lbnQgaXMgdXNlZCB0byBkaXNwbGF5IGEgbGluZWFyIHByb2dyZXNzIGJhci4gSXQgY2FuIGVpdGhlciBkaXNwbGF5IGEgcHJvZ3Jlc3MgYmFyIHRoYXQgc2hvd3MgdGhlIHVzZXIgaG93IG11Y2ggb2YgYSB0YXNrIGhhcyBiZWVuIGNvbXBsZXRlZC4gSW4gdGhlIGNhc2Ugd2hlcmUgdGhlIHBlcmNlbnRhZ2UgaXMgbm90IGtub3duIGl0IGNhbiBiZSB1c2VkIHRvIGRpc3BsYXkgYW4gYW5pbWF0ZWQgcHJvZ3Jlc3MgYmFyIHNvIHRoZSB1c2VyIGNhbiBzZWUgdGhhdCBhbiBvcGVyYXRpb24gaXMgaW4gcHJvZ3Jlc3MuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGNvZGVwZW4genZRYkdqXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvcHJvZ3Jlc3NcbiAqIEBzZWVhbHNvIG9ucy1wcm9ncmVzcy1jaXJjdWxhclxuICogICBbZW5dVGhlIGA8b25zLXByb2dyZXNzLWNpcmN1bGFyPmAgY29tcG9uZW50IGRpc3BsYXlzIGEgY2lyY3VsYXIgcHJvZ3Jlc3MgaW5kaWNhdG9yLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtcHJvZ3Jlc3MtYmFyXG4gKiAgdmFsdWU9XCI1NVwiXG4gKiAgc2Vjb25kYXJ5LXZhbHVlPVwiODdcIj5cbiAqIDwvb25zLXByb2dyZXNzLWJhcj5cbiAqXG4gKiA8b25zLXByb2dyZXNzLWJhclxuICogIGluZGV0ZXJtaW5hdGU+XG4gKiA8L29ucy1wcm9ncmVzcy1iYXI+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByb2dyZXNzQmFyRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ2hhbmdlIHRoZSBhcHBlYXJhbmNlIG9mIHRoZSBwcm9ncmVzcyBpbmRpY2F0b3IuWy9lbl1cbiAgICogICBbamFd44OX44Ot44Kw44Os44K544Kk44Oz44K444Kx44O844K/44Gu6KaL44Gf55uu44KS5aSJ5pu044GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgdmFsdWVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgcHJvZ3Jlc3MuIFNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMTAwLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBrumAsuihjOeKtuazgeOBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAgjDjgYvjgokxMDDjga7plpPjga7lgKTjgpLmjIflrprjgZfjgabkuIvjgZXjgYTjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzZWNvbmRhcnktdmFsdWVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgc2Vjb25kYXJ5IHByb2dyZXNzLiBTaG91bGQgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEwMC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7vvJLnlarnm67jga7pgLLooYznirbms4Hjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIIw44GL44KJMTAw44Gu6ZaT44Gu5YCk44KS5oyH5a6a44GX44Gm5LiL44GV44GE44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaW5kZXRlcm1pbmF0ZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0LCBhbiBpbmZpbml0ZSBsb29waW5nIGFuaW1hdGlvbiB3aWxsIGJlIHNob3duLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOioreWumuOBleOCjOOBn+WgtOWQiOOAgeODq+ODvOODl+OBmeOCi+OCouODi+ODoeODvOOCt+ODp+ODs+OBjOihqOekuuOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGluaXQoKSB7XG4gICAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZSgnX2NvbXBpbGVkJykpIHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICd2YWx1ZScsICdzZWNvbmRhcnktdmFsdWUnLCAnaW5kZXRlcm1pbmF0ZSddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3ZhbHVlJyB8fCBuYW1lID09PSAnc2Vjb25kYXJ5LXZhbHVlJykge1xuICAgICAgdGhpcy5fdXBkYXRlVmFsdWUoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdpbmRldGVybWluYXRlJykge1xuICAgICAgdGhpcy5fdXBkYXRlRGV0ZXJtaW5hdGUoKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlRGV0ZXJtaW5hdGUoKSB7XG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdpbmRldGVybWluYXRlJykpIHtcbiAgICAgIHRoaXMuX3RlbXBsYXRlLmNsYXNzTGlzdC5hZGQoYHByb2dyZXNzLWJhci0taW5kZXRlcm1pbmF0ZWApO1xuICAgICAgdGhpcy5fdGVtcGxhdGUuY2xhc3NMaXN0LnJlbW92ZShgcHJvZ3Jlc3MtYmFyLS1kZXRlcm1pbmF0ZWApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuX3RlbXBsYXRlLmNsYXNzTGlzdC5hZGQoYHByb2dyZXNzLWJhci0tZGV0ZXJtaW5hdGVgKTtcbiAgICAgIHRoaXMuX3RlbXBsYXRlLmNsYXNzTGlzdC5yZW1vdmUoYHByb2dyZXNzLWJhci0taW5kZXRlcm1pbmF0ZWApO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVWYWx1ZSgpIHtcbiAgICB0aGlzLl9wcmltYXJ5LnN0eWxlLndpZHRoID0gKHRoaXMuaGFzQXR0cmlidXRlKCd2YWx1ZScpKSA/IHRoaXMuZ2V0QXR0cmlidXRlKCd2YWx1ZScpICsgJyUnIDogJzAlJztcbiAgICB0aGlzLl9zZWNvbmRhcnkuc3R5bGUud2lkdGggPSB0aGlzLmhhc0F0dHJpYnV0ZSgnc2Vjb25kYXJ5LXZhbHVlJykgPyB0aGlzLmdldEF0dHJpYnV0ZSgnc2Vjb25kYXJ5LXZhbHVlJykgKyAnJScgOiAnMCUnO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBwcm9ncmVzcy4gU2hvdWxkIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxMDAuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu6YCy6KGM54q25rOB44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCMOOBi+OCiTEwMOOBrumWk+OBruWApOOCkuaMh+WumuOBl+OBpuS4i+OBleOBhOOAglsvamFdXG4gICAqL1xuICBzZXQgdmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCB2YWx1ZSA8IDAgfHwgdmFsdWUgPiAxMDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZScpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCd2YWx1ZScsIE1hdGguZmxvb3IodmFsdWUpKTtcbiAgfVxuXG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJykgfHwgJzAnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgc2Vjb25kYXJ5VmFsdWVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgc2Vjb25kYXJ5IHByb2dyZXNzLiBTaG91bGQgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEwMC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7vvJLnlarnm67jga7pgLLooYznirbms4Hjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIIw44GL44KJMTAw44Gu6ZaT44Gu5YCk44KS5oyH5a6a44GX44Gm5LiL44GV44GE44CCWy9qYV1cbiAgICovXG4gIHNldCBzZWNvbmRhcnlWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDEwMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3NlY29uZGFyeS12YWx1ZScsIE1hdGguZmxvb3IodmFsdWUpKTtcbiAgfVxuXG4gIGdldCBzZWNvbmRhcnlWYWx1ZSgpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ3NlY29uZGFyeS12YWx1ZScpIHx8ICcwJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGluZGV0ZXJtaW5hdGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIHByb3BlcnR5IGlzIGB0cnVlYCwgYW4gaW5maW5pdGUgbG9vcGluZyBhbmltYXRpb24gd2lsbCBiZSBzaG93bi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzoqK3lrprjgZXjgozjgZ/loLTlkIjjgIHjg6vjg7zjg5fjgZnjgovjgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgYzooajnpLrjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgc2V0IGluZGV0ZXJtaW5hdGUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdpbmRldGVybWluYXRlJywgJycpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdpbmRldGVybWluYXRlJyk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGluZGV0ZXJtaW5hdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdpbmRldGVybWluYXRlJyk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICB0aGlzLl90ZW1wbGF0ZSA9IHRlbXBsYXRlLmNsb25lTm9kZSh0cnVlKTtcblxuICAgIHRoaXMuX3ByaW1hcnkgPSB0aGlzLl90ZW1wbGF0ZS5jaGlsZE5vZGVzWzNdO1xuICAgIHRoaXMuX3NlY29uZGFyeSA9IHRoaXMuX3RlbXBsYXRlLmNoaWxkTm9kZXNbMV07XG5cbiAgICB0aGlzLl91cGRhdGVEZXRlcm1pbmF0ZSgpO1xuICAgIHRoaXMuX3VwZGF0ZVZhbHVlKCk7XG5cbiAgICB0aGlzLmFwcGVuZENoaWxkKHRoaXMuX3RlbXBsYXRlKTtcblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdfY29tcGlsZWQnLCAnJyk7XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtcHJvZ3Jlc3MtYmFyJywgUHJvZ3Jlc3NCYXJFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcucHJvZ3Jlc3MtY2lyY3VsYXInOiAncHJvZ3Jlc3MtY2lyY3VsYXItLSonLFxuICAnLnByb2dyZXNzLWNpcmN1bGFyX19wcmltYXJ5JzogJ3Byb2dyZXNzLWNpcmN1bGFyX19wcmltYXJ5LS0qJyxcbiAgJy5wcm9ncmVzcy1jaXJjdWxhcl9fc2Vjb25kYXJ5JzogJ3Byb2dyZXNzLWNpcmN1bGFyX19zZWNvbmRhcnktLSonXG59O1xuXG5jb25zdCB0ZW1wbGF0ZSA9IHV0aWwuY3JlYXRlRWxlbWVudChgXG4gIDxzdmcgY2xhc3M9XCJwcm9ncmVzcy1jaXJjdWxhclwiPlxuICAgIDxjaXJjbGUgY2xhc3M9XCJwcm9ncmVzcy1jaXJjdWxhcl9fc2Vjb25kYXJ5XCIgY3g9XCI1MCVcIiBjeT1cIjUwJVwiIHI9XCI0MCVcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS13aWR0aD1cIjEwJVwiIHN0cm9rZS1taXRlcmxpbWl0PVwiMTBcIi8+XG4gICAgPGNpcmNsZSBjbGFzcz1cInByb2dyZXNzLWNpcmN1bGFyX19wcmltYXJ5XCIgY3g9XCI1MCVcIiBjeT1cIjUwJVwiIHI9XCI0MCVcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS13aWR0aD1cIjEwJVwiIHN0cm9rZS1taXRlcmxpbWl0PVwiMTBcIi8+XG4gIDwvc3ZnPlxuYCk7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXByb2dyZXNzLWNpcmN1bGFyXG4gKiBAY2F0ZWdvcnkgdmlzdWFsXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFRoaXMgY29tcG9uZW50IGRpc3BsYXlzIGEgY2lyY3VsYXIgcHJvZ3Jlc3MgaW5kaWNhdG9yLiBJdCBjYW4gZWl0aGVyIGJlIHVzZWQgdG8gc2hvdyBob3cgbXVjaCBvZiBhIHRhc2sgaGFzIGJlZW4gY29tcGxldGVkIG9yIHRvIHNob3cgYSBsb29waW5nIGFuaW1hdGlvbiB0byBpbmRpY2F0ZSB0aGF0IGFuIG9wZXJhdGlvbiBpcyBjdXJyZW50bHkgcnVubmluZy5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiBFVnpNalJcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9wcm9ncmVzc1xuICogQHNlZWFsc28gb25zLXByb2dyZXNzLWJhclxuICogICBbZW5dVGhlIGA8b25zLXByb2dyZXNzLWJhcj5gIGNvbXBvbmVudCBkaXNwbGF5cyBhIGJhciBwcm9ncmVzcyBpbmRpY2F0b3IuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1wcm9ncmVzcy1jaXJjdWxhclxuICogIHZhbHVlPVwiNTVcIlxuICogIHNlY29uZGFyeS12YWx1ZT1cIjg3XCI+XG4gKiA8L29ucy1wcm9ncmVzcy1jaXJjdWxhcj5cbiAqXG4gKiA8b25zLXByb2dyZXNzLWNpcmN1bGFyXG4gKiAgaW5kZXRlcm1pbmF0ZT5cbiAqIDwvb25zLXByb2dyZXNzLWNpcmN1bGFyPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcm9ncmVzc0NpcmN1bGFyRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ2hhbmdlIHRoZSBhcHBlYXJhbmNlIG9mIHRoZSBwcm9ncmVzcyBpbmRpY2F0b3IuWy9lbl1cbiAgICogICBbamFd44OX44Ot44Kw44Os44K544Kk44Oz44K444Kx44O844K/44Gu6KaL44Gf55uu44KS5aSJ5pu044GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgdmFsdWVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgcHJvZ3Jlc3MuIFNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMTAwLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBrumAsuihjOeKtuazgeOBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAgjDjgYvjgokxMDDjga7plpPjga7lgKTjgpLmjIflrprjgZfjgabkuIvjgZXjgYTjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzZWNvbmRhcnktdmFsdWVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgc2Vjb25kYXJ5IHByb2dyZXNzLiBTaG91bGQgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEwMC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7vvJLnlarnm67jga7pgLLooYznirbms4Hjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIIw44GL44KJMTAw44Gu6ZaT44Gu5YCk44KS5oyH5a6a44GX44Gm5LiL44GV44GE44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaW5kZXRlcm1pbmF0ZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0LCBhbiBpbmZpbml0ZSBsb29waW5nIGFuaW1hdGlvbiB3aWxsIGJlIHNob3duLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOioreWumuOBleOCjOOBn+WgtOWQiOOAgeODq+ODvOODl+OBmeOCi+OCouODi+ODoeODvOOCt+ODp+ODs+OBjOihqOekuuOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGluaXQoKSB7XG4gICAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZSgnX2NvbXBpbGVkJykpIHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICd2YWx1ZScsICdzZWNvbmRhcnktdmFsdWUnLCAnaW5kZXRlcm1pbmF0ZSddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3ZhbHVlJyB8fCBuYW1lID09PSAnc2Vjb25kYXJ5LXZhbHVlJykge1xuICAgICAgdGhpcy5fdXBkYXRlVmFsdWUoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdpbmRldGVybWluYXRlJykge1xuICAgICAgdGhpcy5fdXBkYXRlRGV0ZXJtaW5hdGUoKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlRGV0ZXJtaW5hdGUoKSB7XG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdpbmRldGVybWluYXRlJykpIHtcbiAgICAgIHRoaXMuX3RlbXBsYXRlLmNsYXNzTGlzdC5hZGQoYHByb2dyZXNzLWNpcmN1bGFyLS1pbmRldGVybWluYXRlYCk7XG4gICAgICB0aGlzLl90ZW1wbGF0ZS5jbGFzc0xpc3QucmVtb3ZlKGBwcm9ncmVzcy1jaXJjdWxhci0tZGV0ZXJtaW5hdGVgKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLl90ZW1wbGF0ZS5jbGFzc0xpc3QuYWRkKGBwcm9ncmVzcy1jaXJjdWxhci0tZGV0ZXJtaW5hdGVgKTtcbiAgICAgIHRoaXMuX3RlbXBsYXRlLmNsYXNzTGlzdC5yZW1vdmUoYHByb2dyZXNzLWNpcmN1bGFyLS1pbmRldGVybWluYXRlYCk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZVZhbHVlKCkge1xuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgndmFsdWUnKSkge1xuICAgICAgY29uc3QgcGVyID0gTWF0aC5jZWlsKHRoaXMuZ2V0QXR0cmlidXRlKCd2YWx1ZScpICogMjUxLjMyICogMC4wMSk7XG4gICAgICB0aGlzLl9wcmltYXJ5LnN0eWxlWydzdHJva2UtZGFzaGFycmF5J10gPSBwZXIgKyAnJSwgMjUxLjMyJSc7XG4gICAgfVxuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnc2Vjb25kYXJ5LXZhbHVlJykpIHtcbiAgICAgIGNvbnN0IHBlciA9ICBNYXRoLmNlaWwodGhpcy5nZXRBdHRyaWJ1dGUoJ3NlY29uZGFyeS12YWx1ZScpICogMjUxLjMyICogMC4wMSk7XG4gICAgICB0aGlzLl9zZWNvbmRhcnkuc3R5bGVbJ3N0cm9rZS1kYXNoYXJyYXknXSA9IHBlciArICclLCAyNTEuMzIlJztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZhbHVlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DdXJyZW50IHByb2dyZXNzLiBTaG91bGQgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEwMC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7pgLLooYznirbms4Hjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIIw44GL44KJMTAw44Gu6ZaT44Gu5YCk44KS5oyH5a6a44GX44Gm5LiL44GV44GE44CCWy9qYV1cbiAgICovXG4gIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDEwMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgTWF0aC5mbG9vcih2YWx1ZSkpO1xuICB9XG5cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiBwYXJzZUludCh0aGlzLmdldEF0dHJpYnV0ZSgndmFsdWUnKSB8fCAnMCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBzZWNvbmRhcnlWYWx1ZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBzZWNvbmRhcnkgcHJvZ3Jlc3MuIFNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMTAwLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBru+8kueVquebruOBrumAsuihjOeKtuazgeOBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAgjDjgYvjgokxMDDjga7plpPjga7lgKTjgpLmjIflrprjgZfjgabkuIvjgZXjgYTjgIJbL2phXVxuICAgKi9cbiAgc2V0IHNlY29uZGFyeVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgdmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmFsdWUnKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnc2Vjb25kYXJ5LXZhbHVlJywgTWF0aC5mbG9vcih2YWx1ZSkpO1xuICB9XG5cbiAgZ2V0IHNlY29uZGFyeVZhbHVlKCkge1xuICAgIHJldHVybiBwYXJzZUludCh0aGlzLmdldEF0dHJpYnV0ZSgnc2Vjb25kYXJ5LXZhbHVlJykgfHwgJzAnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgaW5kZXRlcm1pbmF0ZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgcHJvcGVydHkgaXMgYHRydWVgLCBhbiBpbmZpbml0ZSBsb29waW5nIGFuaW1hdGlvbiB3aWxsIGJlIHNob3duLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOioreWumuOBleOCjOOBn+WgtOWQiOOAgeODq+ODvOODl+OBmeOCi+OCouODi+ODoeODvOOCt+ODp+ODs+OBjOihqOekuuOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuICBzZXQgaW5kZXRlcm1pbmF0ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2luZGV0ZXJtaW5hdGUnLCAnJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ2luZGV0ZXJtaW5hdGUnKTtcbiAgICB9XG4gIH1cblxuICBnZXQgaW5kZXRlcm1pbmF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2luZGV0ZXJtaW5hdGUnKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIHRoaXMuX3RlbXBsYXRlID0gdGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpO1xuXG4gICAgdGhpcy5fcHJpbWFyeSA9IHRoaXMuX3RlbXBsYXRlLmNoaWxkTm9kZXNbM107XG4gICAgdGhpcy5fc2Vjb25kYXJ5ID0gdGhpcy5fdGVtcGxhdGUuY2hpbGROb2Rlc1sxXTtcblxuICAgIHRoaXMuX3VwZGF0ZURldGVybWluYXRlKCk7XG4gICAgdGhpcy5fdXBkYXRlVmFsdWUoKTtcblxuICAgIHRoaXMuYXBwZW5kQ2hpbGQodGhpcy5fdGVtcGxhdGUpO1xuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ19jb21waWxlZCcsICcnKTtcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1wcm9ncmVzcy1jaXJjdWxhcicsIFByb2dyZXNzQ2lyY3VsYXJFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICdvbnMvcGxhdGZvcm0nO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IEdlc3R1cmVEZXRlY3RvciBmcm9tICdvbnMvZ2VzdHVyZS1kZXRlY3Rvcic7XG5cbmNvbnN0IFNUQVRFX0lOSVRJQUwgPSAnaW5pdGlhbCc7XG5jb25zdCBTVEFURV9QUkVBQ1RJT04gPSAncHJlYWN0aW9uJztcbmNvbnN0IFNUQVRFX0FDVElPTiA9ICdhY3Rpb24nO1xuXG5jb25zdCByZW1vdmVUcmFuc2Zvcm0gPSAoZWwpID0+IHtcbiAgZWwuc3R5bGUudHJhbnNmb3JtID0gJyc7XG4gIGVsLnN0eWxlLldlYmtpdFRyYW5zZm9ybSA9ICcnO1xuICBlbC5zdHlsZS50cmFuc2l0aW9uID0gJyc7XG4gIGVsLnN0eWxlLldlYmtpdFRyYW5zaXRpb24gPSAnJztcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXB1bGwtaG9va1xuICogQGNhdGVnb3J5IGNvbnRyb2xcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgQ29tcG9uZW50IHRoYXQgYWRkcyAqKlB1bGwgdG8gcmVmcmVzaCoqIGZ1bmN0aW9uYWxpdHkgdG8gYW4gYDxvbnMtcGFnZT5gIGVsZW1lbnQuXG4gKlxuICogICAgIEl0IGNhbiBiZSB1c2VkIHRvIHBlcmZvcm0gYSB0YXNrIHdoZW4gdGhlIHVzZXIgcHVsbHMgZG93biBhdCB0aGUgdG9wIG9mIHRoZSBwYWdlLiBBIGNvbW1vbiB1c2FnZSBpcyB0byByZWZyZXNoIHRoZSBkYXRhIGRpc3BsYXllZCBpbiBhIHBhZ2UuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGNvZGVwZW4gV2JKb2dNXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvcHVsbC1ob29rXG4gKiBAZXhhbXBsZVxuICogPG9ucy1wYWdlPlxuICogICA8b25zLXB1bGwtaG9vaz5cbiAqICAgICBSZWxlYXNlIHRvIHJlZnJlc2hcbiAqICAgPC9vbnMtcHVsbC1ob29rPlxuICogPC9vbnMtcGFnZT5cbiAqXG4gKiA8c2NyaXB0PlxuICogICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdvbnMtcHVsbC1ob29rJykub25BY3Rpb24gPSBmdW5jdGlvbihkb25lKSB7XG4gKiAgICAgc2V0VGltZW91dChkb25lLCAxMDAwKTtcbiAqICAgfTtcbiAqIDwvc2NyaXB0PlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQdWxsSG9va0VsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBjaGFuZ2VzdGF0ZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQgd2hlbiB0aGUgc3RhdGUgaXMgY2hhbmdlZC4gVGhlIHN0YXRlIGNhbiBiZSBlaXRoZXIgXCJpbml0aWFsXCIsIFwicHJlYWN0aW9uXCIgb3IgXCJhY3Rpb25cIi5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7nirbmhYvjgYzlpInjgo/jgaPjgZ/loLTlkIjjgavnmbrngavjgZfjgb7jgZnjgILnirbmhYvjga/jgIFcImluaXRpYWxcIiwgXCJwcmVhY3Rpb25cIiwgXCJhY3Rpb25cIuOBruOBhOOBmuOCjOOBi+OBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnB1bGxIb29rXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50LnN0YXRlXG4gICAqICAgW2VuXUN1cnJlbnQgc3RhdGUuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu54q25oWL5ZCN44KS5Y+C54Wn44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgXCJwdWxsLXRvLXJlZnJlc2hcIiBmdW5jdGlvbmFsaXR5IGlzIGRpc2FibGVkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgWRpc2FibGVk54q25oWL44Gr44Gq44KK44Ki44Kv44K344On44Oz44GM5a6f6KGM44GV44KM44Gq44GP44Gq44KK44G+44GZWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaGVpZ2h0XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBoZWlnaHQgb2YgdGhlIGNvbXBvbmVudC4gV2hlbiBwdWxsZWQgZG93biBmdXJ0aGVyIHRoYW4gdGhpcyB2YWx1ZSBpdCB3aWxsIHN3aXRjaCB0byB0aGUgXCJwcmVhY3Rpb25cIiBzdGF0ZS4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgXCI2NHB4XCIuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu6auY44GV44KS5oyH5a6a44GX44G+44GZ44CC44GT44Gu6auY44GV5Lul5LiK44GrcHVsbCBkb3du44GZ44KL44GoXCJwcmVhY3Rpb25cIueKtuaFi+OBq+enu+ihjOOBl+OBvuOBmeOAguODh+ODleOCqeODq+ODiOOBruWApOOBr1wiNjRweFwi44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgdGhyZXNob2xkLWhlaWdodFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgdGhyZXNob2xkIGhlaWdodC4gVGhlIGNvbXBvbmVudCBhdXRvbWF0aWNhbGx5IHN3aXRjaGVzIHRvIHRoZSBcImFjdGlvblwiIHN0YXRlIHdoZW4gcHVsbGVkIGZ1cnRoZXIgdGhhbiB0aGlzIHZhbHVlLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBcIjk2cHhcIi4gQSBuZWdhdGl2ZSB2YWx1ZSBvciBhIHZhbHVlIGxlc3MgdGhhbiB0aGUgaGVpZ2h0IHdpbGwgZGlzYWJsZSB0aGlzIHByb3BlcnR5LlsvZW5dXG4gICAqICAgW2phXemWvuWApOOBqOOBquOCi+mrmOOBleOCkuaMh+WumuOBl+OBvuOBmeOAguOBk+OBruWApOOBp+aMh+WumuOBl+OBn+mrmOOBleOCiOOCiuOCgnB1bGwgZG93buOBmeOCi+OBqOOAgeOBk+OBruOCs+ODs+ODneODvOODjeODs+ODiOOBr+iHquWLleeahOOBq1wiYWN0aW9uXCLnirbmhYvjgavnp7vooYzjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBmaXhlZC1jb250ZW50XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNvbnRlbnQgb2YgdGhlIHBhZ2Ugd2lsbCBub3QgbW92ZSB3aGVuIHB1bGxpbmcuWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CB44OX44Or44OV44OD44Kv44GM5byV44GN5Ye644GV44KM44Gm44GE44KL5pmC44Gr44KC44Kz44Oz44OG44Oz44OE44Gv5YuV44GN44G+44Gb44KT44CCWy9qYV1cbiAgICovXG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLl9ib3VuZE9uRHJhZyA9IHRoaXMuX29uRHJhZy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kT25EcmFnU3RhcnQgPSB0aGlzLl9vbkRyYWdTdGFydC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kT25EcmFnRW5kID0gdGhpcy5fb25EcmFnRW5kLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fYm91bmRPblNjcm9sbCA9IHRoaXMuX29uU2Nyb2xsLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLl9zZXRTdGF0ZShTVEFURV9JTklUSUFMLCB0cnVlKTtcbiAgfVxuXG4gIF9zZXRTdHlsZSgpIHtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmhlaWdodDtcblxuICAgIHRoaXMuc3R5bGUuaGVpZ2h0ID0gYCR7aGVpZ2h0fXB4YDtcbiAgICB0aGlzLnN0eWxlLmxpbmVIZWlnaHQgPSBgJHtoZWlnaHR9cHhgO1xuICAgIHRoaXMuc3R5bGUubWFyZ2luVG9wID0gJy0xcHgnO1xuICAgIHRoaXMuX3BhZ2VFbGVtZW50LnN0eWxlLm1hcmdpblRvcCA9IGAtJHtoZWlnaHR9cHhgO1xuICB9XG5cbiAgX29uU2Nyb2xsKGV2ZW50KSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX3BhZ2VFbGVtZW50O1xuXG4gICAgaWYgKGVsZW1lbnQuc2Nyb2xsVG9wIDwgMCkge1xuICAgICAgZWxlbWVudC5zY3JvbGxUb3AgPSAwO1xuICAgIH1cbiAgfVxuXG4gIF9nZW5lcmF0ZVRyYW5zbGF0aW9uVHJhbnNmb3JtKHNjcm9sbCkge1xuICAgIHJldHVybiBgdHJhbnNsYXRlM2QoMHB4LCAke3Njcm9sbH1weCwgMHB4KWA7XG4gIH1cblxuICBfb25EcmFnKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBIYWNrIHRvIG1ha2UgaXQgd29yayBvbiBBbmRyb2lkIDQuNCBXZWJWaWV3LiBTY3JvbGxzIG1hbnVhbGx5IG5lYXIgdGhlIHRvcCBvZiB0aGUgcGFnZSBzb1xuICAgIC8vIHRoZXJlIHdpbGwgYmUgbm8gaW5lcnRpYWwgc2Nyb2xsIHdoZW4gc2Nyb2xsaW5nIGRvd24uIEFsbG93aW5nIGRlZmF1bHQgc2Nyb2xsaW5nIHdpbGxcbiAgICAvLyBraWxsIGFsbCAndG91Y2htb3ZlJyBldmVudHMuXG4gICAgaWYgKHBsYXRmb3JtLmlzQW5kcm9pZCgpKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fcGFnZUVsZW1lbnQ7XG4gICAgICBlbGVtZW50LnNjcm9sbFRvcCA9IHRoaXMuX3N0YXJ0U2Nyb2xsIC0gZXZlbnQuZ2VzdHVyZS5kZWx0YVk7XG4gICAgICBpZiAoZWxlbWVudC5zY3JvbGxUb3AgPCB3aW5kb3cuaW5uZXJIZWlnaHQgJiYgZXZlbnQuZ2VzdHVyZS5kaXJlY3Rpb24gIT09ICd1cCcpIHtcbiAgICAgICAgZXZlbnQuZ2VzdHVyZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9jdXJyZW50VHJhbnNsYXRpb24gPT09IDAgJiYgdGhpcy5fZ2V0Q3VycmVudFNjcm9sbCgpID09PSAwKSB7XG4gICAgICB0aGlzLl90cmFuc2l0aW9uRHJhZ0xlbmd0aCA9IGV2ZW50Lmdlc3R1cmUuZGVsdGFZO1xuXG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSBldmVudC5nZXN0dXJlLmludGVyaW1EaXJlY3Rpb247XG4gICAgICBpZiAoZGlyZWN0aW9uID09PSAnZG93bicpIHtcbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvbkRyYWdMZW5ndGggLT0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25EcmFnTGVuZ3RoICs9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc2Nyb2xsID0gTWF0aC5tYXgoZXZlbnQuZ2VzdHVyZS5kZWx0YVkgLSB0aGlzLl9zdGFydFNjcm9sbCwgMCk7XG5cbiAgICBpZiAodGhpcy5fdGhyZXNob2xkSGVpZ2h0RW5hYmxlZCgpICYmIHNjcm9sbCA+PSB0aGlzLnRocmVzaG9sZEhlaWdodCkge1xuICAgICAgZXZlbnQuZ2VzdHVyZS5zdG9wRGV0ZWN0KCk7XG5cbiAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLl9maW5pc2goKSk7XG4gICAgfSBlbHNlIGlmIChzY3JvbGwgPj0gdGhpcy5oZWlnaHQpIHtcbiAgICAgIHRoaXMuX3NldFN0YXRlKFNUQVRFX1BSRUFDVElPTik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NldFN0YXRlKFNUQVRFX0lOSVRJQUwpO1xuICAgIH1cblxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHRoaXMuX3RyYW5zbGF0ZVRvKHNjcm9sbCk7XG4gIH1cblxuICBfb25EcmFnU3RhcnQoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3N0YXJ0U2Nyb2xsID0gdGhpcy5fZ2V0Q3VycmVudFNjcm9sbCgpO1xuICB9XG5cbiAgX29uRHJhZ0VuZChldmVudCkge1xuICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2N1cnJlbnRUcmFuc2xhdGlvbiA+IDApIHtcbiAgICAgIGNvbnN0IHNjcm9sbCA9IHRoaXMuX2N1cnJlbnRUcmFuc2xhdGlvbjtcblxuICAgICAgaWYgKHNjcm9sbCA+IHRoaXMuaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuX2ZpbmlzaCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fdHJhbnNsYXRlVG8oMCwge2FuaW1hdGU6IHRydWV9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9uQWN0aW9uXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoaXMgd2lsbCBiZSBjYWxsZWQgaW4gdGhlIGBhY3Rpb25gIHN0YXRlIGlmIGl0IGV4aXN0cy4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgZ2l2ZW4gYSBgZG9uZWAgY2FsbGJhY2sgYXMgaXQncyBmaXJzdCBhcmd1bWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICBfZmluaXNoKCkge1xuICAgIHRoaXMuX3NldFN0YXRlKFNUQVRFX0FDVElPTik7XG4gICAgdGhpcy5fdHJhbnNsYXRlVG8odGhpcy5oZWlnaHQsIHthbmltYXRlOiB0cnVlfSk7XG4gICAgY29uc3QgYWN0aW9uID0gdGhpcy5vbkFjdGlvbiB8fCAoZG9uZSA9PiBkb25lKCkpO1xuICAgIGFjdGlvbigoKSA9PiB7XG4gICAgICB0aGlzLl90cmFuc2xhdGVUbygwLCB7YW5pbWF0ZTogdHJ1ZX0pO1xuICAgICAgdGhpcy5fc2V0U3RhdGUoU1RBVEVfSU5JVElBTCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGhlaWdodFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGhlaWdodCBvZiB0aGUgcHVsbCBob29rIGluIHBpeGVscy4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgYDY0cHhgLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBzZXQgaGVpZ2h0KHZhbHVlKSB7XG4gICAgaWYgKCF1dGlsLmlzSW50ZWdlcih2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGhlaWdodCBtdXN0IGJlIGFuIGludGVnZXInKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgYCR7dmFsdWV9cHhgKTtcbiAgfVxuXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSB8fCAnNjQnLCAxMCk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHRocmVzaG9sZEhlaWdodFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIHRocmVzaG9sZEhlaWdodCBvZiB0aGUgcHVsbCBob29rIGluIHBpeGVscy4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgYDk2cHhgLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBzZXQgdGhyZXNob2xkSGVpZ2h0KHZhbHVlKSB7XG4gICAgaWYgKCF1dGlsLmlzSW50ZWdlcih2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHRocmVzaG9sZCBoZWlnaHQgbXVzdCBiZSBhbiBpbnRlZ2VyJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3RocmVzaG9sZC1oZWlnaHQnLCBgJHt2YWx1ZX1weGApO1xuICB9XG5cbiAgZ2V0IHRocmVzaG9sZEhlaWdodCgpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ3RocmVzaG9sZC1oZWlnaHQnKSB8fCAnOTYnLCAxMCk7XG4gIH1cblxuICBfdGhyZXNob2xkSGVpZ2h0RW5hYmxlZCgpIHtcbiAgICBjb25zdCB0aCA9IHRoaXMudGhyZXNob2xkSGVpZ2h0O1xuICAgIHJldHVybiB0aCA+IDAgJiYgdGggPj0gdGhpcy5oZWlnaHQ7XG4gIH1cblxuICBfc2V0U3RhdGUoc3RhdGUsIG5vRXZlbnQpIHtcbiAgICBjb25zdCBsYXN0U3RhdGUgPSB0aGlzLl9nZXRTdGF0ZSgpO1xuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3N0YXRlJywgc3RhdGUpO1xuXG4gICAgaWYgKCFub0V2ZW50ICYmIGxhc3RTdGF0ZSAhPT0gdGhpcy5fZ2V0U3RhdGUoKSkge1xuICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdjaGFuZ2VzdGF0ZScsIHtcbiAgICAgICAgcHVsbEhvb2s6IHRoaXMsXG4gICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgbGFzdFN0YXRlOiBsYXN0U3RhdGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIF9nZXRTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ3N0YXRlJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHN0YXRlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBzdGF0ZSBvZiB0aGUgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgZ2V0IHN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRTdGF0ZSgpO1xuICB9XG5cbiAgX2dldEN1cnJlbnRTY3JvbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VFbGVtZW50LnNjcm9sbFRvcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgcHVsbERpc3RhbmNlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGN1cnJlbnQgbnVtYmVyIG9mIHBpeGVscyB0aGUgcHVsbCBob29rIGhhcyBtb3ZlZC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7jg5fjg6vjg5Xjg4Pjgq/jgYzlvJXjgY3lh7rjgZXjgozjgZ/ot53pm6LjgpLjg5Tjgq/jgrvjg6vmlbDjgIJbL2phXVxuICAgKi9cbiAgZ2V0IHB1bGxEaXN0YW5jZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFRyYW5zbGF0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdmFsdWUpO1xuICB9XG5cbiAgZ2V0IGRpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgfVxuXG4gIF9pc0NvbnRlbnRGaXhlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2ZpeGVkLWNvbnRlbnQnKTtcbiAgfVxuXG4gIF9nZXRTY3JvbGxhYmxlRWxlbWVudCgpIHtcbiAgICBpZiAodGhpcy5faXNDb250ZW50Rml4ZWQoKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYWdlRWxlbWVudDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNjcm9sbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICovXG4gIF90cmFuc2xhdGVUbyhzY3JvbGwsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh0aGlzLl9jdXJyZW50VHJhbnNsYXRpb24gPT0gMCAmJiBzY3JvbGwgPT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGRvbmUgPSAoKSA9PiB7XG4gICAgICBpZiAoc2Nyb2xsID09PSAwKSB7XG4gICAgICAgIGNvbnN0IGVsID0gdGhpcy5fZ2V0U2Nyb2xsYWJsZUVsZW1lbnQoKTtcbiAgICAgICAgcmVtb3ZlVHJhbnNmb3JtKGVsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuY2FsbGJhY2spIHtcbiAgICAgICAgb3B0aW9ucy5jYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLl9jdXJyZW50VHJhbnNsYXRpb24gPSBzY3JvbGw7XG5cbiAgICBpZiAob3B0aW9ucy5hbmltYXRlKSB7XG4gICAgICBhbmltaXQodGhpcy5fZ2V0U2Nyb2xsYWJsZUVsZW1lbnQoKSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06IHRoaXMuX2dlbmVyYXRlVHJhbnNsYXRpb25UcmFuc2Zvcm0oc2Nyb2xsKVxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IDAuMyxcbiAgICAgICAgICB0aW1pbmc6ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuMSwgMSknXG4gICAgICAgIH0pXG4gICAgICAgIC5wbGF5KGRvbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbmltaXQodGhpcy5fZ2V0U2Nyb2xsYWJsZUVsZW1lbnQoKSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06IHRoaXMuX2dlbmVyYXRlVHJhbnNsYXRpb25UcmFuc2Zvcm0oc2Nyb2xsKVxuICAgICAgICB9KVxuICAgICAgICAucGxheShkb25lKTtcbiAgICB9XG4gIH1cblxuICBfZGlzYWJsZURyYWdMb2NrKCkgeyAvLyBlMmUgdGVzdHMgbmVlZCBpdFxuICAgIHRoaXMuX2RyYWdMb2NrRGlzYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMuX2Rlc3Ryb3lFdmVudExpc3RlbmVycygpO1xuICAgIHRoaXMuX2NyZWF0ZUV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cblxuICBfY3JlYXRlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yID0gbmV3IEdlc3R1cmVEZXRlY3Rvcih0aGlzLl9wYWdlRWxlbWVudCwge1xuICAgICAgZHJhZ01pbkRpc3RhbmNlOiAxLFxuICAgICAgZHJhZ0Rpc3RhbmNlQ29ycmVjdGlvbjogZmFsc2UsXG4gICAgICBkcmFnTG9ja1RvQXhpczogIXRoaXMuX2RyYWdMb2NrRGlzYWJsZWRcbiAgICB9KTtcblxuICAgIC8vIEJpbmQgbGlzdGVuZXJzXG4gICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yLm9uKCdkcmFndXAgZHJhZ2Rvd24nLCB0aGlzLl9ib3VuZE9uRHJhZyk7XG4gICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yLm9uKCdkcmFnc3RhcnQnLCB0aGlzLl9ib3VuZE9uRHJhZ1N0YXJ0KTtcbiAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3Iub24oJ2RyYWdlbmQnLCB0aGlzLl9ib3VuZE9uRHJhZ0VuZCk7XG5cbiAgICB0aGlzLl9wYWdlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9ib3VuZE9uU2Nyb2xsLCBmYWxzZSk7XG4gIH1cblxuICBfZGVzdHJveUV2ZW50TGlzdGVuZXJzKCkge1xuICAgIGlmICh0aGlzLl9nZXN0dXJlRGV0ZWN0b3IpIHtcbiAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5vZmYoJ2RyYWd1cCBkcmFnZG93bicsIHRoaXMuX2JvdW5kT25EcmFnKTtcbiAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5vZmYoJ2RyYWdzdGFydCcsIHRoaXMuX2JvdW5kT25EcmFnU3RhcnQpO1xuICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yLm9mZignZHJhZ2VuZCcsIHRoaXMuX2JvdW5kT25EcmFnRW5kKTtcblxuICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3RvciA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5fcGFnZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fYm91bmRPblNjcm9sbCwgZmFsc2UpO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fY3VycmVudFRyYW5zbGF0aW9uID0gMDtcbiAgICB0aGlzLl9wYWdlRWxlbWVudCA9IHRoaXMucGFyZW50Tm9kZTtcblxuICAgIHRoaXMuX2NyZWF0ZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgdGhpcy5fc2V0U3R5bGUoKTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX3BhZ2VFbGVtZW50LnN0eWxlLm1hcmdpblRvcCA9ICcnO1xuXG4gICAgdGhpcy5fZGVzdHJveUV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydoZWlnaHQnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdoZWlnaHQnKSB7XG4gICAgICB0aGlzLl9zZXRTdHlsZSgpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXQgU1RBVEVfSU5JVElBTCgpIHtcbiAgICByZXR1cm4gU1RBVEVfSU5JVElBTDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgU1RBVEVfUFJFQUNUSU9OKCkge1xuICAgIHJldHVybiBTVEFURV9QUkVBQ1RJT047XG4gIH1cblxuICBzdGF0aWMgZ2V0IFNUQVRFX0FDVElPTigpIHtcbiAgICByZXR1cm4gU1RBVEVfQUNUSU9OO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXB1bGwtaG9vaycsIFB1bGxIb29rRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNiBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnb25zL2ludGVybmFsJztcblxuLyoqXG4gKiBAY2xhc3MgQW5pbWF0b3JDU1MgLSBpbXBsZW1lbnRhdGlvbiBvZiBBbmltYXRvciBjbGFzcyB1c2luZyBjc3MgdHJhbnNpdGlvbnNcbiAqL1xuY2xhc3MgQW5pbWF0b3JDU1Mge1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGFuaW1hdGVcbiAgICogQGRlc2MgbWFpbiBhbmltYXRpb24gZnVuY3Rpb25cbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmaW5hbENTU1xuICAgKiBAcGFyYW0ge251bWJlcn0gW2R1cmF0aW9uPTIwMF0gLSBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHNcbiAgICogQHJldHVybiB7T2JqZWN0fSByZXN1bHRcbiAgICogQHJldHVybiB7RnVuY3Rpb259IHJlc3VsdC50aGVuKGNhbGxiYWNrKSAtIHNldHMgYSBjYWxsYmFjayB0byBiZSBleGVjdXRlZCBhZnRlciB0aGUgYW5pbWF0aW9uIGhhcyBzdG9wcGVkXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSByZXN1bHQuc3RvcChvcHRpb25zKSAtIHN0b3BzIHRoZSBhbmltYXRpb247IGlmIG9wdGlvbnMuc3RvcE5leHQgaXMgdHJ1ZSB0aGVuIGl0IGRvZXNuJ3QgY2FsbCB0aGUgY2FsbGJhY2tcbiAgICogQHJldHVybiB7RnVuY3Rpb259IHJlc3VsdC5maW5pc2gobXMpIC0gZmluaXNoZXMgdGhlIGFuaW1hdGlvbiBpbiB0aGUgc3BlY2lmaWVkIHRpbWUgaW4gbWlsbGlzZWNvbmRzXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSByZXN1bHQuc3BlZWQobXMpIC0gc2V0cyB0aGUgYW5pbWF0aW9uIHNwZWVkIHNvIHRoYXQgaXQgZmluaXNoZXMgYXMgaWYgdGhlIG9yaWdpbmFsIGR1cmF0aW9uIHdhcyB0aGUgb25lIHNwZWNpZmllZCBoZXJlXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGBcbiAgICogIHZhciByZXN1bHQgPSBhbmltYXRvci5hbmltYXRlKGVsLCB7b3BhY2l0eTogMC41fSwgMTAwMCk7XG4gICAqXG4gICAqICBlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGUpe1xuICAgKiAgICByZXN1bHQuc3BlZWQoMjAwKS50aGVuKGZ1bmN0aW9uKCl7XG4gICAqICAgICAgY29uc29sZS5sb2coJ2RvbmUnKTtcbiAgICogICAgfSk7XG4gICAqICB9LCAzMDApO1xuICAgKiBgYGBgXG4gICAqL1xuICBhbmltYXRlKGVsLCBmaW5hbCwgZHVyYXRpb24gPSAyMDApIHtcbiAgICB2YXIgc3RhcnQgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpLFxuICAgICAgICBpbml0aWFsID0ge30sXG4gICAgICAgIHN0b3BwZWQgPSBmYWxzZSxcbiAgICAgICAgbmV4dCA9IGZhbHNlLFxuICAgICAgICB0aW1lb3V0ID0gZmFsc2UsXG4gICAgICAgIHByb3BlcnRpZXMgPSBPYmplY3Qua2V5cyhmaW5hbCk7XG5cbiAgICB2YXIgdXBkYXRlU3R5bGVzID0gKCkgPT4ge1xuICAgICAgbGV0IHMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgICBwcm9wZXJ0aWVzLmZvckVhY2gocy5nZXRQcm9wZXJ0eVZhbHVlLmJpbmQocykpO1xuICAgICAgcyA9IGVsLm9mZnNldEhlaWdodDtcbiAgICB9O1xuXG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIHN0b3A6IChvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgdGltZW91dCAmJiBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIHZhciBrID0gTWF0aC5taW4oMSwgKChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLSBzdGFydCkgLyBkdXJhdGlvbik7XG4gICAgICAgIHByb3BlcnRpZXMuZm9yRWFjaChpID0+IHtcbiAgICAgICAgICBlbC5zdHlsZVtpXSA9ICgxIC0gaykgKiBpbml0aWFsW2ldICsgayAqIGZpbmFsW2ldICsgKGkgPT0gJ29wYWNpdHknID8gJycgOiAncHgnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc3RvcE5leHQpIHtcbiAgICAgICAgICBuZXh0ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoIXN0b3BwZWQpIHtcbiAgICAgICAgICBzdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICBuZXh0ICYmIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgICAgIHRoZW46IChjYikgPT4ge1xuICAgICAgICBuZXh0ID0gY2I7XG4gICAgICAgIGlmIChzdG9wcGVkKSB7XG4gICAgICAgICAgbmV4dCAmJiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sXG4gICAgICBzcGVlZDogKG5ld0R1cmF0aW9uKSA9PiB7XG4gICAgICAgIGlmIChpbnRlcm5hbC5jb25maWcuYW5pbWF0aW9uc0Rpc2FibGVkKSB7XG4gICAgICAgICAgbmV3RHVyYXRpb24gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RvcHBlZCkge1xuICAgICAgICAgIHRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXG4gICAgICAgICAgY29uc3QgcGFzc2VkID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIHN0YXJ0O1xuICAgICAgICAgIGNvbnN0ICBrID0gcGFzc2VkIC8gZHVyYXRpb247XG4gICAgICAgICAgY29uc3QgcmVtYWluaW5nID0gbmV3RHVyYXRpb24gKiAoMSAtIGspO1xuXG4gICAgICAgICAgcHJvcGVydGllcy5mb3JFYWNoKGkgPT4ge1xuICAgICAgICAgICAgZWwuc3R5bGVbaV0gPSAoMSAtIGspICogaW5pdGlhbFtpXSArIGsgKiBmaW5hbFtpXSArIChpID09ICdvcGFjaXR5JyA/ICcnIDogJ3B4Jyk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB1cGRhdGVTdHlsZXMoKTtcblxuICAgICAgICAgIHN0YXJ0ID0gZWwuc3BlZWRVcFRpbWU7XG4gICAgICAgICAgZHVyYXRpb24gPSByZW1haW5pbmc7XG5cbiAgICAgICAgICBlbC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBkdXJhdGlvbiAvIDEwMDAgKyAncyc7XG5cbiAgICAgICAgICBwcm9wZXJ0aWVzLmZvckVhY2goaSA9PiB7XG4gICAgICAgICAgICBlbC5zdHlsZVtpXSA9IGZpbmFsW2ldICsgKGkgPT0gJ29wYWNpdHknID8gJycgOiAncHgnKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KHJlc3VsdC5zdG9wLCByZW1haW5pbmcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAgZmluaXNoOiAobWlsbGlzZWNvbmRzID0gNTApID0+IHtcbiAgICAgICAgdmFyIGsgPSAoKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIHN0YXJ0KSAvIGR1cmF0aW9uO1xuXG4gICAgICAgIHJlc3VsdC5zcGVlZChtaWxsaXNlY29uZHMgLyAoMSAtIGspKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKGVsLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSB8fCBzdG9wcGVkIHx8IGludGVybmFsLmNvbmZpZy5hbmltYXRpb25zRGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgIHByb3BlcnRpZXMuZm9yRWFjaChlID0+IHtcbiAgICAgIGNvbnN0IHYgPSBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoZSkpO1xuICAgICAgaW5pdGlhbFtlXSA9IGlzTmFOKHYpID8gMCA6IHY7XG4gICAgfSk7XG5cblxuICAgIGlmICghc3RvcHBlZCkge1xuICAgICAgZWwuc3R5bGUudHJhbnNpdGlvblByb3BlcnR5ID0gcHJvcGVydGllcy5qb2luKCcsJyk7XG4gICAgICBlbC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBkdXJhdGlvbiAvIDEwMDAgKyAncyc7XG5cbiAgICAgIHByb3BlcnRpZXMuZm9yRWFjaChlID0+IHtcbiAgICAgICAgZWwuc3R5bGVbZV0gPSBmaW5hbFtlXSArIChlID09ICdvcGFjaXR5JyA/ICcnIDogJ3B4Jyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dChyZXN1bHQuc3RvcCwgZHVyYXRpb24pO1xuICAgIHRoaXMuX29uU3RvcEFuaW1hdGlvbnMoZWwsIHJlc3VsdC5zdG9wKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuICAgIHRoaXMuX2luZGV4ID0gMDtcbiAgfVxuXG4gIF9vblN0b3BBbmltYXRpb25zKGVsLCBsaXN0ZW5lcikge1xuICAgIHZhciBxdWV1ZSA9IHRoaXMuX3F1ZXVlO1xuICAgIHZhciBpID0gdGhpcy5faW5kZXgrKztcbiAgICBxdWV1ZVtlbF0gPSBxdWV1ZVtlbF0gfHwgW107XG4gICAgcXVldWVbZWxdW2ldID0gKG9wdGlvbnMpID0+IHtcbiAgICAgIGRlbGV0ZSBxdWV1ZVtlbF1baV07XG4gICAgICBpZiAocXVldWVbZWxdICYmIHF1ZXVlW2VsXS5sZW5ndGggPT0gMCkge1xuICAgICAgICBkZWxldGUgcXVldWVbZWxdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpc3RlbmVyKG9wdGlvbnMpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgKiBAbWV0aG9kIHN0b3BBbmltYXRpb25zXG4gICogQGRlc2Mgc3RvcHMgYWN0aXZlIGFuaW1hdGlvbnMgb24gYSBzcGVjaWZpZWQgZWxlbWVudFxuICAqIEBwYXJhbSB7RWxlbWVudHxBcnJheX0gZWxlbWVudCAtIGVsZW1lbnQgb3IgYXJyYXkgb2YgZWxlbWVudHNcbiAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXG4gICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zdG9wTmV4dF0gLSB0aGUgY2FsbGJhY2tzIGFmdGVyIHRoZSBhbmltYXRpb25zIHdvbid0IGJlIGNhbGxlZCBpZiB0aGlzIG9wdGlvbiBpcyB0cnVlXG4gICovXG4gIHN0b3BBbmltYXRpb25zKGVsLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlbCkpIHtcbiAgICAgIHJldHVybiBlbC5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgdGhpcy5zdG9wQW5pbWF0aW9ucyhlbCwgb3B0aW9ucyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAodGhpcy5fcXVldWVbZWxdIHx8IFtdKS5mb3JFYWNoKGUgPT4geyBlKG9wdGlvbnMgfHwge30pOyB9KTtcbiAgfVxuXG4gIC8qKlxuICAqIEBtZXRob2Qgc3RvcEFsbFxuICAqIEBkZXNjIHN0b3BzIGFsbCBhY3RpdmUgYW5pbWF0aW9uc1xuICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cbiAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnN0b3BOZXh0XSAtIHRoZSBjYWxsYmFja3MgYWZ0ZXIgdGhlIGFuaW1hdGlvbnMgd29uJ3QgYmUgY2FsbGVkIGlmIHRoaXMgb3B0aW9uIGlzIHRydWVcbiAgKi9cbiAgc3RvcEFsbChvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLnN0b3BBbmltYXRpb25zKE9iamVjdC5rZXlzKHRoaXMuX3F1ZXVlKSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgKiBAbWV0aG9kIGZhZGVcbiAgKiBAZGVzYyBmYWRlcyB0aGUgZWxlbWVudCAoc2hvcnQgdmVyc2lvbiBmb3IgYW5pbWF0ZShlbCwge29wYWNpdHk6IDB9KSlcbiAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgKiBAcGFyYW0ge251bWJlcn0gW2R1cmF0aW9uPTIwMF1cbiAgKi9cbiAgZmFkZShlbCwgZHVyYXRpb24gPSAyMDApIHtcbiAgICByZXR1cm4gdGhpcy5hbmltYXRlKGVsLCB7b3BhY2l0eTogMH0sIGR1cmF0aW9uKTtcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEFuaW1hdG9yQ1NTO1xuXG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnb25zL2ludGVybmFsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yLWNzcyc7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXJpcHBsZVxuICogQGNhdGVnb3J5IHZpc3VhbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBBZGRzIGEgTWF0ZXJpYWwgRGVzaWduIFwicmlwcGxlXCIgZWZmZWN0IHRvIGFuIGVsZW1lbnQuIFRoZSByaXBwbGUgZWZmZWN0IHdpbGwgc3ByZWFkIGZyb20gdGhlIHBvc2l0aW9uIHdoZXJlIHRoZSB1c2VyIHRhcHMuXG4gKlxuICogICAgIFNvbWUgZWxlbWVudHMgc3VjaCBhcyBgPG9ucy1idXR0b24+YCBhbmQgYDxvbnMtZmFiPmAgIHN1cHBvcnQgYSBgcmlwcGxlYCBhdHRyaWJ1dGUuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV3jg57jg4bjg6rjgqLjg6vjg4fjgrbjgqTjg7Pjga7jg6rjg4Pjg5fjg6vlirnmnpzjgpJET03opoHntKDjgavov73liqDjgZfjgb7jgZnjgIJbL2phXVxuICogQGNvZGVwZW4gd0tRV2RaXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvcmlwcGxlXG4gKiBAZ3VpZGUgY3Jvc3MtcGxhdGZvcm0tc3R5bGluZ1xuICogIFtlbl1Dcm9zcyBwbGF0Zm9ybSBzdHlsaW5nWy9lbl1cbiAqICBbamFdQ3Jvc3MgcGxhdGZvcm0gc3R5bGluZ1svamFdXG4gKiBAZXhhbXBsZVxuICogPGRpdiBjbGFzcz1cIm15LWRpdlwiPlxuICogIDxvbnMtcmlwcGxlPjwvb25zLXJpcHBsZT5cbiAqIDwvZGl2PlxuICpcbiAqIEBleGFtcGxlXG4gKiA8b25zLWJ1dHRvbiByaXBwbGU+Q2xpY2sgbWUhPC9vbnMtYnV0dG9uPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSaXBwbGVFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGNvbG9yXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Db2xvciBvZiB0aGUgcmlwcGxlIGVmZmVjdC5bL2VuXVxuICAgKiAgIFtqYV3jg6rjg4Pjg5fjg6vjgqjjg5Xjgqfjgq/jg4jjga7oibLjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBiYWNrZ3JvdW5kXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Db2xvciBvZiB0aGUgYmFja2dyb3VuZC5bL2VuXVxuICAgKiAgIFtqYV3og4zmma/jga7oibLjgpLoqK3lrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXNhYmxlZFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0LCB0aGUgcmlwcGxlIGVmZmVjdCB3aWxsIGJlIGRpc2FibGVkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOioreWumuOBleOCjOOBn+WgtOWQiOOAgeODquODg+ODl+ODq+OCqOODleOCp+OCr+ODiOOBr+eEoeWKueOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdyaXBwbGUnKTtcbiAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKCdfY29tcGlsZWQnKSkge1xuICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9iYWNrZ3JvdW5kID0gdGhpcy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdyaXBwbGVfX2JhY2tncm91bmQnKVswXTtcbiAgICAgIHRoaXMuX3dhdmUgPSB0aGlzLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3JpcHBsZV9fd2F2ZScpWzBdO1xuICAgIH1cblxuICAgIHRoaXMuX2FuaW1hdG9yID0gbmV3IEFuaW1hdG9yKCk7XG5cbiAgICBbJ2NvbG9yJywgJ2NlbnRlcicsICdzdGFydC1yYWRpdXMnLCAnYmFja2dyb3VuZCddLmZvckVhY2goZSA9PiB7XG4gICAgICB0aGlzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhlLCBudWxsLCB0aGlzLmdldEF0dHJpYnV0ZShlKSk7XG4gICAgfSk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBbJ193YXZlJywgJ19iYWNrZ3JvdW5kJ10uZm9yRWFjaChlID0+IHtcbiAgICAgIHRoaXNbZV0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXNbZV0uY2xhc3NMaXN0LmFkZCgncmlwcGxlXycgKyBlKTtcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGhpc1tlXSk7XG4gICAgfSk7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ19jb21waWxlZCcsICcnKTtcbiAgfVxuXG4gIF9jYWxjdWxhdGVDb29yZHMoZSkge1xuICAgIHZhciB4LCB5LCBoLCB3LCByO1xuICAgIHZhciBiID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAodGhpcy5fY2VudGVyKSB7XG4gICAgICB4ID0gYi53aWR0aCAvIDI7XG4gICAgICB5ID0gYi5oZWlnaHQgLyAyO1xuICAgICAgciA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IChlLmNsaWVudFggfHwgZS5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRYKSAtIGIubGVmdDtcbiAgICAgIHkgPSAoZS5jbGllbnRZIHx8IGUuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WSkgLSBiLnRvcDtcbiAgICAgIGggPSBNYXRoLm1heCh5LCBiLmhlaWdodCAtIHkpO1xuICAgICAgdyA9IE1hdGgubWF4KHgsIGIud2lkdGggLSB4KTtcbiAgICAgIHIgPSBNYXRoLnNxcnQoaCAqIGggKyB3ICogdyk7XG4gICAgfVxuICAgIHJldHVybiB7eCwgeSwgcn07XG4gIH1cblxuICBfcmlwcGxlQW5pbWF0aW9uKGUsIGR1cmF0aW9uID0gMzAwKSB7XG4gICAgdmFyXG4gICAgICB7X2FuaW1hdG9yLCBfd2F2ZSwgX2JhY2tncm91bmQsIF9taW5SfSA9IHRoaXMsXG4gICAgICB7eCwgeSwgcn0gPSB0aGlzLl9jYWxjdWxhdGVDb29yZHMoZSk7XG5cbiAgICBfYW5pbWF0b3Iuc3RvcEFsbCh7c3RvcE5leHQ6IDF9KTtcbiAgICBfYW5pbWF0b3IuYW5pbWF0ZShfYmFja2dyb3VuZCwge29wYWNpdHk6IDF9LCBkdXJhdGlvbik7XG5cbiAgICB1dGlsLmV4dGVuZChfd2F2ZS5zdHlsZSwge1xuICAgICAgb3BhY2l0eTogMSxcbiAgICAgIHRvcDogeSAtIF9taW5SICsgJ3B4JyxcbiAgICAgIGxlZnQ6IHggLSBfbWluUiArICdweCcsXG4gICAgICB3aWR0aDogMiAqIF9taW5SICsgJ3B4JyxcbiAgICAgIGhlaWdodDogMiAqIF9taW5SICsgJ3B4J1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIF9hbmltYXRvci5hbmltYXRlKF93YXZlLCB7XG4gICAgICB0b3A6IHkgLSByLFxuICAgICAgbGVmdDogeCAtIHIsXG4gICAgICBoZWlnaHQ6IDIgKiByLFxuICAgICAgd2lkdGg6IDIgKiByXG4gICAgfSwgZHVyYXRpb24pO1xuICB9XG5cbiAgX3VwZGF0ZVBhcmVudCgpIHtcbiAgICBpZiAoIXRoaXMuX3BhcmVudFVwZGF0ZWQgJiYgdGhpcy5wYXJlbnROb2RlKSB7XG4gICAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5wYXJlbnROb2RlKTtcbiAgICAgIGlmIChjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnKSB7XG4gICAgICAgIHRoaXMucGFyZW50Tm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICB9XG4gICAgICB0aGlzLl9wYXJlbnRVcGRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBfb25UYXAoZSkge1xuICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5fdXBkYXRlUGFyZW50KCk7XG4gICAgICB0aGlzLl9yaXBwbGVBbmltYXRpb24oZS5nZXN0dXJlLnNyY0V2ZW50KS50aGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy5fYW5pbWF0b3IuZmFkZSh0aGlzLl93YXZlKTtcbiAgICAgICAgdGhpcy5fYW5pbWF0b3IuZmFkZSh0aGlzLl9iYWNrZ3JvdW5kKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIF9vbkhvbGQoZSkge1xuICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5fdXBkYXRlUGFyZW50KCk7XG4gICAgICB0aGlzLl9ob2xkaW5nID0gdGhpcy5fcmlwcGxlQW5pbWF0aW9uKGUuZ2VzdHVyZS5zcmNFdmVudCwgMjAwMCk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdyZWxlYXNlJywgdGhpcy5fYm91bmRPblJlbGVhc2UpO1xuICAgIH1cbiAgfVxuXG4gIF9vblJlbGVhc2UoZSkge1xuICAgIGlmICh0aGlzLl9ob2xkaW5nKSB7XG4gICAgICB0aGlzLl9ob2xkaW5nLnNwZWVkKDMwMCkudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMuX2FuaW1hdG9yLnN0b3BBbGwoe3N0b3BOZXh0OiB0cnVlfSk7XG4gICAgICAgIHRoaXMuX2FuaW1hdG9yLmZhZGUodGhpcy5fd2F2ZSk7XG4gICAgICAgIHRoaXMuX2FuaW1hdG9yLmZhZGUodGhpcy5fYmFja2dyb3VuZCk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5faG9sZGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3JlbGVhc2UnLCB0aGlzLl9ib3VuZE9uUmVsZWFzZSk7XG4gIH1cblxuICBfb25EcmFnU3RhcnQoZSkge1xuICAgIGlmICh0aGlzLl9ob2xkaW5nKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb25SZWxlYXNlKGUpO1xuICAgIH1cbiAgICBpZiAoWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihlLmdlc3R1cmUuZGlyZWN0aW9uKSAhPSAtMSkge1xuICAgICAgdGhpcy5fb25UYXAoZSk7XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fcGFyZW50Tm9kZSA9IHRoaXMucGFyZW50Tm9kZTtcbiAgICB0aGlzLl9ib3VuZE9uVGFwID0gdGhpcy5fb25UYXAuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9ib3VuZE9uSG9sZCA9IHRoaXMuX29uSG9sZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kT25EcmFnU3RhcnQgPSB0aGlzLl9vbkRyYWdTdGFydC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kT25SZWxlYXNlID0gdGhpcy5fb25SZWxlYXNlLmJpbmQodGhpcyk7XG5cbiAgICBpZiAoaW50ZXJuYWwuY29uZmlnLmFuaW1hdGlvbnNEaXNhYmxlZCkge1xuICAgICAgdGhpcy5kaXNhYmxlZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3BhcmVudE5vZGUuYWRkRXZlbnRMaXN0ZW5lcigndGFwJywgdGhpcy5fYm91bmRPblRhcCk7XG4gICAgICB0aGlzLl9wYXJlbnROb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2hvbGQnLCB0aGlzLl9ib3VuZE9uSG9sZCk7XG4gICAgICB0aGlzLl9wYXJlbnROb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXMuX2JvdW5kT25EcmFnU3RhcnQpO1xuICAgIH1cbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGNvbnN0IHBuID0gdGhpcy5fcGFyZW50Tm9kZSB8fCB0aGlzLnBhcmVudE5vZGU7XG4gICAgcG4ucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGFwJywgdGhpcy5fYm91bmRPblRhcCk7XG4gICAgcG4ucmVtb3ZlRXZlbnRMaXN0ZW5lcignaG9sZCcsIHRoaXMuX2JvdW5kT25Ib2xkKTtcbiAgICBwbi5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLl9ib3VuZE9uRHJhZ1N0YXJ0KTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ3N0YXJ0LXJhZGl1cycsICdjb2xvcicsICdiYWNrZ3JvdW5kJywgJ2NlbnRlciddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ3N0YXJ0LXJhZGl1cycpIHtcbiAgICAgIHRoaXMuX21pblIgPSBNYXRoLm1heCgwLCBwYXJzZUZsb2F0KGN1cnJlbnQpIHx8IDApO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gJ2NvbG9yJyAmJiBjdXJyZW50KSB7XG4gICAgICB0aGlzLl93YXZlLnN0eWxlLmJhY2tncm91bmQgPSBjdXJyZW50O1xuICAgICAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZSgnYmFja2dyb3VuZCcpKSB7XG4gICAgICAgIHRoaXMuX2JhY2tncm91bmQuc3R5bGUuYmFja2dyb3VuZCA9IGN1cnJlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuYW1lID09PSAnYmFja2dyb3VuZCcgJiYgKGN1cnJlbnQgfHwgbGFzdCkpIHtcbiAgICAgIGlmIChjdXJyZW50ID09PSAnbm9uZScpIHtcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZC5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJyk7XG4gICAgICAgIHRoaXMuX2JhY2tncm91bmQuc3R5bGUuYmFja2dyb3VuZCA9ICd0cmFuc3BhcmVudCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5fYmFja2dyb3VuZC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykpIHtcbiAgICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kLnJlbW92ZUF0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kLnN0eWxlLmJhY2tncm91bmQgPSBjdXJyZW50O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIHRoaXMuX2NlbnRlciA9IGN1cnJlbnQgIT0gbnVsbCAmJiBjdXJyZW50ICE9ICdmYWxzZSc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdmFsdWUpO1xuICB9XG5cbiAgZ2V0IGRpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1yaXBwbGUnLCBSaXBwbGVFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtcm93XG4gKiBAY2F0ZWdvcnkgZ3JpZFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1SZXByZXNlbnRzIGEgcm93IGluIHRoZSBncmlkIHN5c3RlbS4gVXNlIHdpdGggYDxvbnMtY29sPmAgdG8gbGF5b3V0IGNvbXBvbmVudHMuWy9lbl1cbiAqICAgW2phXeOCsOODquODg+ODieOCt+OCueODhuODoOOBq+OBpuihjOOCkuWumue+qeOBl+OBvuOBmeOAgm9ucy1jb2zjgajjgajjgoLjgavkvb/nlKjjgZfjgIHjgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7phY3nva7jgavkvb/nlKjjgZfjgb7jgZnjgIJbL2phXVxuICogQGNvZGVwZW4gR2d1akMge3dpZGV9XG4gKiBAZ3VpZGUgbGF5b3V0aW5nXG4gKiAgIFtlbl1MYXlvdXRpbmcgZ3VpZGVbL2VuXVxuICogICBbamFd44Os44Kk44Ki44Km44OI6Kq/5pW0Wy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1jb2xcbiAqICAgW2VuXVRoZSBgPG9ucy1jb2w+YCBjb21wb25lbnQgaXMgdXNlZCBhcyBjaGlsZHJlbiBvZiBgPG9ucy1yb3c+YC5bL2VuXVxuICogICBbamFdb25zLWNvbOOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAbm90ZVxuICogICBbZW5dRm9yIEFuZHJvaWQgNC4zIGFuZCBlYXJsaWVyLCBhbmQgaU9TNiBhbmQgZWFybGllciwgd2hlbiB1c2luZyBtaXhlZCBhbGlnbm1lbnQgd2l0aCBvbnMtcm93IGFuZCBvbnMtY29sLCB0aGV5IG1heSBub3QgYmUgZGlzcGxheWVkIGNvcnJlY3RseS4gWW91IGNhbiB1c2Ugb25seSBvbmUgdmVydGljYWwtYWxpZ24uWy9lbl1cbiAqICAgW2phXUFuZHJvaWQgNC4z5Lul5YmN44CB44KC44GX44GP44GvaU9TIDbku6XliY3jga5PU+OBruWgtOWQiOOAgW9ucy1yb3fjgahvbnMtY29s44KS57WE44G/5ZCI44KP44Gb44Gm44Gd44KM44Ge44KM44Gub25zLWNvbOimgee0oOOBrnZlcnRpY2FsLWFsaWdu5bGe5oCn44Gu5YCk44Gr5Yil44CF44Gu5YCk44KS5oyH5a6a44GZ44KL44Go44CB5o+P55S744GM5bSp44KM44KL5aC05ZCI44GM44GC44KK44G+44GZ44CCdmVydGljYWwtYWxpZ27lsZ7mgKfjga7lgKTjgavjga/kuIDjgaTjga7lgKTjgaDjgZHjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtcm93PlxuICogICA8b25zLWNvbCB3aWR0aD1cIjUwcHhcIj48b25zLWljb24gaWNvbj1cImZhLXR3aXR0ZXJcIj48L29ucy1pY29uPjwvb25zLWNvbD5cbiAqICAgPG9ucy1jb2w+VGV4dDwvb25zLWNvbD5cbiAqIDwvb25zLXJvdz5cbiAqL1xuXG4vKipcbiAqIEBhdHRyaWJ1dGUgdmVydGljYWwtYWxpZ25cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVNob3J0IGhhbmQgYXR0cmlidXRlIGZvciBhbGlnbmluZyB2ZXJ0aWNhbGx5LiBWYWxpZCB2YWx1ZXMgYXJlIHRvcCwgYm90dG9tLCBhbmQgY2VudGVyLlsvZW5dXG4gKiAgIFtqYV3nuKbjgavmlbTliJfjgZnjgovjgZ/jgoHjgavmjIflrprjgZfjgb7jgZnjgIJ0b3DjgIFib3R0b23jgIFjZW50ZXLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJvd0VsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXJvdycsIFJvd0VsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJ29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnJzogJ3NwZWVkLWRpYWxfX2l0ZW0tLSonLFxufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtc3BlZWQtZGlhbC1pdGVtXG4gKiBAY2F0ZWdvcnkgY29udHJvbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBUaGlzIGNvbXBvbmVudCBkaXNwbGF5cyB0aGUgY2hpbGQgZWxlbWVudHMgb2YgdGhlIE1hdGVyaWFsIERlc2lnbiBTcGVlZCBkaWFsIGNvbXBvbmVudC5cbiAqICAgWy9lbl1cbiAqICAgW2phXVxuICogICAgIE1hdGVyaWFsIERlc2lnbuOBrlNwZWVkIGRpYWzjga7lrZDopoHntKDjgpLooajnj77jgZnjgovopoHntKDjgafjgZnjgIJcbiAqICAgWy9qYV1cbiAqIEBjb2RlcGVuIGRZUVlMZ1xuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3NwZWVkLWRpYWxcbiAqIEBzZWVhbHNvIG9ucy1zcGVlZC1kaWFsXG4gKiAgIFtlbl1UaGUgYDxvbnMtc3BlZWQtZGlhbD5gIGNvbXBvbmVudC5bL2VuXVxuICogICBbamFdb25zLXNwZWVkLWRpYWzjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLWZhYlxuICogICBbZW5db25zLWZhYiBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWZhYuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1zcGVlZC1kaWFsIHBvc2l0aW9uPVwibGVmdCBib3R0b21cIj5cbiAqICAgPG9ucy1mYWI+XG4gKiAgICAgPG9ucy1pY29uIGljb249XCJmYS10d2l0dGVyXCI+PC9vbnMtaWNvbj5cbiAqICAgPC9vbnMtZmFiPlxuICogICA8b25zLXNwZWVkLWRpYWwtaXRlbT5BPC9vbnMtc3BlZWQtZGlhbC1pdGVtPlxuICogICA8b25zLXNwZWVkLWRpYWwtaXRlbT5CPC9vbnMtc3BlZWQtZGlhbC1pdGVtPlxuICogICA8b25zLXNwZWVkLWRpYWwtaXRlbT5DPC9vbnMtc3BlZWQtZGlhbC1pdGVtPlxuICogPC9vbnMtc3BlZWQtZGlhbD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3BlZWREaWFsSXRlbUVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBjb21wb25lbnQuWy9lbl1cbiAgICogICBbamFd44GT44Gu44Kz44Oz44Od44O844ON44Oz44OI44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgdGhpcy5fYm91bmRPbkNsaWNrID0gdGhpcy5fb25DbGljay5iaW5kKHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAncmlwcGxlJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyaXBwbGUnOlxuICAgICAgICB0aGlzLl91cGRhdGVSaXBwbGUoKTtcbiAgICB9XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRPbkNsaWNrLCBmYWxzZSk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRPbkNsaWNrLCBmYWxzZSk7XG4gIH1cblxuICBfdXBkYXRlUmlwcGxlKCkge1xuICAgIHV0aWwudXBkYXRlUmlwcGxlKHRoaXMpO1xuICB9XG5cbiAgX29uQ2xpY2soZSkge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiJyk7XG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLW1pbmknKTtcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ3NwZWVkLWRpYWxfX2l0ZW0nKTtcblxuICAgIHRoaXMuX3VwZGF0ZVJpcHBsZSgpO1xuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXNwZWVkLWRpYWwtaXRlbScsIFNwZWVkRGlhbEl0ZW1FbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbi8qKlxuICogTWluaW1hbCB1dGlsaXR5IGxpYnJhcnkgZm9yIG1hbmlwdWxhdGluZyBlbGVtZW50J3Mgc3R5bGUuXG4gKi9cbmNvbnN0IHN0eWxlciA9IGZ1bmN0aW9uKGVsZW1lbnQsIHN0eWxlKSB7XG4gIHJldHVybiBzdHlsZXIuY3NzLmFwcGx5KHN0eWxlciwgYXJndW1lbnRzKTtcbn07XG5cbi8qKlxuICogU2V0IGVsZW1lbnQncyBzdHlsZS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZXNcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cbnN0eWxlci5jc3MgPSBmdW5jdGlvbihlbGVtZW50LCBzdHlsZXMpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzdHlsZXMpO1xuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKGtleSBpbiBlbGVtZW50LnN0eWxlKSB7XG4gICAgICBlbGVtZW50LnN0eWxlW2tleV0gPSBzdHlsZXNba2V5XTtcbiAgICB9IGVsc2UgaWYgKHN0eWxlci5fcHJlZml4KGtleSkgaW4gZWxlbWVudC5zdHlsZSkge1xuICAgICAgZWxlbWVudC5zdHlsZVtzdHlsZXIuX3ByZWZpeChrZXkpXSA9IHN0eWxlc1trZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oJ05vIHN1Y2ggc3R5bGUgcHJvcGVydHk6ICcgKyBrZXkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuLyoqXG4gKiBBZGQgdmVuZG9yIHByZWZpeC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5zdHlsZXIuX3ByZWZpeCA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgJycpO1xuICB2YXIgcHJlZml4ID0gKEFycmF5LnByb3RvdHlwZS5zbGljZVxuICAgIC5jYWxsKHN0eWxlcylcbiAgICAuam9pbignJylcbiAgICAubWF0Y2goLy0obW96fHdlYmtpdHxtcyktLykgfHwgKHN0eWxlcy5PTGluayA9PT0gJycgJiYgWycnLCAnbyddKVxuICApWzFdO1xuXG4gIHJldHVybiBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHByZWZpeCArIG5hbWUuc3Vic3RyKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnN1YnN0cigxKTtcbiAgfTtcbn0pKCk7XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKi9cbnN0eWxlci5jbGVhciA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgc3R5bGVyLl9jbGVhcihlbGVtZW50KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKi9cbnN0eWxlci5fY2xlYXIgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIHZhciBsZW4gPSBlbGVtZW50LnN0eWxlLmxlbmd0aDtcbiAgdmFyIHN0eWxlID0gZWxlbWVudC5zdHlsZTtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGtleXMucHVzaChzdHlsZVtpXSk7XG4gIH1cblxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgc3R5bGVba2V5XSA9ICcnO1xuICB9KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHN0eWxlcjtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJ29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICdvbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJ29ucy9jb250ZW50LXJlYWR5JztcbmltcG9ydCBzdHlsZXIgZnJvbSAnbGliL3N0eWxlcic7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICdzcGVlZC1kaWFsLS0qJyxcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXNwZWVkLWRpYWxcbiAqIEBjYXRlZ29yeSBjb250cm9sXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIEVsZW1lbnQgdGhhdCBkaXNwbGF5cyBhIE1hdGVyaWFsIERlc2lnbiBTcGVlZCBEaWFsb2cgY29tcG9uZW50LiBJdCBpcyB1c2VmdWwgd2hlbiB0aGVyZSBhcmUgbW9yZSB0aGFuIG9uZSBwcmltYXJ5IGFjdGlvbiB0aGF0IGNhbiBiZSBwZXJmb3JtZWQgaW4gYSBwYWdlLlxuICpcbiAqICAgICBUaGUgU3BlZWQgZGlhbCBsb29rcyBsaWtlIGEgYDxvbnMtZmFiPmAgZWxlbWVudCBidXQgd2lsbCBleHBhbmQgYSBtZW51IHdoZW4gdGFwcGVkLlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIGRZUVlMZ1xuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3NwZWVkLWRpYWxcbiAqIEBzZWVhbHNvIG9ucy1zcGVlZC1kaWFsLWl0ZW1cbiAqICAgW2VuXVRoZSBgPG9ucy1zcGVlZC1kaWFsLWl0ZW0+YCByZXByZXNlbnRzIGEgbWVudSBpdGVtLlsvZW5dXG4gKiAgIFtqYV1vbnMtc3BlZWQtZGlhbC1pdGVt44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1mYWJcbiAqICAgW2VuXW9ucy1mYWIgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1mYWLjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtc3BlZWQtZGlhbCBwb3NpdGlvbj1cImxlZnQgYm90dG9tXCI+XG4gKiAgIDxvbnMtZmFiPlxuICogICAgIDxvbnMtaWNvbiBpY29uPVwiZmEtdHdpdHRlclwiPjwvb25zLWljb24+XG4gKiAgIDwvb25zLWZhYj5cbiAqICAgPG9ucy1zcGVlZC1kaWFsLWl0ZW0+QTwvb25zLXNwZWVkLWRpYWwtaXRlbT5cbiAqICAgPG9ucy1zcGVlZC1kaWFsLWl0ZW0+Qjwvb25zLXNwZWVkLWRpYWwtaXRlbT5cbiAqICAgPG9ucy1zcGVlZC1kaWFsLWl0ZW0+Qzwvb25zLXNwZWVkLWRpYWwtaXRlbT5cbiAqIDwvb25zLXNwZWVkLWRpYWw+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwZWVkRGlhbEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBvcGVuXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCB3aGVuIHRoZSBtZW51IGl0ZW1zIGFyZSBzaG93bi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IGNsb3NlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCB3aGVuIHRoZSBtZW51IGl0ZW1zIGFyZSBoaWRkZW4uWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBjb21wb25lbnQuWy9lbl1cbiAgICogICBbamFd44GT44Gu44Kz44Oz44Od44O844ON44Oz44OI44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcG9zaXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVxuICAgKiAgICAgU3BlY2lmeSB0aGUgdmVydGljYWwgYW5kIGhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGNvbXBvbmVudC5cbiAgICogICAgIEkuZS4gdG8gZGlzcGxheSBpdCBpbiB0aGUgdG9wIHJpZ2h0IGNvcm5lciBzcGVjaWZ5IFwicmlnaHQgdG9wXCIuXG4gICAqICAgICBDaG9vc2UgZnJvbSBcInJpZ2h0XCIsIFwibGVmdFwiLCBcInRvcFwiIGFuZCBcImJvdHRvbVwiLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVxuICAgKiAgICAg44GT44Gu6KaB57Sg44KS6KGo56S644GZ44KL5bem5Y+z44Go5LiK5LiL44Gu5L2N572u44KS5oyH5a6a44GX44G+44GZ44CCXG4gICAqICAgICDkvovjgYjjgbDjgIHlj7PkuIrjgavooajnpLrjgZnjgovloLTlkIjjgavjga9cInJpZ2h0IHRvcFwi44KS5oyH5a6a44GX44G+44GZ44CCXG4gICAqICAgICDlt6blj7PjgajkuIrkuIvjga7kvY3nva7jga7mjIflrprjgavjga/jgIFyaWdodOOBqGxlZnTjgIF0b3Djgahib3R0b23jgYzjgZ3jgozjgZ7jgozmjIflrprjgafjgY3jgb7jgZnjgIJcbiAgICogICBbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXJlY3Rpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGRpcmVjdGlvbiB0aGUgaXRlbXMgYXJlIGRpc3BsYXllZC4gUG9zc2libGUgdmFsdWVzIGFyZSBcInVwXCIsIFwiZG93blwiLCBcImxlZnRcIiBhbmQgXCJyaWdodFwiLlsvZW5dXG4gICAqICAgW2phXVxuICAgKiAgICAg6KaB57Sg44GM6KGo56S644GZ44KL5pa55ZCR44KS5oyH5a6a44GX44G+44GZ44CCdXAsIGRvd24sIGxlZnQsIHJpZ2h044GM5oyH5a6a44Gn44GN44G+44GZ44CCXG4gICAqICAgWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgaWYgYnV0dG9uIHNob3VsZCBiZSBkaXNhYmxlZC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZnjgovloLTlkIjjgavmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBpbml0KCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9zaG93biA9IHRydWU7XG4gICAgdGhpcy5faXRlbVNob3duID0gZmFsc2U7XG4gICAgdGhpcy5fYm91bmRPbkNsaWNrID0gdGhpcy5fb25DbGljay5iaW5kKHRoaXMpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgaWYgKCF0aGlzLmNsYXNzTGlzdC5jb250YWlucygnc3BlZWRfX2RpYWwnKSkge1xuICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdzcGVlZF9fZGlhbCcpO1xuICAgICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG4gICAgICB0aGlzLl91cGRhdGVSaXBwbGUoKTtcbiAgICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcblxuICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdkaXJlY3Rpb24nKSkge1xuICAgICAgICB0aGlzLl91cGRhdGVEaXJlY3Rpb24odGhpcy5nZXRBdHRyaWJ1dGUoJ2RpcmVjdGlvbicpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZURpcmVjdGlvbigndXAnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAncmlwcGxlJywgJ2RpcmVjdGlvbicsICdwb3NpdGlvbiddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlwcGxlJzpcbiAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX3VwZGF0ZVJpcHBsZSgpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkaXJlY3Rpb24nOlxuICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fdXBkYXRlRGlyZWN0aW9uKGN1cnJlbnQpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdwb3NpdGlvbic6XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl91cGRhdGVQb3NpdGlvbigpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljaywgZmFsc2UpO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljaywgZmFsc2UpO1xuICB9XG5cbiAgZ2V0IGl0ZW1zKCkge1xuICAgIHJldHVybiB1dGlsLmFycmF5RnJvbSh0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoJ29ucy1zcGVlZC1kaWFsLWl0ZW0nKSk7XG4gIH1cblxuICBfb25DbGljayhlKSB7XG4gICAgaWYgKCF0aGlzLmRpc2FibGVkICYmIHRoaXMuX3Nob3duKSB7XG4gICAgICB0aGlzLnRvZ2dsZUl0ZW1zKCk7XG4gICAgfVxuICB9XG5cbiAgX3Nob3coKSB7XG4gICAgaWYgKCF0aGlzLmlubGluZSkge1xuICAgICAgdGhpcy5zaG93KCk7XG4gICAgfVxuICB9XG5cbiAgX2hpZGUoKSB7XG4gICAgaWYgKCF0aGlzLmlubGluZSkge1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZVJpcHBsZSgpIHtcbiAgICBjb25zdCBmYWIgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnb25zLWZhYicpO1xuXG4gICAgaWYgKGZhYikge1xuICAgICAgdGhpcy5oYXNBdHRyaWJ1dGUoJ3JpcHBsZScpID8gZmFiLnNldEF0dHJpYnV0ZSgncmlwcGxlJywgJycpIDogZmFiLnJlbW92ZUF0dHJpYnV0ZSgncmlwcGxlJyk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZURpcmVjdGlvbihkaXJlY3Rpb24pIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuaXRlbXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgc3R5bGVyKGNoaWxkcmVuW2ldLCB7XG4gICAgICAgIHRyYW5zaXRpb25EZWxheTogMjUgKiBpICsgJ21zJyxcbiAgICAgICAgYm90dG9tOiAnYXV0bycsXG4gICAgICAgIHJpZ2h0OiAnYXV0bycsXG4gICAgICAgIHRvcDogJ2F1dG8nLFxuICAgICAgICBsZWZ0OiAnYXV0bydcbiAgICAgIH0pO1xuICAgIH1cbiAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgY2FzZSAndXAnOlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUuYm90dG9tID0gNzIgKyA1NiAqIGkgKyAncHgnO1xuICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnJpZ2h0ID0gJzhweCc7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkb3duJzpcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnRvcCA9IDcyICsgNTYgKiBpICsgJ3B4JztcbiAgICAgICAgICBjaGlsZHJlbltpXS5zdHlsZS5sZWZ0ID0gJzhweCc7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnRvcCA9ICc4cHgnO1xuICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnJpZ2h0ID0gNzIgKyA1NiAqIGkgKyAncHgnO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUudG9wID0gJzhweCc7XG4gICAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUubGVmdCA9IDcyICsgNTYgKiBpICsgJ3B4JztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdXAsIGRvd24sIGxlZnQgb3IgcmlnaHQuJyk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZVBvc2l0aW9uKCkge1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJyk7XG4gICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgJ2ZhYi0tdG9wX19sZWZ0JyxcbiAgICAgICdmYWItLWJvdHRvbV9fcmlnaHQnLFxuICAgICAgJ2ZhYi0tYm90dG9tX19sZWZ0JyxcbiAgICAgICdmYWItLXRvcF9fcmlnaHQnLFxuICAgICAgJ2ZhYi0tdG9wX19jZW50ZXInLFxuICAgICAgJ2ZhYi0tYm90dG9tX19jZW50ZXInKTtcbiAgICBzd2l0Y2gocG9zaXRpb24pIHtcbiAgICAgIGNhc2UgJ3RvcCByaWdodCc6XG4gICAgICBjYXNlICdyaWdodCB0b3AnOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tdG9wX19yaWdodCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcCBsZWZ0JzpcbiAgICAgIGNhc2UgJ2xlZnQgdG9wJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLXRvcF9fbGVmdCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2JvdHRvbSByaWdodCc6XG4gICAgICBjYXNlICdyaWdodCBib3R0b20nOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tYm90dG9tX19yaWdodCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2JvdHRvbSBsZWZ0JzpcbiAgICAgIGNhc2UgJ2xlZnQgYm90dG9tJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLWJvdHRvbV9fbGVmdCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NlbnRlciB0b3AnOlxuICAgICAgY2FzZSAndG9wIGNlbnRlcic6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS10b3BfX2NlbnRlcicpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NlbnRlciBib3R0b20nOlxuICAgICAgY2FzZSAnYm90dG9tIGNlbnRlcic6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS1ib3R0b21fX2NlbnRlcicpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNob3dcbiAgICogQHNpZ25hdHVyZSBzaG93KClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNob3cgdGhlIHNwZWVkIGRpYWwuWy9lbl1cbiAgICogICBbamFdU3BlZWQgZGlhbOOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBzaG93KG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMucXVlcnlTZWxlY3Rvcignb25zLWZhYicpLnNob3coKTtcbiAgICB0aGlzLl9zaG93biA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBoaWRlXG4gICAqIEBzaWduYXR1cmUgaGlkZSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1IaWRlIHRoZSBzcGVlZCBkaWFsLlsvZW5dXG4gICAqICAgW2phXVNwZWVkIGRpYWzjgpLpnZ7ooajnpLrjgavjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgaGlkZShvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLmhpZGVJdGVtcygpO1xuICAgIHNldFRpbWVvdXQoKCk9PntcbiAgICAgIHRoaXMucXVlcnlTZWxlY3Rvcignb25zLWZhYicpLmhpZGUoKTtcbiAgICB9LCAyMDApO1xuICAgIHRoaXMuX3Nob3duID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBzaG93SXRlbXNcbiAgICogQHNpZ25hdHVyZSBzaG93SXRlbXMoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdyB0aGUgc3BlZWQgZGlhbCBpdGVtcy5bL2VuXVxuICAgKiAgIFtqYV1TcGVlZCBkaWFs44Gu5a2Q6KaB57Sg44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIHNob3dJdGVtcygpIHtcblxuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnZGlyZWN0aW9uJykpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZURpcmVjdGlvbih0aGlzLmdldEF0dHJpYnV0ZSgnZGlyZWN0aW9uJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl91cGRhdGVEaXJlY3Rpb24oJ3VwJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9pdGVtU2hvd24pIHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5pdGVtcztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3R5bGVyKGNoaWxkcmVuW2ldLCB7XG4gICAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGUoMSknLFxuICAgICAgICAgIHRyYW5zaXRpb25EZWxheTogMjUgKiBpICsgJ21zJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5faXRlbVNob3duID0gdHJ1ZTtcblxuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnb3BlbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaGlkZUl0ZW1zXG4gICAqIEBzaWduYXR1cmUgaGlkZUl0ZW1zKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUhpZGUgdGhlIHNwZWVkIGRpYWwgaXRlbXMuWy9lbl1cbiAgICogICBbamFdU3BlZWQgZGlhbOOBruWtkOimgee0oOOCkumdnuihqOekuuOBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBoaWRlSXRlbXMoKSB7XG4gICAgaWYgKHRoaXMuX2l0ZW1TaG93bikge1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLml0ZW1zO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBzdHlsZXIoY2hpbGRyZW5baV0sIHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICdzY2FsZSgwKScsXG4gICAgICAgICAgdHJhbnNpdGlvbkRlbGF5OiAyNSAqIChjaGlsZHJlbi5sZW5ndGggLSBpKSArICdtcydcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2l0ZW1TaG93biA9IGZhbHNlO1xuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnY2xvc2UnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLmhpZGVJdGVtcygpO1xuICAgIH1cbiAgICB1dGlsLmFycmF5RnJvbSh0aGlzLmNoaWxkcmVuKS5mb3JFYWNoKGUgPT4ge1xuICAgICAgdXRpbC5tYXRjaChlLCAnLmZhYicpICYmIHV0aWwudG9nZ2xlQXR0cmlidXRlKGUsICdkaXNhYmxlZCcsIHZhbHVlKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBpbmxpbmVcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyBpbmxpbmUgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeOCpOODs+ODqeOCpOODs+imgee0oOOBruWgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBnZXQgaW5saW5lKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnaW5saW5lJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZpc2libGVcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3opoHntKDjgYzopovjgYjjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Nob3duICYmIHRoaXMuc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNPcGVuXG4gICAqIEBzaWduYXR1cmUgaXNPcGVuKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgbWVudSBpcyBvcGVuIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgaXNPcGVuKCkge1xuICAgIHJldHVybiB0aGlzLl9pdGVtU2hvd247XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCB0b2dnbGVcbiAgICogQHNpZ25hdHVyZSB0b2dnbGUoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVG9nZ2xlIHZpc2liaWxpdHkuWy9lbl1cbiAgICogICBbamFdU3BlZWQgZGlhbOOBruihqOekuumdnuihqOekuuOCkuWIh+OCiuabv+OBiOOBvuOBmeOAglsvamFdXG4gICAqL1xuICB0b2dnbGUoKSB7XG4gICAgdGhpcy52aXNpYmxlID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3coKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHRvZ2dsZUl0ZW1zXG4gICAqIEBzaWduYXR1cmUgdG9nZ2xlSXRlbXMoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVG9nZ2xlIGl0ZW0gdmlzaWJpbGl0eS5bL2VuXVxuICAgKiAgIFtqYV1TcGVlZCBkaWFs44Gu5a2Q6KaB57Sg44Gu6KGo56S66Z2e6KGo56S644KS5YiH44KK5pu/44GI44G+44GZ44CCWy9qYV1cbiAgICovXG4gIHRvZ2dsZUl0ZW1zKCkge1xuICAgIGlmICh0aGlzLmlzT3BlbigpKSB7XG4gICAgICB0aGlzLmhpZGVJdGVtcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNob3dJdGVtcygpO1xuICAgIH1cbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1zcGVlZC1kaWFsJywgU3BlZWREaWFsRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnb25zL2ludGVybmFsJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IHtQYWdlTG9hZGVyLCBkZWZhdWx0UGFnZUxvYWRlcn0gZnJvbSAnb25zL3BhZ2UtbG9hZGVyJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCByZXdyaXRhYmxlcyA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcmVhZHkoZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICBzZXRJbW1lZGlhdGUoY2FsbGJhY2spO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtIVE1MRnJhZ21lbnR9IHRhcmdldFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgbGluayhlbGVtZW50LCB0YXJnZXQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sodGFyZ2V0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtc3BsaXR0ZXItY29udGVudFxuICogQGNhdGVnb3J5IG1lbnVcbiAqIEBkZXNjcmlwdGlvblxuICogIFtlbl1cbiAqICAgIFRoZSBgPG9ucy1zcGxpdHRlci1jb250ZW50PmAgZWxlbWVudCBpcyB1c2VkIGFzIGEgY2hpbGQgZWxlbWVudCBvZiBgPG9ucy1zcGxpdHRlcj5gLlxuICpcbiAqICAgIEl0IGNvbnRhaW5zIHRoZSBtYWluIGNvbnRlbnQgb2YgdGhlIHBhZ2Ugd2hpbGUgYDxvbnMtc3BsaXR0ZXItc2lkZT5gIGNvbnRhaW5zIHRoZSBsaXN0LlxuICogIFsvZW5dXG4gKiAgW2phXW9ucy1zcGxpdHRlci1jb250ZW506KaB57Sg44Gv44CBb25zLXNwbGl0dGVy6KaB57Sg44Gu5a2Q6KaB57Sg44Go44GX44Gm5Yip55So44GX44G+44GZ44CCWy9qYV1cbiAqIEBjb2RlcGVuIHJPUU9NTFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3NwbGl0dGVyXG4gKiBAZ3VpZGUgbXVsdGlwbGUtcGFnZS1uYXZpZ2F0aW9uXG4gKiAgW2VuXU1hbmFnaW5nIG11bHRpcGxlIHBhZ2VzLlsvZW5dXG4gKiAgW2phXU1hbmFnaW5nIG11bHRpcGxlIHBhZ2VzWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1zcGxpdHRlclxuICogIFtlbl1UaGUgYDxvbnMtc3BsaXR0ZXI+YCBjb21wb25lbnQgaXMgdGhlIHBhcmVudCBlbGVtZW50LlsvZW5dXG4gKiAgW2phXW9ucy1zcGxpdHRlcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtc3BsaXR0ZXItc2lkZVxuICogIFtlbl1UaGUgYDxvbnMtc3BsaXR0ZXItc2lkZT5gIGNvbXBvbmVudCBjb250YWlucyB0aGUgbWVudS5bL2VuXVxuICogIFtqYV1vbnMtc3BsaXR0ZXItc2lkZeOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1zcGxpdHRlcj5cbiAqICAgPG9ucy1zcGxpdHRlci1jb250ZW50PlxuICogICAgIC4uLlxuICogICA8L29ucy1zcGxpdHRlci1jb250ZW50PlxuICpcbiAqICAgPG9ucy1zcGxpdHRlci1zaWRlIHNpZGU9XCJsZWZ0XCIgd2lkdGg9XCI4MCVcIiBjb2xsYXBzZT5cbiAqICAgICAuLi5cbiAqICAgPC9vbnMtc3BsaXR0ZXItc2lkZT5cbiAqIDwvb25zLXNwbGl0dGVyPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGxpdHRlckNvbnRlbnRFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHBhZ2VcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVxuICAgKiAgICAgVGhlIHVybCBvZiB0aGUgY29udGVudCBwYWdlLiBJZiB0aGlzIGF0dHJpYnV0ZSBpcyB1c2VkIHRoZSBjb250ZW50IHdpbGwgYmUgbG9hZGVkIGZyb20gYSBgPG9ucy10ZW1wbGF0ZT5gIHRhZyBvciBhIHJlbW90ZSBmaWxlLlxuICAgKlxuICAgKiAgICAgSXQgaXMgYWxzbyBwb3NzaWJsZSB0byBwdXQgYDxvbnMtcGFnZT5gIGVsZW1lbnQgYXMgYSBjaGlsZCBvZiB0aGUgZWxlbWVudC5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1vbnMtc3BsaXR0ZXItY29udGVudOimgee0oOOBq+ihqOekuuOBmeOCi+ODmuODvOOCuOOBrlVSTOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5fcGFnZSA9IG51bGw7XG4gICAgdGhpcy5fcGFnZUxvYWRlciA9IGRlZmF1bHRQYWdlTG9hZGVyO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIGNvbnN0IHBhZ2UgPSB0aGlzLl9nZXRQYWdlVGFyZ2V0KCk7XG5cbiAgICAgIGlmIChwYWdlKSB7XG4gICAgICAgIHRoaXMubG9hZChwYWdlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGlmICghdXRpbC5tYXRjaCh0aGlzLnBhcmVudE5vZGUsICdvbnMtc3BsaXR0ZXInKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIm9ucy1zcGxpdHRlci1jb250ZW50XCIgbXVzdCBoYXZlIFwib25zLXNwbGl0dGVyXCIgYXMgcGFyZW50Tm9kZS5gKTtcbiAgICB9XG4gIH1cblxuICBfZ2V0UGFnZVRhcmdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZSB8fCB0aGlzLmdldEF0dHJpYnV0ZSgncGFnZScpO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7fVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHBhZ2VcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIHBhZ2UgdG8gbG9hZCBpbiB0aGUgc3BsaXR0ZXIgY29udGVudC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7opoHntKDlhoXjgavooajnpLrjgZnjgovjg5rjg7zjgrjjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0IHBhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2U7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHsqfSBwYWdlXG4gICAqL1xuICBzZXQgcGFnZShwYWdlKSB7XG4gICAgdGhpcy5fcGFnZSA9IHBhZ2U7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHBhZ2VMb2FkZXJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUGFnZSBlbGVtZW50IGxvYWRlZCBpbiB0aGUgc3BsaXR0ZXIgY29udGVudC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7opoHntKDlhoXjgavooajnpLrjgZnjgovjg5rjg7zjgrjjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0IHBhZ2VMb2FkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VMb2FkZXI7XG4gIH1cblxuICBzZXQgcGFnZUxvYWRlcihsb2FkZXIpIHtcbiAgICBpZiAoIShsb2FkZXIgaW5zdGFuY2VvZiBQYWdlTG9hZGVyKSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0ZpcnN0IHBhcmFtZXRlciBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFBhZ2VMb2FkZXInKTtcbiAgICB9XG4gICAgdGhpcy5fcGFnZUxvYWRlciA9IGxvYWRlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGxvYWRcbiAgICogQHNpZ25hdHVyZSBsb2FkKHBhZ2UsIFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhZ2UsIFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYWdlIFVSTC4gQ2FuIGJlIGVpdGhlciBhbiBIVE1MIGRvY3VtZW50IG9yIGFuIGA8b25zLXRlbXBsYXRlPmAgaWQuWy9lbl1cbiAgICogICBbamFdcGFnZeOBrlVSTOOBi+OAgW9ucy10ZW1wbGF0ZeOBp+Wuo+iogOOBl+OBn+ODhuODs+ODl+ODrOODvOODiOOBrmlk5bGe5oCn44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNob3cgdGhlIHBhZ2Ugc3BlY2lmaWVkIGluIGBwYWdlYCBpbiB0aGUgY29udGVudC5bL2VuXVxuICAgKiAgIFtqYV3mjIflrprjgZfjgZ9VUkzjgpLjg6HjgqTjg7Pjg5rjg7zjgrjjgpLoqq3jgb/ovrzjgb/jgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgbmV3IGA8b25zLXBhZ2U+YCBlbGVtZW50Wy9lbl1cbiAgICogICBbamFdYDxvbnMtcGFnZT5g6KaB57Sg44KS6Kej5rG644GZ44KLUHJvbWlzZeOCquODluOCuOOCp+OCr+ODiOOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBsb2FkKHBhZ2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX3BhZ2UgPSBwYWdlO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjayB8fCBmdW5jdGlvbigpIHt9O1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgdGhpcy5fcGFnZUxvYWRlci5sb2FkKHtwYWdlLCBwYXJlbnQ6IHRoaXMsIHJlcGxhY2U6IHRydWV9LCAoe2VsZW1lbnQsIHVubG9hZH0pID0+IHtcbiAgICAgICAgcmV3cml0YWJsZXMubGluayh0aGlzLCBlbGVtZW50LCBvcHRpb25zLCBmcmFnbWVudCA9PiB7XG4gICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuX3Nob3coKSk7XG4gICAgICAgICAgY2FsbGJhY2soKTtcblxuICAgICAgICAgIHJlc29sdmUodGhpcy5maXJzdENoaWxkKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIF9zaG93KCkge1xuICAgIHV0aWwucHJvcGFnYXRlQWN0aW9uKHRoaXMsICdfc2hvdycpO1xuICB9XG5cbiAgX2hpZGUoKSB7XG4gICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24odGhpcywgJ19oaWRlJyk7XG4gIH1cblxuICBfZGVzdHJveSgpIHtcbiAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbih0aGlzLCAnX2Rlc3Ryb3knKTtcbiAgICB0aGlzLnJlbW92ZSgpO1xuICB9XG5cbiAgc3RhdGljIGdldCByZXdyaXRhYmxlcygpIHtcbiAgICByZXR1cm4gcmV3cml0YWJsZXM7XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtc3BsaXR0ZXItY29udGVudCcsIFNwbGl0dGVyQ29udGVudEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJ29ucy9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGxpdHRlck1hc2tFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5fYm91bmRPbkNsaWNrID0gdGhpcy5fb25DbGljay5iaW5kKHRoaXMpO1xuICB9XG5cbiAgX29uQ2xpY2soZXZlbnQpIHtcbiAgICBpZiAodXRpbC5tYXRjaCh0aGlzLnBhcmVudE5vZGUsICdvbnMtc3BsaXR0ZXInKSkge1xuICAgICAgdGhpcy5wYXJlbnROb2RlLl9zaWRlcy5mb3JFYWNoKHNpZGUgPT4gc2lkZS5jbG9zZSgnbGVmdCcpLmNhdGNoKCgpID0+IHt9KSk7XG4gICAgfVxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE9uQ2xpY2spO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljayk7XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtc3BsaXR0ZXItbWFzaycsIFNwbGl0dGVyTWFza0VsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnb25zL3V0aWwnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICdvbnMvY29udGVudC1yZWFkeSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwbGl0dGVyQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX29wdGlvbnMgPSB7XG4gICAgICB0aW1pbmc6ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuMSwgMSknLFxuICAgICAgZHVyYXRpb246ICcwLjMnLFxuICAgICAgZGVsYXk6ICcwJ1xuICAgIH07XG4gICAgdGhpcy51cGRhdGVPcHRpb25zKG9wdGlvbnMpO1xuICB9XG5cbiAgdXBkYXRlT3B0aW9ucyhvcHRpb25zID0ge30pIHtcbiAgICB1dGlsLmV4dGVuZCh0aGlzLl9vcHRpb25zLCBvcHRpb25zKTtcbiAgICB0aGlzLl90aW1pbmcgPSB0aGlzLl9vcHRpb25zLnRpbWluZztcbiAgICB0aGlzLl9kdXJhdGlvbiA9IHRoaXMuX29wdGlvbnMuZHVyYXRpb247XG4gICAgdGhpcy5fZGVsYXkgPSB0aGlzLl9vcHRpb25zLmRlbGF5O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gc2lkZUVsZW1lbnRcbiAgICovXG4gIGFjdGl2YXRlKHNpZGVFbGVtZW50KSB7XG4gICAgY29uc3Qgc3BsaXR0ZXIgPSBzaWRlRWxlbWVudC5wYXJlbnROb2RlO1xuXG4gICAgY29udGVudFJlYWR5KHNwbGl0dGVyLCAoKSA9PiB7XG4gICAgICB0aGlzLl9zaWRlID0gc2lkZUVsZW1lbnQ7XG4gICAgICB0aGlzLl9jb250ZW50ID0gc3BsaXR0ZXIuY29udGVudDtcbiAgICAgIHRoaXMuX21hc2sgPSBzcGxpdHRlci5tYXNrO1xuICAgIH0pO1xuICB9XG5cbiAgaW5hY3RpdmF0ZSgpIHtcbiAgICB0aGlzLl9jb250ZW50ID0gdGhpcy5fc2lkZSA9IHRoaXMuX21hc2sgPSBudWxsO1xuICB9XG5cbiAgZ2V0IG1pbnVzKCkge1xuICAgIHJldHVybiB0aGlzLl9zaWRlLl9zaWRlID09PSAncmlnaHQnID8gJy0nIDogJyc7XG4gIH1cblxuICB0cmFuc2xhdGUoZGlzdGFuY2UpIHtcbiAgICBhbmltaXQodGhpcy5fc2lkZSlcbiAgICAgIC5xdWV1ZSh7XG4gICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKCR7dGhpcy5taW51cyArIGRpc3RhbmNlfXB4LCAwcHgsIDBweClgXG4gICAgICB9KVxuICAgICAgLnBsYXkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBvcGVuKGRvbmUpIHtcbiAgICBhbmltaXQucnVuQWxsKFxuICAgICAgYW5pbWl0KHRoaXMuX3NpZGUpXG4gICAgICAgIC53YWl0KHRoaXMuX2RlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKCR7dGhpcy5taW51c30xMDAlLCAwcHgsIDBweClgXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5fZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLl90aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKGNhbGxiYWNrID0+IHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUgJiYgZG9uZSgpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KHRoaXMuX21hc2spXG4gICAgICAgIC53YWl0KHRoaXMuX2RlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAnMSdcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLl9kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6ICdsaW5lYXInLFxuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgY2xvc2UoZG9uZSkge1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcbiAgICAgIGFuaW1pdCh0aGlzLl9zaWRlKVxuICAgICAgICAud2FpdCh0aGlzLl9kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwcHgsIDBweCwgMHB4KSdcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLl9kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMuX3RpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucXVldWUoY2FsbGJhY2sgPT4ge1xuICAgICAgICAgIHRoaXMuX3NpZGUuc3R5bGUud2Via2l0VHJhbnNpdGlvbiA9ICcnO1xuICAgICAgICAgIGRvbmUgJiYgZG9uZSgpO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQodGhpcy5fbWFzaylcbiAgICAgICAgLndhaXQodGhpcy5fZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogJzAnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5fZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiAnbGluZWFyJyxcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBkaXNwbGF5OiAnbm9uZSdcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJ29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBBbmltYXRvckZhY3RvcnkgZnJvbSAnb25zL2ludGVybmFsL2FuaW1hdG9yLWZhY3RvcnknO1xuaW1wb3J0IFNwbGl0dGVyQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIgZnJvbSAnb25zL2RldmljZS1iYWNrLWJ1dHRvbi1kaXNwYXRjaGVyJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBfYW5pbWF0b3JEaWN0ID0ge1xuICBkZWZhdWx0OiBTcGxpdHRlckFuaW1hdG9yLFxuICBvdmVybGF5OiBTcGxpdHRlckFuaW1hdG9yXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1zcGxpdHRlclxuICogQGNhdGVnb3J5IG1lbnVcbiAqIEBkZXNjcmlwdGlvblxuICogIFtlbl1cbiAqICAgIEEgY29tcG9uZW50IHRoYXQgZW5hYmxlcyByZXNwb25zaXZlIGxheW91dCBieSBpbXBsZW1lbnRpbmcgYm90aCBhIHR3by1jb2x1bW4gbGF5b3V0IGFuZCBhIHNsaWRpbmcgbWVudSBsYXlvdXQuXG4gKlxuICogICAgSXQgY2FuIGJlIGNvbmZpZ3VyZWQgdG8gYXV0b21hdGljYWxseSBleHBhbmQgaW50byBhIGNvbHVtbiBsYXlvdXQgb24gbGFyZ2Ugc2NyZWVucyBhbmQgY29sbGFwc2UgdGhlIG1lbnUgb24gc21hbGxlciBzY3JlZW5zLiBXaGVuIHRoZSBtZW51IGlzIGNvbGxhcHNlZCB0aGUgdXNlciBjYW4gb3BlbiBpdCBieSBzd2lwaW5nLlxuICogIFsvZW5dXG4gKiAgW2phXVsvamFdXG4gKiBAY29kZXBlbiByT1FPTUxcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9zcGxpdHRlclxuICogQGd1aWRlIG11bHRpcGxlLXBhZ2UtbmF2aWdhdGlvblxuICogIFtlbl1NYW5hZ2luZyBtdWx0aXBsZSBwYWdlcy5bL2VuXVxuICogIFtqYV1NYW5hZ2luZyBtdWx0aXBsZSBwYWdlc1svamFdXG4gKiBAc2VlYWxzbyBvbnMtc3BsaXR0ZXItY29udGVudFxuICogIFtlbl1UaGUgYDxvbnMtc3BsaXR0ZXItY29udGVudD5gIGNvbXBvbmVudCBjb250YWlucyB0aGUgbWFpbiBjb250ZW50IG9mIHRoZSBwYWdlLlsvZW5dXG4gKiAgW2phXW9ucy1zcGxpdHRlci1jb250ZW5044Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1zcGxpdHRlci1zaWRlXG4gKiAgW2VuXVRoZSBgPG9ucy1zcGxpdHRlci1zaWRlPmAgY29tcG9uZW50IGNvbnRhaW5zIHRoZSBtZW51LlsvZW5dXG4gKiAgW2phXW9ucy1zcGxpdHRlci1zaWRl44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXNwbGl0dGVyIGlkPVwic3BsaXR0ZXJcIj5cbiAqICAgPG9ucy1zcGxpdHRlci1jb250ZW50PlxuICogICAgIC4uLlxuICogICA8L29ucy1zcGxpdHRlci1jb250ZW50PlxuICpcbiAqICAgPG9ucy1zcGxpdHRlci1zaWRlIHNpZGU9XCJsZWZ0XCIgd2lkdGg9XCI4MCVcIiBjb2xsYXBzZSBzd2lwZWFibGU+XG4gKiAgICAgLi4uXG4gKiAgIDwvb25zLXNwbGl0dGVyLXNpZGU+XG4gKiA8L29ucy1zcGxpdHRlcj5cbiAqXG4gKiA8c2NyaXB0PlxuICogICB2YXIgc3BsaXR0ZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3BsaXR0ZXInKTtcbiAqICAgc3BsaXR0ZXIubGVmdC5vcGVuKCk7XG4gKiA8L3NjcmlwdD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3BsaXR0ZXJFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIF9nZXRTaWRlKHNpZGUpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdXRpbC5maW5kQ2hpbGQodGhpcywgZSA9PiB7XG4gICAgICByZXR1cm4gdXRpbC5tYXRjaChlLCAnb25zLXNwbGl0dGVyLXNpZGUnKSAmJiBlLmdldEF0dHJpYnV0ZSgnc2lkZScpID09PSBzaWRlO1xuICAgIH0pO1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBsZWZ0XG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1MZWZ0IGA8b25zLXNwbGl0dGVyLXNpZGU+YCBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgbGVmdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0U2lkZSgnbGVmdCcpO1xuICB9XG4gIC8qKlxuICAgKiBAcHJvcGVydHkgcmlnaHRcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJpZ2h0IGA8b25zLXNwbGl0dGVyLXNpZGU+YCBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgcmlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFNpZGUoJ3JpZ2h0Jyk7XG4gIH1cblxuICBnZXQgX3NpZGVzKCkge1xuICAgIHJldHVybiBbdGhpcy5sZWZ0LCB0aGlzLnJpZ2h0XS5maWx0ZXIoZSA9PiBlKTtcbiAgfVxuICAvKipcbiAgICogQHByb3BlcnR5IGNvbnRlbnRcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBgPG9ucy1zcGxpdHRlci1jb250ZW50PmAgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgZ2V0IGNvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICdvbnMtc3BsaXR0ZXItY29udGVudCcpO1xuICB9XG5cbiAgZ2V0IG1hc2soKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICdvbnMtc3BsaXR0ZXItbWFzaycpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvbkRldmljZUJhY2tCdXR0b25cbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUJhY2stYnV0dG9uIGhhbmRsZXIuWy9lbl1cbiAgICogICBbamFd44OQ44OD44Kv44Oc44K/44Oz44OP44Oz44OJ44Op44CCWy9qYV1cbiAgICovXG4gIGdldCBvbkRldmljZUJhY2tCdXR0b24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyO1xuICB9XG5cbiAgc2V0IG9uRGV2aWNlQmFja0J1dHRvbihjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcikge1xuICAgICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyID0gZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIuY3JlYXRlSGFuZGxlcih0aGlzLCBjYWxsYmFjayk7XG4gIH1cblxuICBfb25EZXZpY2VCYWNrQnV0dG9uKGV2ZW50KSB7XG4gICAgdGhpcy5fc2lkZXMuc29tZShzID0+IHMuaXNPcGVuID8gcy5jbG9zZSgpIDogZmFsc2UpIHx8IGV2ZW50LmNhbGxQYXJlbnRIYW5kbGVyKCk7XG4gIH1cblxuICBfb25Nb2RlQ2hhbmdlKGUpIHtcbiAgICBpZiAoZS50YXJnZXQucGFyZW50Tm9kZSkge1xuICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgdGhpcy5fbGF5b3V0KCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBfbGF5b3V0KCkge1xuICAgIHRoaXMuX3NpZGVzLmZvckVhY2goc2lkZSA9PiB7XG4gICAgICB0aGlzLmNvbnRlbnQuc3R5bGVbc2lkZS5fc2lkZV0gPSBzaWRlLm1vZGUgPT09ICdzcGxpdCcgPyBzaWRlLl93aWR0aCA6IDA7XG4gICAgfSk7XG4gIH1cblxuICBpbml0KCkge1xuICAgIHRoaXMuX2JvdW5kT25Nb2RlQ2hhbmdlID0gdGhpcy5fb25Nb2RlQ2hhbmdlLmJpbmQodGhpcyk7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgICAgdGhpcy5fbGF5b3V0KCk7XG4gICAgfSk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBpZiAoIXRoaXMubWFzaykge1xuICAgICAgdGhpcy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvbnMtc3BsaXR0ZXItbWFzaycpKTtcbiAgICB9XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLm9uRGV2aWNlQmFja0J1dHRvbiA9IHRoaXMuX29uRGV2aWNlQmFja0J1dHRvbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignbW9kZWNoYW5nZScsIHRoaXMuX2JvdW5kT25Nb2RlQ2hhbmdlLCBmYWxzZSk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlci5kZXN0cm95KCk7XG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIgPSBudWxsO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW9kZWNoYW5nZScsIHRoaXMuX2JvdW5kT25Nb2RlQ2hhbmdlLCBmYWxzZSk7XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge31cblxuICBfc2hvdygpIHtcbiAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbih0aGlzLCAnX3Nob3cnKTtcbiAgfVxuXG4gIF9oaWRlKCkge1xuICAgIHV0aWwucHJvcGFnYXRlQWN0aW9uKHRoaXMsICdfaGlkZScpO1xuICB9XG5cbiAgX2Rlc3Ryb3koKSB7XG4gICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24odGhpcywgJ19kZXN0cm95Jyk7XG4gICAgdGhpcy5yZW1vdmUoKTtcbiAgfVxuXG4gIHN0YXRpYyByZWdpc3RlckFuaW1hdG9yKG5hbWUsIEFuaW1hdG9yKSB7XG4gICAgaWYgKCEoQW5pbWF0b3IgaW5zdGFuY2VvZiBTcGxpdHRlckFuaW1hdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbmltYXRvciBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBTcGxpdHRlckFuaW1hdG9yLicpO1xuICAgIH1cbiAgICBfYW5pbWF0b3JEaWN0W25hbWVdID0gQW5pbWF0b3I7XG4gIH1cblxuICBzdGF0aWMgZ2V0IFNwbGl0dGVyQW5pbWF0b3IoKSB7XG4gICAgcmV0dXJuIFNwbGl0dGVyQW5pbWF0b3I7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGFuaW1hdG9ycygpIHtcbiAgICByZXR1cm4gX2FuaW1hdG9yRGljdDtcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1zcGxpdHRlcicsIFNwbGl0dGVyRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5pbXBvcnQgQW5pbWF0b3JGYWN0b3J5IGZyb20gJ29ucy9pbnRlcm5hbC9hbmltYXRvci1mYWN0b3J5JztcbmltcG9ydCBvcmllbnRhdGlvbiBmcm9tICdvbnMvb3JpZW50YXRpb24nO1xuaW1wb3J0IGludGVybmFsIGZyb20gJ29ucy9pbnRlcm5hbCc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJ29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCBTcGxpdHRlckFuaW1hdG9yIGZyb20gJy4vb25zLXNwbGl0dGVyL2FuaW1hdG9yJztcbmltcG9ydCBHZXN0dXJlRGV0ZWN0b3IgZnJvbSAnb25zL2dlc3R1cmUtZGV0ZWN0b3InO1xuaW1wb3J0IERvb3JMb2NrIGZyb20gJ29ucy9kb29ybG9jayc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJ29ucy9jb250ZW50LXJlYWR5JztcbmltcG9ydCB7IFBhZ2VMb2FkZXIsIGRlZmF1bHRQYWdlTG9hZGVyfSBmcm9tICdvbnMvcGFnZS1sb2FkZXInO1xuaW1wb3J0IFNwbGl0dGVyRWxlbWVudCBmcm9tICcuL29ucy1zcGxpdHRlcic7XG5cbmNvbnN0IFNQTElUX01PREUgPSAnc3BsaXQnO1xuY29uc3QgQ09MTEFQU0VfTU9ERSA9ICdjb2xsYXBzZSc7XG5jb25zdCBDTE9TRURfU1RBVEUgPSAnY2xvc2VkJztcbmNvbnN0IE9QRU5fU1RBVEUgPSAnb3Blbic7XG5jb25zdCBDSEFOR0lOR19TVEFURSA9ICdjaGFuZ2luZyc7XG5cbmNvbnN0IFdBVENIRURfQVRUUklCVVRFUyA9IFsnYW5pbWF0aW9uJywgJ3dpZHRoJywgJ3NpZGUnLCAnY29sbGFwc2UnLCAnc3dpcGVhYmxlJywgJ3N3aXBlLXRhcmdldC13aWR0aCcsICdhbmltYXRpb24tb3B0aW9ucycsICdvcGVuLXRocmVzaG9sZCddO1xuXG5cbmNvbnN0IHJld3JpdGFibGVzID0ge1xuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBzcGxpdHRlclNpZGVFbGVtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICByZWFkeShzcGxpdHRlclNpZGVFbGVtZW50LCBjYWxsYmFjaykge1xuICAgIHNldEltbWVkaWF0ZShjYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gc3BsaXR0ZXJTaWRlRWxlbWVudFxuICAgKiBAcGFyYW0ge0hUTUxGcmFnbWVudH0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBsaW5rKHNwbGl0dGVyU2lkZUVsZW1lbnQsIHRhcmdldCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayh0YXJnZXQpO1xuICB9XG59O1xuXG5jbGFzcyBDb2xsYXBzZURldGVjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIHRhcmdldCkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuX2JvdW5kT25DaGFuZ2UgPSB0aGlzLl9vbkNoYW5nZS5iaW5kKHRoaXMpO1xuICAgIHRhcmdldCAmJiB0aGlzLmNoYW5nZVRhcmdldCh0YXJnZXQpO1xuICB9XG5cbiAgY2hhbmdlVGFyZ2V0KHRhcmdldCkge1xuICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICB0aGlzLl9vcmllbnRhdGlvbiA9IFsncG9ydHJhaXQnLCAnbGFuZHNjYXBlJ10uaW5kZXhPZih0YXJnZXQpICE9PSAtMTtcbiAgICAgIHRoaXMuYWN0aXZhdGUoKTtcbiAgICB9XG4gIH1cblxuICBfbWF0Y2godmFsdWUpIHtcbiAgICBpZiAodGhpcy5fb3JpZW50YXRpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLl90YXJnZXQgPT09ICh2YWx1ZS5pc1BvcnRyYWl0ID8gJ3BvcnRyYWl0JyA6ICdsYW5kc2NhcGUnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLm1hdGNoZXM7XG4gIH1cblxuICBfb25DaGFuZ2UodmFsdWUpIHtcbiAgICB0aGlzLl9lbGVtZW50Ll91cGRhdGVNb2RlKHRoaXMuX21hdGNoKHZhbHVlKSA/IENPTExBUFNFX01PREUgOiBTUExJVF9NT0RFKTtcbiAgfVxuXG4gIGFjdGl2YXRlKCkge1xuICAgIGlmICh0aGlzLl9vcmllbnRhdGlvbikge1xuICAgICAgb3JpZW50YXRpb24ub24oJ2NoYW5nZScsIHRoaXMuX2JvdW5kT25DaGFuZ2UpO1xuICAgICAgdGhpcy5fb25DaGFuZ2Uoe2lzUG9ydHJhaXQ6IG9yaWVudGF0aW9uLmlzUG9ydHJhaXQoKX0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9xdWVyeVJlc3VsdCA9IHdpbmRvdy5tYXRjaE1lZGlhKHRoaXMuX3RhcmdldCk7XG4gICAgICB0aGlzLl9xdWVyeVJlc3VsdC5hZGRMaXN0ZW5lcih0aGlzLl9ib3VuZE9uQ2hhbmdlKTtcbiAgICAgIHRoaXMuX29uQ2hhbmdlKHRoaXMuX3F1ZXJ5UmVzdWx0KTtcbiAgICB9XG4gIH1cblxuICBkaXNhYmxlKCkge1xuICAgIGlmICh0aGlzLl9vcmllbnRhdGlvbikge1xuICAgICAgb3JpZW50YXRpb24ub2ZmKCdjaGFuZ2UnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3F1ZXJ5UmVzdWx0KSB7XG4gICAgICB0aGlzLl9xdWVyeVJlc3VsdC5yZW1vdmVMaXN0ZW5lcih0aGlzLl9ib3VuZE9uQ2hhbmdlKTtcbiAgICAgIHRoaXMuX3F1ZXJ5UmVzdWx0ID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuY29uc3Qgd2lkdGhUb1B4ID0gKHdpZHRoLCBwYXJlbnQpID0+IHtcbiAgY29uc3QgW3ZhbHVlLCBweF0gPSBbcGFyc2VJbnQod2lkdGgsIDEwKSwgL3B4Ly50ZXN0KHdpZHRoKV07XG4gIHJldHVybiBweCA/IHZhbHVlIDogTWF0aC5yb3VuZChwYXJlbnQub2Zmc2V0V2lkdGggKiB2YWx1ZSAvIDEwMCk7XG59O1xuXG5jbGFzcyBDb2xsYXBzZU1vZGUge1xuICBnZXQgX2FuaW1hdG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50Ll9hbmltYXRvcjtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQpIHtcbiAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLl9zdGF0ZSA9IENMT1NFRF9TVEFURTtcbiAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLl9sb2NrID0gbmV3IERvb3JMb2NrKCk7XG4gIH1cblxuICBpc09wZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZSAmJiB0aGlzLl9zdGF0ZSAhPT0gQ0xPU0VEX1NUQVRFO1xuICB9XG5cbiAgaGFuZGxlR2VzdHVyZShlKSB7XG4gICAgaWYgKCF0aGlzLl9hY3RpdmUgfHwgdGhpcy5fbG9jay5pc0xvY2tlZCgpIHx8IHRoaXMuX2lzT3Blbk90aGVyU2lkZU1lbnUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZS50eXBlID09PSAnZHJhZ3N0YXJ0Jykge1xuICAgICAgdGhpcy5fb25EcmFnU3RhcnQoZSk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5faWdub3JlRHJhZykge1xuICAgICAgZS50eXBlID09PSAnZHJhZ2VuZCcgPyB0aGlzLl9vbkRyYWdFbmQoZSkgOiB0aGlzLl9vbkRyYWcoZSk7XG4gICAgfVxuICB9XG5cbiAgX29uRHJhZ1N0YXJ0KGV2ZW50KSB7XG4gICAgY29uc3Qgc2Nyb2xsaW5nID0gIS9sZWZ0fHJpZ2h0Ly50ZXN0KGV2ZW50Lmdlc3R1cmUuZGlyZWN0aW9uKTtcbiAgICBjb25zdCBkaXN0YW5jZSA9IHRoaXMuX2VsZW1lbnQuX3NpZGUgPT09ICdsZWZ0JyA/IGV2ZW50Lmdlc3R1cmUuY2VudGVyLmNsaWVudFggOiB3aW5kb3cuaW5uZXJXaWR0aCAtIGV2ZW50Lmdlc3R1cmUuY2VudGVyLmNsaWVudFg7XG4gICAgY29uc3QgYXJlYSA9IHRoaXMuX2VsZW1lbnQuX3N3aXBlVGFyZ2V0V2lkdGg7XG4gICAgY29uc3QgaXNPcGVuID0gdGhpcy5pc09wZW4oKTtcbiAgICB0aGlzLl9pZ25vcmVEcmFnID0gc2Nyb2xsaW5nIHx8IChhcmVhICYmIGRpc3RhbmNlID4gYXJlYSAmJiAhaXNPcGVuKTtcblxuICAgIHRoaXMuX3dpZHRoID0gd2lkdGhUb1B4KHRoaXMuX2VsZW1lbnQuX3dpZHRoLCB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUpO1xuICAgIHRoaXMuX3N0YXJ0RGlzdGFuY2UgPSB0aGlzLl9kaXN0YW5jZSA9IGlzT3BlbiA/IHRoaXMuX3dpZHRoIDogMDtcbiAgfVxuXG4gIF9vbkRyYWcoZXZlbnQpIHtcbiAgICBldmVudC5nZXN0dXJlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3QgZGVsdGEgPSB0aGlzLl9lbGVtZW50Ll9zaWRlID09PSAnbGVmdCcgPyBldmVudC5nZXN0dXJlLmRlbHRhWCA6IC1ldmVudC5nZXN0dXJlLmRlbHRhWDtcbiAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMuX3dpZHRoLCB0aGlzLl9zdGFydERpc3RhbmNlICsgZGVsdGEpKTtcbiAgICBpZiAoZGlzdGFuY2UgIT09IHRoaXMuX2Rpc3RhbmNlKSB7XG4gICAgICB0aGlzLl9hbmltYXRvci50cmFuc2xhdGUoZGlzdGFuY2UpO1xuICAgICAgdGhpcy5fZGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgIHRoaXMuX3N0YXRlID0gQ0hBTkdJTkdfU1RBVEU7XG4gICAgfVxuICB9XG5cbiAgX29uRHJhZ0VuZChldmVudCkge1xuICAgIGNvbnN0IHtfZGlzdGFuY2U6IGRpc3RhbmNlLCBfd2lkdGg6IHdpZHRoLCBfZWxlbWVudDogZWx9ID0gdGhpcztcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBldmVudC5nZXN0dXJlLmludGVyaW1EaXJlY3Rpb247XG4gICAgY29uc3Qgc2hvdWxkT3BlbiA9IGVsLl9zaWRlICE9PSBkaXJlY3Rpb24gJiYgZGlzdGFuY2UgPiB3aWR0aCAqIGVsLl90aHJlc2hvbGQ7XG4gICAgdGhpcy5leGVjdXRlQWN0aW9uKHNob3VsZE9wZW4gPyAnb3BlbicgOiAnY2xvc2UnKTtcbiAgICB0aGlzLl9pZ25vcmVEcmFnID0gdHJ1ZTtcbiAgfVxuXG4gIGxheW91dCgpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlICYmIHRoaXMuX3N0YXRlID09PSBPUEVOX1NUQVRFKSB7XG4gICAgICB0aGlzLl9hbmltYXRvci5vcGVuKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gZW50ZXIgY29sbGFwc2UgbW9kZVxuICBlbnRlck1vZGUoKSB7XG4gICAgaWYgKCF0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG4gICAgICB0aGlzLmxheW91dCgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGV4aXQgY29sbGFwc2UgbW9kZVxuICBleGl0TW9kZSgpIHtcbiAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgfVxuXG4gIF9pc09wZW5PdGhlclNpZGVNZW51KCkge1xuICAgIHJldHVybiB1dGlsLmFycmF5RnJvbSh0aGlzLl9lbGVtZW50LnBhcmVudEVsZW1lbnQuY2hpbGRyZW4pLnNvbWUoZSA9PiB7XG4gICAgICByZXR1cm4gdXRpbC5tYXRjaChlLCAnb25zLXNwbGl0dGVyLXNpZGUnKSAmJiBlICE9PSB0aGlzLl9lbGVtZW50ICYmIGUuaXNPcGVuO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gJ29wZW4nIG9yICdjbG9zZSdcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy53aXRob3V0QW5pbWF0aW9uXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlcyB0byB0aGUgc3BsaXR0ZXIgc2lkZSBlbGVtZW50IG9yIGZhbHNlIGlmIG5vdCBpbiBjb2xsYXBzZSBtb2RlXG4gICAqL1xuICBleGVjdXRlQWN0aW9uKG5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IEZJTkFMX1NUQVRFID0gbmFtZSA9PT0gJ29wZW4nID8gT1BFTl9TVEFURSA6IENMT1NFRF9TVEFURTtcblxuICAgIGlmICghdGhpcy5fYWN0aXZlKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IEZJTkFMX1NUQVRFKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2VsZW1lbnQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fbG9jay5pc0xvY2tlZCgpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ1NwbGl0dGVyIHNpZGUgaXMgbG9ja2VkLicpO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gJ29wZW4nICYmIHRoaXMuX2lzT3Blbk90aGVyU2lkZU1lbnUoKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdBbm90aGVyIG1lbnUgaXMgYWxyZWFkeSBvcGVuLicpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZWxlbWVudC5fZW1pdEV2ZW50KGBwcmUke25hbWV9YCkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChgQ2FuY2VsZWQgaW4gcHJlJHtuYW1lfSBldmVudC5gKTtcbiAgICB9XG5cbiAgICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2s7XG4gICAgY29uc3QgdW5sb2NrID0gdGhpcy5fbG9jay5sb2NrKCk7XG4gICAgY29uc3QgZG9uZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX3N0YXRlID0gRklOQUxfU1RBVEU7XG4gICAgICB0aGlzLmxheW91dCgpO1xuICAgICAgdW5sb2NrKCk7XG4gICAgICB0aGlzLl9lbGVtZW50Ll9lbWl0RXZlbnQoYHBvc3Qke25hbWV9YCk7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgIH07XG5cbiAgICBpZiAob3B0aW9ucy53aXRob3V0QW5pbWF0aW9uKSB7XG4gICAgICBkb25lKCk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2VsZW1lbnQpO1xuICAgIH1cbiAgICB0aGlzLl9zdGF0ZSA9IENIQU5HSU5HX1NUQVRFO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHRoaXMuX2FuaW1hdG9yW25hbWVdKCgpID0+IHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgICByZXNvbHZlKHRoaXMuX2VsZW1lbnQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtc3BsaXR0ZXItc2lkZVxuICogQGNhdGVnb3J5IG1lbnVcbiAqIEBkZXNjcmlwdGlvblxuICogIFtlbl1cbiAqICAgIFRoZSBgPG9ucy1zcGxpdHRlci1zaWRlPmAgZWxlbWVudCBpcyB1c2VkIGFzIGEgY2hpbGQgZWxlbWVudCBvZiBgPG9ucy1zcGxpdHRlcj5gLlxuICpcbiAqICAgIEl0IHdpbGwgYmUgZGlzcGxheWVkIG9uIGVpdGhlciB0aGUgbGVmdCBvciByaWdodCBzaWRlIG9mIHRoZSBgPG9ucy1zcGxpdHRlci1jb250ZW50PmAgZWxlbWVudC5cbiAqXG4gKiAgICBJdCBzdXBwb3J0cyB0d28gbW9kZXM6IGNvbGxhcHNlZCBhbmQgc3BsaXQuIFdoZW4gaXQncyBpbiBjb2xsYXBzZWQgbW9kZSBpdCB3aWxsIGJlIGhpZGRlbiBmcm9tIHZpZXcgYW5kIGNhbiBiZSBkaXNwbGF5ZWQgd2hlbiB0aGUgdXNlciBzd2lwZXMgdGhlIHNjcmVlbiBvciB0YXBzIGEgYnV0dG9uLiBJbiBzcGxpdCBtb2RlIHRoZSBlbGVtZW50IGlzIGFsd2F5cyBzaG93bi4gSXQgY2FuIGJlIGNvbmZpZ3VyZWQgdG8gYXV0b21hdGljYWxseSBzd2l0Y2ggYmV0d2VlbiB0aGUgdHdvIG1vZGVzIGRlcGVuZGluZyBvbiB0aGUgc2NyZWVuIHNpemUuXG4gKiAgWy9lbl1cbiAqICBbamFdb25zLXNwbGl0dGVyLXNpZGXopoHntKDjga/jgIFvbnMtc3BsaXR0ZXLopoHntKDjga7lrZDopoHntKDjgajjgZfjgabliKnnlKjjgZfjgb7jgZnjgIJbL2phXVxuICogQGNvZGVwZW4gck9RT01MXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2Uvc3BsaXR0ZXJcbiAqIEBndWlkZSBtdWx0aXBsZS1wYWdlLW5hdmlnYXRpb25cbiAqICBbZW5dTWFuYWdpbmcgbXVsdGlwbGUgcGFnZXMuWy9lbl1cbiAqICBbamFdTWFuYWdpbmcgbXVsdGlwbGUgcGFnZXNbL2phXVxuICogQHNlZWFsc28gb25zLXNwbGl0dGVyXG4gKiAgW2VuXVRoZSBgPG9ucy1zcGxpdHRlcj5gIGlzIHRoZSBwYXJlbnQgY29tcG9uZW50LlsvZW5dXG4gKiAgW2phXW9ucy1zcGxpdHRlcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtc3BsaXR0ZXItY29udGVudFxuICogIFtlbl1UaGUgYDxvbnMtc3BsaXR0ZXItY29udGVudD5gIGNvbXBvbmVudCBjb250YWlucyB0aGUgbWFpbiBjb250ZW50IG9mIHRoZSBwYWdlLlsvZW5dXG4gKiAgW2phXW9ucy1zcGxpdHRlci1jb250ZW5044Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXNwbGl0dGVyPlxuICogICA8b25zLXNwbGl0dGVyLWNvbnRlbnQ+XG4gKiAgICAgLi4uXG4gKiAgIDwvb25zLXNwbGl0dGVyLWNvbnRlbnQ+XG4gKlxuICogICA8b25zLXNwbGl0dGVyLXNpZGUgc2lkZT1cImxlZnRcIiB3aWR0aD1cIjgwJVwiIGNvbGxhcHNlPlxuICogICAgIC4uLlxuICogICA8L29ucy1zcGxpdHRlci1zaWRlPlxuICogPC9vbnMtc3BsaXR0ZXI+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwbGl0dGVyU2lkZUVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBtb2RlY2hhbmdlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBjb21wb25lbnQncyBtb2RlIGNoYW5nZXMuWy9lbl1cbiAgICogICBbamFd44GT44Gu6KaB57Sg44Gu44Oi44O844OJ44GM5aSJ5YyW44GX44Gf6Zqb44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuc2lkZVxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudC5tb2RlXG4gICAqICAgW2VuXVJldHVybnMgdGhlIGN1cnJlbnQgbW9kZS4gQ2FuIGJlIGVpdGhlciBgXCJjb2xsYXBzZVwiYCBvciBgXCJzcGxpdFwiYC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7jg6Ljg7zjg4njgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHByZW9wZW5cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYmVmb3JlIHRoZSBzbGlkaW5nIG1lbnUgaXMgb3BlbmVkLlsvZW5dXG4gICAqICAgW2phXeOCueODqeOCpOODh+OCo+ODs+OCsOODoeODi+ODpeODvOOBjOmWi+OBj+WJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUNhbGwgdG8gY2FuY2VsIG9wZW5pbmcgc2xpZGluZyBtZW51LlsvZW5dXG4gICAqICAgW2phXeOCueODqeOCpOODh+OCo+ODs+OCsOODoeODi+ODpeODvOOBjOmWi+OBj+OBruOCkuOCreODo+ODs+OCu+ODq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5zaWRlXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0b3BlblxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgc2xpZGluZyBtZW51IGlzIG9wZW5lZC5bL2VuXVxuICAgKiAgIFtqYV3jgrnjg6njgqTjg4fjgqPjg7PjgrDjg6Hjg4vjg6Xjg7zjgYzplovjgYTjgZ/lvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5zaWRlXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVjbG9zZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIHNsaWRpbmcgbWVudSBpcyBjbG9zZWQuWy9lbl1cbiAgICogICBbamFd44K544Op44Kk44OH44Kj44Oz44Kw44Oh44OL44Ol44O844GM6ZaJ44GY44KL5YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuc2lkZVxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LmNhbmNlbFxuICAgKiAgIFtlbl1DYWxsIHRvIGNhbmNlbCBvcGVuaW5nIHNsaWRpbmctbWVudS5bL2VuXVxuICAgKiAgIFtqYV3jgrnjg6njgqTjg4fjgqPjg7PjgrDjg6Hjg4vjg6Xjg7zjgYzplonjgZjjgovjga7jgpLjgq3jg6Pjg7Pjgrvjg6vjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RjbG9zZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgc2xpZGluZyBtZW51IGlzIGNsb3NlZC5bL2VuXVxuICAgKiAgIFtqYV3jgrnjg6njgqTjg4fjgqPjg7PjgrDjg6Hjg4vjg6Xjg7zjgYzplonjgZjjgZ/lvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5zaWRlXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0ICBkZWZhdWx0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbi4gVXNlIG9uZSBvZiBgXCJvdmVybGF5XCJgLCBhbmQgYFwiZGVmYXVsdFwiYC5bL2VuXVxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+OCkuaMh+WumuOBl+OBvuOBmeOAglwib3ZlcmxheVwiLCBcImRlZmF1bHRcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvbi1vcHRpb25zXG4gICAqIEB0eXBlIHtFeHByZXNzaW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgdGltaW5nIGFuZCBkZWxheSB3aXRoIGFuIG9iamVjdCBsaXRlcmFsLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgdGltaW5nLCBkZWxheeOCkuOCquODluOCuOOCp+OCr+ODiOODquODhuODqeODq+OBp+aMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBvcGVuLXRocmVzaG9sZFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVmYXVsdCAgMC4zXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgaG93IG11Y2ggdGhlIG1lbnUgbmVlZHMgdG8gYmUgc3dpcGVkIGJlZm9yZSBvcGVuaW5nLiBBIHZhbHVlIGJldHdlZW4gYDBgIGFuZCBgMWAuWy9lbl1cbiAgICogIFtqYV3jganjga7jgY/jgonjgYTjgrnjg6/jgqTjg5fjgZnjgozjgbDjgrnjg6njgqTjg4fjgqPjg7PjgrDjg6Hjg4vjg6Xjg7zjgpLplovjgY/jgYvjganjgYbjgYvjga7libLlkIjjgpLmjIflrprjgZfjgb7jgZnjgIIw44GL44KJMeOBrumWk+OBruaVsOWApOOCkuaMh+WumuOBl+OBvuOBmeOAguOCueODr+OCpOODl+OBrui3nembouOBjOOBk+OBk+OBp+aMh+WumuOBl+OBn+aVsOWApOaOm+OBkeOCi+OBk+OBruimgee0oOOBruW5heOCiOOCiuOCguWkp+OBjeOBkeOCjOOBsOOAgeOCueODr+OCpOODl+OBjOe1guOCj+OBo+OBn+aZguOBq+OBk+OBruimgee0oOOCkumWi+OBjeOBvuOBmeOAguODh+ODleOCqeODq+ODiOOBrzAuM+OBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGNvbGxhcHNlXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIFNwZWNpZnkgdGhlIGNvbGxhcHNlIGJlaGF2aW9yLiBWYWxpZCB2YWx1ZXMgYXJlIGBcInBvcnRyYWl0XCJgLCBgXCJsYW5kc2NhcGVcImAgb3IgYSBtZWRpYSBxdWVyeS5cbiAgICogICAgIFRoZSBzdHJpbmdzIGBcInBvcnRyYWl0XCJgIGFuZCBgXCJsYW5kc2NhcGVcImAgbWVhbnMgdGhlIHZpZXcgd2lsbCBjb2xsYXBzZSB3aGVuIGRldmljZSBpcyBpbiBsYW5kc2NhcGUgb3IgcG9ydHJhaXQgb3JpZW50YXRpb24uXG4gICAqICAgICBJZiB0aGUgdmFsdWUgaXMgYSBtZWRpYSBxdWVyeSwgdGhlIHZpZXcgd2lsbCBjb2xsYXBzZSB3aGVuIHRoZSBtZWRpYSBxdWVyeSByZXNvbHZlcyB0byBgdHJ1ZWAuXG4gICAqICAgICBJZiB0aGUgdmFsdWUgaXMgbm90IGRlZmluZWQsIHRoZSB2aWV3IGFsd2F5cyBiZSBpbiBgXCJjb2xsYXBzZVwiYCBtb2RlLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVxuICAgKiAgICAg5bem5YG044Gu44Oa44O844K444KS6Z2e6KGo56S644Gr44GZ44KL5p2h5Lu244KS5oyH5a6a44GX44G+44GZ44CCcG9ydHJhaXQsIGxhbmRzY2FwZeOAgXdpZHRoICNweOOCguOBl+OBj+OBr+ODoeODh+OCo+OCouOCr+OCqOODquOBruaMh+WumuOBjOWPr+iDveOBp+OBmeOAglxuICAgKiAgICAgcG9ydHJhaXTjgoLjgZfjgY/jga9sYW5kc2NhcGXjgpLmjIflrprjgZnjgovjgajjgIHjg4fjg5DjgqTjgrnjga7nlLvpnaLjgYznuKblkJHjgY3jgoLjgZfjgY/jga/mqKrlkJHjgY3jgavjgarjgaPjgZ/mmYLjgavpgannlKjjgZXjgozjgb7jgZnjgIJcbiAgICogICAgIOODoeODh+OCo+OCouOCr+OCqOODquOCkuaMh+WumuOBmeOCi+OBqOOAgeaMh+WumuOBl+OBn+OCr+OCqOODquOBq+mBqeWQiOOBl+OBpuOBhOOCi+WgtOWQiOOBq+mBqeeUqOOBleOCjOOBvuOBmeOAglxuICAgKiAgICAg5YCk44Gr5L2V44KC5oyH5a6a44GX44Gq44GE5aC05ZCI44Gr44Gv44CB5bi444GrY29sbGFwc2Xjg6Ljg7zjg4njgavjgarjgorjgb7jgZnjgIJcbiAgICogICBbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzd2lwZS10YXJnZXQtd2lkdGhcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSB3aWR0aCBvZiBzd2lwZWFibGUgYXJlYSBjYWxjdWxhdGVkIGZyb20gdGhlIGVkZ2UgKGluIHBpeGVscykuIFVzZSB0aGlzIHRvIGVuYWJsZSBzd2lwZSBvbmx5IHdoZW4gdGhlIGZpbmdlciB0b3VjaCBvbiB0aGUgc2NyZWVuIGVkZ2UuWy9lbl1cbiAgICogICBbamFd44K544Ov44Kk44OX44Gu5Yik5a6a6aCY5Z+f44KS44OU44Kv44K744Or5Y2Y5L2N44Gn5oyH5a6a44GX44G+44GZ44CC55S76Z2i44Gu56uv44GL44KJ5oyH5a6a44GX44Gf6Led6Zui44Gr6YGU44GZ44KL44Go44Oa44O844K444GM6KGo56S644GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgd2lkdGhcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUNhbiBiZSBzcGVjaWZpZWQgaW4gZWl0aGVyIHBpeGVscyBvciBhcyBhIHBlcmNlbnRhZ2UsIGUuZy4gYDkwJWAgb3IgYDIwMHB4YC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7opoHntKDjga7mqKrluYXjgpLmjIflrprjgZfjgb7jgZnjgIJweOOBqCXjgafjga7mjIflrprjgYzlj6/og73jgafjgZnjgIJlZy4gOTAlLCAyMDBweFsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHNpZGVcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgbGVmdFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB3aGljaCBzaWRlIG9mIHRoZSBzY3JlZW4gdGhlIGA8b25zLXNwbGl0dGVyLXNpZGU+YCBlbGVtZW50IGlzIGxvY2F0ZWQuIFBvc3NpYmxlIHZhbHVlcyBhcmUgYFwibGVmdFwiYCBhbmQgYFwicmlnaHRcImAuWy9lbl1cbiAgICogICBbamFd44GT44Gu6KaB57Sg44GM5bem44GL5Y+z44GL44KS5oyH5a6a44GX44G+44GZ44CC5oyH5a6a44Gn44GN44KL5YCk44GvXCJsZWZ0XCLjgYtcInJpZ2h0XCLjga7jgb/jgafjgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RlXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DdXJyZW50IG1vZGUuIFBvc3NpYmxlIHZhbHVlcyBhcmUgYFwiY29sbGFwc2VcImAgb3IgYFwic3BsaXRcImAuIFRoaXMgYXR0cmlidXRlIGlzIHJlYWQgb25seS5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7jg6Ljg7zjg4njgYzoqK3lrprjgZXjgozjgb7jgZnjgIJcImNvbGxhcHNlXCLjgoLjgZfjgY/jga9cInNwbGl0XCLjgYzmjIflrprjgZXjgozjgb7jgZnjgILjgZPjga7lsZ7mgKfjga/oqq3jgb/ovrzjgb/lsILnlKjjgafjgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBwYWdlXG4gICAqIEBpbml0b25seVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIFVSTCBvZiB0aGUgbWVudSBwYWdlLlsvZW5dXG4gICAqICAgW2phXW9ucy1zcGxpdHRlci1zaWRl6KaB57Sg44Gr6KGo56S644GZ44KL44Oa44O844K444GuVVJM44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgc3dpcGVhYmxlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0byBlbmFibGUgc3dpcGUgaW50ZXJhY3Rpb24gb24gY29sbGFwc2UgbW9kZS5bL2VuXVxuICAgKiAgIFtqYV1jb2xsYXBzZeODouODvOODieaZguOBq+OCueODr+OCpOODl+aTjeS9nOOCkuacieWKueOBq+OBmeOCi+WgtOWQiOOBq+aMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5fcGFnZSA9IG51bGw7XG4gICAgdGhpcy5fcGFnZUxvYWRlciA9IGRlZmF1bHRQYWdlTG9hZGVyO1xuICAgIHRoaXMuX2NvbGxhcHNlTW9kZSA9IG5ldyBDb2xsYXBzZU1vZGUodGhpcyk7XG4gICAgdGhpcy5fY29sbGFwc2VEZXRlY3Rpb24gPSBuZXcgQ29sbGFwc2VEZXRlY3Rpb24odGhpcyk7XG5cbiAgICB0aGlzLl9hbmltYXRvckZhY3RvcnkgPSBuZXcgQW5pbWF0b3JGYWN0b3J5KHtcbiAgICAgIGFuaW1hdG9yczogU3BsaXR0ZXJFbGVtZW50LmFuaW1hdG9ycyxcbiAgICAgIGJhc2VDbGFzczogU3BsaXR0ZXJBbmltYXRvcixcbiAgICAgIGJhc2VDbGFzc05hbWU6ICdTcGxpdHRlckFuaW1hdG9yJyxcbiAgICAgIGRlZmF1bHRBbmltYXRpb246IHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24nKVxuICAgIH0pO1xuICAgIHRoaXMuX2JvdW5kSGFuZGxlR2VzdHVyZSA9IChlKSA9PiB0aGlzLl9jb2xsYXBzZU1vZGUuaGFuZGxlR2VzdHVyZShlKTtcbiAgICB0aGlzLl93YXRjaGVkQXR0cmlidXRlcyA9IFdBVENIRURfQVRUUklCVVRFUztcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgcmV3cml0YWJsZXMucmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICBjb25zdCBwYWdlID0gdGhpcy5fZ2V0UGFnZVRhcmdldCgpO1xuXG4gICAgICAgIGlmIChwYWdlKSB7XG4gICAgICAgICAgdGhpcy5sb2FkKHBhZ2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGlmICghdXRpbC5tYXRjaCh0aGlzLnBhcmVudE5vZGUsICdvbnMtc3BsaXR0ZXInKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJlbnQgbXVzdCBiZSBhbiBvbnMtc3BsaXR0ZXIgZWxlbWVudC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IgPSBuZXcgR2VzdHVyZURldGVjdG9yKHRoaXMucGFyZW50RWxlbWVudCwge2RyYWdNaW5EaXN0YW5jZTogMX0pO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX3dhdGNoZWRBdHRyaWJ1dGVzLmZvckVhY2goZSA9PiB0aGlzLl91cGRhdGUoZSkpO1xuICAgIH0pO1xuXG4gICAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZSgnc2lkZScpKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnc2lkZScsICdsZWZ0Jyk7XG4gICAgfVxuICB9XG5cbiAgX2dldFBhZ2VUYXJnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2UgfHwgdGhpcy5nZXRBdHRyaWJ1dGUoJ3BhZ2UnKTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX2NvbGxhcHNlRGV0ZWN0aW9uLmRpc2FibGUoKTtcbiAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IuZGlzcG9zZSgpO1xuICAgIHRoaXMuX2dlc3R1cmVEZXRlY3RvciA9IG51bGw7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gV0FUQ0hFRF9BVFRSSUJVVEVTO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICB0aGlzLl91cGRhdGUobmFtZSwgY3VycmVudCk7XG4gIH1cblxuICBfdXBkYXRlKG5hbWUsIHZhbHVlKSB7XG4gICAgbmFtZSA9ICdfdXBkYXRlJyArIG5hbWUuc3BsaXQoJy0nKS5tYXAoZSA9PiBlWzBdLnRvVXBwZXJDYXNlKCkgKyBlLnNsaWNlKDEpKS5qb2luKCcnKTtcbiAgICByZXR1cm4gdGhpc1tuYW1lXSh2YWx1ZSk7XG4gIH1cblxuICBfZW1pdEV2ZW50KG5hbWUpIHtcbiAgICBpZiAobmFtZS5zbGljZSgwLCAzKSAhPT0gJ3ByZScpIHtcbiAgICAgIHJldHVybiB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgbmFtZSwge3NpZGU6IHRoaXN9KTtcbiAgICB9XG4gICAgbGV0IGlzQ2FuY2VsZWQgPSBmYWxzZTtcblxuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCBuYW1lLCB7XG4gICAgICBzaWRlOiB0aGlzLFxuICAgICAgY2FuY2VsOiAoKSA9PiBpc0NhbmNlbGVkID0gdHJ1ZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGlzQ2FuY2VsZWQ7XG4gIH1cblxuICBfdXBkYXRlQ29sbGFwc2UodmFsdWUgPSB0aGlzLmdldEF0dHJpYnV0ZSgnY29sbGFwc2UnKSkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gJ3NwbGl0Jykge1xuICAgICAgdGhpcy5fY29sbGFwc2VEZXRlY3Rpb24uZGlzYWJsZSgpO1xuICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZU1vZGUoU1BMSVRfTU9ERSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09ICdjb2xsYXBzZScpIHtcbiAgICAgIHRoaXMuX2NvbGxhcHNlRGV0ZWN0aW9uLmRpc2FibGUoKTtcbiAgICAgIHJldHVybiB0aGlzLl91cGRhdGVNb2RlKENPTExBUFNFX01PREUpO1xuICAgIH1cblxuICAgIHRoaXMuX2NvbGxhcHNlRGV0ZWN0aW9uLmNoYW5nZVRhcmdldCh2YWx1ZSk7XG4gIH1cblxuICAvLyByZWFkb25seSBhdHRyaWJ1dGUgZm9yIHRoZSB1c2Vyc1xuICBfdXBkYXRlTW9kZShtb2RlKSB7XG4gICAgaWYgKG1vZGUgIT09IHRoaXMuX21vZGUpIHtcbiAgICAgIHRoaXMuX21vZGUgPSBtb2RlO1xuICAgICAgdGhpcy5fY29sbGFwc2VNb2RlW21vZGUgPT09IENPTExBUFNFX01PREUgPyAnZW50ZXJNb2RlJyA6ICdleGl0TW9kZSddKCk7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnbW9kZScsIG1vZGUpO1xuXG4gICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ21vZGVjaGFuZ2UnLCB7c2lkZTogdGhpcywgbW9kZTogbW9kZX0pO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVPcGVuVGhyZXNob2xkKHRocmVzaG9sZCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdvcGVuLXRocmVzaG9sZCcpKSB7XG4gICAgdGhpcy5fdGhyZXNob2xkID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgcGFyc2VGbG9hdCh0aHJlc2hvbGQpIHx8IDAuMykpO1xuICB9XG5cbiAgX3VwZGF0ZVN3aXBlYWJsZShzd2lwZWFibGUgPSB0aGlzLmdldEF0dHJpYnV0ZSgnc3dpcGVhYmxlJykpIHtcbiAgICBjb25zdCBhY3Rpb24gPSBzd2lwZWFibGUgPT09IG51bGwgPyAnb2ZmJyA6ICdvbic7XG5cbiAgICBpZiAodGhpcy5fZ2VzdHVyZURldGVjdG9yKSB7XG4gICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3JbYWN0aW9uXSgnZHJhZ3N0YXJ0IGRyYWdsZWZ0IGRyYWdyaWdodCBkcmFnZW5kJywgdGhpcy5fYm91bmRIYW5kbGVHZXN0dXJlKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlU3dpcGVUYXJnZXRXaWR0aCh2YWx1ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdzd2lwZS10YXJnZXQtd2lkdGgnKSkge1xuICAgIHRoaXMuX3N3aXBlVGFyZ2V0V2lkdGggPSBNYXRoLm1heCgwLCBwYXJzZUludCh2YWx1ZSkgfHwgMCk7XG4gIH1cblxuICBfdXBkYXRlV2lkdGgoKSB7XG4gICAgdGhpcy5zdHlsZS53aWR0aCA9IHRoaXMuX3dpZHRoO1xuICB9XG5cbiAgZ2V0IF93aWR0aCgpIHtcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcpO1xuICAgIHJldHVybiAvXlxcZCsocHh8JSkkLy50ZXN0KHdpZHRoKSA/IHdpZHRoIDogJzgwJSc7XG4gIH1cblxuICBzZXQgX3dpZHRoKHZhbHVlKSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdmFsdWUpO1xuICB9XG5cbiAgX3VwZGF0ZVNpZGUoc2lkZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdzaWRlJykpIHtcbiAgICB0aGlzLl9zaWRlID0gc2lkZSA9PT0gJ3JpZ2h0JyA/IHNpZGUgOiAnbGVmdCc7XG4gIH1cblxuICBfdXBkYXRlQW5pbWF0aW9uKGFuaW1hdGlvbiA9IHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24nKSkge1xuICAgIHRoaXMuX2FuaW1hdG9yID0gdGhpcy5fYW5pbWF0b3JGYWN0b3J5Lm5ld0FuaW1hdG9yKHthbmltYXRpb259KTtcbiAgICB0aGlzLl9hbmltYXRvci5hY3RpdmF0ZSh0aGlzKTtcbiAgfVxuXG4gIF91cGRhdGVBbmltYXRpb25PcHRpb25zKHZhbHVlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpIHtcbiAgICB0aGlzLl9hbmltYXRvci51cGRhdGVPcHRpb25zKEFuaW1hdG9yRmFjdG9yeS5wYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcodmFsdWUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgcGFnZVxuICAgKiBAdHlwZSB7Kn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVBhZ2UgbG9jYXRpb24gdG8gbG9hZCBpbiB0aGUgc3BsaXR0ZXIgc2lkZS5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7opoHntKDlhoXjgavooajnpLrjgZnjgovjg5rjg7zjgrjjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0IHBhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2U7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHsqfSBwYWdlXG4gICAqL1xuICBzZXQgcGFnZShwYWdlKSB7XG4gICAgdGhpcy5fcGFnZSA9IHBhZ2U7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHBhZ2VMb2FkZXJcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgcGFnZUxvYWRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZUxvYWRlcjtcbiAgfVxuXG4gIHNldCBwYWdlTG9hZGVyKGxvYWRlcikge1xuICAgIGlmICghKGxvYWRlciBpbnN0YW5jZW9mIFBhZ2VMb2FkZXIpKSB7XG4gICAgICB0aHJvdyBFcnJvcignRmlyc3QgcGFyYW1ldGVyIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUGFnZUxvYWRlci4nKTtcbiAgICB9XG4gICAgdGhpcy5fcGFnZUxvYWRlciA9IGxvYWRlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgbW9kZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgbW9kZS4gUG9zc2libGUgdmFsdWVzIGFyZSBcInNwbGl0XCIsIFwiY29sbGFwc2VcIiwgXCJjbG9zZWRcIiwgXCJvcGVuXCIgb3IgXCJjaGFuZ2luZ1wiLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgbW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgaXNPcGVuXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoaXMgdmFsdWUgaXMgYHRydWVgIHdoZW4gdGhlIG1lbnUgaXMgb3Blbi4uWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCBpc09wZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbGxhcHNlTW9kZS5pc09wZW4oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIG9wZW5cbiAgICogQHNpZ25hdHVyZSBvcGVuKFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1UaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSBtZW51IGhhcyBiZWVuIG9wZW5lZC5bL2VuXVxuICAgKiAgIFtqYV3jg6Hjg4vjg6Xjg7zjgYzplovjgYTjgZ/lvozjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dT3BlbiBtZW51IGluIGNvbGxhcHNlIG1vZGUuWy9lbl1cbiAgICogICBbamFdY29sbGFwc2Xjg6Ljg7zjg4njgavjgarjgaPjgabjgYTjgotvbnMtc3BsaXR0ZXItc2lkZeimgee0oOOCkumWi+OBjeOBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBzcGxpdHRlciBzaWRlIGVsZW1lbnQgb3IgZmFsc2UgaWYgbm90IGluIGNvbGxhcHNlIG1vZGVbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgb3BlbihvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5fY29sbGFwc2VNb2RlLmV4ZWN1dGVBY3Rpb24oJ29wZW4nLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGNsb3NlXG4gICAqIEBzaWduYXR1cmUgY2xvc2UoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXVRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIG1lbnUgaGFzIGJlZW4gY2xvc2VkLlsvZW5dXG4gICAqICAgW2phXeODoeODi+ODpeODvOOBjOmWieOBmOOBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DbG9zZSBtZW51IGluIGNvbGxhcHNlIG1vZGUuWy9lbl1cbiAgICogICBbamFdY29sbGFwc2Xjg6Ljg7zjg4njgavjgarjgaPjgabjgYTjgotvbnMtc3BsaXR0ZXItc2lkZeimgee0oOOCkumWieOBmOOBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBzcGxpdHRlciBzaWRlIGVsZW1lbnQgb3IgZmFsc2UgaWYgbm90IGluIGNvbGxhcHNlIG1vZGVbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgY2xvc2Uob3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbGxhcHNlTW9kZS5leGVjdXRlQWN0aW9uKCdjbG9zZScsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgdG9nZ2xlXG4gICAqIEBzaWduYXR1cmUgdG9nZ2xlKFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dT3BlbnMgaWYgaXQncyBjbG9zZWQuIENsb3NlcyBpZiBpdCdzIG9wZW4uWy9lbl1cbiAgICogICBbamFd6ZaL44GR44Gm44GE44KL5aC05ZCI44Gv6KaB57Sg44KS6ZaJ44GY44G+44GZ44Gd44GX44Gm6ZaL44GR44Gm44GE44KL5aC05ZCI44Gv6KaB57Sg44KS6ZaL44GN44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIHNwbGl0dGVyIHNpZGUgZWxlbWVudCBvciBmYWxzZSBpZiBub3QgaW4gY29sbGFwc2UgbW9kZVsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICB0b2dnbGUob3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNPcGVuID8gdGhpcy5jbG9zZShvcHRpb25zKSA6IHRoaXMub3BlbihvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGxvYWRcbiAgICogQHNpZ25hdHVyZSBsb2FkKHBhZ2UsIFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAgICogICBbZW5dUGFnZSBVUkwuIENhbiBiZSBlaXRoZXIgYW4gSFRNTCBkb2N1bWVudCBvciBhbiA8b25zLXRlbXBsYXRlPi5bL2VuXVxuICAgKiAgIFtqYV1wYWdl44GuVVJM44GL44CBb25zLXRlbXBsYXRl44Gn5a6j6KiA44GX44Gf44OG44Oz44OX44Os44O844OI44GuaWTlsZ7mgKfjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdyB0aGUgcGFnZSBzcGVjaWZpZWQgaW4gcGFnZVVybCBpbiB0aGUgcmlnaHQgc2VjdGlvblsvZW5dXG4gICAqICAgW2phXeaMh+WumuOBl+OBn1VSTOOCkuODoeOCpOODs+ODmuODvOOCuOOCkuiqreOBv+i+vOOBv+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBuZXcgcGFnZSBlbGVtZW50Wy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGxvYWQocGFnZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5fcGFnZSA9IHBhZ2U7XG4gICAgY29uc3QgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrIHx8ICgoKSA9PiB7fSk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICB0aGlzLl9wYWdlTG9hZGVyLmxvYWQoe3BhZ2UsIHBhcmVudDogdGhpcywgcmVwbGFjZTogdHJ1ZX0sICh7ZWxlbWVudCwgdW5sb2FkfSkgPT4ge1xuICAgICAgICByZXdyaXRhYmxlcy5saW5rKHRoaXMsIGVsZW1lbnQsIG9wdGlvbnMsIGZyYWdtZW50ID0+IHtcbiAgICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5fc2hvdygpKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuXG4gICAgICAgICAgcmVzb2x2ZSh0aGlzLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgX3Nob3coKSB7XG4gICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24odGhpcywgJ19zaG93Jyk7XG4gIH1cblxuICBfaGlkZSgpIHtcbiAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbih0aGlzLCAnX2hpZGUnKTtcbiAgfVxuXG4gIF9kZXN0cm95KCkge1xuICAgIHV0aWwucHJvcGFnYXRlQWN0aW9uKHRoaXMsICdfZGVzdHJveScpO1xuICAgIHRoaXMucmVtb3ZlKCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHJld3JpdGFibGVzKCkge1xuICAgIHJldHVybiByZXdyaXRhYmxlcztcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1zcGxpdHRlci1zaWRlJywgU3BsaXR0ZXJTaWRlRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJ29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICdvbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgR2VzdHVyZURldGVjdG9yIGZyb20gJ29ucy9nZXN0dXJlLWRldGVjdG9yJztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnJzogJ3N3aXRjaC0tKicsXG4gICcuc3dpdGNoX19pbnB1dCc6ICdzd2l0Y2gtLSpfX2lucHV0JyxcbiAgJy5zd2l0Y2hfX2hhbmRsZSc6ICdzd2l0Y2gtLSpfX2hhbmRsZScsXG4gICcuc3dpdGNoX190b2dnbGUnOiAnc3dpdGNoLS0qX190b2dnbGUnXG59O1xuXG5jb25zdCB0ZW1wbGF0ZSA9IHV0aWwuY3JlYXRlRnJhZ21lbnQoYFxuICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgY2xhc3M9XCJzd2l0Y2hfX2lucHV0XCI+XG4gIDxkaXYgY2xhc3M9XCJzd2l0Y2hfX3RvZ2dsZVwiPlxuICAgIDxkaXYgY2xhc3M9XCJzd2l0Y2hfX2hhbmRsZVwiPlxuICAgICAgPGRpdiBjbGFzcz1cInN3aXRjaF9fdG91Y2hcIj48L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG5gKTtcblxuY29uc3QgbG9jYXRpb25zID0ge1xuICBpb3M6IFsxLCAyMV0sXG4gIG1hdGVyaWFsOiBbMCwgMTZdXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1zd2l0Y2hcbiAqIEBjYXRlZ29yeSBmb3JtXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFN3aXRjaCBjb21wb25lbnQuIFRoZSBzd2l0Y2ggY2FuIGJlIHRvZ2dsZWQgYm90aCBieSBkcmFnZ2luZyBhbmQgdGFwcGluZy5cbiAqXG4gKiAgICAgV2lsbCBhdXRvbWF0aWNhbGx5IGRpc3BsYXlzIGEgTWF0ZXJpYWwgRGVzaWduIHN3aXRjaCBvbiBBbmRyb2lkIGRldmljZXMuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV3jgrnjgqTjg4Pjg4HjgpLooajnpLrjgZnjgovjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgIFtlbl1NYXRlcmlhbCBEZXNpZ24gc3dpdGNoWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiBMcFhaUVFcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9zd2l0Y2hcbiAqIEBndWlkZSBhZGRpbmctcGFnZS1jb250ZW50XG4gKiAgIFtlbl1Vc2luZyBmb3JtIGNvbXBvbmVudHNbL2VuXVxuICogICBbamFd44OV44Kp44O844Og44KS5L2/44GGWy9qYV1cbiAqIEBndWlkZSB1c2luZy1tb2RpZmllciBbZW5dTW9yZSBkZXRhaWxzIGFib3V0IHRoZSBgbW9kaWZpZXJgIGF0dHJpYnV0ZVsvZW5dW2phXW1vZGlmaWVy5bGe5oCn44Gu5L2/44GE5pa5Wy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXN3aXRjaCBjaGVja2VkPjwvb25zLXN3aXRjaD5cbiAqIDxvbnMtc3dpdGNoIGRpc2FibGVkPjwvb25zLXN3aXRjaD5cbiAqIDxvbnMtc3dpdGNoIG1vZGlmaWVyPVwibWF0ZXJpYWxcIj48L29ucy1zd2l0Y2g+XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3dpdGNoRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGV2ZW50IGNoYW5nZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQgd2hlbiB0aGUgc3dpdGNoIGlzIHRvZ2dsZWQuWy9lbl1cbiAgICogICBbamFdT04vT0ZG44GM5aSJ44KP44Gj44Gf5pmC44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuc3dpdGNoXG4gICAqICAgW2VuXVN3aXRjaCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44GM55m654Gr44GX44GfU3dpdGNo44Kq44OW44K444Kn44Kv44OI44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtCb29sZWFufSBldmVudC52YWx1ZVxuICAgKiAgIFtlbl1DdXJyZW50IHZhbHVlLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBruWApOOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQuaXNJbnRlcmFjdGl2ZVxuICAgKiAgIFtlbl1UcnVlIGlmIHRoZSBjaGFuZ2Ugd2FzIHRyaWdnZXJlZCBieSB0aGUgdXNlciBjbGlja2luZyBvbiB0aGUgc3dpdGNoLlsvZW5dXG4gICAqICAgW2phXeOCv+ODg+ODl+OChOOCr+ODquODg+OCr+OBquOBqeOBruODpuODvOOCtuOBruaTjeS9nOOBq+OCiOOBo+OBpuWkieOCj+OBo+OBn+WgtOWQiOOBq+OBr3RydWXjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgc3dpdGNoLlsvZW5dXG4gICAqICBbamFd44K544Kk44OD44OB44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIHN3aXRjaCBpcyBiZSBkaXNhYmxlZC5bL2VuXVxuICAgKiAgIFtqYV3jgrnjgqTjg4Pjg4HjgpLnhKHlirnjga7nirbmhYvjgavjgZnjgovloLTlkIjjgavmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBjaGVja2VkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBzd2l0Y2ggaXMgY2hlY2tlZC5bL2VuXVxuICAgKiAgIFtqYV3jgrnjgqTjg4Pjg4HjgYxPTuOBrueKtuaFi+OBq+OBmeOCi+OBqOOBjeOBq+aMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGlucHV0LWlkXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIGBpZGAgYXR0cmlidXRlIG9mIHRoZSBpbm5lciBgPGlucHV0PmAgZWxlbWVudC4gVGhpcyBpcyB1c2VmdWwgd2hlbiB1c2luZyBgPGxhYmVsIGZvcj1cIi4uLlwiPmAgZWxlbWVudHMuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IGNoZWNrZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGlzIHZhbHVlIGlzIGB0cnVlYCBpZiB0aGUgc3dpdGNoIGlzIGNoZWNrZWQuWy9lbl1cbiAgICogICBbamFd44K544Kk44OD44OB44GMT07jga7loLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cblxuICBnZXQgY2hlY2tlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hlY2tib3guY2hlY2tlZDtcbiAgfVxuXG4gIHNldCBjaGVja2VkKHZhbHVlKSB7XG4gICAgaWYgKCEhdmFsdWUgIT09IHRoaXMuX2NoZWNrYm94LmNoZWNrZWQpIHtcbiAgICAgIHRoaXMuX2NoZWNrYm94LmNsaWNrKCk7XG4gICAgICB0aGlzLl9jaGVja2JveC5jaGVja2VkID0gISF2YWx1ZTtcbiAgICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnY2hlY2tlZCcsIHRoaXMuY2hlY2tlZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoZWNrYm94LmRpc2FibGVkO1xuICB9XG5cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgdGhpcy5fY2hlY2tib3guZGlzYWJsZWQgPSB2YWx1ZTtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdGhpcy5kaXNhYmxlZCk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGNoZWNrYm94XG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgdW5kZXJseWluZyBjaGVja2JveCBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOWGhemDqOOBrmNoZWNrYm946KaB57Sg44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBjaGVja2JveCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hlY2tib3g7XG4gIH1cblxuICBpbml0KCkge1xuICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoJ19jb21waWxlZCcpKSB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fY2hlY2tib3ggPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJy5zd2l0Y2hfX2lucHV0Jyk7XG4gICAgdGhpcy5faGFuZGxlID0gdGhpcy5xdWVyeVNlbGVjdG9yKCcuc3dpdGNoX19oYW5kbGUnKTtcblxuICAgIFsnY2hlY2tlZCcsICdkaXNhYmxlZCcsICdtb2RpZmllcicsICduYW1lJywgJ2lucHV0LWlkJ10uZm9yRWFjaChlID0+IHtcbiAgICAgIHRoaXMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGUsIG51bGwsIHRoaXMuZ2V0QXR0cmlidXRlKGUpKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdzd2l0Y2gnKTtcblxuICAgIHRoaXMuYXBwZW5kQ2hpbGQodGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpKTtcblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdfY29tcGlsZWQnLCAnJyk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9jaGVja2JveC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9vbkNoYW5nZSk7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLl9vbkRyYWdTdGFydCk7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdob2xkJywgdGhpcy5fb25Ib2xkKTtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RhcCcsIHRoaXMuY2xpY2spO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbkNsaWNrKTtcbiAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IuZGlzcG9zZSgpO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fY2hlY2tib3guYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5fb25DaGFuZ2UpO1xuICAgIHRoaXMuX2dlc3R1cmVEZXRlY3RvciA9IG5ldyBHZXN0dXJlRGV0ZWN0b3IodGhpcywge2RyYWdNaW5EaXN0YW5jZTogMSwgaG9sZFRpbWVvdXQ6IDI1MX0pO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgdGhpcy5fb25EcmFnU3RhcnQpO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignaG9sZCcsIHRoaXMuX29uSG9sZCk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0YXAnLCB0aGlzLmNsaWNrKTtcbiAgICB0aGlzLl9ib3VuZE9uUmVsZWFzZSA9IHRoaXMuX29uUmVsZWFzZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbkNsaWNrKTtcbiAgfVxuXG4gIF9vbkNoYW5nZSgpIHtcbiAgICBpZiAodGhpcy5jaGVja2VkKSB7XG4gICAgICB0aGlzLnBhcmVudE5vZGUuc2V0QXR0cmlidXRlKCdjaGVja2VkJywgJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhcmVudE5vZGUucmVtb3ZlQXR0cmlidXRlKCdjaGVja2VkJyk7XG4gICAgfVxuICB9XG5cbiAgX29uQ2xpY2soZXYpIHtcbiAgICBpZiAoZXYudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnc3dpdGNoX190b3VjaCcpKSB7XG4gICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuXG4gIGNsaWNrKCkge1xuICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5jaGVja2VkID0gIXRoaXMuY2hlY2tlZDtcbiAgICB9XG4gIH1cblxuICBfZ2V0UG9zaXRpb24oZSkge1xuICAgIGNvbnN0IGwgPSB0aGlzLl9sb2NhdGlvbnM7XG4gICAgcmV0dXJuIE1hdGgubWluKGxbMV0sIE1hdGgubWF4KGxbMF0sIHRoaXMuX3N0YXJ0WCArIGUuZ2VzdHVyZS5kZWx0YVgpKTtcbiAgfVxuXG4gIF9vbkhvbGQoZSkge1xuICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdzd2l0Y2gtLWFjdGl2ZScpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncmVsZWFzZScsIHRoaXMuX2JvdW5kT25SZWxlYXNlKTtcbiAgICB9XG4gIH1cblxuICBfb25EcmFnU3RhcnQoZSkge1xuICAgIGlmICh0aGlzLmRpc2FibGVkIHx8IFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YoZS5nZXN0dXJlLmRpcmVjdGlvbikgPT09IC0xKSB7XG4gICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ3N3aXRjaC0tYWN0aXZlJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnc3dpdGNoLS1hY3RpdmUnKTtcbiAgICB0aGlzLl9zdGFydFggPSB0aGlzLl9sb2NhdGlvbnNbdGhpcy5jaGVja2VkID8gMSA6IDBdOy8vIC0gZS5nZXN0dXJlLmRlbHRhWDtcblxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZHJhZycsIHRoaXMuX29uRHJhZyk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncmVsZWFzZScsIHRoaXMuX2JvdW5kT25SZWxlYXNlKTtcbiAgfVxuXG4gIF9vbkRyYWcoZSkge1xuICAgIGUuZ2VzdHVyZS5zcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuX2hhbmRsZS5zdHlsZS5sZWZ0ID0gdGhpcy5fZ2V0UG9zaXRpb24oZSkgKyAncHgnO1xuICB9XG5cbiAgX29uUmVsZWFzZShlKSB7XG4gICAgY29uc3QgbCA9IHRoaXMuX2xvY2F0aW9ucztcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuX2dldFBvc2l0aW9uKGUpO1xuXG4gICAgdGhpcy5jaGVja2VkID0gcG9zaXRpb24gPj0gKGxbMF0gKyBsWzFdKSAvIDI7XG5cbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWcnLCB0aGlzLl9vbkRyYWcpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3JlbGVhc2UnLCB0aGlzLl9ib3VuZE9uUmVsZWFzZSk7XG5cbiAgICB0aGlzLl9oYW5kbGUuc3R5bGUubGVmdCA9ICcnO1xuICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZSgnc3dpdGNoLS1hY3RpdmUnKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ2lucHV0LWlkJywgJ2NoZWNrZWQnLCAnZGlzYWJsZWQnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoKG5hbWUpIHtcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgdGhpcy5faXNNYXRlcmlhbCA9IChjdXJyZW50IHx8ICcnKS5pbmRleE9mKCdtYXRlcmlhbCcpICE9PSAtMTtcbiAgICAgICAgdGhpcy5fbG9jYXRpb25zID0gbG9jYXRpb25zW3RoaXMuX2lzTWF0ZXJpYWwgPyAnbWF0ZXJpYWwnIDogJ2lvcyddO1xuICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpbnB1dC1pZCc6XG4gICAgICAgIHRoaXMuX2NoZWNrYm94LmlkID0gY3VycmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjaGVja2VkJzpcbiAgICAgICAgdGhpcy5fY2hlY2tib3guY2hlY2tlZCA9IGN1cnJlbnQgIT09IG51bGw7XG4gICAgICAgIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMuX2NoZWNrYm94LCBuYW1lLCBjdXJyZW50ICE9PSBudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkaXNhYmxlZCc6XG4gICAgICAgIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMuX2NoZWNrYm94LCBuYW1lLCBjdXJyZW50ICE9PSBudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtc3dpdGNoJywgU3dpdGNoRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5leHBvcnQgY2xhc3MgVGFiYmFyQW5pbWF0b3Ige1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy50aW1pbmdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZHVyYXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZGVsYXlcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMudGltaW5nID0gb3B0aW9ucy50aW1pbmcgfHwgJ2xpbmVhcic7XG4gICAgdGhpcy5kdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiAnMC40JztcbiAgICB0aGlzLmRlbGF5ID0gb3B0aW9ucy5kZWxheSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kZWxheSA6ICcwJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVudGVyUGFnZSBvbnMtcGFnZSBlbGVtZW50XG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbGVhdmVQYWdlIG9ucy1wYWdlIGVsZW1lbnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGVudGVyUGFnZUluZGV4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsZWF2ZVBhZ2VJbmRleFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBhcHBseShlbnRlclBhZ2UsIGxlYXZlUGFnZSwgZW50ZXJQYWdlSW5kZXgsIGxlYXZlUGFnZUluZGV4LCBkb25lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBtdXN0IGJlIGltcGxlbWVudGVkLicpO1xuICB9XG59XG5cblxuZXhwb3J0IGNsYXNzIFRhYmJhck5vbmVBbmltYXRvciBleHRlbmRzIFRhYmJhckFuaW1hdG9yIHtcbiAgYXBwbHkoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGVudGVySW5kZXgsIGxlYXZlSW5kZXgsIGRvbmUpIHtcbiAgICBzZXRUaW1lb3V0KGRvbmUsIDEwMDAgLyA2MCk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFRhYmJhckZhZGVBbmltYXRvciBleHRlbmRzIFRhYmJhckFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucy50aW1pbmcgPSBvcHRpb25zLnRpbWluZyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy50aW1pbmcgOiAnbGluZWFyJztcbiAgICBvcHRpb25zLmR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kdXJhdGlvbiA6ICcwLjQnO1xuICAgIG9wdGlvbnMuZGVsYXkgPSBvcHRpb25zLmRlbGF5ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRlbGF5IDogJzAnO1xuXG4gICAgc3VwZXIob3B0aW9ucyk7XG4gIH1cblxuICBhcHBseShlbnRlclBhZ2UsIGxlYXZlUGFnZSwgZW50ZXJQYWdlSW5kZXgsIGxlYXZlUGFnZUluZGV4LCBkb25lKSB7XG4gICAgYW5pbWl0LnJ1bkFsbChcbiAgICAgIGFuaW1pdChlbnRlclBhZ2UpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGxlYXZlUGFnZSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgVGFiYmFyU2xpZGVBbmltYXRvciBleHRlbmRzIFRhYmJhckFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucy50aW1pbmcgPSBvcHRpb25zLnRpbWluZyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy50aW1pbmcgOiAnZWFzZS1pbic7XG4gICAgb3B0aW9ucy5kdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiAnMC4xNSc7XG4gICAgb3B0aW9ucy5kZWxheSA9IG9wdGlvbnMuZGVsYXkgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZGVsYXkgOiAnMCc7XG5cbiAgICBzdXBlcihvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2pxTGl0ZX0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7anFMaXRlfSBsZWF2ZVBhZ2VcbiAgICovXG4gIGFwcGx5KGVudGVyUGFnZSwgbGVhdmVQYWdlLCBlbnRlckluZGV4LCBsZWF2ZUluZGV4LCBkb25lKSB7XG4gICAgY29uc3Qgc2duID0gZW50ZXJJbmRleCA+IGxlYXZlSW5kZXg7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuICAgICAgYW5pbWl0KGVudGVyUGFnZSlcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoJyArIChzZ24gPyAnJyA6ICctJykgKyAnMTAwJSwgMCwgMCknLFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KSxcbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKCcgKyAoc2duID8gJy0nIDogJycpICsgJzEwMCUsIDAsIDApJyxcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnb25zL3BsYXRmb3JtJztcbmltcG9ydCBpbnRlcm5hbCBmcm9tICdvbnMvaW50ZXJuYWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICdvbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEFuaW1hdG9yRmFjdG9yeSBmcm9tICdvbnMvaW50ZXJuYWwvYW5pbWF0b3ItZmFjdG9yeSc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQge1RhYmJhckFuaW1hdG9yLCBUYWJiYXJGYWRlQW5pbWF0b3IsIFRhYmJhck5vbmVBbmltYXRvciwgVGFiYmFyU2xpZGVBbmltYXRvcn0gZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgVGFiRWxlbWVudCBmcm9tICcuLi9vbnMtdGFiJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcudGFiLWJhcl9fY29udGVudCc6ICd0YWItYmFyLS0qX19jb250ZW50JyxcbiAgJy50YWItYmFyJzogJ3RhYi1iYXItLSonXG59O1xuXG5jb25zdCBfYW5pbWF0b3JEaWN0ID0ge1xuICAnZGVmYXVsdCc6IFRhYmJhck5vbmVBbmltYXRvcixcbiAgJ2ZhZGUnOiBUYWJiYXJGYWRlQW5pbWF0b3IsXG4gICdzbGlkZSc6IFRhYmJhclNsaWRlQW5pbWF0b3IsXG4gICdub25lJzogVGFiYmFyTm9uZUFuaW1hdG9yXG59O1xuXG5jb25zdCByZXdyaXRhYmxlcyA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gdGFiYmFyRWxlbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcmVhZHkodGFiYmFyRWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhYmJhckVsZW1lbnRcbiAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIGxpbmsodGFiYmFyRWxlbWVudCwgdGFyZ2V0LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKHRhcmdldCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gdGFiYmFyRWxlbWVudFxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgdW5saW5rKHRhYmJhckVsZW1lbnQsIHRhcmdldCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayh0YXJnZXQpO1xuICB9XG59O1xuXG5jb25zdCBnZW5lcmF0ZUlkID0gKCgpID0+IHtcbiAgbGV0IGkgPSAwO1xuICByZXR1cm4gKCkgPT4gJ29ucy10YWJiYXItZ2VuLScgKyAoaSsrKTtcbn0pKCk7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXRhYmJhclxuICogQGNhdGVnb3J5IHRhYmJhclxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1BIGNvbXBvbmVudCB0byBkaXNwbGF5IGEgdGFiIGJhciBvbiB0aGUgYm90dG9tIG9mIGEgcGFnZS4gVXNlZCB3aXRoIGA8b25zLXRhYj5gIHRvIG1hbmFnZSBwYWdlcyB1c2luZyB0YWJzLlsvZW5dXG4gKiAgIFtqYV3jgr/jg5bjg5Djg7zjgpLjg5rjg7zjgrjkuIvpg6jjgavooajnpLrjgZnjgovjgZ/jgoHjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgIJvbnMtdGFi44Go57WE44G/5ZCI44KP44Gb44Gm5L2/44GG44GT44Go44Gn44CB44Oa44O844K444KS566h55CG44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEBjb2RlcGVuIHBHdURMXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvdGFiYmFyXG4gKiBAZ3VpZGUgbXVsdGlwbGUtcGFnZS1uYXZpZ2F0aW9uXG4gKiAgW2VuXU1hbmFnaW5nIG11bHRpcGxlIHBhZ2VzLlsvZW5dXG4gKiAgW2phXU1hbmFnaW5nIG11bHRpcGxlIHBhZ2VzWy9qYV1cbiAqIEBndWlkZSB0ZW1wbGF0ZXNcbiAqICAgW2VuXURlZmluaW5nIG11bHRpcGxlIHBhZ2VzIGluIHNpbmdsZSBodG1sWy9lbl1cbiAqICAgW2phXeikh+aVsOOBruODmuODvOOCuOOCkjHjgaTjga5IVE1M44Gr6KiY6L+w44GZ44KLWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy10YWJcbiAqICAgW2VuXVRoZSBgPG9ucy10YWI+YCBjb21wb25lbnQuWy9lbl1cbiAqICAgW2phXW9ucy10YWLjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLXBhZ2VcbiAqICAgW2VuXVRoZSBgPG9ucy1wYWdlPmAgY29tcG9uZW50LlsvZW5dXG4gKiAgIFtqYV1vbnMtcGFnZeOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy10YWJiYXI+XG4gKiAgIDxvbnMtdGFiXG4gKiAgICAgcGFnZT1cImhvbWUuaHRtbFwiXG4gKiAgICAgbGFiZWw9XCJIb21lXCJcbiAqICAgICBhY3RpdmU+XG4gKiAgIDwvb25zLXRhYj5cbiAqICAgPG9ucy10YWJcbiAqICAgICBwYWdlPVwic2V0dGluZ3MuaHRtbFwiXG4gKiAgICAgbGFiZWw9XCJTZXR0aW5nc1wiXG4gKiAgICAgYWN0aXZlPlxuICogICA8L29ucy10YWI+XG4gKiA8L29ucy10YWJiYXI+XG4gKlxuICogPG9ucy10ZW1wbGF0ZSBpZD1cImhvbWUuaHRtbFwiPlxuICogICAuLi5cbiAqIDwvb25zLXRlbXBsYXRlPlxuICpcbiAqIDxvbnMtdGVtcGxhdGUgaWQ9XCJzZXR0aW5ncy5odG1sXCI+XG4gKiAgIC4uLlxuICogPC9vbnMtdGVtcGxhdGU+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRhYmJhckVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVjaGFuZ2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVzIGp1c3QgYmVmb3JlIHRoZSB0YWIgaXMgY2hhbmdlZC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjgq/jg4bjgqPjg5bjgarjgr/jg5bjgYzlpInjgo/jgovliY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudC5pbmRleFxuICAgKiAgIFtlbl1DdXJyZW50IGluZGV4LlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOCouOCr+ODhuOCo+ODluOBq+OBquOBo+OBpuOBhOOCi29ucy10YWLjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQudGFiSXRlbVxuICAgKiAgIFtlbl1UYWIgaXRlbSBvYmplY3QuWy9lbl1cbiAgICogICBbamFddGFiSXRlbeOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LmNhbmNlbFxuICAgKiAgIFtlbl1DYWxsIHRoaXMgZnVuY3Rpb24gdG8gY2FuY2VsIHRoZSBjaGFuZ2UgZXZlbnQuWy9lbl1cbiAgICogICBbamFd44GT44Gu6Zai5pWw44KS5ZG844Gz5Ye644GZ44Go44CB44Ki44Kv44OG44Kj44OW44Gq44K/44OW44Gu5aSJ5pu044GM44Kt44Oj44Oz44K744Or44GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0Y2hhbmdlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlcyBqdXN0IGFmdGVyIHRoZSB0YWIgaXMgY2hhbmdlZC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjgq/jg4bjgqPjg5bjgarjgr/jg5bjgYzlpInjgo/jgaPjgZ/lvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudC5pbmRleFxuICAgKiAgIFtlbl1DdXJyZW50IGluZGV4LlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOCouOCr+ODhuOCo+ODluOBq+OBquOBo+OBpuOBhOOCi29ucy10YWLjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQudGFiSXRlbVxuICAgKiAgIFtlbl1UYWIgaXRlbSBvYmplY3QuWy9lbl1cbiAgICogICBbamFddGFiSXRlbeOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcmVhY3RpdmVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVzIGlmIHRoZSBhbHJlYWR5IG9wZW4gdGFiIGlzIHRhcHBlZCBhZ2Fpbi5bL2VuXVxuICAgKiAgIFtqYV3jgZnjgafjgavjgqLjgq/jg4bjgqPjg5bjgavjgarjgaPjgabjgYTjgovjgr/jg5bjgYzjgoLjgYbkuIDluqbjgr/jg4Pjg5fjgoTjgq/jg6rjg4Pjgq/jgZXjgozjgZ/loLTlkIjjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudC5pbmRleFxuICAgKiAgIFtlbl1DdXJyZW50IGluZGV4LlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOCouOCr+ODhuOCo+ODluOBq+OBquOBo+OBpuOBhOOCi29ucy10YWLjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQudGFiSXRlbVxuICAgKiAgIFtlbl1UYWIgaXRlbSBvYmplY3QuWy9lbl1cbiAgICogICBbamFddGFiSXRlbeOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCBub25lXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIHZhbHVlcyBhcmUgYFwibm9uZVwiYCwgYFwic2xpZGVcImAgYW5kIGBcImZhZGVcImAuIERlZmF1bHQgaXMgYFwibm9uZVwiYC5bL2VuXVxuICAgKiAgIFtqYV3jg5rjg7zjgrjoqq3jgb/ovrzjgb/mmYLjga7jgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIuOAgVwiZmFkZVwi44CBXCJzbGlkZVwi44Gu44GE44Ga44KM44GL44KS6YG45oqe44Gn44GN44G+44GZ44CC44OH44OV44Kp44Or44OI44GvXCJub25lXCLjgafjgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb24tb3B0aW9uc1xuICAgKiBAdHlwZSB7RXhwcmVzc2lvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIHRpbWluZyBhbmQgZGVsYXkgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbC4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIHRpbWluZywgZGVsYXnjgpLjgqrjg5bjgrjjgqfjgq/jg4jjg6rjg4bjg6njg6vjgafmjIflrprjgZfjgb7jgZnjgIJlLmcuIHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcG9zaXRpb25cbiAgICogQGluaXRvbmx5XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IGJvdHRvbVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGFiYmFyJ3MgcG9zaXRpb24uIEF2YWlsYWJsZSB2YWx1ZXMgYXJlIGBcImJvdHRvbVwiYCBhbmQgYFwidG9wXCJgLiBVc2UgYFwiYXV0b1wiYCB0byBjaG9vc2UgcG9zaXRpb24gZGVwZW5kaW5nIG9uIHBsYXRmb3JtIChpT1MgYm90dG9tLCBBbmRyb2lkIHRvcCkuWy9lbl1cbiAgICogICBbamFd44K/44OW44OQ44O844Gu5L2N572u44KS5oyH5a6a44GX44G+44GZ44CCXCJib3R0b21cIuOCguOBl+OBj+OBr1widG9wXCLjgpLpgbjmip7jgafjgY3jgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga9cImJvdHRvbVwi44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLl90YWJiYXJJZCA9IGdlbmVyYXRlSWQoKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG5cbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLl9jb250ZW50RWxlbWVudDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGVudC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb250ZW50LmNoaWxkcmVuW2ldLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGFjdGl2ZUluZGV4ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2FjdGl2ZUluZGV4Jyk7XG5cbiAgICAgIGNvbnN0IHRhYmJhciA9IHRoaXMuX3RhYmJhckVsZW1lbnQ7XG4gICAgICBpZiAoYWN0aXZlSW5kZXggJiYgdGFiYmFyLmNoaWxkcmVuLmxlbmd0aCA+IGFjdGl2ZUluZGV4KSB7XG4gICAgICAgIHRhYmJhci5jaGlsZHJlblthY3RpdmVJbmRleF0uc2V0QXR0cmlidXRlKCdhY3RpdmUnLCAndHJ1ZScpO1xuICAgICAgfVxuXG4gICAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcbiAgICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcblxuICAgICAgdGhpcy5fYW5pbWF0b3JGYWN0b3J5ID0gbmV3IEFuaW1hdG9yRmFjdG9yeSh7XG4gICAgICAgIGFuaW1hdG9yczogX2FuaW1hdG9yRGljdCxcbiAgICAgICAgYmFzZUNsYXNzOiBUYWJiYXJBbmltYXRvcixcbiAgICAgICAgYmFzZUNsYXNzTmFtZTogJ1RhYmJhckFuaW1hdG9yJyxcbiAgICAgICAgZGVmYXVsdEFuaW1hdGlvbjogdGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbicpXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl91cGRhdGVQb3NpdGlvbigpKTtcbiAgfVxuXG4gIGdldCBfY29udGVudEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICcudGFiLWJhcl9fY29udGVudCcpO1xuICB9XG5cbiAgZ2V0IF90YWJiYXJFbGVtZW50KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnRhYi1iYXInKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGlmICh0aGlzLl9jb250ZW50RWxlbWVudCAmJiB0aGlzLl90YWJiYXJFbGVtZW50KSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJy50YWItYmFyX19jb250ZW50Jyk7XG4gICAgICBjb25zdCBiYXIgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnRhYi1iYXInKTtcblxuICAgICAgY29udGVudC5jbGFzc0xpc3QuYWRkKCdvbnMtdGFiLWJhcl9fY29udGVudCcpO1xuICAgICAgYmFyLmNsYXNzTGlzdC5hZGQoJ29ucy10YWItYmFyX19mb290ZXInKTtcbiAgICAgIGJhci5jbGFzc0xpc3QuYWRkKCdvbnMtdGFiYmFyLWlubmVyJyk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBjb25zdCBjb250ZW50ID0gdXRpbC5jcmVhdGUoJy5vbnMtdGFiLWJhcl9fY29udGVudC50YWItYmFyX19jb250ZW50Jyk7XG4gICAgICBjb25zdCB0YWJiYXIgPSB1dGlsLmNyZWF0ZSgnLnRhYi1iYXIub25zLXRhYi1iYXJfX2Zvb3Rlci5vbnMtdGFiYmFyLWlubmVyJyk7XG5cbiAgICAgIHdoaWxlICh0aGlzLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgdGFiYmFyLmFwcGVuZENoaWxkKHRoaXMuZmlyc3RDaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgICB0aGlzLmFwcGVuZENoaWxkKHRhYmJhcik7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZVBvc2l0aW9uKHBvc2l0aW9uID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJykpIHtcbiAgICBjb25zdCB0b3AgPSB0aGlzLl90b3AgPSBwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgKHBvc2l0aW9uID09PSAnYXV0bycgJiYgcGxhdGZvcm0uaXNBbmRyb2lkKCkpO1xuICAgIGNvbnN0IGFjdGlvbiA9IHRvcCA/IHV0aWwuYWRkTW9kaWZpZXIgOiB1dGlsLnJlbW92ZU1vZGlmaWVyO1xuXG4gICAgYWN0aW9uKHRoaXMsICd0b3AnKTtcblxuICAgIGNvbnN0IHBhZ2UgPSB1dGlsLmZpbmRQYXJlbnQodGhpcywgJ29ucy1wYWdlJyk7XG4gICAgaWYgKHBhZ2UpIHtcbiAgICAgIHRoaXMuc3R5bGUudG9wID0gdG9wID8gd2luZG93LmdldENvbXB1dGVkU3R5bGUocGFnZS5fZ2V0Q29udGVudEVsZW1lbnQoKSwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZSgncGFkZGluZy10b3AnKSA6ICcnO1xuXG4gICAgICBpZiAodXRpbC5tYXRjaChwYWdlLmZpcnN0Q2hpbGQsICdvbnMtdG9vbGJhcicpKSB7XG4gICAgICAgIGFjdGlvbihwYWdlLmZpcnN0Q2hpbGQsICdub3NoYWRvdycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGludGVybmFsLmF1dG9TdGF0dXNCYXJGaWxsKCgpID0+IHtcbiAgICAgIGNvbnN0IGZpbGxlZCA9IHV0aWwuZmluZFBhcmVudCh0aGlzLCBlID0+IGUuaGFzQXR0cmlidXRlKCdzdGF0dXMtYmFyLWZpbGwnKSk7XG4gICAgICB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnc3RhdHVzLWJhci1maWxsJywgdG9wICYmICFmaWxsZWQpO1xuICAgIH0pO1xuICB9XG5cbiAgX2dldFRhYmJhckVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICcudGFiLWJhcicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgbG9hZFBhZ2VcbiAgICogQHNpZ25hdHVyZSBsb2FkUGFnZSh1cmwsIFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICAgKiAgIFtlbl1QYWdlIFVSTC4gQ2FuIGJlIGVpdGhlciBhbiBIVE1MIGRvY3VtZW50IG9yIGFuIGA8b25zLXRlbXBsYXRlPmAgaWQuWy9lbl1cbiAgICogICBbamFdcGFnZeOBrlVSTOOBi+OAgeOCguOBl+OBj+OBr29ucy10ZW1wbGF0ZeOBp+Wuo+iogOOBl+OBn2lk5bGe5oCn44Gu5YCk44KS5Yip55So44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXURpc3BsYXlzIGEgbmV3IHBhZ2Ugd2l0aG91dCBjaGFuZ2luZyB0aGUgYWN0aXZlIGluZGV4LlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBruOCouOCr+ODhuOCo+ODluOBquOCpOODs+ODh+ODg+OCr+OCueOCkuWkieabtOOBm+OBmuOBq+OAgeaWsOOBl+OBhOODmuODvOOCuOOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgbmV3IHBhZ2UgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgbG9hZFBhZ2UocGFnZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgY29uc3QgdGFiID0gdGhpcy5fdGFiYmFyRWxlbWVudC5jaGlsZHJlblswXSB8fCBuZXcgVGFiRWxlbWVudCgpO1xuICAgICAgdGFiLl9sb2FkUGFnZShwYWdlLCB0aGlzLl9jb250ZW50RWxlbWVudCwgcGFnZUVsZW1lbnQgPT4ge1xuICAgICAgICByZXNvbHZlKHRoaXMuX2xvYWRQYWdlRE9NQXN5bmMocGFnZUVsZW1lbnQsIG9wdGlvbnMpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcGFnZUVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVzIHRvIHRoZSBuZXcgcGFnZSBlbGVtZW50LlxuICAgKi9cbiAgX2xvYWRQYWdlRE9NQXN5bmMocGFnZUVsZW1lbnQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHJld3JpdGFibGVzLmxpbmsodGhpcywgcGFnZUVsZW1lbnQsIG9wdGlvbnMsIHBhZ2VFbGVtZW50ID0+IHtcbiAgICAgICAgdGhpcy5fY29udGVudEVsZW1lbnQuYXBwZW5kQ2hpbGQocGFnZUVsZW1lbnQpO1xuXG4gICAgICAgIGlmICh0aGlzLmdldEFjdGl2ZVRhYkluZGV4KCkgIT09IC0xKSB7XG4gICAgICAgICAgcmVzb2x2ZSh0aGlzLl9zd2l0Y2hQYWdlKHBhZ2VFbGVtZW50LCBvcHRpb25zKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMuY2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fb2xkUGFnZUVsZW1lbnQgPSBwYWdlRWxlbWVudDtcbiAgICAgICAgICByZXNvbHZlKHBhZ2VFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0VGFiYmFySWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RhYmJhcklkO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0VsZW1lbnQvbnVsbH1cbiAgICovXG4gIF9nZXRDdXJyZW50UGFnZUVsZW1lbnQoKSB7XG4gICAgY29uc3QgcGFnZXMgPSB0aGlzLl9jb250ZW50RWxlbWVudC5jaGlsZHJlbjtcbiAgICBsZXQgcGFnZSA9IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHBhZ2VzW2ldLnN0eWxlLmRpc3BsYXkgIT09ICdub25lJykge1xuICAgICAgICBwYWdlID0gcGFnZXNbaV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwYWdlICYmIHBhZ2Uubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ29ucy1wYWdlJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0YXRlOiBwYWdlIGVsZW1lbnQgbXVzdCBiZSBhIFwib25zLXBhZ2VcIiBlbGVtZW50LicpO1xuICAgIH1cblxuICAgIHJldHVybiBwYWdlO1xuICB9XG5cbiAgZ2V0IHBhZ2VzKCkge1xuICAgIHJldHVybiB1dGlsLmFycmF5RnJvbSh0aGlzLl9jb250ZW50RWxlbWVudC5jaGlsZHJlbik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuc2VsZWN0ZWRUYWJJbmRleFxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5wcmV2aW91c1RhYkluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVzIHRvIHRoZSBuZXcgcGFnZSBlbGVtZW50LlxuICAgKi9cbiAgX3N3aXRjaFBhZ2UoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIGNvbnN0IG9sZFBhZ2VFbGVtZW50ID0gdGhpcy5fb2xkUGFnZUVsZW1lbnQgfHwgaW50ZXJuYWwubnVsbEVsZW1lbnQ7XG4gICAgdGhpcy5fb2xkUGFnZUVsZW1lbnQgPSBlbGVtZW50O1xuICAgIGNvbnN0IGFuaW1hdG9yID0gdGhpcy5fYW5pbWF0b3JGYWN0b3J5Lm5ld0FuaW1hdG9yKG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgaWYgKG9sZFBhZ2VFbGVtZW50ICE9PSBpbnRlcm5hbC5udWxsRWxlbWVudCkge1xuICAgICAgICBvbGRQYWdlRWxlbWVudC5faGlkZSgpO1xuICAgICAgfVxuXG4gICAgICBhbmltYXRvci5hcHBseShlbGVtZW50LCBvbGRQYWdlRWxlbWVudCwgb3B0aW9ucy5zZWxlY3RlZFRhYkluZGV4LCBvcHRpb25zLnByZXZpb3VzVGFiSW5kZXgsICgpID0+IHtcbiAgICAgICAgaWYgKG9sZFBhZ2VFbGVtZW50ICE9PSBpbnRlcm5hbC5udWxsRWxlbWVudCkge1xuICAgICAgICAgIG9sZFBhZ2VFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICBlbGVtZW50Ll9zaG93KCk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuY2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2soKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc29sdmUoZWxlbWVudCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNldEFjdGl2ZVRhYlxuICAgKiBAc2lnbmF0dXJlIHNldEFjdGl2ZVRhYihpbmRleCwgW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogICBbZW5dVGFiIGluZGV4LlsvZW5dXG4gICAqICAgW2phXeOCv+ODluOBruOCpOODs+ODh+ODg+OCr+OCueOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmtlZXBQYWdlXVxuICAgKiAgIFtlbl1JZiB0cnVlIHRoZSBwYWdlIHdpbGwgbm90IGJlIGNoYW5nZWQuWy9lbl1cbiAgICogICBbamFd44K/44OW44OQ44O844GM54++5Zyo6KGo56S644GX44Gm44GE44KLcGFnZeOCkuWkieOBiOOBquOBhOWgtOWQiOOBq+OBr3RydWXjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcImZhZGVcImAsIGBcInNsaWRlXCJgIGFuZCBgXCJub25lXCJgLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAgmBcImZhZGVcImDjgIFgXCJzbGlkZVwiYOOAgWBcIm5vbmVcImDjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNob3cgc3BlY2lmaWVkIHRhYiBwYWdlLiBBbmltYXRpb25zIGFuZCBvdGhlciBvcHRpb25zIGNhbiBiZSBzcGVjaWZpZWQgYnkgdGhlIHNlY29uZCBwYXJhbWV0ZXIuWy9lbl1cbiAgICogICBbamFd5oyH5a6a44GX44Gf44Kk44Oz44OH44OD44Kv44K544Gu44K/44OW44KS6KGo56S644GX44G+44GZ44CC44Ki44OL44Oh44O844K344On44Oz44Gq44Gp44Gu44Kq44OX44K344On44Oz44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIG5ldyBwYWdlIGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHNldEFjdGl2ZVRhYihpbmRleCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMgIT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdC4gWW91IHN1cHBsaWVkICcgKyBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgPSB1dGlsLmV4dGVuZChcbiAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fSxcbiAgICAgIEFuaW1hdG9yRmFjdG9yeS5wYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpXG4gICAgKTtcblxuICAgIGlmICghb3B0aW9ucy5hbmltYXRpb24gJiYgdGhpcy5oYXNBdHRyaWJ1dGUoJ2FuaW1hdGlvbicpKSB7XG4gICAgICBvcHRpb25zLmFuaW1hdGlvbiA9IHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24nKTtcbiAgICB9XG5cbiAgICBjb25zdCBwcmV2aW91c1RhYiA9IHRoaXMuX2dldEFjdGl2ZVRhYkVsZW1lbnQoKSxcbiAgICAgIHNlbGVjdGVkVGFiID0gdGhpcy5fZ2V0VGFiRWxlbWVudChpbmRleCksXG4gICAgICBwcmV2aW91c1RhYkluZGV4ID0gdGhpcy5nZXRBY3RpdmVUYWJJbmRleCgpLFxuICAgICAgc2VsZWN0ZWRUYWJJbmRleCA9IGluZGV4LFxuICAgICAgcHJldmlvdXNQYWdlRWxlbWVudCA9IHRoaXMuX2dldEN1cnJlbnRQYWdlRWxlbWVudCgpO1xuXG4gICAgaWYgKCFzZWxlY3RlZFRhYikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdTcGVjaWZpZWQgaW5kZXggZG9lcyBub3QgbWF0Y2ggYW55IHRhYi4nKTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZWN0ZWRUYWJJbmRleCA9PT0gcHJldmlvdXNUYWJJbmRleCkge1xuICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdyZWFjdGl2ZScsIHtcbiAgICAgICAgaW5kZXg6IHNlbGVjdGVkVGFiSW5kZXgsXG4gICAgICAgIHRhYkl0ZW06IHNlbGVjdGVkVGFiXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwcmV2aW91c1BhZ2VFbGVtZW50KTtcbiAgICB9XG5cbiAgICBsZXQgY2FuY2VsZWQgPSBmYWxzZTtcblxuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncHJlY2hhbmdlJywge1xuICAgICAgaW5kZXg6IHNlbGVjdGVkVGFiSW5kZXgsXG4gICAgICB0YWJJdGVtOiBzZWxlY3RlZFRhYixcbiAgICAgIGNhbmNlbDogKCkgPT4gY2FuY2VsZWQgPSB0cnVlXG4gICAgfSk7XG5cbiAgICBpZiAoY2FuY2VsZWQpIHtcbiAgICAgIHNlbGVjdGVkVGFiLnNldEluYWN0aXZlKCk7XG4gICAgICBpZiAocHJldmlvdXNUYWIpIHtcbiAgICAgICAgcHJldmlvdXNUYWIuc2V0QWN0aXZlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0NhbmNlbGVkIGluIHByZWNoYW5nZSBldmVudC4nKTtcbiAgICB9XG5cbiAgICBzZWxlY3RlZFRhYi5zZXRBY3RpdmUoKTtcblxuICAgIGNvbnN0IG5lZWRMb2FkID0gIW9wdGlvbnMua2VlcFBhZ2U7XG5cbiAgICB1dGlsLmFycmF5RnJvbSh0aGlzLl9nZXRUYWJiYXJFbGVtZW50KCkuY2hpbGRyZW4pLmZvckVhY2goKHRhYikgPT4ge1xuICAgICAgaWYgKHRhYiAhPSBzZWxlY3RlZFRhYikge1xuICAgICAgICB0YWIuc2V0SW5hY3RpdmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghbmVlZExvYWQpIHtcbiAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3Bvc3RjaGFuZ2UnLCB7XG4gICAgICAgICAgICBpbmRleDogc2VsZWN0ZWRUYWJJbmRleCxcbiAgICAgICAgICAgIHRhYkl0ZW06IHNlbGVjdGVkVGFiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChuZWVkTG9hZCkge1xuICAgICAgbGV0IHJlbW92ZUVsZW1lbnQgPSBmYWxzZTtcblxuICAgICAgaWYgKCghcHJldmlvdXNUYWIgJiYgcHJldmlvdXNQYWdlRWxlbWVudCkgfHwgKHByZXZpb3VzVGFiICYmIHByZXZpb3VzVGFiLl9wYWdlRWxlbWVudCAhPT0gcHJldmlvdXNQYWdlRWxlbWVudCkpIHtcbiAgICAgICAgcmVtb3ZlRWxlbWVudCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3Bvc3RjaGFuZ2UnLCB7XG4gICAgICAgICAgICBpbmRleDogc2VsZWN0ZWRUYWJJbmRleCxcbiAgICAgICAgICAgIHRhYkl0ZW06IHNlbGVjdGVkVGFiXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5jYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwcmV2aW91c1RhYkluZGV4OiBwcmV2aW91c1RhYkluZGV4LFxuICAgICAgICBzZWxlY3RlZFRhYkluZGV4OiBzZWxlY3RlZFRhYkluZGV4XG4gICAgICB9O1xuXG4gICAgICBpZiAob3B0aW9ucy5hbmltYXRpb24pIHtcbiAgICAgICAgcGFyYW1zLmFuaW1hdGlvbiA9IG9wdGlvbnMuYW5pbWF0aW9uO1xuICAgICAgfVxuXG4gICAgICBwYXJhbXMuYW5pbWF0aW9uT3B0aW9ucyA9IG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fTtcblxuICAgICAgY29uc3QgbGluayA9IChlbGVtZW50LCBjYWxsYmFjaykgPT4ge1xuICAgICAgICByZXdyaXRhYmxlcy5saW5rKHRoaXMsIGVsZW1lbnQsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgc2VsZWN0ZWRUYWIuX2xvYWRQYWdlRWxlbWVudCh0aGlzLl9jb250ZW50RWxlbWVudCwgcGFnZUVsZW1lbnQgPT4ge1xuICAgICAgICAgIHBhZ2VFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgIHJlc29sdmUodGhpcy5fbG9hZFBlcnNpc3RlbnRQYWdlRE9NKHBhZ2VFbGVtZW50LCBwYXJhbXMpKTtcbiAgICAgICAgfSwgbGluayk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICB0aGlzLl9jb250ZW50RWxlbWVudC5hcHBlbmRDaGlsZChzZWxlY3RlZFRhYi5wYWdlRWxlbWVudCk7XG4gICAgICAgIHNlbGVjdGVkVGFiLnBhZ2VFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICByZXNvbHZlKHRoaXMuX2xvYWRQZXJzaXN0ZW50UGFnZURPTShzZWxlY3RlZFRhYi5wYWdlRWxlbWVudCwgcGFyYW1zKSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmFuaW1hdGlvblxuICAgKi9cbiAgX2xvYWRQZXJzaXN0ZW50UGFnZURPTShlbGVtZW50LCBvcHRpb25zID0ge30pIHtcblxuICAgIGlmICghdXRpbC5pc0F0dGFjaGVkKGVsZW1lbnQpKSB7XG4gICAgICB0aGlzLl9jb250ZW50RWxlbWVudC5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICB9XG5cbiAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICByZXR1cm4gdGhpcy5fc3dpdGNoUGFnZShlbGVtZW50LCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNldFRhYmJhclZpc2liaWxpdHlcbiAgICogQHNpZ25hdHVyZSBzZXRUYWJiYXJWaXNpYmlsaXR5KHZpc2libGUpXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmlzaWJsZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVXNlZCB0byBoaWRlIG9yIHNob3cgdGhlIHRhYiBiYXIuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHNldFRhYmJhclZpc2liaWxpdHkodmlzaWJsZSkge1xuICAgIHRoaXMuX2NvbnRlbnRFbGVtZW50LnN0eWxlW3RoaXMuX3RvcCA/ICd0b3AnIDogJ2JvdHRvbSddID0gdmlzaWJsZSA/ICcnIDogJzBweCc7XG4gICAgdGhpcy5fZ2V0VGFiYmFyRWxlbWVudCgpLnN0eWxlLmRpc3BsYXkgPSB2aXNpYmxlID8gJycgOiAnbm9uZSc7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBnZXRBY3RpdmVUYWJJbmRleFxuICAgKiBAc2lnbmF0dXJlIGdldEFjdGl2ZVRhYkluZGV4KClcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKiAgIFtlbl1UaGUgaW5kZXggb2YgdGhlIGN1cnJlbnRseSBhY3RpdmUgdGFiLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOCouOCr+ODhuOCo+ODluOBq+OBquOBo+OBpuOBhOOCi+OCv+ODluOBruOCpOODs+ODh+ODg+OCr+OCueOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHRhYiBpbmRleCBvbiBjdXJyZW50IGFjdGl2ZSB0YWIuIElmIGFjdGl2ZSB0YWIgaXMgbm90IGZvdW5kLCByZXR1cm5zIC0xLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOCouOCr+ODhuOCo+ODluOBq+OBquOBo+OBpuOBhOOCi+OCv+ODluOBruOCpOODs+ODh+ODg+OCr+OCueOCkui/lOOBl+OBvuOBmeOAguePvuWcqOOCouOCr+ODhuOCo+ODluOBquOCv+ODluOBjOOBquOBhOWgtOWQiOOBq+OBry0x44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldEFjdGl2ZVRhYkluZGV4KCkge1xuICAgIGNvbnN0IHRhYnMgPSB0aGlzLl9nZXRUYWJiYXJFbGVtZW50KCkuY2hpbGRyZW47XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0YWJzW2ldIGluc3RhbmNlb2YgVGFiRWxlbWVudCAmJiB0YWJzW2ldLmlzQWN0aXZlICYmIHRhYnNbaV0uaXNBY3RpdmUoKSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7TnVtYmVyfSBXaGVuIGFjdGl2ZSB0YWIgaXMgbm90IGZvdW5kLCByZXR1cm5zIC0xLlxuICAgKi9cbiAgX2dldEFjdGl2ZVRhYkVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFRhYkVsZW1lbnQodGhpcy5nZXRBY3RpdmVUYWJJbmRleCgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKi9cbiAgX2dldFRhYkVsZW1lbnQoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VGFiYmFyRWxlbWVudCgpLmNoaWxkcmVuW2luZGV4XTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkgeyB9XG5cbiAgX3Nob3coKSB7XG4gICAgY29uc3QgY3VycmVudFBhZ2VFbGVtZW50ID0gdGhpcy5fZ2V0Q3VycmVudFBhZ2VFbGVtZW50KCk7XG4gICAgaWYgKGN1cnJlbnRQYWdlRWxlbWVudCkge1xuICAgICAgY3VycmVudFBhZ2VFbGVtZW50Ll9zaG93KCk7XG4gICAgfVxuICB9XG5cbiAgX2hpZGUoKSB7XG4gICAgY29uc3QgY3VycmVudFBhZ2VFbGVtZW50ID0gdGhpcy5fZ2V0Q3VycmVudFBhZ2VFbGVtZW50KCk7XG4gICAgaWYgKGN1cnJlbnRQYWdlRWxlbWVudCkge1xuICAgICAgY3VycmVudFBhZ2VFbGVtZW50Ll9oaWRlKCk7XG4gICAgfVxuICB9XG5cbiAgX2Rlc3Ryb3koKSB7XG4gICAgY29uc3QgcGFnZXMgPSB0aGlzLl9jb250ZW50RWxlbWVudC5jaGlsZHJlbjtcbiAgICBmb3IgKGxldCBpID0gcGFnZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHBhZ2VzW2ldLl9kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlKCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllciddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXQgcmV3cml0YWJsZXMoKSB7XG4gICAgcmV0dXJuIHJld3JpdGFibGVzO1xuICB9XG5cbiAgc3RhdGljIGdldCBUYWJiYXJBbmltYXRvcigpIHtcbiAgICByZXR1cm4gVGFiYmFyQW5pbWF0b3I7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gQW5pbWF0b3JcbiAgICovXG4gIHN0YXRpYyByZWdpc3RlckFuaW1hdG9yKG5hbWUsIEFuaW1hdG9yKSB7XG4gICAgaWYgKCEoQW5pbWF0b3IucHJvdG90eXBlIGluc3RhbmNlb2YgVGFiYmFyQW5pbWF0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiQW5pbWF0b3JcIiBwYXJhbSBtdXN0IGluaGVyaXQgVGFiYmFyRWxlbWVudC5UYWJiYXJBbmltYXRvcicpO1xuICAgIH1cbiAgICBfYW5pbWF0b3JEaWN0W25hbWVdID0gQW5pbWF0b3I7XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtdGFiYmFyJywgVGFiYmFyRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICdvbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJ29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICdvbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnb25zL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnb25zL2ludGVybmFsJztcbmltcG9ydCBUYWJiYXJFbGVtZW50IGZyb20gJy4vb25zLXRhYmJhcic7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJ29ucy9jb250ZW50LXJlYWR5JztcbmltcG9ydCB7UGFnZUxvYWRlciwgZGVmYXVsdFBhZ2VMb2FkZXJ9IGZyb20gJ29ucy9wYWdlLWxvYWRlcic7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICd0YWItYmFyLS0qX19pdGVtJyxcbiAgJy50YWItYmFyX19idXR0b24nOiAndGFiLWJhci0tKl9fYnV0dG9uJ1xufTtcbmNvbnN0IHRlbXBsYXRlU291cmNlID0gdXRpbC5jcmVhdGVFbGVtZW50KGBcbiAgPGRpdj5cbiAgICA8aW5wdXQgdHlwZT1cInJhZGlvXCIgc3R5bGU9XCJkaXNwbGF5OiBub25lXCI+XG4gICAgPGJ1dHRvbiBjbGFzcz1cInRhYi1iYXJfX2J1dHRvbiB0YWItYmFyLWlubmVyXCI+PC9idXR0b24+XG4gIDwvZGl2PlxuYCk7XG5jb25zdCBkZWZhdWx0SW5uZXJUZW1wbGF0ZVNvdXJjZSA9IHV0aWwuY3JlYXRlRWxlbWVudChgXG4gIDxkaXY+XG4gICAgPGRpdiBjbGFzcz1cInRhYi1iYXJfX2ljb25cIj5cbiAgICAgIDxvbnMtaWNvbiBpY29uPVwiaW9uLWNsb3VkXCI+PC9vbnMtaWNvbj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwidGFiLWJhcl9fbGFiZWxcIj5sYWJlbDwvZGl2PlxuICA8L2Rpdj5cbmApO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy10YWJcbiAqIEBjYXRlZ29yeSB0YWJiYXJcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dUmVwcmVzZW50cyBhIHRhYiBpbnNpZGUgdGFiIGJhci4gRWFjaCBgPG9ucy10YWI+YCByZXByZXNlbnRzIGEgcGFnZS5bL2VuXVxuICogICBbamFdXG4gKiAgICAg44K/44OW44OQ44O844Gr6YWN572u44GV44KM44KL5ZCE44Ki44Kk44OG44Og44Gu44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CC44Gd44KM44Ge44KM44Gub25zLXRhYuOBr+ODmuODvOOCuOOCkuihqOOBl+OBvuOBmeOAglxuICogICAgIG9ucy10YWLopoHntKDjga7kuK3jgavjga/jgIHjgr/jg5bjgavooajnpLrjgZXjgozjgovjgrPjg7Pjg4bjg7Pjg4TjgpLnm7TmjqXoqJjov7DjgZnjgovjgZPjgajjgYzlh7rmnaXjgb7jgZnjgIJcbiAqICAgWy9qYV1cbiAqIEBjb2RlcGVuIHBHdURMXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvdGFiYmFyXG4gKiBAZ3VpZGUgbXVsdGlwbGUtcGFnZS1uYXZpZ2F0aW9uXG4gKiAgIFtlbl1NYW5hZ2luZyBtdWx0aXBsZSBwYWdlcy5bL2VuXVxuICogICBbamFdTWFuYWdpbmcgbXVsdGlwbGUgcGFnZXNbL2phXV1cbiAqIEBndWlkZSB0ZW1wbGF0ZXNcbiAqICAgW2VuXURlZmluaW5nIG11bHRpcGxlIHBhZ2VzIGluIHNpbmdsZSBodG1sWy9lbl1cbiAqICAgW2phXeikh+aVsOOBruODmuODvOOCuOOCkjHjgaTjga5IVE1M44Gr6KiY6L+w44GZ44KLWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy10YWJiYXJcbiAqICAgW2VuXW9ucy10YWJiYXIgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy10YWJiYXLjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLXBhZ2VcbiAqICAgW2VuXW9ucy1wYWdlIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtcGFnZeOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtaWNvblxuICogICBbZW5db25zLWljb24gY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1pY29u44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXRhYmJhcj5cbiAqICAgPG9ucy10YWJcbiAqICAgICBwYWdlPVwiaG9tZS5odG1sXCJcbiAqICAgICBsYWJlbD1cIkhvbWVcIlxuICogICAgIGFjdGl2ZT5cbiAqICAgPC9vbnMtdGFiPlxuICogICA8b25zLXRhYlxuICogICAgIHBhZ2U9XCJzZXR0aW5ncy5odG1sXCJcbiAqICAgICBsYWJlbD1cIlNldHRpbmdzXCJcbiAqICAgICBhY3RpdmU+XG4gKiAgIDwvb25zLXRhYj5cbiAqIDwvb25zLXRhYmJhcj5cbiAqXG4gKiA8b25zLXRlbXBsYXRlIGlkPVwiaG9tZS5odG1sXCI+XG4gKiAgIC4uLlxuICogPC9vbnMtdGVtcGxhdGU+XG4gKlxuICogPG9ucy10ZW1wbGF0ZSBpZD1cInNldHRpbmdzLmh0bWxcIj5cbiAqICAgLi4uXG4gKiA8L29ucy10ZW1wbGF0ZT5cblxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUYWJFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHBhZ2VcbiAgICogQGluaXRvbmx5XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgcGFnZSB0aGF0IGlzIGRpc3BsYXllZCB3aGVuIHRoZSB0YWIgaXMgdGFwcGVkLlsvZW5dXG4gICAqICAgW2phXW9ucy10YWLjgYzlj4LnhafjgZnjgovjg5rjg7zjgrjjgbjjga5VUkzjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBpY29uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIFRoZSBpY29uIG5hbWUgZm9yIHRoZSB0YWIuIENhbiBzcGVjaWZ5IHRoZSBzYW1lIGljb24gbmFtZSBhcyBgPG9ucy1pY29uPmAuXG4gICAqICAgICBJZiB5b3UgbmVlZCB0byB1c2UgeW91ciBvd24gaWNvbiwgY3JlYXRlIGEgQ1NTIGNsYXNzIHdpdGggYGJhY2tncm91bmQtaW1hZ2VgIG9yIGFueSBDU1MgcHJvcGVydGllcyBhbmQgc3BlY2lmeSB0aGUgbmFtZSBvZiB5b3VyIENTUyBjbGFzcyBoZXJlLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVxuICAgKiAgICAg44Ki44Kk44Kz44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCb25zLWljb27jgajlkIzjgZjjgqLjgqTjgrPjg7PlkI3jgpLmjIflrprjgafjgY3jgb7jgZnjgIJcbiAgICogICAgIOWAi+WIpeOBq+OCouOCpOOCs+ODs+OCkuOCq+OCueOCv+ODnuOCpOOCuuOBmeOCi+WgtOWQiOOBr+OAgWJhY2tncm91bmQtaW1hZ2Xjgarjganjga5DU1Pjgrnjgr/jgqTjg6vjgpLnlKjjgYTjgabmjIflrprjgafjgY3jgb7jgZnjgIJcbiAgICogICBbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhY3RpdmUtaWNvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIG5hbWUgb2YgdGhlIGljb24gd2hlbiB0aGUgdGFiIGlzIGFjdGl2ZS5bL2VuXVxuICAgKiAgIFtqYV3jgqLjgq/jg4bjgqPjg5bjga7pmpvjga7jgqLjgqTjgrPjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBsYWJlbFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGxhYmVsIG9mIHRoZSB0YWIgaXRlbS5bL2VuXVxuICAgKiAgIFtqYV3jgqLjgqTjgrPjg7PkuIvjgavooajnpLrjgZXjgozjgovjg6njg5njg6vjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhY3RpdmVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoaXMgYXR0cmlidXRlIHNob3VsZCBiZSBzZXQgdG8gdGhlIHRhYiB0aGF0IGlzIGFjdGl2ZSBieSBkZWZhdWx0LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5fcGFnZUxvYWRlciA9IGRlZmF1bHRQYWdlTG9hZGVyO1xuICAgIHRoaXMuX3BhZ2UgPSBudWxsO1xuXG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdsYWJlbCcpIHx8IHRoaXMuaGFzQXR0cmlidXRlKCdpY29uJykpIHtcbiAgICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoJ19jb21waWxlZCcpKSB7XG4gICAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZSgnX2NvbXBpbGVkJykpIHtcbiAgICAgICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuX2JvdW5kT25DbGljayA9IHRoaXMuX29uQ2xpY2suYmluZCh0aGlzKTtcbiAgfVxuXG4gIF9nZXRQYWdlVGFyZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLnBhZ2UgfHwgdGhpcy5nZXRBdHRyaWJ1dGUoJ3BhZ2UnKTtcbiAgfVxuXG4gIHNldCBwYWdlKHBhZ2UpIHtcbiAgICB0aGlzLl9wYWdlID0gcGFnZTtcbiAgfVxuXG4gIGdldCBwYWdlKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlO1xuICB9XG5cbiAgc2V0IHBhZ2VMb2FkZXIobG9hZGVyKSB7XG4gICAgaWYgKCEobG9hZGVyIGluc3RhbmNlb2YgUGFnZUxvYWRlcikpIHtcbiAgICAgIHRocm93IEVycm9yKCdGaXJzdCBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBQYWdlTG9hZGVyLicpO1xuICAgIH1cbiAgICB0aGlzLl9wYWdlTG9hZGVyID0gbG9hZGVyO1xuICB9XG5cbiAgZ2V0IHBhZ2VMb2FkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VMb2FkZXI7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIGNvbnN0IGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIGxldCBoYXNDaGlsZHJlbiA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKHRoaXMuY2hpbGROb2Rlc1swXSkge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuY2hpbGROb2Rlc1swXTtcbiAgICAgIHRoaXMucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChub2RlKTtcblxuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgaGFzQ2hpbGRyZW4gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHRlbXBsYXRlID0gdGVtcGxhdGVTb3VyY2UuY2xvbmVOb2RlKHRydWUpO1xuICAgIHdoaWxlICh0ZW1wbGF0ZS5jaGlsZHJlblswXSkge1xuICAgICAgdGhpcy5hcHBlbmRDaGlsZCh0ZW1wbGF0ZS5jaGlsZHJlblswXSk7XG4gICAgfVxuICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgndGFiLWJhcl9faXRlbScpO1xuXG4gICAgY29uc3QgYnV0dG9uID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJy50YWItYmFyX19idXR0b24nKTtcblxuICAgIGlmIChoYXNDaGlsZHJlbikge1xuICAgICAgYnV0dG9uLmFwcGVuZENoaWxkKGZyYWdtZW50KTtcbiAgICAgIHRoaXMuX2hhc0RlZmF1bHRUZW1wbGF0ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9oYXNEZWZhdWx0VGVtcGxhdGUgPSB0cnVlO1xuICAgICAgdGhpcy5fdXBkYXRlRGVmYXVsdFRlbXBsYXRlKCk7XG4gICAgfVxuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICAgIHRoaXMuX3VwZGF0ZVJpcHBsZSgpO1xuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ19jb21waWxlZCcsICcnKTtcbiAgfVxuXG4gIF91cGRhdGVSaXBwbGUoKSB7XG4gICAgLy8gdXRpbC51cGRhdGVSaXBwbGUodGhpcy5xdWVyeVNlbGVjdG9yKCcudGFiLWJhcl9fYnV0dG9uJyksIHRoaXMpO1xuICB9XG5cbiAgX3VwZGF0ZURlZmF1bHRUZW1wbGF0ZSgpIHtcbiAgICBpZiAoIXRoaXMuX2hhc0RlZmF1bHRUZW1wbGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGJ1dHRvbiA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcudGFiLWJhcl9fYnV0dG9uJyk7XG5cbiAgICBpZiAoYnV0dG9uLmNoaWxkcmVuLmxlbmd0aCA9PSAwKSB7XG4gICAgICBjb25zdCB0ZW1wbGF0ZSA9IGRlZmF1bHRJbm5lclRlbXBsYXRlU291cmNlLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgIHdoaWxlICh0ZW1wbGF0ZS5jaGlsZHJlblswXSkge1xuICAgICAgICBidXR0b24uYXBwZW5kQ2hpbGQodGVtcGxhdGUuY2hpbGRyZW5bMF0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWJ1dHRvbi5xdWVyeVNlbGVjdG9yKCcudGFiLWJhcl9faWNvbicpKSB7XG4gICAgICAgIGJ1dHRvbi5pbnNlcnRCZWZvcmUodGVtcGxhdGUucXVlcnlTZWxlY3RvcignLnRhYi1iYXJfX2ljb24nKSwgYnV0dG9uLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWJ1dHRvbi5xdWVyeVNlbGVjdG9yKCcudGFiLWJhcl9fbGFiZWwnKSkge1xuICAgICAgICBidXR0b24uYXBwZW5kQ2hpbGQodGVtcGxhdGUucXVlcnlTZWxlY3RvcignLnRhYi1iYXJfX2xhYmVsJykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGNvbnN0IGljb24gPSB0aGlzLmdldEF0dHJpYnV0ZSgnaWNvbicpO1xuICAgIGNvbnN0IGxhYmVsID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2xhYmVsJyk7XG5cbiAgICBpZiAodHlwZW9mIGljb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICBnZXRJY29uRWxlbWVudCgpLnNldEF0dHJpYnV0ZSgnaWNvbicsIGljb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB3cmFwcGVyID0gYnV0dG9uLnF1ZXJ5U2VsZWN0b3IoJy50YWItYmFyX19pY29uJyk7XG4gICAgICBpZiAod3JhcHBlcikge1xuICAgICAgICB3cmFwcGVyLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbGFiZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICBnZXRMYWJlbEVsZW1lbnQoKS50ZXh0Q29udGVudCA9IGxhYmVsO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsYWJlbCA9IGdldExhYmVsRWxlbWVudCgpO1xuICAgICAgaWYgKGxhYmVsKSB7XG4gICAgICAgIGxhYmVsLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldExhYmVsRWxlbWVudCgpIHtcbiAgICAgIHJldHVybiBzZWxmLnF1ZXJ5U2VsZWN0b3IoJy50YWItYmFyX19sYWJlbCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEljb25FbGVtZW50KCkge1xuICAgICAgcmV0dXJuIHNlbGYucXVlcnlTZWxlY3Rvcignb25zLWljb24nKTtcbiAgICB9XG4gIH1cblxuICBfb25DbGljaygpIHtcbiAgICBjb25zdCB0YWJiYXIgPSB0aGlzLl9maW5kVGFiYmFyRWxlbWVudCgpO1xuICAgIGlmICh0YWJiYXIpIHtcbiAgICAgIHRhYmJhci5zZXRBY3RpdmVUYWIodGhpcy5fZmluZFRhYkluZGV4KCkpO1xuICAgIH1cbiAgfVxuXG4gIHNldEFjdGl2ZSgpIHtcbiAgICBjb25zdCByYWRpbyA9IHV0aWwuZmluZENoaWxkKHRoaXMsICdpbnB1dCcpO1xuICAgIHJhZGlvLmNoZWNrZWQgPSB0cnVlO1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG5cbiAgICB1dGlsLmFycmF5RnJvbSh0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tvbnMtdGFiLWluYWN0aXZlXSwgb25zLXRhYi1pbmFjdGl2ZScpKVxuICAgICAgLmZvckVhY2goZWxlbWVudCA9PiBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZScpO1xuICAgIHV0aWwuYXJyYXlGcm9tKHRoaXMucXVlcnlTZWxlY3RvckFsbCgnW29ucy10YWItYWN0aXZlXSwgb25zLXRhYi1hY3RpdmUnKSlcbiAgICAgIC5mb3JFYWNoKGVsZW1lbnQgPT4gZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2luaGVyaXQnKTtcbiAgfVxuXG4gIHNldEluYWN0aXZlKCkge1xuICAgIGNvbnN0IHJhZGlvID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJ2lucHV0Jyk7XG4gICAgcmFkaW8uY2hlY2tlZCA9IGZhbHNlO1xuICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG5cbiAgICB1dGlsLmFycmF5RnJvbSh0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tvbnMtdGFiLWluYWN0aXZlXSwgb25zLXRhYi1pbmFjdGl2ZScpKVxuICAgICAgLmZvckVhY2goZWxlbWVudCA9PiBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnaW5oZXJpdCcpO1xuICAgIHV0aWwuYXJyYXlGcm9tKHRoaXMucXVlcnlTZWxlY3RvckFsbCgnW29ucy10YWItYWN0aXZlXSwgb25zLXRhYi1hY3RpdmUnKSlcbiAgICAgIC5mb3JFYWNoKGVsZW1lbnQgPT4gZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHBhcmVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaW5rXG4gICAqL1xuICBfbG9hZFBhZ2VFbGVtZW50KHBhcmVudCwgY2FsbGJhY2ssIGxpbmspIHtcbiAgICBpZiAoIXRoaXMuX2xvYWRlZFBhZ2UgJiYgIXRoaXMuX2dldFBhZ2VUYXJnZXQoKSkge1xuICAgICAgY29uc3QgcGFnZXMgPSB0aGlzLl9maW5kVGFiYmFyRWxlbWVudCgpLnBhZ2VzO1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9maW5kVGFiSW5kZXgoKTtcbiAgICAgIGNhbGxiYWNrKHBhZ2VzW2luZGV4XSk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5fbG9hZGVkUGFnZSkge1xuICAgICAgdGhpcy5fcGFnZUxvYWRlci5sb2FkKHtwYWdlOiB0aGlzLl9nZXRQYWdlVGFyZ2V0KCksIHBhcmVudH0sIHBhZ2UgPT4ge1xuICAgICAgICB0aGlzLl9sb2FkZWRQYWdlID0gcGFnZTtcbiAgICAgICAgbGluayhwYWdlLmVsZW1lbnQsIGVsZW1lbnQgPT4ge1xuICAgICAgICAgIHBhZ2UuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgICAgY2FsbGJhY2socGFnZS5lbGVtZW50KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sodGhpcy5fbG9hZGVkUGFnZS5lbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICBfbG9hZFBhZ2UocGFnZSwgcGFyZW50LCBjYWxsYmFjaykge1xuICAgIHRoaXMuX3BhZ2VMb2FkZXIubG9hZCh7cGFnZSwgcGFyZW50fSwgcGFnZSA9PiB7XG4gICAgICBjYWxsYmFjayhwYWdlLmVsZW1lbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0IHBhZ2VFbGVtZW50KCkge1xuICAgIGlmICh0aGlzLl9sb2FkZWRQYWdlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbG9hZGVkUGFnZS5lbGVtZW50O1xuICAgIH1cblxuICAgIGNvbnN0IHRhYmJhciA9IHRoaXMuX2ZpbmRUYWJiYXJFbGVtZW50KCk7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9maW5kVGFiSW5kZXgoKTtcblxuICAgIHJldHVybiB0YWJiYXIuX2NvbnRlbnRFbGVtZW50LmNoaWxkcmVuW2luZGV4XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE9uQ2xpY2ssIGZhbHNlKTtcbiAgICBpZiAodGhpcy5fbG9hZGVkUGFnZSkge1xuICAgICAgdGhpcy5fbG9hZGVkUGFnZS51bmxvYWQoKTtcbiAgICAgIHRoaXMuX2xvYWRlZFBhZ2UgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9lbnN1cmVFbGVtZW50UG9zaXRpb24oKTtcblxuICAgICAgY29uc3QgdGFiYmFyID0gdGhpcy5fZmluZFRhYmJhckVsZW1lbnQoKTtcblxuICAgICAgaWYgKHRhYmJhci5oYXNBdHRyaWJ1dGUoJ21vZGlmaWVyJykpIHtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gdGhpcy5oYXNBdHRyaWJ1dGUoJ21vZGlmaWVyJykgPyB0aGlzLmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKSArICcgJyA6ICcnO1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnbW9kaWZpZXInLCBwcmVmaXggKyB0YWJiYXIuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdhY3RpdmUnKSkge1xuICAgICAgICBjb25zdCB0YWJJbmRleCA9IHRoaXMuX2ZpbmRUYWJJbmRleCgpO1xuXG4gICAgICAgIFRhYmJhckVsZW1lbnQucmV3cml0YWJsZXMucmVhZHkodGFiYmFyLCAoKSA9PiB7XG4gICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHRhYmJhci5zZXRBY3RpdmVUYWIodGFiSW5kZXgsIHthbmltYXRpb246ICdub25lJ30pKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBvblJlYWR5ID0gKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLl9nZXRQYWdlVGFyZ2V0KCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvYWRQYWdlRWxlbWVudCh0YWJiYXIuX2NvbnRlbnRFbGVtZW50LCBwYWdlRWxlbWVudCA9PiB7XG4gICAgICAgICAgICAgIHBhZ2VFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgIHRhYmJhci5fY29udGVudEVsZW1lbnQuYXBwZW5kQ2hpbGQocGFnZUVsZW1lbnQpO1xuICAgICAgICAgICAgfSwgKHBhZ2VFbGVtZW50LCBkb25lKSA9PiB7XG4gICAgICAgICAgICAgIFRhYmJhckVsZW1lbnQucmV3cml0YWJsZXMubGluayh0YWJiYXIsIHBhZ2VFbGVtZW50LCB7fSwgZWxlbWVudCA9PiBkb25lKGVsZW1lbnQpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgVGFiYmFyRWxlbWVudC5yZXdyaXRhYmxlcy5yZWFkeSh0YWJiYXIsIG9uUmVhZHkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRPbkNsaWNrLCBmYWxzZSk7XG4gICAgfSk7XG4gIH1cblxuICBfZmluZFRhYmJhckVsZW1lbnQoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50Tm9kZSAmJiB0aGlzLnBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29ucy10YWJiYXInKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBhcmVudE5vZGUucGFyZW50Tm9kZSAmJiB0aGlzLnBhcmVudE5vZGUucGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb25zLXRhYmJhcicpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIF9maW5kVGFiSW5kZXgoKSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLnBhcmVudE5vZGUuY2hpbGRyZW47XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMgPT09IGVsZW1lbnRzW2ldKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9lbnN1cmVFbGVtZW50UG9zaXRpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9maW5kVGFiYmFyRWxlbWVudCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgb25zLXRhYiBlbGVtZW50IGlzIG11c3QgYmUgY2hpbGQgb2Ygb25zLXRhYmJhciBlbGVtZW50LicpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ3JpcHBsZScsICdpY29uJywgJ2xhYmVsJywgJ3BhZ2UnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlwcGxlJzpcbiAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX3VwZGF0ZVJpcHBsZSgpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpY29uJzpcbiAgICAgIGNhc2UgJ2xhYmVsJzpcbiAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX3VwZGF0ZURlZmF1bHRUZW1wbGF0ZSgpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdwYWdlJzpcbiAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuX3BhZ2UgPSBjdXJyZW50O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy10YWInLCBUYWJFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJ29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcblxuY29uc3Qgc2NoZW1lID0geycnOiAndG9vbGJhci1idXR0b24tLSonfTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtdG9vbGJhci1idXR0b25cbiAqIEBjYXRlZ29yeSBwYWdlXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiB0b29sYmFyIGJ1dHRvbi5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBtb2RpZmllciBvdXRsaW5lXG4gKiAgIFtlbl1BIGJ1dHRvbiB3aXRoIGFuIG91dGxpbmUuWy9lbl1cbiAqICAgW2phXeOCouOCpuODiOODqeOCpOODs+OCkuOCguOBo+OBn+ODnOOCv+ODs+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUJ1dHRvbiBjb21wb25lbnQgZm9yIG9ucy10b29sYmFyIGFuZCBvbnMtYm90dG9tLXRvb2xiYXIuWy9lbl1cbiAqICAgW2phXW9ucy10b29sYmFy44GC44KL44GE44Gvb25zLWJvdHRvbS10b29sYmFy44Gr6Kit572u44Gn44GN44KL44Oc44K/44Oz55So44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CCWy9qYV1cbiAqIEBjb2RlcGVuIGFIbUdMXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvYnV0dG9uXG4gKiBAZ3VpZGUgYWRkaW5nLWEtdG9vbGJhclxuICogICBbZW5dQWRkaW5nIGEgdG9vbGJhclsvZW5dXG4gKiAgIFtqYV3jg4Tjg7zjg6vjg5Djg7zjga7ov73liqBbL2phXVxuICogQHNlZWFsc28gb25zLXRvb2xiYXJcbiAqICAgW2VuXVRoZSBgPG9ucy10b29sYmFyPmAgY29tcG9uZW50IGRpc3BsYXlzIGEgbmF2aWdhdGlvbiBiYXIgYXQgdGhlIHRvcCBvZiBhIHBhZ2UuWy9lbl1cbiAqICAgW2phXW9ucy10b29sYmFy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1iYWNrLWJ1dHRvblxuICogICBbZW5dVGhlIGA8b25zLWJhY2stYnV0dG9uPmAgZGlzcGxheXMgYSBiYWNrIGJ1dHRvbiBpbiB0aGUgbmF2aWdhdGlvbiBiYXIuWy9lbl1cbiAqICAgW2phXW9ucy1iYWNrLWJ1dHRvbuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy10b29sYmFyPlxuICogICA8ZGl2IGNsYXNzPVwibGVmdFwiPlxuICogICAgIDxvbnMtdG9vbGJhci1idXR0b24+XG4gKiAgICAgICBCdXR0b25cbiAqICAgICA8L29ucy10b29sYmFyLWJ1dHRvbj5cbiAqICAgPC9kaXY+XG4gKiAgIDxkaXYgY2xhc3M9XCJjZW50ZXJcIj5cbiAqICAgICBUaXRsZVxuICogICA8L2Rpdj5cbiAqICAgPGRpdiBjbGFzcz1cInJpZ2h0XCI+XG4gKiAgICAgPG9ucy10b29sYmFyLWJ1dHRvbj5cbiAqICAgICAgIDxvbnMtaWNvbiBpY29uPVwiaW9uLW5hdmljb25cIiBzaXplPVwiMjhweFwiPjwvb25zLWljb24+XG4gKiAgICAgPC9vbnMtdG9vbGJhci1idXR0b24+XG4gKiAgIDwvZGl2PlxuICogPC9vbnMtdG9vbGJhcj5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVG9vbGJhckJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBidXR0b24uWy9lbl1cbiAgICogICBbamFd44Oc44K/44Oz44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgaWYgYnV0dG9uIHNob3VsZCBiZSBkaXNhYmxlZC5bL2VuXVxuICAgKiAgIFtqYV3jg5zjgr/jg7PjgpLnhKHlirnljJbjgZnjgovloLTlkIjjga/mjIflrprjgZfjgabjgY/jgaDjgZXjgYTjgIJbL2phXVxuICAgKi9cblxuICBpbml0KCkge1xuICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoJ19jb21waWxlZCcpKSB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdmFsdWUpO1xuICB9XG5cbiAgZ2V0IGRpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKCd0b29sYmFyLWJ1dHRvbicpO1xuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ19jb21waWxlZCcsICcnKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChuYW1lID09PSAnbW9kaWZpZXInKSB7XG4gICAgICByZXR1cm4gTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgfVxuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXRvb2xiYXItYnV0dG9uJywgVG9vbGJhckJ1dHRvbkVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJ29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICdvbnMvYmFzZS1lbGVtZW50JztcbmltcG9ydCB1dGlsIGZyb20gJ29ucy91dGlsJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcucmFuZ2UnOiAncmFuZ2UtLSonLFxuICAnLnJhbmdlX19sZWZ0JzogJ3JhbmdlLS0qX19sZWZ0J1xufTtcblxuY29uc3QgdGVtcGxhdGVTb3VyY2UgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoYDxkaXY+XG4gIDxkaXYgY2xhc3M9XCJyYW5nZV9fbGVmdFwiPjwvZGl2PlxuICA8aW5wdXQgdHlwZT1cInJhbmdlXCIgY2xhc3M9XCJyYW5nZVwiPlxuPC9kaXY+YCk7XG5cbmNvbnN0IElOUFVUX0FUVFJJQlVURVMgPSBbXG4gICdhdXRvZm9jdXMnLFxuICAnZGlzYWJsZWQnLFxuICAnaW5wdXRtb2RlJyxcbiAgJ21heCcsXG4gICdtaW4nLFxuICAnbmFtZScsXG4gICdwbGFjZWhvbGRlcicsXG4gICdyZWFkb25seScsXG4gICdzaXplJyxcbiAgJ3N0ZXAnLFxuICAndmFsaWRhdG9yJyxcbiAgJ3ZhbHVlJ1xuXTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtcmFuZ2VcbiAqIEBjYXRlZ29yeSBmb3JtXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiBzbGlkZXJbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgUmFuZ2UgaW5wdXQgY29tcG9uZW50LiBVc2VkIHRvIGRpc3BsYXkgYSBkcmFnZ2FibGUgc2xpZGVyLlxuICpcbiAqICAgICBXb3JrcyB2ZXJ5IHNpbWlsYXIgdG8gdGhlIGA8aW5wdXQgdHlwZT1cInJhbmdlXCI+YCBlbGVtZW50LlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIHhaUW9tTVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3JhbmdlXG4gKiBAZ3VpZGUgdXNpbmctbW9kaWZpZXIgW2VuXU1vcmUgZGV0YWlscyBhYm91dCB0aGUgYG1vZGlmaWVyYCBhdHRyaWJ1dGVbL2VuXVtqYV1tb2RpZmllcuWxnuaAp+OBruS9v+OBhOaWuVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtaW5wdXRcbiAqICAgW2VuXVRoZSBgPG9ucy1pbnB1dD5gIGNvbXBvbmVudCBpcyB1c2VkIHRvIGRpc3BsYXkgdGV4dCBpbnB1dHMsIHJhZGlvIGJ1dHRvbnMgYW5kIGNoZWNrYm94ZXMuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1yYW5nZSB2YWx1ZT1cIjIwXCI+PC9vbnMtcmFuZ2U+XG4gKiA8b25zLXJhbmdlIG1vZGlmaWVyPVwibWF0ZXJpYWxcIiB2YWx1ZT1cIjEwXCI+PC9yYW5nZT5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmFuZ2VFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIGluaXQoKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoJ19jb21waWxlZCcpKSB7XG4gICAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdXBkYXRlQm91bmRBdHRyaWJ1dGVzKCk7XG4gICAgICB0aGlzLl9vbkNoYW5nZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICBpZiAoISh1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnJhbmdlX19sZWZ0JykgJiYgdXRpbC5maW5kQ2hpbGQodGhpcywgJ2lucHV0JykpKSB7XG4gICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRlbXBsYXRlU291cmNlLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgIHdoaWxlICh0ZW1wbGF0ZS5jaGlsZHJlblswXSkge1xuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKHRlbXBsYXRlLmNoaWxkcmVuWzBdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG5cbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnX2NvbXBpbGVkJywgJycpO1xuICB9XG5cbiAgX29uQ2hhbmdlKCkge1xuICAgIHRoaXMuX2xlZnQuc3R5bGUud2lkdGggPSAoMTAwICogdGhpcy5fcmF0aW8pICsgJyUnO1xuICB9XG5cbiAgX29uRHJhZ3N0YXJ0KGUpIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGUuZ2VzdHVyZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxuXG4gIGdldCBfcmF0aW8oKSB7XG4gICAgLy8gUmV0dXJucyB0aGUgY3VycmVudCByYXRpby5cbiAgICBjb25zdCBtaW4gPSB0aGlzLl9pbnB1dC5taW4gPT09ICcnID8gMCA6IHBhcnNlSW50KHRoaXMuX2lucHV0Lm1pbik7XG4gICAgY29uc3QgbWF4ID0gdGhpcy5faW5wdXQubWF4ID09PSAnJyA/IDEwMCA6IHBhcnNlSW50KHRoaXMuX2lucHV0Lm1heCk7XG5cbiAgICByZXR1cm4gKHRoaXMudmFsdWUgLSBtaW4pIC8gKG1heCAtIG1pbik7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsIC4uLklOUFVUX0FUVFJJQlVURVNdO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKElOUFVUX0FUVFJJQlVURVMuaW5kZXhPZihuYW1lKSA+PSAwKSB7XG4gICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICB0aGlzLl91cGRhdGVCb3VuZEF0dHJpYnV0ZXMoKTtcblxuICAgICAgICBpZiAobmFtZSA9PT0gJ21pbicgfHwgbmFtZSA9PT0gJ21heCcpIHtcbiAgICAgICAgICB0aGlzLl9vbkNoYW5nZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXMuX29uRHJhZ3N0YXJ0KTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5fb25DaGFuZ2UpO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLl9vbkRyYWdzdGFydCk7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMuX29uQ2hhbmdlKTtcbiAgfVxuXG4gIF91cGRhdGVCb3VuZEF0dHJpYnV0ZXMoKSB7XG4gICAgSU5QVVRfQVRUUklCVVRFUy5mb3JFYWNoKChhdHRyKSA9PiB7XG4gICAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoYXR0cikpIHtcbiAgICAgICAgdGhpcy5faW5wdXQuc2V0QXR0cmlidXRlKGF0dHIsIHRoaXMuZ2V0QXR0cmlidXRlKGF0dHIpKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9pbnB1dC5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBnZXQgX2lucHV0KCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0Jyk7XG4gIH1cblxuICBnZXQgX2xlZnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvcignLnJhbmdlX19sZWZ0Jyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCB2YWx1ZS5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnB1dC52YWx1ZTtcbiAgfVxuXG4gIHNldCB2YWx1ZSh2YWwpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5faW5wdXQudmFsdWUgPSB2YWw7XG4gICAgICB0aGlzLl9vbkNoYW5nZSgpO1xuICAgIH0pO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXJhbmdlJywgUmFuZ2VFbGVtZW50KTtcbiIsImltcG9ydCBvbnMgZnJvbSAnLi9vbnMvb25zJztcblxuaW1wb3J0IFRlbXBsYXRlRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy10ZW1wbGF0ZSc7XG5pbXBvcnQgSWZFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLWlmJztcbmltcG9ydCBBbGVydERpYWxvZ0VsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtYWxlcnQtZGlhbG9nJztcbmltcG9ydCBCYWNrQnV0dG9uRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1iYWNrLWJ1dHRvbic7XG5pbXBvcnQgQm90dG9tVG9vbGJhckVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtYm90dG9tLXRvb2xiYXInO1xuaW1wb3J0IEJ1dHRvbkVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtYnV0dG9uJztcbmltcG9ydCBDYXJvdXNlbEl0ZW1FbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLWNhcm91c2VsLWl0ZW0nO1xuaW1wb3J0IENhcm91c2VsRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1jYXJvdXNlbCc7XG5pbXBvcnQgQ29sRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1jb2wnO1xuaW1wb3J0IERpYWxvZ0VsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtZGlhbG9nJztcbmltcG9ydCBGYWJFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLWZhYic7XG5pbXBvcnQgR2VzdHVyZURldGVjdG9yRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1nZXN0dXJlLWRldGVjdG9yJztcbmltcG9ydCBJY29uRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1pY29uJztcbmltcG9ydCBMYXp5UmVwZWF0RWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1sYXp5LXJlcGVhdCc7XG5pbXBvcnQgTGlzdEhlYWRlckVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtbGlzdC1oZWFkZXInO1xuaW1wb3J0IExpc3RJdGVtRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1saXN0LWl0ZW0nO1xuaW1wb3J0IExpc3RFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLWxpc3QnO1xuaW1wb3J0IElucHV0RWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1pbnB1dCc7XG5pbXBvcnQgTW9kYWxFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLW1vZGFsJztcbmltcG9ydCBOYXZpZ2F0b3JFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLW5hdmlnYXRvcic7XG5pbXBvcnQgUGFnZUVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtcGFnZSc7XG5pbXBvcnQgUG9wb3ZlckVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtcG9wb3Zlcic7XG5pbXBvcnQgUHJvZ3Jlc3NCYXJFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLXByb2dyZXNzLWJhcic7XG5pbXBvcnQgUHJvZ3Jlc3NDaXJjdWxhckVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtcHJvZ3Jlc3MtY2lyY3VsYXInO1xuaW1wb3J0IFB1bGxIb29rRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1wdWxsLWhvb2snO1xuaW1wb3J0IFJpcHBsZUVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtcmlwcGxlJztcbmltcG9ydCBSb3dFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLXJvdyc7XG5pbXBvcnQgU3BlZWREaWFsSXRlbUVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtc3BlZWQtZGlhbC1pdGVtJztcbmltcG9ydCBTcGVlZERpYWxFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLXNwZWVkLWRpYWwnO1xuaW1wb3J0IFNwbGl0dGVyQ29udGVudEVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtc3BsaXR0ZXItY29udGVudCc7XG5pbXBvcnQgU3BsaXR0ZXJNYXNrRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1zcGxpdHRlci1tYXNrJztcbmltcG9ydCBTcGxpdHRlclNpZGVFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLXNwbGl0dGVyLXNpZGUnO1xuaW1wb3J0IFNwbGl0dGVyRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1zcGxpdHRlcic7XG5pbXBvcnQgU3dpdGNoRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1zd2l0Y2gnO1xuaW1wb3J0IFRhYkVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtdGFiJztcbmltcG9ydCBUYWJiYXJFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLXRhYmJhcic7XG5pbXBvcnQgVG9vbGJhckJ1dHRvbkVsZW1lbnQgZnJvbSAnLi9lbGVtZW50cy9vbnMtdG9vbGJhci1idXR0b24nO1xuaW1wb3J0IFRvb2xiYXJFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvb25zLXRvb2xiYXInO1xuaW1wb3J0IFJhbmdlRWxlbWVudCBmcm9tICcuL2VsZW1lbnRzL29ucy1yYW5nZSc7XG5cbm9ucy5UZW1wbGF0ZUVsZW1lbnQgPSBUZW1wbGF0ZUVsZW1lbnQ7XG5vbnMuSWZFbGVtZW50ID0gSWZFbGVtZW50O1xub25zLkFsZXJ0RGlhbG9nRWxlbWVudCA9IEFsZXJ0RGlhbG9nRWxlbWVudDtcbm9ucy5CYWNrQnV0dG9uRWxlbWVudCA9IEJhY2tCdXR0b25FbGVtZW50O1xub25zLkJvdHRvbVRvb2xiYXJFbGVtZW50ID0gQm90dG9tVG9vbGJhckVsZW1lbnQ7XG5vbnMuQnV0dG9uRWxlbWVudCA9IEJ1dHRvbkVsZW1lbnQ7XG5vbnMuQ2Fyb3VzZWxJdGVtRWxlbWVudCA9IENhcm91c2VsSXRlbUVsZW1lbnQ7XG5vbnMuQ2Fyb3VzZWxFbGVtZW50ID0gQ2Fyb3VzZWxFbGVtZW50O1xub25zLkNvbEVsZW1lbnQgPSBDb2xFbGVtZW50O1xub25zLkRpYWxvZ0VsZW1lbnQgPSBEaWFsb2dFbGVtZW50O1xub25zLkZhYkVsZW1lbnQgPSBGYWJFbGVtZW50O1xub25zLkdlc3R1cmVEZXRlY3RvckVsZW1lbnQgPSBHZXN0dXJlRGV0ZWN0b3JFbGVtZW50O1xub25zLkljb25FbGVtZW50ID0gSWNvbkVsZW1lbnQ7XG5vbnMuTGF6eVJlcGVhdEVsZW1lbnQgPSBMYXp5UmVwZWF0RWxlbWVudDtcbm9ucy5MaXN0SGVhZGVyRWxlbWVudCA9IExpc3RIZWFkZXJFbGVtZW50O1xub25zLkxpc3RJdGVtRWxlbWVudCA9IExpc3RJdGVtRWxlbWVudDtcbm9ucy5MaXN0RWxlbWVudCA9IExpc3RFbGVtZW50O1xub25zLklucHV0RWxlbWVudCA9IElucHV0RWxlbWVudDtcbm9ucy5Nb2RhbEVsZW1lbnQgPSBNb2RhbEVsZW1lbnQ7XG5vbnMuTmF2aWdhdG9yRWxlbWVudCA9IE5hdmlnYXRvckVsZW1lbnQ7XG5vbnMuUGFnZUVsZW1lbnQgPSBQYWdlRWxlbWVudDtcbm9ucy5Qb3BvdmVyRWxlbWVudCA9IFBvcG92ZXJFbGVtZW50O1xub25zLlByb2dyZXNzQmFyRWxlbWVudCA9IFByb2dyZXNzQmFyRWxlbWVudDtcbm9ucy5Qcm9ncmVzc0NpcmN1bGFyRWxlbWVudCA9IFByb2dyZXNzQ2lyY3VsYXJFbGVtZW50O1xub25zLlB1bGxIb29rRWxlbWVudCA9IFB1bGxIb29rRWxlbWVudDtcbm9ucy5SaXBwbGVFbGVtZW50ID0gUmlwcGxlRWxlbWVudDtcbm9ucy5Sb3dFbGVtZW50ID0gUm93RWxlbWVudDtcbm9ucy5TcGVlZERpYWxJdGVtRWxlbWVudCA9IFNwZWVkRGlhbEl0ZW1FbGVtZW50O1xub25zLlNwZWVkRGlhbEVsZW1lbnQgPSBTcGVlZERpYWxFbGVtZW50O1xub25zLlNwbGl0dGVyQ29udGVudEVsZW1lbnQgPSBTcGxpdHRlckNvbnRlbnRFbGVtZW50O1xub25zLlNwbGl0dGVyTWFza0VsZW1lbnQgPSBTcGxpdHRlck1hc2tFbGVtZW50O1xub25zLlNwbGl0dGVyU2lkZUVsZW1lbnQgPSBTcGxpdHRlclNpZGVFbGVtZW50O1xub25zLlNwbGl0dGVyRWxlbWVudCA9IFNwbGl0dGVyRWxlbWVudDtcbm9ucy5Td2l0Y2hFbGVtZW50ID0gU3dpdGNoRWxlbWVudDtcbm9ucy5UYWJFbGVtZW50ID0gVGFiRWxlbWVudDtcbm9ucy5UYWJiYXJFbGVtZW50ID0gVGFiYmFyRWxlbWVudDtcbm9ucy5Ub29sYmFyQnV0dG9uRWxlbWVudCA9IFRvb2xiYXJCdXR0b25FbGVtZW50O1xub25zLlRvb2xiYXJFbGVtZW50ID0gVG9vbGJhckVsZW1lbnQ7XG5vbnMuUmFuZ2VFbGVtZW50ID0gUmFuZ2VFbGVtZW50O1xuXG4vLyBmYXN0Y2xpY2tcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4ge1xuICAgIG9ucy5mYXN0Q2xpY2sgPSBGYXN0Q2xpY2suYXR0YWNoKGRvY3VtZW50LmJvZHkpO1xufSwgZmFsc2UpO1xuXG4vLyBvbnMuX2RlZmF1bHREZXZpY2VCYWNrQnV0dG9uSGFuZGxlclxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCAoKSA9PiB7XG4gIG9ucy5fZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIuZW5hYmxlKCk7XG4gIG9ucy5fZGVmYXVsdERldmljZUJhY2tCdXR0b25IYW5kbGVyID0gb25zLl9kZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlci5jcmVhdGVIYW5kbGVyKHdpbmRvdy5kb2N1bWVudC5ib2R5LCAoKSA9PiB7XG4gICAgbmF2aWdhdG9yLmFwcC5leGl0QXBwKCk7XG4gIH0pO1xuICBkb2N1bWVudC5ib2R5Ll9nZXN0dXJlRGV0ZWN0b3IgPSBuZXcgb25zLkdlc3R1cmVEZXRlY3Rvcihkb2N1bWVudC5ib2R5KTtcbn0sIGZhbHNlKTtcblxuLy8gc2V0dXAgbG9hZGluZyBwbGFjZWhvbGRlclxub25zLnJlYWR5KGZ1bmN0aW9uKCkge1xuICBvbnMuX3NldHVwTG9hZGluZ1BsYWNlSG9sZGVycygpO1xufSk7XG5cbi8vIHZpZXdwb3J0LmpzXG5uZXcgVmlld3BvcnQoKS5zZXR1cCgpO1xuXG5leHBvcnQgZGVmYXVsdCBvbnM7XG4iXSwic291cmNlUm9vdCI6Ii9zb3VyY2UvIn0=
